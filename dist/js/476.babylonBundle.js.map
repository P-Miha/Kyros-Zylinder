{"version":3,"file":"js/476.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/externals/havok.ts","webpack://babylonjs-typescript-webpack-template/./src/scenes/collisions.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleMoveablePiece.glb"],"sourcesContent":["import HavokPlugin from \"@babylonjs/havok\";\r\n\r\nexport const havokModule = HavokPlugin();\r\n","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { CreateSphere } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\r\n// Needed for .glb import support via SceneLoader\r\nimport \"@babylonjs/loaders/glTF\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\nimport \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { havokModule } from \"../externals/havok\";\r\nimport { PhysicsShapeBox, PhysicsShapeConvexHull, PhysicsShapeSphere } from \"@babylonjs/core/Physics/v2/physicsShape\";\r\nimport { PhysicsBody } from \"@babylonjs/core/Physics/v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"@babylonjs/core/Physics/v2/IPhysicsEnginePlugin\";\r\nimport { HavokPlugin } from \"@babylonjs/core/Physics/v2/Plugins/havokPlugin\";\r\nimport { Color3, CreateBox, CreateIcoSphere, CreateTorus, SceneLoader, Sound, StandardMaterial } from \"@babylonjs/core\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\n\r\n// Meshes\r\nimport MoveablePiece from \"../../assets/glb/AlphaPuzzleMoveablePiece.glb\";\r\n\r\nclass Collisions implements CreateSceneClass {\r\n    preTasks = [havokModule];\r\n\r\n    // eslint-disable-next-line no-undef\r\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\r\n        // Boilerplate Code\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        // Enable Inspector and Scene Exlporer\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        // Inspector and Scene Explorer End\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        // MeshCreation Code\r\n        // Our built-in 'sphere' shape.\r\n        //const sphere = CreateSphere(\"sphere\", { diameter: 2, segments: 32 }, scene);\r\n\r\n        // Move the sphere upward at 4 units\r\n        //sphere.position.y = 4;\r\n        // Sphere body\r\n        //const sphereBody = new PhysicsBody(sphere, PhysicsMotionType.DYNAMIC, false, scene);\r\n        // Set shape material properties\r\n        //sphereShape.material = { friction: 0.2, restitution: 0.6 };\r\n        // Associate shape and body\r\n        //sphereBody.shape = sphereShape;\r\n        // And body mass\r\n        //sphereBody.setMassProperties({ mass: 1 });\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\"ground\", { width: 10, height: 10 }, scene);\r\n        \r\n        // PHYSICS!\r\n        const physicsPlugin = new HavokPlugin(true, await havokModule);\r\n        scene.enablePhysics(null, physicsPlugin);\r\n        // Create a sphere shape\r\n        // const sphereShape = new PhysicsShapeSphere(new Vector3(0, 0, 0)\r\n        //     , 1\r\n        //     , scene);\r\n    \r\n\r\n\r\n        // Preparing Sounds for collisions\r\n        const buzzer = new Sound(\"buzzer\", \"sounds/Buzzer.wav\", scene);\r\n        buzzer.play();\r\n\r\n        // Create a static box shape\r\n        const groundShape = new PhysicsShapeBox(new Vector3(0, 0, 0)\r\n            , Quaternion.Identity()\r\n            , new Vector3(10, 0.1, 10)\r\n            , scene);\r\n\r\n        // Create a body and attach it to the ground. Set it as Static.\r\n        const groundBody = new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n\r\n        // Set material properties\r\n        groundShape.material = { friction: 0.2, restitution: 0.8 };\r\n\r\n        // Associate the body and the shape\r\n        groundBody.shape = groundShape;\r\n\r\n        // Set the mass to 0\r\n        groundBody.setMassProperties({ mass: 0 });\r\n\r\n        // Settin up list for objects to check collisions with\r\n        const objectsToCollideWith: Mesh[] = [];\r\n\r\n        const icoSphere = CreateIcoSphere(\"icoSphere\")\r\n        icoSphere.position = new Vector3(0, 2, 0);\r\n        icoSphere.showBoundingBox = true;\r\n        objectsToCollideWith.push(icoSphere);\r\n\r\n        const torusMesh = CreateTorus(\"torusMesh\")\r\n        torusMesh.position = new Vector3(0, 2, 3);\r\n        torusMesh.showBoundingBox = true;\r\n        objectsToCollideWith.push(torusMesh);\r\n\r\n        const stick = CreateBox(\"stick\", { width: 0.25, height: 2, depth: 0.25 }, scene);\r\n        stick.position = new Vector3(0, 2, -3);\r\n        stick.showBoundingBox = true;\r\n        objectsToCollideWith.push(stick);\r\n\r\n        // Detecting Collisions of Meshes with PhysicsBodys\r\n        // Create Mesh\r\n        const stickPhysic = CreateBox(\"stickPhysic\", { width: 0.25, height: 2, depth: 0.25 }, scene);\r\n        stickPhysic.position = new Vector3(0, 2, -6);\r\n        stickPhysic.showBoundingBox = true;\r\n        const stickPhysicBody = new PhysicsBody(stickPhysic, PhysicsMotionType.DYNAMIC, false, scene);\r\n        // Set to Floating / disable Gravity for this object\r\n        stickPhysicBody.setMassProperties({ mass: 0 });\r\n        // Overwrite default shape to the shape of a single line of the mesh\r\n        stickPhysicBody.shape = new PhysicsShapeBox(stickPhysic.absolutePosition, stickPhysic.absoluteRotationQuaternion, new Vector3(0.25, 2, 0.25), scene);\r\n\r\n        const moveablePieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", MoveablePiece, scene, undefined);\r\n        // Casting Loadresult (ISceneLoaderAsyncResult) to Mesh for easier handling and enabling useage of updateFacetData()\r\n        // [0] is the rootnode of the mesh (Empty Parent), [1] is the actual mesh)\r\n        const moveablePiece = moveablePieceLoad.meshes[1] as Mesh;\r\n        moveablePiece.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        //moveablePiece.position = new Vector3(0, 2, -9);\r\n        // Physics boilerplate for moveablePiece, setting shape and linking\r\n        const moveablePiecePhysicsShape = new PhysicsShapeConvexHull(moveablePiece, scene); \r\n        const moveablePiecePhysics = new PhysicsBody(moveablePiece, PhysicsMotionType.DYNAMIC, false, scene)\r\n        \r\n        moveablePiecePhysics.shape = moveablePiecePhysicsShape;\r\n        // Physics Properties\r\n        moveablePiecePhysics.setMassProperties({ mass: 0 });\r\n        const toDraw = physicsPlugin.getBoundingBox(moveablePiecePhysicsShape);\r\n        //toDraw.showBoundingBox = true;\r\n        /**\r\n         * Function to check for collisions between objectsToCollideWith and stickPhysic\r\n         * where objectsToCollideWith is an array of Meshes, previously defined and filled with meshes which should be checked for collisions\r\n         */\r\n        function checkForCollision(){\r\n            const currentlyColliding: Mesh[] = []\r\n            for(let i = 0; i < objectsToCollideWith.length; i++){\r\n                \r\n                objectsToCollideWith.forEach((mesh) => {\r\n                    if (objectsToCollideWith[i] != mesh && objectsToCollideWith[i].intersectsMesh(mesh, true)){\r\n                            objectsToCollideWith[i].material = materialCollision\r\n                            mesh.material = materialCollision\r\n                            console.log(objectsToCollideWith[i].name, mesh.name)\r\n                            currentlyColliding.push(objectsToCollideWith[i], mesh)\r\n                        }\r\n\r\n                    else{\r\n                        // Currently not colliding with compared Mesh\r\n                        // If Object has already collided with something, but not with the currently compared mesh, do not change color again\r\n                        if (currentlyColliding.includes(objectsToCollideWith[i])){\r\n                            null;\r\n                        }\r\n                        // If Object has not collided with anything, change color back to green (not anymore colliding)\r\n                        else{\r\n                            objectsToCollideWith[i].material = materialNoCollision\r\n                        }\r\n                        // Check if objectsToCollideWith[i] is no longer colliding with anything\r\n\r\n                    }\r\n                })\r\n            }  \r\n        }\r\n        // Collision checking logic\r\n        // Prepare materials for colorchange based on collision\r\n        const materialCollision = new StandardMaterial(\"materialCollision\", scene);\r\n        materialCollision.diffuseColor = Color3.Red();\r\n\r\n        const materialNoCollision = new StandardMaterial(\"materialNoCollision\", scene);\r\n        materialNoCollision.diffuseColor = Color3.Green();\r\n        // if Object A collides with Object B, and A != B then play sound and change color\r\n        \r\n        scene.onBeforeRenderObservable.add(() => {\r\n            checkForCollision();\r\n        });\r\n\r\n\r\n        // WebXR Code\r\n        const options = {\r\n            floorMeshes: [ground],\r\n        }\r\n        const xrHelper = await scene.createDefaultXRExperienceAsync(options);\r\n        \r\n\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new Collisions();\r\n","export default __webpack_public_path__ + \"87c16888db5ebec0fb7b6c3bb705d897.glb\";"],"names":["havokModule","preTasks","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Math","PI","setTarget","attachControl","intensity","ground","width","height","physicsPlugin","enablePhysics","Sound","play","groundShape","groundBody","material","friction","restitution","shape","setMassProperties","mass","objectsToCollideWith","icoSphere","CreateIcoSphere","position","showBoundingBox","push","torusMesh","CreateTorus","stick","CreateBox","depth","stickPhysic","stickPhysicBody","absolutePosition","absoluteRotationQuaternion","moveablePiece","SceneLoader","meshes","scaling","moveablePiecePhysicsShape","moveablePiecePhysics","getBoundingBox","materialCollision","StandardMaterial","diffuseColor","Color3","materialNoCollision","onBeforeRenderObservable","add","currentlyColliding","i","length","forEach","mesh","intersectsMesh","name","includes","checkForCollision","options","floorMeshes","createDefaultXRExperienceAsync"],"sourceRoot":""}