{"version":3,"file":"js/522.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/joinedPhysicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/physicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/physicsRaycastResult.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v1/physicsEngine.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v1/physicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v1/physicsJoint.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/physicsEngine.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"./v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine\";\r\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine\";\r\n\r\ndeclare module \"../scene\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @internal */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @returns a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @returns a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        if (!plugin || plugin?.getPluginVersion() === 1) {\r\n            this._physicsEngine = new PhysicsEngineV1(gravity, plugin as IPhysicsEnginePluginV1);\r\n        } else if (plugin?.getPluginVersion() === 2) {\r\n            this._physicsEngine = new PhysicsEngineV2(gravity, plugin as IPhysicsEnginePluginV2);\r\n        } else {\r\n            throw new Error(\"Unsupported Physics plugin version.\");\r\n        }\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\nimport \"../joinedPhysicsEngineComponent\";\r\n\r\ndeclare module \"../../Meshes/transformNode\" {\r\n    /**\r\n     *\r\n     */\r\n    /** @internal */\r\n    export interface TransformNode {\r\n        /** @internal */\r\n        _physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         * @see\r\n         */\r\n        physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         *\r\n         */\r\n        getPhysicsBody(): Nullable<PhysicsBody>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): TransformNode;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(TransformNode.prototype, \"physicsBody\", {\r\n    get: function (this: TransformNode) {\r\n        return this._physicsBody;\r\n    },\r\n    set: function (this: TransformNode, value: Nullable<PhysicsBody>) {\r\n        if (this._physicsBody === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsBody = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsBody) {\r\n                    this.physicsBody.dispose(/*!doNotRecurse*/);\r\n                    this.physicsBody = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics body\r\n * @returns a physics body or null\r\n */\r\nTransformNode.prototype.getPhysicsBody = function (): Nullable<PhysicsBody> {\r\n    return this.physicsBody;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nTransformNode.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): TransformNode {\r\n    if (!this.physicsBody) {\r\n        throw new Error(\"No Physics Body for TransformNode\");\r\n    }\r\n    this.physicsBody.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\nimport type { PhysicsBody } from \"./v2/physicsBody\";\r\n\r\n/**\r\n * Holds the data for the raycast result\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsRaycastResult {\r\n    private _hasHit: boolean = false;\r\n\r\n    private _hitDistance: number = 0;\r\n    private _hitNormalWorld: Vector3 = Vector3.Zero();\r\n    private _hitPointWorld: Vector3 = Vector3.Zero();\r\n    private _rayFromWorld: Vector3 = Vector3.Zero();\r\n    private _rayToWorld: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The Physics body that the ray hit\r\n     */\r\n    public body?: PhysicsBody;\r\n    /**\r\n     * The body Index in case the Physics body is using instances\r\n     */\r\n    public bodyIndex?: number;\r\n\r\n    /**\r\n     * Gets if there was a hit\r\n     */\r\n    get hasHit(): boolean {\r\n        return this._hasHit;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance from the hit\r\n     */\r\n    get hitDistance(): number {\r\n        return this._hitDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit normal/direction in the world\r\n     */\r\n    get hitNormalWorld(): Vector3 {\r\n        return this._hitNormalWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit point in the world\r\n     */\r\n    get hitPointWorld(): Vector3 {\r\n        return this._hitPointWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"start point\" of the ray in the world\r\n     */\r\n    get rayFromWorld(): Vector3 {\r\n        return this._rayFromWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"end point\" of the ray in the world\r\n     */\r\n    get rayToWorld(): Vector3 {\r\n        return this._rayToWorld;\r\n    }\r\n\r\n    /**\r\n     * Sets the hit data (normal & point in world space)\r\n     * @param hitNormalWorld defines the normal in world space\r\n     * @param hitPointWorld defines the point in world space\r\n     */\r\n    public setHitData(hitNormalWorld: IXYZ, hitPointWorld: IXYZ) {\r\n        this._hasHit = true;\r\n        this._hitNormalWorld.set(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);\r\n        this._hitPointWorld.set(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);\r\n    }\r\n\r\n    /**\r\n     * Sets the distance from the start point to the hit point\r\n     * @param distance\r\n     */\r\n    public setHitDistance(distance: number) {\r\n        this._hitDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance manually\r\n     */\r\n    public calculateHitDistance() {\r\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     * @param from The from point on world space\r\n     * @param to The to point on world space\r\n     */\r\n    public reset(from: Vector3 = Vector3.Zero(), to: Vector3 = Vector3.Zero()) {\r\n        this._rayFromWorld.copyFrom(from);\r\n        this._rayToWorld.copyFrom(to);\r\n\r\n        this._hasHit = false;\r\n        this._hitDistance = 0;\r\n\r\n        this._hitNormalWorld.setAll(0);\r\n        this._hitPointWorld.setAll(0);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for the size containing width and height\r\n */\r\ninterface IXYZ {\r\n    /**\r\n     * X\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * Y\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Z\r\n     */\r\n    z: number;\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PhysicsImpostorJoint, IPhysicsEnginePlugin } from \"./IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport type { PhysicsJoint } from \"./physicsJoint\";\r\nimport type { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /**\r\n     * Global value used to control the smallest number supported by the simulation\r\n     */\r\n    private _impostors: Array<PhysicsImpostor> = [];\r\n    private _joints: Array<PhysicsImpostorJoint> = [];\r\n    private _subTimeStep: number = 0;\r\n    private _uniqueIdCounter = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePlugin {\r\n        throw _WarnImport(\"CannonJSPlugin\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePlugin = PhysicsEngine.DefaultPluginFactory()) {\r\n        if (!this._physicsPlugin.isSupported()) {\r\n            throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\r\n        }\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._impostors.forEach(function (impostor) {\r\n            impostor.dispose();\r\n        });\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    public addImpostor(impostor: PhysicsImpostor) {\r\n        this._impostors.push(impostor);\r\n        impostor.uniqueId = this._uniqueIdCounter++;\r\n        //if no parent, generate the body\r\n        if (!impostor.parent) {\r\n            this._physicsPlugin.generatePhysicsBody(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    public removeImpostor(impostor: PhysicsImpostor) {\r\n        const index = this._impostors.indexOf(impostor);\r\n        if (index > -1) {\r\n            const removed = this._impostors.splice(index, 1);\r\n            //Is it needed?\r\n            if (removed.length) {\r\n                this.getPhysicsPlugin().removePhysicsBody(impostor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    public addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const impostorJoint = {\r\n            mainImpostor: mainImpostor,\r\n            connectedImpostor: connectedImpostor,\r\n            joint: joint,\r\n        };\r\n        joint.physicsPlugin = this._physicsPlugin;\r\n        this._joints.push(impostorJoint);\r\n        this._physicsPlugin.generateJoint(impostorJoint);\r\n    }\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    public removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const matchingJoints = this._joints.filter(function (impostorJoint) {\r\n            return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\r\n        });\r\n        if (matchingJoints.length) {\r\n            this._physicsPlugin.removeJoint(matchingJoints[0]);\r\n            //TODO remove it from the list as well\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        //check if any mesh has no body / requires an update\r\n        this._impostors.forEach((impostor) => {\r\n            if (impostor.isBodyInitRequired()) {\r\n                this._physicsPlugin.generatePhysicsBody(impostor);\r\n            }\r\n        });\r\n\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._impostors);\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePlugin {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    public getImpostors(): Array<PhysicsImpostor> {\r\n        return this._impostors;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].object === object) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].physicsBody === body) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        return this._physicsPlugin.raycast(from, to);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult) {\r\n        return this._physicsPlugin.raycastToRef(from, to, result);\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function (this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function (): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options,\r\n    });\r\n    return this;\r\n};\r\n","import type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin } from \"./IPhysicsEnginePlugin\";\r\n/**\r\n * Interface for Physics-Joint data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface PhysicsJointData {\r\n    //Important for some engines, optional!\r\n    /**\r\n     * The main pivot of the joint\r\n     */\r\n    mainPivot?: Vector3;\r\n    /**\r\n     * The connected pivot of the joint\r\n     */\r\n    connectedPivot?: Vector3;\r\n    /**\r\n     * The main axis of the joint\r\n     */\r\n    mainAxis?: Vector3;\r\n    /**\r\n     * The connected axis of the joint\r\n     */\r\n    connectedAxis?: Vector3;\r\n    /**\r\n     * The collision of the joint\r\n     */\r\n    collision?: boolean;\r\n    /**\r\n     * Native Oimo/Cannon/Energy data\r\n     */\r\n    nativeParams?: any;\r\n}\r\n\r\n/**\r\n * This is a holder class for the physics joint created by the physics plugin\r\n * It holds a set of functions to control the underlying joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsJoint {\r\n    private _physicsJoint: any;\r\n    protected _physicsPlugin: IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Initializes the physics joint\r\n     * @param type The type of the physics joint\r\n     * @param jointData The data for the physics joint\r\n     */\r\n    constructor(\r\n        /**\r\n         * The type of the physics joint\r\n         */\r\n        public type: number,\r\n        /**\r\n         * The data for the physics joint\r\n         */\r\n        public jointData: PhysicsJointData\r\n    ) {\r\n        jointData.nativeParams = jointData.nativeParams || {};\r\n    }\r\n\r\n    /**\r\n     * Gets the physics joint\r\n     */\r\n    public get physicsJoint(): any {\r\n        return this._physicsJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics joint\r\n     */\r\n    public set physicsJoint(newJoint: any) {\r\n        if (this._physicsJoint) {\r\n            //remove from the world\r\n        }\r\n\r\n        this._physicsJoint = newJoint;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics plugin\r\n     */\r\n    public set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin) {\r\n        this._physicsPlugin = physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Execute a function that is physics-plugin specific.\r\n     * @param {Function} func the function that will be executed.\r\n     *                        It accepts two parameters: the physics world and the physics joint\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsJoint: any) => void) {\r\n        func(this._physicsPlugin.world, this._physicsJoint);\r\n    }\r\n\r\n    //TODO check if the native joints are the same\r\n\r\n    //Joint Types\r\n    /**\r\n     * Distance-Joint type\r\n     */\r\n    public static DistanceJoint = 0;\r\n    /**\r\n     * Hinge-Joint type\r\n     */\r\n    public static HingeJoint = 1;\r\n    /**\r\n     * Ball-and-Socket joint type\r\n     */\r\n    public static BallAndSocketJoint = 2;\r\n    /**\r\n     * Wheel-Joint type\r\n     */\r\n    public static WheelJoint = 3;\r\n    /**\r\n     * Slider-Joint type\r\n     */\r\n    public static SliderJoint = 4;\r\n    //OIMO\r\n    /**\r\n     * Prismatic-Joint type\r\n     */\r\n    public static PrismaticJoint = 5;\r\n    //\r\n    /**\r\n     * Universal-Joint type\r\n     * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\r\n     */\r\n    public static UniversalJoint = 6;\r\n    /**\r\n     * Hinge-Joint 2 type\r\n     */\r\n    public static Hinge2Joint = PhysicsJoint.WheelJoint;\r\n    //Cannon\r\n    /**\r\n     * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters\r\n     */\r\n    public static PointToPointJoint = 8;\r\n    //Cannon only at the moment\r\n    /**\r\n     * Spring-Joint type\r\n     */\r\n    public static SpringJoint = 9;\r\n    /**\r\n     * Lock-Joint type\r\n     */\r\n    public static LockJoint = 10;\r\n}\r\n\r\n/**\r\n * A class representing a physics distance joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class DistanceJoint extends PhysicsJoint {\r\n    /**\r\n     *\r\n     * @param jointData The data for the Distance-Joint\r\n     */\r\n    constructor(jointData: DistanceJointData) {\r\n        super(PhysicsJoint.DistanceJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Update the predefined distance.\r\n     * @param maxDistance The maximum preferred distance\r\n     * @param minDistance The minimum preferred distance\r\n     */\r\n    public updateDistance(maxDistance: number, minDistance?: number) {\r\n        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Motor-Enabled Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {\r\n    /**\r\n     * Initializes the Motor-Enabled Joint\r\n     * @param type The type of the joint\r\n     * @param jointData The physical joint data for the joint\r\n     */\r\n    constructor(type: number, jointData: PhysicsJointData) {\r\n        super(type, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param force the force to apply\r\n     * @param maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a single physics Hinge-Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class HingeJoint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge-Joint\r\n     * @param jointData The joint data for the Hinge-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.HingeJoint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param {number} force the force to apply\r\n     * @param {number} maxForce max force for this motor.\r\n     */\r\n    public setMotor(force?: number, maxForce?: number) {\r\n        this._physicsPlugin.setMotor(this, force || 0, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Set the motor's limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a dual hinge physics joint (same as wheel joint)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class Hinge2Joint extends MotorEnabledJoint {\r\n    /**\r\n     * Initializes the Hinge2-Joint\r\n     * @param jointData The joint data for the Hinge2-Joint\r\n     */\r\n    constructor(jointData: PhysicsJointData) {\r\n        super(PhysicsJoint.Hinge2Joint, jointData);\r\n    }\r\n\r\n    /**\r\n     * Set the motor values.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param targetSpeed the speed the motor is to reach\r\n     * @param maxForce max force for this motor.\r\n     * @param motorIndex motor's index, 0 or 1.\r\n     */\r\n    public setMotor(targetSpeed?: number, maxForce?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);\r\n    }\r\n\r\n    /**\r\n     * Set the motor limits.\r\n     * Attention, this function is plugin specific. Engines won't react 100% the same.\r\n     * @param upperLimit the upper limit\r\n     * @param lowerLimit lower limit\r\n     * @param motorIndex the motor's index, 0 or 1.\r\n     */\r\n    public setLimit(upperLimit: number, lowerLimit?: number, motorIndex: number = 0) {\r\n        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for a motor enabled joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface IMotorEnabledJoint {\r\n    /**\r\n     * Physics joint\r\n     */\r\n    physicsJoint: any;\r\n    /**\r\n     * Sets the motor of the motor-enabled joint\r\n     * @param force The force of the motor\r\n     * @param maxForce The maximum force of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setMotor(force?: number, maxForce?: number, motorIndex?: number): void;\r\n    /**\r\n     * Sets the limit of the motor\r\n     * @param upperLimit The upper limit of the motor\r\n     * @param lowerLimit The lower limit of the motor\r\n     * @param motorIndex The index of the motor\r\n     */\r\n    setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n}\r\n\r\n/**\r\n * Joint data for a Distance-Joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface DistanceJointData extends PhysicsJointData {\r\n    /**\r\n     * Max distance the 2 joint objects can be apart\r\n     */\r\n    maxDistance: number;\r\n    //Oimo - minDistance\r\n    //Cannon - maxForce\r\n}\r\n\r\n/**\r\n * Joint data from a spring joint\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface SpringJointData extends PhysicsJointData {\r\n    /**\r\n     * Length of the spring\r\n     */\r\n    length: number;\r\n    /**\r\n     * Stiffness of the spring\r\n     */\r\n    stiffness: number;\r\n    /**\r\n     * Damping of the spring\r\n     */\r\n    damping: number;\r\n    /** this callback will be called when applying the force to the impostors. */\r\n    forceApplicationCallback: () => void;\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./IPhysicsEnginePlugin\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /** @internal */\r\n    private _physicsBodies: Array<PhysicsBody> = [];\r\n    private _subTimeStep: number = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns physics plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePluginV2 {\r\n        throw _WarnImport(\"\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePluginV2 = PhysicsEngine.DefaultPluginFactory()) {\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._physicsBodies);\r\n    }\r\n\r\n    /**\r\n     * Add a body as an active component of this engine\r\n     * @param body\r\n     */\r\n    public addBody(physicsBody: PhysicsBody): void {\r\n        this._physicsBodies.push(physicsBody);\r\n    }\r\n    /**\r\n     * Removes a particular body from this engine\r\n     */\r\n    public removeBody(physicsBody: PhysicsBody): void {\r\n        const index = this._physicsBodies.indexOf(physicsBody);\r\n        if (index > -1) {\r\n            /*const removed =*/ this._physicsBodies.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of bodies added to this engine\r\n\r\n     */\r\n    public getBodies(): Array<PhysicsBody> {\r\n        return this._physicsBodies;\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePluginV2 {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._physicsPlugin.raycast(from, to, result);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        const result = new PhysicsRaycastResult();\r\n        this._physicsPlugin.raycast(from, to, result);\r\n        return result;\r\n    }\r\n}\r\n"],"names":["this","_physicsEngine","gravity","plugin","component","_getComponent","PhysicsEngineSceneComponent","_addComponent","getPluginVersion","Error","_physicsTimeAccumulator","e","message","dispose","undefined","compound","mesh","parts","physicsImpostor","step","subTime","getSubTimeStep","onBeforePhysicsObservable","notifyObservers","_step","onAfterPhysicsObservable","constructor","scene","name","getDeterministicFrameTime","getTimeStep","register","rebuild","clear","disablePhysicsEngine","Object","defineProperty","get","_physicsBody","set","value","_disposePhysicsObserver","onDisposeObservable","remove","add","physicsBody","enumerable","configurable","force","contactPoint","applyImpulse","PhysicsRaycastResult","_hasHit","_hitDistance","_hitNormalWorld","_hitPointWorld","_rayFromWorld","_rayToWorld","hasHit","hitDistance","hitNormalWorld","hitPointWorld","rayFromWorld","rayToWorld","setHitData","x","y","z","setHitDistance","distance","calculateHitDistance","reset","from","to","copyFrom","setAll","PhysicsEngine","_physicsPlugin","static","DefaultPluginFactory","_impostors","_joints","_subTimeStep","_uniqueIdCounter","isSupported","setGravity","setTimeStep","newTimeStep","setSubTimeStep","subTimeStep","forEach","impostor","getPhysicsPluginName","addImpostor","push","uniqueId","parent","generatePhysicsBody","removeImpostor","index","indexOf","splice","length","getPhysicsPlugin","removePhysicsBody","addJoint","mainImpostor","connectedImpostor","joint","impostorJoint","physicsPlugin","generateJoint","removeJoint","matchingJoints","filter","delta","isBodyInitRequired","executeStep","getImpostors","getImpostorForPhysicsObject","object","i","getImpostorWithPhysicsBody","body","raycast","raycastToRef","result","_physicsImpostor","otherMesh","pivot1","pivot2","options","createJoint","mainPivot","connectedPivot","nativeParams","PhysicsJoint","type","jointData","physicsJoint","_physicsJoint","newJoint","executeNativeFunction","func","world","DistanceJoint","HingeJoint","BallAndSocketJoint","WheelJoint","SliderJoint","PrismaticJoint","UniversalJoint","Hinge2Joint","PointToPointJoint","SpringJoint","LockJoint","super","updateDistance","maxDistance","minDistance","updateDistanceJoint","MotorEnabledJoint","setMotor","maxForce","setLimit","upperLimit","lowerLimit","targetSpeed","motorIndex","_physicsBodies","addBody","removeBody","getBodies"],"sourceRoot":""}