{"version":3,"file":"js/488.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/scenes/exampleScenes/navigationMeshRecast.ts"],"sourcesContent":["import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../../createScene\";\r\n\r\nimport { RecastJSPlugin } from \"@babylonjs/core/Navigation/Plugins/recastJSPlugin\";\r\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\n\r\nimport Recast from \"recast-detour\";\r\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents\";\r\nimport { LinesMesh } from \"@babylonjs/core/Meshes/linesMesh\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\n\r\nimport \"@babylonjs/core/Culling/ray\";\r\n\r\n// import * as GUI from \"@babylonjs/gui\";\r\n\r\nconst agents: { idx: number, trf: TransformNode, mesh: Mesh, target: Mesh }[] = [];\r\n\r\nexport class NavigationMeshRecast implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // Casting to any will not be required in future versions of the recast plugin\r\n        const recast = await Recast()\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n        const navigationPlugin = new RecastJSPlugin(recast);\r\n        navigationPlugin.setWorkerURL(\"./navMeshWorker.js\");\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new FreeCamera(\"camera1\", new Vector3(-6, 4, -8), scene);\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light1\", new Vector3(0, 1, 0), scene);\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        const staticMesh = createStaticMesh(scene);\r\n        const navmeshParameters = {\r\n            cs: 0.2,\r\n            ch: 0.2,\r\n            walkableSlopeAngle: 90,\r\n            walkableHeight: 1.0,\r\n            walkableClimb: 1,\r\n            walkableRadius: 1,\r\n            maxEdgeLen: 12.,\r\n            maxSimplificationError: 1.3,\r\n            minRegionArea: 8,\r\n            mergeRegionArea: 20,\r\n            maxVertsPerPoly: 6,\r\n            detailSampleDist: 6,\r\n            detailSampleMaxError: 1,\r\n        };\r\n\r\n        navigationPlugin.createNavMesh([staticMesh], navmeshParameters, (navmeshData) => {\r\n            console.log(\"got worker data\", navmeshData);\r\n            navigationPlugin.buildFromNavmeshData(navmeshData);\r\n            const navmeshdebug = navigationPlugin.createDebugNavMesh(scene);\r\n            navmeshdebug.position = new Vector3(0, 0.01, 0);\r\n\r\n            const matdebug = new StandardMaterial('matdebug', scene);\r\n            matdebug.diffuseColor = new Color3(0.1, 0.2, 1);\r\n            matdebug.alpha = 0.2;\r\n            navmeshdebug.material = matdebug;\r\n\r\n            // crowd\r\n            const crowd = navigationPlugin.createCrowd(10, 0.1, scene);\r\n            let i;\r\n            const agentParams = {\r\n                radius: 0.1,\r\n                height: 0.2,\r\n                maxAcceleration: 4.0,\r\n                maxSpeed: 1.0,\r\n                collisionQueryRange: 0.5,\r\n                pathOptimizationRange: 0.0,\r\n                separationWeight: 1.0\r\n            };\r\n\r\n            for (i = 0; i < 1; i++) {\r\n                const width = 0.20;\r\n                const agentCube = MeshBuilder.CreateBox(\"cube\", { size: width, height: width }, scene);\r\n                const targetCube = MeshBuilder.CreateBox(\"cube\", { size: 0.1, height: 0.1 }, scene);\r\n                const matAgent = new StandardMaterial('mat2', scene);\r\n                const variation = Math.random();\r\n                matAgent.diffuseColor = new Color3(0.4 + variation * 0.6, 0.3, 1.0 - variation * 0.3);\r\n                agentCube.material = matAgent;\r\n                const randomPos = navigationPlugin.getRandomPointAround(new Vector3(-2.0, 0.1, -1.8), 0.5);\r\n                const transform = new TransformNode(\"transform\");\r\n                //agentCube.parent = transform;\r\n                const agentIndex = crowd.addAgent(randomPos, agentParams, transform);\r\n                agents.push({ idx: agentIndex, trf: transform, mesh: agentCube, target: targetCube });\r\n            }\r\n\r\n            let startingPoint: Vector3 | null;\r\n            let currentMesh: AbstractMesh;\r\n            let pathLine: LinesMesh;\r\n            const getGroundPosition = function () {\r\n                const pickinfo = scene.pick(scene.pointerX, scene.pointerY);\r\n                if (pickinfo?.hit) {\r\n                    return pickinfo.pickedPoint;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            const pointerDown = function (mesh: AbstractMesh) {\r\n                currentMesh = mesh;\r\n                startingPoint = getGroundPosition();\r\n                if (startingPoint) { // we need to disconnect camera from canvas\r\n                    setTimeout(function () {\r\n                        camera.detachControl();\r\n                    }, 0);\r\n                    const agents = crowd.getAgents();\r\n                    let i;\r\n                    for (i = 0; i < agents.length; i++) {\r\n                        crowd.agentGoto(agents[i], navigationPlugin.getClosestPoint(startingPoint));\r\n                    }\r\n                    const pathPoints = navigationPlugin.computePath(crowd.getAgentPosition(agents[0]), navigationPlugin.getClosestPoint(startingPoint));\r\n                    pathLine = MeshBuilder.CreateDashedLines(\"ribbon\", { points: pathPoints, updatable: true, instance: pathLine }, scene);\r\n                }\r\n            }\r\n\r\n            scene.onPointerObservable.add((pointerInfo) => {\r\n                switch (pointerInfo.type) {\r\n                    case PointerEventTypes.POINTERDOWN:\r\n                        if (pointerInfo?.pickInfo?.pickedMesh) {\r\n                            console.log(\"pointer down\", pointerInfo.pickInfo.pickedMesh.name);\r\n                            pointerDown(pointerInfo.pickInfo.pickedMesh)\r\n                        }\r\n                        break;\r\n                }\r\n            });\r\n\r\n            scene.onBeforeRenderObservable.add(() => {\r\n                const agentCount = agents.length;\r\n                for (let i = 0; i < agentCount; i++) {\r\n                    const ag = agents[i];\r\n                    ag.mesh.position = crowd.getAgentPosition(ag.idx);\r\n                    const vel = crowd.getAgentVelocity(ag.idx);\r\n                    crowd.getAgentNextTargetPathToRef(ag.idx, ag.target.position);\r\n                    if (vel.length() > 0.2) {\r\n                        vel.normalize();\r\n                        const desiredRotation = Math.atan2(vel.x, vel.z);\r\n                        ag.mesh.rotation.y = ag.mesh.rotation.y + (desiredRotation - ag.mesh.rotation.y) * 0.05;\r\n                    }\r\n                }\r\n            });\r\n        }); // worker\r\n        return scene;\r\n    };\r\n}\r\n\r\nfunction createStaticMesh(scene: Scene): Mesh {\r\n    const ground = MeshBuilder.CreateGround(\"ground1\", {\r\n        width: 6,\r\n        height: 6,\r\n        subdivisions: 2\r\n    }, scene);\r\n\r\n    // Materials\r\n    const mat1 = new StandardMaterial('mat1', scene);\r\n    mat1.diffuseColor = new Color3(1, 1, 1);\r\n\r\n    const sphere = MeshBuilder.CreateSphere(\"sphere1\", { diameter: 2, segments: 16 }, scene);\r\n    sphere.material = mat1;\r\n    sphere.position.y = 1;\r\n\r\n    const cube = MeshBuilder.CreateBox(\"cube\", { size: 1, height: 3 }, scene);\r\n    cube.position = new Vector3(1, 1.5, 0);\r\n    //cube.material = mat2;\r\n\r\n    const mesh = Mesh.MergeMeshes([sphere, cube, ground]);\r\n    if (!mesh) {\r\n        throw new Error(\"Could not merge meshes\");\r\n    }\r\n    return mesh;\r\n}\r\n\r\nexport default new NavigationMeshRecast();\r\n"],"names":["agents","NavigationMeshRecast","createScene","async","engine","canvas","recast","scene","navigationPlugin","setWorkerURL","camera","setTarget","attachControl","intensity","staticMesh","ground","width","height","subdivisions","mat1","diffuseColor","sphere","diameter","segments","material","position","y","cube","size","mesh","Error","createStaticMesh","createNavMesh","cs","ch","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","navmeshData","console","log","buildFromNavmeshData","navmeshdebug","createDebugNavMesh","matdebug","alpha","crowd","createCrowd","i","agentParams","radius","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","agentCube","targetCube","matAgent","variation","Math","random","randomPos","getRandomPointAround","transform","agentIndex","addAgent","push","idx","trf","target","startingPoint","currentMesh","pathLine","onPointerObservable","add","pointerInfo","type","pickInfo","pickedMesh","name","pickinfo","pick","pointerX","pointerY","hit","pickedPoint","getGroundPosition","setTimeout","detachControl","getAgents","length","agentGoto","getClosestPoint","pathPoints","computePath","getAgentPosition","points","updatable","instance","pointerDown","onBeforeRenderObservable","agentCount","ag","vel","getAgentVelocity","getAgentNextTargetPathToRef","normalize","desiredRotation","atan2","x","z","rotation"],"sourceRoot":""}