"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[198],{1528:(e,t,n)=>{n.d(t,{BH:()=>h,Gz:()=>f,RN:()=>p,eW:()=>c,nL:()=>d,xW:()=>u});var a=n(972),o=n(3632),r=n(4517),i=n(2078),s=n(7959),l=n(9288);function c(e){const t=[],n=[],a=e.lines,o=e.colors,i=[];let s=0;for(let e=0;e<a.length;e++){const r=a[e];for(let a=0;a<r.length;a++){if(n.push(r[a].x,r[a].y,r[a].z),o){const t=o[e];i.push(t[a].r,t[a].g,t[a].b,t[a].a)}a>0&&(t.push(s-1),t.push(s)),s++}}const l=new r.x;return l.indices=t,l.positions=n,o&&(l.colors=i),l}function h(e){const t=e.dashSize||3,n=e.gapSize||1,o=e.dashNb||200,i=e.points,s=new Array,l=new Array,c=a.P.Zero();let h=0,u=0,d=0,f=0,p=0,g=0,_=0;for(_=0;_<i.length-1;_++)i[_+1].subtractToRef(i[_],c),h+=c.length();for(d=h/o,f=t*d/(t+n),_=0;_<i.length-1;_++){i[_+1].subtractToRef(i[_],c),u=Math.floor(c.length()/d),c.normalize();for(let e=0;e<u;e++)p=d*e,s.push(i[_].x+p*c.x,i[_].y+p*c.y,i[_].z+p*c.z),s.push(i[_].x+(p+f)*c.x,i[_].y+(p+f)*c.y,i[_].z+(p+f)*c.z),l.push(g,g+1),g+=2}const S=new r.x;return S.positions=s,S.indices=l,S}function u(e,t,n){const a=t.instance,o=t.lines,r=t.colors;if(a){const e=a.getVerticesData(s.o.PositionKind);let t,n;r&&(t=a.getVerticesData(s.o.ColorKind));let i=0,l=0;for(let a=0;a<o.length;a++){const s=o[a];for(let o=0;o<s.length;o++)e[i]=s[o].x,e[i+1]=s[o].y,e[i+2]=s[o].z,r&&t&&(n=r[a],t[l]=n[o].r,t[l+1]=n[o].g,t[l+2]=n[o].b,t[l+3]=n[o].a,l+=4),i+=3}return a.updateVerticesData(s.o.PositionKind,e,!1,!1),r&&t&&a.updateVerticesData(s.o.ColorKind,t,!1,!1),a}const l=!!r,h=new i._(e,n,null,void 0,void 0,l,t.useVertexAlpha,t.material);return c(t).applyToMesh(h,t.updatable),h}function d(e,t,n=null){const a=t.colors?[t.colors]:null;return u(e,{lines:[t.points],updatable:t.updatable,instance:t.instance,colors:a,useVertexAlpha:t.useVertexAlpha,material:t.material},n)}function f(e,t,n=null){const r=t.points,s=t.instance,c=t.gapSize||1,u=t.dashSize||3;if(s){const e=e=>{const t=a.P.Zero(),n=e.length/6;let o=0,i=0,l=0,c=0,h=0,u=0,d=0,f=0;for(d=0;d<r.length-1;d++)r[d+1].subtractToRef(r[d],t),o+=t.length();l=o/n;const p=s._creationDataStorage.dashSize;for(c=p*l/(p+s._creationDataStorage.gapSize),d=0;d<r.length-1;d++)for(r[d+1].subtractToRef(r[d],t),i=Math.floor(t.length()/l),t.normalize(),f=0;f<i&&u<e.length;)h=l*f,e[u]=r[d].x+h*t.x,e[u+1]=r[d].y+h*t.y,e[u+2]=r[d].z+h*t.z,e[u+3]=r[d].x+(h+c)*t.x,e[u+4]=r[d].y+(h+c)*t.y,e[u+5]=r[d].z+(h+c)*t.z,u+=6,f++;for(;u<e.length;)e[u]=r[d].x,e[u+1]=r[d].y,e[u+2]=r[d].z,u+=3};return(t.dashNb||t.dashSize||t.gapSize||t.useVertexAlpha||t.material)&&l.Y.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),s.updateMeshPositions(e,!1),s}const d=new i._(e,n,null,void 0,void 0,void 0,t.useVertexAlpha,t.material);return h(t).applyToMesh(d,t.updatable),d._creationDataStorage=new o.gW,d._creationDataStorage.dashSize=u,d._creationDataStorage.gapSize=c,d}const p={CreateDashedLines:f,CreateLineSystem:u,CreateLines:d};r.x.CreateLineSystem=c,r.x.CreateDashedLines=h,o.Kj.CreateLines=(e,t,n=null,a=!1,o=null)=>d(e,{points:t,updatable:a,instance:o},n),o.Kj.CreateDashedLines=(e,t,n,a,o,r=null,i,s)=>f(e,{points:t,dashSize:n,gapSize:a,dashNb:o,updatable:i,instance:s},r)},7079:(e,t,n)=>{n.d(t,{LY:()=>c,Ub:()=>h,jM:()=>l});var a=n(972),o=n(3632),r=n(7959),i=n(4517),s=n(3027);function l(e){let t=e.pathArray;const n=e.closeArray||!1,a=e.closePath||!1,o=e.invertUV||!1,l=Math.floor(t[0].length/2);let c=e.offset||l;c=c>l?l:Math.floor(c);const h=0===e.sideOrientation?0:e.sideOrientation||i.x.DEFAULTSIDE,u=e.uvs,d=e.colors,f=[],p=[],g=[],_=[],S=[],x=[],y=[],b=[];let C;const A=[],m=[];let P,D,V;if(t.length<2){const e=[],n=[];for(D=0;D<t[0].length-c;D++)e.push(t[0][D]),n.push(t[0][D+c]);t=[e,n]}let O=0;const v=a?1:0;let E,N,w,I,T,M;for(C=t[0].length,P=0;P<t.length;P++){for(y[P]=0,S[P]=[0],E=t[P],N=E.length,C=C<N?C:N,V=0;V<N;)f.push(E[V].x,E[V].y,E[V].z),V>0&&(w=E[V].subtract(E[V-1]).length(),I=w+y[P],S[P].push(I),y[P]=I),V++;a&&(V--,f.push(E[0].x,E[0].y,E[0].z),w=E[V].subtract(E[0]).length(),I=w+y[P],S[P].push(I),y[P]=I),A[P]=N+v,m[P]=O,O+=N+v}let z,L,R=null,F=null;for(D=0;D<C+v;D++){for(b[D]=0,x[D]=[0],P=0;P<t.length-1;P++)T=t[P],M=t[P+1],D===C?(R=T[0],F=M[0]):(R=T[D],F=M[D]),w=F.subtract(R).length(),I=w+b[D],x[D].push(I),b[D]=I;n&&F&&R&&(T=t[P],M=t[0],D===C&&(F=M[0]),w=F.subtract(R).length(),I=w+b[D],b[D]=I)}if(u)for(P=0;P<u.length;P++)_.push(u[P].x,s.e.UseOpenGLOrientationForUV?1-u[P].y:u[P].y);else for(P=0;P<t.length;P++)for(D=0;D<C+v;D++)z=0!=y[P]?S[P][D]/y[P]:0,L=0!=b[D]?x[D][P]/b[D]:0,o?_.push(L,z):_.push(z,s.e.UseOpenGLOrientationForUV?1-L:L);P=0;let j=0,K=A[P]-1,U=A[P+1]-1,B=K<U?K:U,k=m[1]-m[0];const G=n?A.length:A.length-1;for(;j<=B&&P<G;)p.push(j,j+k,j+1),p.push(j+k+1,j+1,j+k),j+=1,j===B&&(P++,P===A.length-1?(k=m[0]-m[P],K=A[P]-1,U=A[0]-1):(k=m[P+1]-m[P],K=A[P]-1,U=A[P+1]-1),j=m[P],B=K<U?K+j:U+j);if(i.x.ComputeNormals(f,p,g),a){let e=0,n=0;for(P=0;P<t.length;P++)e=3*m[P],n=P+1<t.length?3*(m[P+1]-1):g.length-3,g[e]=.5*(g[e]+g[n]),g[e+1]=.5*(g[e+1]+g[n+1]),g[e+2]=.5*(g[e+2]+g[n+2]),g[n]=g[e],g[n+1]=g[e+1],g[n+2]=g[e+2]}i.x._ComputeSides(h,f,p,g,_,e.frontUVs,e.backUVs);let X=null;if(d){X=new Float32Array(4*d.length);for(let e=0;e<d.length;e++)X[4*e]=d[e].r,X[4*e+1]=d[e].g,X[4*e+2]=d[e].b,X[4*e+3]=d[e].a}const W=new i.x,Y=new Float32Array(f),Z=new Float32Array(g),H=new Float32Array(_);return W.indices=p,W.positions=Y,W.normals=Z,W.uvs=H,X&&W.set(X,r.o.ColorKind),a&&(W._idx=m),W}function c(e,t,n=null){const c=t.pathArray,h=t.closeArray,u=t.closePath,d=o.Kj._GetDefaultSideOrientation(t.sideOrientation),f=t.instance,p=t.updatable;if(f){const e=a.jp.Vector3[0].setAll(Number.MAX_VALUE),n=a.jp.Vector3[1].setAll(-Number.MAX_VALUE),l=t=>{let a=c[0].length;const r=f;let i=0;const s=r._originalBuilderSideOrientation===o.Kj.DOUBLESIDE?2:1;for(let o=1;o<=s;++o)for(let o=0;o<c.length;++o){const s=c[o],l=s.length;a=a<l?a:l;for(let o=0;o<a;++o){const a=s[o];t[i]=a.x,t[i+1]=a.y,t[i+2]=a.z,e.minimizeInPlaceFromFloats(a.x,a.y,a.z),n.maximizeInPlaceFromFloats(a.x,a.y,a.z),i+=3}if(r._creationDataStorage&&r._creationDataStorage.closePath){const e=s[0];t[i]=e.x,t[i+1]=e.y,t[i+2]=e.z,i+=3}}},h=f.getVerticesData(r.o.PositionKind);if(l(h),f.hasBoundingInfo?f.getBoundingInfo().reConstruct(e,n,f._worldMatrix):f.buildBoundingInfo(e,n,f._worldMatrix),f.updateVerticesData(r.o.PositionKind,h,!1,!1),t.colors){const e=f.getVerticesData(r.o.ColorKind);for(let n=0,a=0;n<t.colors.length;n++,a+=4){const o=t.colors[n];e[a]=o.r,e[a+1]=o.g,e[a+2]=o.b,e[a+3]=o.a}f.updateVerticesData(r.o.ColorKind,e,!1,!1)}if(t.uvs){const e=f.getVerticesData(r.o.UVKind);for(let n=0;n<t.uvs.length;n++)e[2*n]=t.uvs[n].x,e[2*n+1]=s.e.UseOpenGLOrientationForUV?1-t.uvs[n].y:t.uvs[n].y;f.updateVerticesData(r.o.UVKind,e,!1,!1)}if(!f.areNormalsFrozen||f.isFacetDataEnabled){const e=f.getIndices(),t=f.getVerticesData(r.o.NormalKind),n=f.isFacetDataEnabled?f.getFacetDataParameters():null;if(i.x.ComputeNormals(h,e,t,n),f._creationDataStorage&&f._creationDataStorage.closePath){let e=0,n=0;for(let a=0;a<c.length;a++)e=3*f._creationDataStorage.idx[a],n=a+1<c.length?3*(f._creationDataStorage.idx[a+1]-1):t.length-3,t[e]=.5*(t[e]+t[n]),t[e+1]=.5*(t[e+1]+t[n+1]),t[e+2]=.5*(t[e+2]+t[n+2]),t[n]=t[e],t[n+1]=t[e+1],t[n+2]=t[e+2]}f.areNormalsFrozen||f.updateVerticesData(r.o.NormalKind,t,!1,!1)}return f}{const a=new o.Kj(e,n);a._originalBuilderSideOrientation=d,a._creationDataStorage=new o.gW;const r=l(t);return u&&(a._creationDataStorage.idx=r._idx),a._creationDataStorage.closePath=u,a._creationDataStorage.closeArray=h,r.applyToMesh(a,p),a}}const h={CreateRibbon:c};i.x.CreateRibbon=l,o.Kj.CreateRibbon=(e,t,n=!1,a,o,r,i=!1,s,l)=>c(e,{pathArray:t,closeArray:n,closePath:a,offset:o,updatable:i,sideOrientation:s,instance:l},r)},9590:(e,t,n)=>{n.d(t,{Gc:()=>s,Oy:()=>h,bC:()=>l});var a=n(972),o=n(3632),r=n(7079),i=n(1021);function s(e,t,n=null){const a=t.path,r=t.shape,i=t.scale||1,s=t.rotation||0,l=0===t.cap?0:t.cap||o.Kj.NO_CAP,h=t.updatable,u=o.Kj._GetDefaultSideOrientation(t.sideOrientation),d=t.instance||null,f=t.invertUV||!1,p=t.closeShape||!1;return c(e,r,a,i,s,null,null,t.closePath||!1,p,l,!1,n,!!h,u,d,f,t.frontUVs||null,t.backUVs||null,t.firstNormal||null,!!t.adjustFrame)}function l(e,t,n=null){const a=t.path,r=t.shape,i=t.scaleFunction||(()=>1),s=t.rotationFunction||(()=>0),l=t.closePath||t.ribbonCloseArray||!1,h=t.closeShape||t.ribbonClosePath||!1,u=0===t.cap?0:t.cap||o.Kj.NO_CAP,d=t.updatable,f=t.firstNormal||null,p=t.adjustFrame||!1;return c(e,r,a,null,null,i,s,l,h,u,!0,n,!!d,o.Kj._GetDefaultSideOrientation(t.sideOrientation),t.instance||null,t.invertUV||!1,t.frontUVs||null,t.backUVs||null,f,p)}function c(e,t,n,s,l,c,h,u,d,f,p,g,_,S,x,y,b,C,A,m){const P=(e,t,n,r,i,s,l,c,h,u,d)=>{const f=n.getTangents(),p=n.getNormals(),g=n.getBinormals(),_=n.getDistances();if(d)for(let e=0;e<f.length;e++)if(0==f[e].x&&0==f[e].y&&0==f[e].z&&f[e].copyFrom(f[e-1]),0==p[e].x&&0==p[e].y&&0==p[e].z&&p[e].copyFrom(p[e-1]),0==g[e].x&&0==g[e].y&&0==g[e].z&&g[e].copyFrom(g[e-1]),e>0){let t=f[e-1];a.P.Dot(t,f[e])<0&&f[e].scaleInPlace(-1),t=p[e-1],a.P.Dot(t,p[e])<0&&p[e].scaleInPlace(-1),t=g[e-1],a.P.Dot(t,g[e])<0&&g[e].scaleInPlace(-1)}let S=0;const x=u&&c?c:()=>null!==s?s:0,y=u&&l?l:()=>null!==i?i:1;let b=h===o.Kj.NO_CAP||h===o.Kj.CAP_END?0:2;const C=a.jp.Matrix[0];for(let n=0;n<t.length;n++){const o=new Array,i=x(n,_[n]),s=y(n,_[n]);a.y3.RotationAxisToRef(f[n],S,C);for(let r=0;r<e.length;r++){const i=f[n].scale(e[r].z).add(p[n].scale(e[r].x)).add(g[n].scale(e[r].y)),l=a.P.Zero();a.P.TransformCoordinatesToRef(i,C,l),l.scaleInPlace(s).addInPlace(t[n]),o[r]=l}r[b]=o,S+=i,b++}const A=e=>{const t=Array(),n=a.P.Zero();let o;for(o=0;o<e.length;o++)n.addInPlace(e[o]);for(n.scaleInPlace(1/e.length),o=0;o<e.length;o++)t.push(n);return t};switch(h){case o.Kj.NO_CAP:break;case o.Kj.CAP_START:r[0]=A(r[2]),r[1]=r[2];break;case o.Kj.CAP_END:r[b]=r[b-1],r[b+1]=A(r[b-1]);break;case o.Kj.CAP_ALL:r[0]=A(r[2]),r[1]=r[2],r[b]=r[b-1],r[b+1]=A(r[b-1])}return r};let D,V;if(x){const e=x._creationDataStorage;return D=A?e.path3D.update(n,A):e.path3D.update(n),V=P(t,n,e.path3D,e.pathArray,s,l,c,h,e.cap,p,m),(0,r.LY)("",{pathArray:V,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:x},g||void 0)}D=A?new i.$B(n,A):new i.$B(n),V=P(t,n,D,new Array,s,l,c,h,f=f<0||f>3?0:f,p,m);const O=(0,r.LY)(e,{pathArray:V,closeArray:u,closePath:d,updatable:_,sideOrientation:S,invertUV:y,frontUVs:b||void 0,backUVs:C||void 0},g);return O._creationDataStorage.pathArray=V,O._creationDataStorage.path3D=D,O._creationDataStorage.cap=f,O}const h={ExtrudeShape:s,ExtrudeShapeCustom:l};o.Kj.ExtrudeShape=(e,t,n,a,r,i,l=null,c,h,u)=>s(e,{shape:t,path:n,scale:a,rotation:r,cap:0===i?0:i||o.Kj.NO_CAP,sideOrientation:h,instance:u,updatable:c},l),o.Kj.ExtrudeShapeCustom=(e,t,n,a,r,i,s,c,h,u,d,f)=>l(e,{shape:t,path:n,scaleFunction:a,rotationFunction:r,ribbonCloseArray:i,ribbonClosePath:s,cap:0===c?0:c||o.Kj.NO_CAP,sideOrientation:d,instance:f,updatable:u},h)},2078:(e,t,n)=>{n.d(t,{E:()=>h,_:()=>c});var a=n(9859),o=n(7959),r=n(3632),i=n(6906),s=n(9061),l=n(3778);n(3135),n(6789),r.Kj._LinesMeshParser=(e,t)=>c.Parse(e,t);class c extends r.Kj{_isShaderMaterial(e){return"ShaderMaterial"===e.getClassName()}constructor(e,t=null,n=null,r=null,i,s,c,h){super(e,t,n,r,i),this.useVertexColor=s,this.useVertexAlpha=c,this.color=new a.Wo(1,1,1),this.alpha=1,r&&(this.color=r.color.clone(),this.alpha=r.alpha,this.useVertexColor=r.useVertexColor,this.useVertexAlpha=r.useVertexAlpha),this.intersectionThreshold=.1;const u={attributes:[o.o.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:[],useClipPlane:null};!1===c?u.needAlphaBlending=!1:u.defines.push("#define VERTEXALPHA"),s?(u.defines.push("#define VERTEXCOLOR"),u.attributes.push(o.o.ColorKind)):(u.uniforms.push("color"),this._color4=new a.HE),h?this.material=h:(this.material=new l.j("colorShader",this.getScene(),"color",u,!1),this.material.doNotSerialize=!0)}isReady(){return!!this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage)&&super.isReady()}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=s.F.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,t){if(!this._geometry)return this;const n=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(this._userInstancedBuffersStorage?this._geometry._bind(t,n,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects):this._geometry._bind(t,n),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r:e,g:t,b:n}=this.color;this._color4.set(e,t,n,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,t,n){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const a=this.getScene().getEngine();return this._unIndexed?a.drawArraysType(s.F.LineListDrawMode,e.verticesStart,e.verticesCount,n):a.drawElementsType(s.F.LineListDrawMode,e.indexStart,e.indexCount,n),this}dispose(e,t=!1,n){n||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,t=null,n){return new c(e,this.getScene(),t,this,n)}createInstance(e){const t=new h(e,this);if(this.instancedBuffers){t.instancedBuffers={};for(const e in this.instancedBuffers)t.instancedBuffers[e]=this.instancedBuffers[e]}return t}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,t){const n=new c(e.name,t);return n.color=a.Wo.FromArray(e.color),n.alpha=e.alpha,n}}class h extends i.S{constructor(e,t){super(e,t),this.intersectionThreshold=t.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}},3135:(e,t,n)=>{var a=n(3127);n(3476),n(8380);a.v.ShadersStore.colorPixelShader="#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}"},6789:(e,t,n)=>{var a=n(3127);n(1041),n(3652),n(2475),n(3816),n(7154),n(6886),n(4120),n(1252),n(9380);a.v.ShadersStore.colorVertexShader="attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}"}}]);
//# sourceMappingURL=198.babylonBundle.js.map