{"version":3,"file":"js/187.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Lights/hemisphericLight.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/instancedMesh.ts"],"sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n","import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._userInstancedBuffersStorage = {\r\n                data: {},\r\n                vertexBuffers: {},\r\n                strides: {},\r\n                sizes: {},\r\n                vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n            };\r\n        }\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n"],"names":["N","name","scene","HemisphericLight","constructor","direction","super","groundColor","this","_buildUniformLayout","_uniformBuffer","addUniform","create","getClassName","setDirectionToTarget","target","subtract","getShadowGenerator","transferToEffect","_effect","lightIndex","normalizeDirection","updateFloat4","x","y","z","updateColor3","scale","intensity","transferToNodeMaterialEffect","effect","lightDataUniformName","setFloat3","computeWorldMatrix","_worldMatrix","getTypeID","prepareLightSpecificDefines","defines","mesh","instance","InstancedMesh","instancedBuffers","key","source","getScene","_indexInSourceMeshInstanceArray","_distanceToCamera","addInstance","_sourceMesh","_unIndexed","position","copyFrom","rotation","scaling","rotationQuaternion","clone","animations","slice","range","getAnimationRanges","createAnimationRange","from","to","infiniteDistance","setPivotMatrix","getPivotMatrix","refreshBoundingInfo","_syncSubMeshes","lightSources","_lightSources","_resyncLightSources","_resyncLightSource","_removeLightSource","receiveShadows","_value","material","visibility","skeleton","renderingGroupId","value","getTotalVertices","getTotalIndices","sourceMesh","createInstance","isReady","completeCheck","getVerticesData","kind","copyWhenShared","forceCopy","setVerticesData","data","updatable","stride","updateVerticesData","updateExtends","makeItUnique","setIndices","indices","totalVertices","isVerticesDataPresent","getIndices","_positions","applySkeleton","applyMorph","hasBoundingInfo","getBoundingInfo","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","_preActivate","_currentLOD","_activate","renderId","intermediateRendering","subMeshes","_getWorldMatrixDeterminant","_internalAbstractMeshDataInfo","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","_postActivate","edgesShareWithInstances","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","push","getWorldMatrix","billboardMode","_masterMesh","_billboardWorldMatrix","tempMaster","set","isAnInstance","getLOD","camera","sourceMeshLODLevels","getLODLevels","length","boundingInfo","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","index","_generatePointsArray","_updateBoundingInfo","update","worldMatrixFromCache","buildBoundingInfo","absolutePosition","_updateSubMeshesBoundingInfo","newParent","doNotCloneChildren","newSourceMesh","result","parent","meshes","onClonedObservable","notifyObservers","dispose","doNotRecurse","disposeMaterialAndTextures","removeInstance","_serializeAsParent","serializationObject","parentId","uniqueId","parentInstanceIndex","instantiateHierarchy","options","onNewNodeCreated","id","newSourcedMesh","child","getChildTransformNodes","_userInstancedBuffersStorage","vertexBuffers","instances","strides","sizes","vertexArrayObjects","getEngine","getCaps","vertexArrayObject","undefined","Float32Array","_invalidateInstanceVertexArrayObject","_markSubMeshesAsAttributesDirty","visibleInstances","renderSelf","instanceCount","size","expectedSize","offset","toArray","copyToArray","instanceIndex","updateDirectly","releaseVertexArrayObject","_instanceDataStorage","instancesBuffer"],"sourceRoot":""}