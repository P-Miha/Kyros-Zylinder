{"version":3,"file":"js/198.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/linesBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/ribbonBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/shapeBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/linesMesh.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Shaders/color.fragment.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Shaders/color.vertex.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare type Material = import(\"../../Materials/material\").Material;\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene>\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\n(Mesh as any).CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n","import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {\r\n                // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            } else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\n(Mesh as any).CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scale\r\n * @param options.rotation\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        options.firstNormal || null,\r\n        options.adjustFrame ? true : false\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scaleFunction\r\n * @param options.rotationFunction\r\n * @param options.ribbonCloseArray\r\n * @param options.ribbonClosePath\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const firstNormal = options.firstNormal || null;\r\n    const adjustFrame = options.adjustFrame || false;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        firstNormal,\r\n        adjustFrame\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>,\r\n    firstNormal: Nullable<Vector3>,\r\n    adjustFrame: boolean\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean,\r\n        adjustFrame: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n        if (adjustFrame) {\r\n            /* fix tangents,normals, binormals */\r\n            for (let i = 0; i < tangents.length; i++) {\r\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\r\n                    tangents[i].copyFrom(tangents[i - 1]);\r\n                }\r\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\r\n                    normals[i].copyFrom(normals[i - 1]);\r\n                }\r\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\r\n                    binormals[i].copyFrom(binormals[i - 1]);\r\n                }\r\n                if (i > 0) {\r\n                    let v = tangents[i - 1];\r\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\r\n                        tangents[i].scaleInPlace(-1);\r\n                    }\r\n                    v = normals[i - 1];\r\n                    if (Vector3.Dot(v, normals[i]) < 0) {\r\n                        normals[i].scaleInPlace(-1);\r\n                    }\r\n                    v = binormals[i - 1];\r\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\r\n                        binormals[i].scaleInPlace(-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath = new Array<Vector3>();\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\n(Mesh as any).ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\n(Mesh as any).ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n","import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\r#else\nuniform vec4 color;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\r#else\ngl_FragColor=color;\r#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\r#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\r#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\r#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\rgl_Position=viewProjection*worldPos;\r} else {\rgl_Position=viewProjectionR*worldPos;\r}\r#else\ngl_Position=viewProjection*worldPos;\r#endif\n#include<clipPlaneVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n"],"names":["CreateLineSystemVertexData","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","x","y","z","color","r","g","b","a","vertexData","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","Array","curvect","lg","nb","shft","dashshft","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLineSystem","name","scene","instance","getVerticesData","vertexColor","lineColors","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","material","applyToMesh","updatable","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","updateMeshPositions","dashedLines","LinesBuilder","CreateRibbonVertexData","pathArray","closeArray","closePath","invertUV","defaultOffset","offset","sideOrientation","customUV","uvs","customColors","normals","us","vs","uTotalDistance","vTotalDistance","minlg","ar1","ar2","idc","closePathCorr","path","vectlg","dist","path1","path2","subtract","u","v","vertex1","vertex2","pi","l1","l2","min","path1nb","indexFirst","indexLast","frontUVs","backUVs","Float32Array","positions32","normals32","uvs32","set","_idx","CreateRibbon","minimum","Number","MAX_VALUE","maximum","mesh","ns","_originalBuilderSideOrientation","si","pathPoint","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","hasBoundingInfo","getBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","colorIndex","areNormalsFrozen","isFacetDataEnabled","getIndices","params","getFacetDataParameters","ribbon","RibbonBuilder","ExtrudeShape","shape","scale","rotation","cap","closeShape","_ExtrudeShapeGeneric","firstNormal","adjustFrame","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","curve","rotateFunction","rbCA","rbCP","custom","updtbl","side","extrusionPathArray","path3D","shapePaths","tangents","getTangents","getNormals","binormals","getBinormals","distances","getDistances","copyFrom","scaleInPlace","angle","rotate","scl","rotationMatrix","shapePath","angleStep","scaleRatio","planed","add","rotated","addInPlace","capPath","pointCap","barycenter","storage","update","extrudedGeneric","ShapeBuilder","parsedMesh","LinesMesh","Parse","_isShaderMaterial","shader","getClassName","constructor","parent","source","doNotCloneChildren","super","alpha","this","clone","intersectionThreshold","attributes","uniforms","needAlphaBlending","defines","useClipPlane","_color4","getScene","doNotSerialize","isReady","_lineMaterial","_userInstancedBuffersStorage","value","fillMode","checkCollisions","_bind","_subMesh","colorEffect","_geometry","indexToBind","isUnIndexed","getIndexBuffer","vertexBuffers","vertexArrayObjects","setColor4","_draw","subMesh","instancesCount","getVertexBuffers","_unIndexed","engine","getEngine","drawArraysType","verticesStart","verticesCount","drawElementsType","indexStart","indexCount","dispose","doNotRecurse","disposeMaterialAndTextures","doNotDisposeMaterial","newParent","createInstance","InstancedLinesMesh","instancedBuffers","key","serialize","serializationObject","asArray","static","result"],"sourceRoot":""}