{"version":3,"file":"js/14.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/Inputs/BaseCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/Inputs/freeCameraKeyboardMoveInput.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/Inputs/freeCameraMouseInput.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/Inputs/freeCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/Inputs/freeCameraTouchInput.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/freeCamera.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Cameras/freeCameraInputsManager.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/boxBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/planeBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        let rotation = (this.rotationSpeed * this._engine.getDeltaTime()) / 1000;\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            rotation *= -1;\r\n        }\r\n        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            rotation *= -1;\r\n        }\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n","import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: () => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (engine.isInVRExclusivePointerMode) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        let offsetX = evt.clientX - this._previousPosition.x;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n                        if (this.camera.getScene().useRightHandedSystem) {\r\n                            offsetX *= -1;\r\n                        }\r\n                        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                            offsetX *= -1;\r\n                        }\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            let offsetX = evt.movementX;\r\n            if (this.camera.getScene().useRightHandedSystem) {\r\n                offsetX *= -1;\r\n            }\r\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                offsetX *= -1;\r\n            }\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = this.onContextMenu.bind(this);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n","import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        const updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n","import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\n(Mesh as any).CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Plane\r\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n * * size sets the width and height of the plane to the value of size, optional default 1\r\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreatePlaneVertexData(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    const halfWidth = width / 2.0;\r\n    const halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane mesh\r\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param options.sourcePlane\r\n * @param scene defines the hosting scene\r\n * @returns the plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#plane\r\n */\r\nexport function CreatePlane(\r\n    name: string,\r\n    options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; updatable?: boolean; sourcePlane?: Plane } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    if (options.sourcePlane) {\r\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n    }\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePlane,\r\n};\r\n\r\nVertexData.CreatePlane = CreatePlaneVertexData;\r\n(Mesh as any).CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreatePlane(name, options, scene);\r\n};\r\n"],"names":["BaseCameraMouseWheelInput","wheelPrecisionX","wheelPrecisionY","wheelPrecisionZ","onChangedObservable","_wheelDeltaX","_wheelDeltaY","_wheelDeltaZ","_ffMultiplier","_normalize","attachControl","noPreventDefault","arguments","this","_wheel","pointer","type","event","platformScale","deltaMode","deltaX","deltaY","deltaZ","preventDefault","_observer","camera","getScene","_inputManager","_addCameraPointerObserver","detachControl","_removeCameraPointerObserver","clear","checkInputs","notifyObservers","wheelDeltaX","wheelDeltaY","wheelDeltaZ","getClassName","getSimpleName","FreeCameraKeyboardMoveInput","keysUp","keysUpward","keysDown","keysDownward","keysLeft","keysRight","rotationSpeed","keysRotateLeft","keysRotateRight","keysRotateUp","keysRotateDown","_keys","Array","_onCanvasBlurObserver","_scene","_engine","getEngine","onCanvasBlurObservable","add","length","_onKeyboardObserver","onKeyboardObservable","info","evt","metaKey","indexOf","keyCode","push","index","splice","remove","speed","_computeLocalCameraSpeed","_localDirection","copyFromFloats","cameraRotation","y","_getLocalRotation","x","useRightHandedSystem","z","getViewMatrix","invertToRef","_cameraTransformMatrix","_transformedDirection","cameraDirection","addInPlace","_onLostFocus","rotation","getDeltaTime","parent","_getWorldMatrixDeterminant","FreeCameraMouseInput","constructor","touchEnabled","buttons","angularSensibility","_previousPosition","onPointerMovedObservable","_allowCameraRotation","_currentActiveButton","_activePointerId","engine","element","getInputElement","_pointerInput","p","isTouch","pointerType","isInVRExclusivePointerMode","button","srcElement","target","pointerId","setPointerCapture","e","clientX","clientY","focus","isPointerLock","_onMouseMove","releasePointerCapture","offsetX","offsetY","movementX","movementY","_contextMenuBind","onContextMenu","bind","addEventListener","removeEventListener","_CameraProperty","FreeCameraMouseWheelInput","_moveRelative","_rotateRelative","_moveScene","_wheelXAction","MoveRelative","_wheelXActionCoordinate","_wheelYAction","_wheelYActionCoordinate","_wheelZAction","_wheelZActionCoordinate","wheelXMoveRelative","axis","wheelYMoveRelative","wheelZMoveRelative","wheelXRotateRelative","RotateRelative","wheelYRotateRelative","wheelZRotateRelative","wheelXMoveScene","MoveScene","wheelYMoveScene","wheelZMoveScene","setAll","_updateCamera","cameraTransformMatrix","transformedDirection","super","_updateCameraProperty","value","cameraProperty","coordinate","action","set","FreeCameraTouchInput","allowMouse","touchAngularSensibility","touchMoveSensibility","singleFingerRotate","_offsetX","_offsetY","_pointerPressed","_isSafari","previousPosition","undefined","isMouseEvent","direction","_cameraRotationMatrix","FreeCamera","mouse","inputs","attached","keyboard","name","position","scene","setActiveOnSceneIfNoneActive","ellipsoid","ellipsoidOffset","checkCollisions","applyGravity","_needMoveForGravity","_oldPosition","_diffPosition","_newPosition","_collisionMask","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","newPos","copyFrom","subtractToRef","onCollide","updatePosition","addKeyboard","addMouse","ignored","attachElement","detachElement","collisionMask","mask","isNaN","_collideWithWorld","displacement","globalPosition","getWorldMatrix","subtractFromFloatsToRef","coordinator","collisionCoordinator","_collider","createCollider","_radius","actualDisplacement","gravity","getNewPosition","uniqueId","_checkInputs","_decideIfNeedsToMove","Math","abs","_updatePosition","collisionsEnabled","dispose","FreeCameraInputsManager","_mouseInput","_mouseWheelInput","removeMouse","addMouseWheel","removeMouseWheel","addTouch","CreateBoxVertexData","options","indices","normals","uvs","positions","width","size","height","depth","wrap","topBaseAt","bottomBaseAt","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","concat","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","faceUV","faceColors","colors","f","w","c","r","g","b","a","frontUVs","backUVs","vertexData","totalColors","CreateBox","box","_originalBuilderSideOrientation","applyToMesh","updatable","BoxBuilder","CreatePlaneVertexData","halfWidth","halfHeight","CreatePlane","plane","sourcePlane","translate","normal","d","setDirection","scale","PlaneBuilder"],"sourceRoot":""}