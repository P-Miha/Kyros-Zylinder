{"version":3,"file":"js/419.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v1/Plugins/ammoJSPlugin.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v1/physicsImpostor.ts"],"sourcesContent":["import { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData } from \"..//physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../../Meshes/mesh\";\r\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder\";\r\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder\";\r\nimport type { LinesMesh } from \"../../../Meshes/linesMesh\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n    private _tmpContactNormal = new Vector3();\r\n    private _tmpContactDistance: number;\r\n    private _tmpContactImpulse: number;\r\n    private _tmpVec3 = new Vector3();\r\n\r\n    private static readonly _DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly _KINEMATIC_FLAG = 2;\r\n    private static readonly _DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            const worldNormal = contactPoint.m_normalWorldOnB;\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactNormal.x = worldNormal.x();\r\n            this._tmpContactNormal.y = worldNormal.y();\r\n            this._tmpContactNormal.z = worldNormal.z();\r\n            this._tmpContactImpulse = contactPoint.getAppliedImpulse();\r\n            this._tmpContactDistance = contactPoint.getDistance();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom mesh impostor handler function to support building custom mesh impostor vertex data\r\n     */\r\n    public onCreateCustomMeshImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom convex hull impostor handler function to support building custom convex hull impostor vertex data\r\n     */\r\n    public onCreateCustomConvexHullImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (const impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (const mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            } else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (const otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({\r\n                                        body: otherImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                    otherImpostor.onCollide({\r\n                                        body: mainImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        } else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        const nbVertices = bodyVertices.size();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        const path: Array<Vector3> = new Array();\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        const object = impostor.object;\r\n        const shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        } else {\r\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\r\n        const object = impostor.object;\r\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        const nbVertices = vertexPositions.length / 3;\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        let nx, ny, nz: number;\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            const nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        const vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\r\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\r\n            } else {\r\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            }\r\n\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const colShape = this._createShape(impostor);\r\n            const mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            } else {\r\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                const startTransform = new this.bjsAMMO.btTransform();\r\n                impostor.object.computeWorldMatrix(true);\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(\r\n                    impostor.object.rotationQuaternion!.x,\r\n                    impostor.object.rotationQuaternion!.y,\r\n                    impostor.object.rotationQuaternion!.z,\r\n                    impostor.object.rotationQuaternion!.w\r\n                );\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                // compute delta position: compensate the difference between shape center and mesh origin\r\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\r\n                    const boundingInfo = impostor.object.getBoundingInfo();\r\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\r\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\r\n                    this._tmpVec3.x /= impostor.object.scaling.x;\r\n                    this._tmpVec3.y /= impostor.object.scaling.y;\r\n                    this._tmpVec3.z /= impostor.object.scaling.z;\r\n                    impostor.setDeltaPosition(this._tmpVec3);\r\n                }\r\n\r\n                const group = impostor.getParam(\"group\");\r\n                const mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        const jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        let joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint: {\r\n                const distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.HingeJoint: {\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z),\r\n                    mainAxis,\r\n                    connectedAxis\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n\r\n            let localMatrix;\r\n\r\n            if (topLevelObject && topLevelObject !== object) {\r\n                // top level matrix used for shape transform doesn't take scale into account.\r\n                // Moreover, every children vertex position must be in that space.\r\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\r\n                let topLevelQuaternion;\r\n                if (topLevelObject.rotationQuaternion) {\r\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\r\n                } else if (topLevelObject.rotation) {\r\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\r\n                } else {\r\n                    topLevelQuaternion = Quaternion.Identity();\r\n                }\r\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\r\n                topLevelMatrix.invertToRef(this._tmpMatrix);\r\n                const wm = object.computeWorldMatrix(false);\r\n                localMatrix = wm.multiply(this._tmpMatrix);\r\n            } else {\r\n                // current top level is same as object level -> only use local scaling\r\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                localMatrix = this._tmpMatrix;\r\n            }\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    v = Vector3.TransformCoordinates(v, localMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const newPoints = [];\r\n            const newNorms = [];\r\n            for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            const vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const triPoints = [];\r\n                const triNorms = [];\r\n                for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\r\n\r\n                const nbVertices = vertexPositions.length / 3;\r\n                const bodyVertices = softBody.get_m_nodes();\r\n                let node: any;\r\n                let nodeNormals: any;\r\n                for (let i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const len = vertexPositions.length;\r\n                const segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                const segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        let len: number;\r\n        let segments: number;\r\n        const vertex_data = this._softVertexData(impostor);\r\n        const vertexPositions = vertex_data.positions;\r\n        const vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        const vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        const reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        const reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) {\r\n            // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        } else {\r\n            //extruded mesh\r\n            impostor._isFromLine = false;\r\n            const pathVectors = impostor.getParam(\"path\");\r\n            const shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\r\n\r\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue: any;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n\r\n        if (!ignoreChildren) {\r\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            let childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                const childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    const shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    const parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    const s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(\r\n                        childMesh.rotationQuaternion!.x,\r\n                        childMesh.rotationQuaternion!.y,\r\n                        childMesh.rotationQuaternion!.z,\r\n                        childMesh.rotationQuaternion!.w\r\n                    );\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    const shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\r\n                if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    const radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                {\r\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\r\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\r\n                    const capRadius = impostorExtents.x / 2;\r\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape if the impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    if (this.onCreateCustomMeshImpostor) {\r\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\r\n                    } else {\r\n                        const triMesh = new this.bjsAMMO.btTriangleMesh();\r\n                        impostor._pluginData.toDispose.push(triMesh);\r\n                        const triangleCount = this._addMeshVerts(triMesh, object, object);\r\n                        if (triangleCount == 0) {\r\n                            returnValue = new this.bjsAMMO.btCompoundShape();\r\n                        } else {\r\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // Otherwise create convexHullImpostor\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsImpostor.ConvexHullImpostor: {\r\n                if (this.onCreateCustomConvexHullImpostor) {\r\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\r\n                } else {\r\n                    const convexHull = new this.bjsAMMO.btConvexHullShape();\r\n                    const triangleCount = this._addHullVerts(convexHull, object, object);\r\n                    if (triangleCount == 0) {\r\n                        // Cleanup Unused Convex Hull Shape\r\n                        impostor._pluginData.toDispose.push(convexHull);\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = convexHull;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh body position/rotation from the babylon impostor\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(\r\n                    this._tmpAmmoTransform.getRotation().x(),\r\n                    this._tmpAmmoTransform.getRotation().y(),\r\n                    this._tmpAmmoTransform.getRotation().z(),\r\n                    this._tmpAmmoTransform.getRotation().w()\r\n                );\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(\r\n                this._tmpAmmoTransform.getRotation().x(),\r\n                this._tmpAmmoTransform.getRotation().y(),\r\n                this._tmpAmmoTransform.getRotation().z(),\r\n                this._tmpAmmoTransform.getRotation().w()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                const motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.linearVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.angularVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        } else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        } else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets restitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            } else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        } else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        } else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        } else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append an anchor to a cloth object\r\n     * @param impostor is the cloth impostor to add anchor to\r\n     * @param otherImpostor is the rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendAnchor(\r\n        impostor: PhysicsImpostor,\r\n        otherImpostor: PhysicsImpostor,\r\n        width: number,\r\n        height: number,\r\n        influence: number = 1,\r\n        noCollisionBetweenLinkedBodies: boolean = false\r\n    ) {\r\n        const segs = impostor.segments;\r\n        const nbAcross = Math.round((segs - 1) * width);\r\n        const nbUp = Math.round((segs - 1) * height);\r\n        const nbDown = segs - 1 - nbUp;\r\n        const node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        const node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.forceActivationState(0);\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     */\r\n    public updateDistanceJoint() {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     */\r\n    public setLimit() {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const extents = impostor.getObjectExtents();\r\n        return extents.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const extents = impostor.getObjectExtents();\r\n        result.x = extents.x;\r\n        result.y = extents.y;\r\n        result.z = extents.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of temp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from where should the ray start?\r\n     * @param to where should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        result.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            result.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            result.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n    }\r\n}\r\n","import type { Nullable, IndicesArray } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { ArrayTools } from \"../../Misc/arrayTools\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Bone } from \"../../Bones/bone\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { PhysicsEngine as PhysicsEngineV1 } from \"./physicsEngine\";\r\n\r\nimport type { PhysicsJointData } from \"./physicsJoint\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function (scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(\r\n        physicObject,\r\n        jsonObject.physicsImpostor,\r\n        {\r\n            mass: jsonObject.physicsMass,\r\n            friction: jsonObject.physicsFriction,\r\n            restitution: jsonObject.physicsRestitution,\r\n        },\r\n        scene\r\n    );\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsImpostor {\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @internal */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<PhysicsEngineV1>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @internal */\r\n    public _onPhysicsCollideCallbacks: Array<{\r\n        callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>, distance: number, impulse: number, normal: Nullable<Vector3>) => void;\r\n        otherImpostors: Array<PhysicsImpostor>;\r\n    }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @internal */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private static _TmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint;\r\n        otherImpostor: PhysicsImpostor;\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter. Types are available as static members of this class.\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number,\r\n        private _options: PhysicsImpostorParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as any;\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n            }\r\n            //default options params\r\n            this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n            this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n            this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\r\n                this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\r\n                this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\r\n                this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\r\n                this._options.path = _options.path === void 0 ? null : _options.path;\r\n                this._options.shape = _options.shape === void 0 ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completely initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @internal\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            const parentMesh: AbstractMesh = <AbstractMesh>this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && (!this._parent || !!this._options.ignoreParent));\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use with caution - This will remove all previously-instantiated joints.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const q = this.object.rotationQuaternion;\r\n            const scaling = this.object.scaling.clone();\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter's collision callback\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        let index = -1;\r\n        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                const sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        this._deltaRotationConjugated &&\r\n            this.object.rotationQuaternion &&\r\n            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            this.object.rotationQuaternion &&\r\n                this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n        }\r\n\r\n        this._onBeforePhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterPhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        if (this._deltaRotation) {\r\n            this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\r\n            this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\r\n        } else {\r\n            this.object.translate(this._deltaPosition, 1);\r\n        }\r\n        this.object.computeWorldMatrix(true);\r\n    };\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     *\r\n     * @param e\r\n     * @returns\r\n     */\r\n    public onCollide = (e: { body: any; point: Nullable<Vector3>; distance: number; impulse: number; normal: Nullable<Vector3> }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            this._onPhysicsCollideCallbacks\r\n                .filter((obj) => {\r\n                    return obj.otherImpostors.indexOf(<PhysicsImpostor>otherImpostor) !== -1;\r\n                })\r\n                .forEach((obj) => {\r\n                    obj.callback(this, <PhysicsImpostor>otherImpostor, e.point, e.distance, e.impulse, e.normal);\r\n                });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        const joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint,\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor!(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) {\r\n            return null;\r\n        }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._joints.forEach((j) => {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        });\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        } else {\r\n            /*this._object.getChildMeshes().forEach(function(mesh) {\r\n                if (mesh.physicsImpostor) {\r\n                    if (disposeChildren) {\r\n                        mesh.physicsImpostor.dispose();\r\n                        mesh.physicsImpostor = null;\r\n                    }\r\n                }\r\n            })*/\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n        const tempVec = PhysicsImpostor._TmpVecs[0];\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = PhysicsImpostor._TmpVecs[0];\r\n        const boneDir = PhysicsImpostor._TmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._TmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type (Only available to objects with vertices data)\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n"],"names":["AmmoJSPlugin","_useDeltaForWorldStep","ammoInjection","Ammo","overlappingPairCache","bjsAMMO","name","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpContactPoint","_tmpContactNormal","_tmpVec3","_tmpMatrix","this","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","contactPoint","worldPoint","wrapPointer","btManifoldPoint","getPositionWorldOnA","worldNormal","m_normalWorldOnB","x","y","z","_tmpContactImpulse","getAppliedImpulse","_tmpContactDistance","getDistance","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","getPluginVersion","setGravity","gravity","setValue","getWorldInfo","set_m_gravity","setTimeStep","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","getTimeStep","_isImpostorInContact","impostor","contactTest","physicsBody","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","executeStep","delta","impostors","soft","beforeStep","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","length","collideCallback","otherImpostor","otherImpostors","isActive","onCollide","body","point","distance","impulse","normal","type","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","size","node","nodePositions","path","Array","n","at","get_m_x","push","object","shape","getParam","_isFromLine","points","instance","normalDirection","vertexPositions","getVerticesData","vertexNormals","nx","ny","nz","nodeNormals","get_m_n","vertex_data","positions","normals","uvs","colors","getIndices","indices","applyToMesh","applyImpulse","force","activate","getWorldMatrix","subtractInPlace","getTranslation","applyForce","localTranslation","generatePhysicsBody","_pluginData","toDispose","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","mass","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","computeWorldMatrix","calculateLocalInertia","position","rotationQuaternion","w","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","getChildShape","_DISABLE_COLLISION_FLAG","boundingInfo","getBoundingInfo","copyFrom","getAbsolutePosition","boundingBox","centerWorld","scaling","setDeltaPosition","group","mask","addRigidBody","concat","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","forEach","d","destroy","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","maxDistance","btPoint2PointConstraint","mainAxis","connectedAxis","btHingeConstraint","addConstraint","collision","physicsJoint","removeJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","rotation","invertToRef","multiply","faceCount","i","triPoints","vec","v","addTriangle","m","_softVertexData","newPoints","newNorms","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","segments","Math","sqrt","segs","CreatePatch","_createRope","map","reduce","accumulator","currentValue","pathVectors","fixedPoints","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","impostorExtents","getObjectExtents","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","clone","s","decompose","getOrigin","addChildShape","dispose","btSphereShape","radii","btMultiSphereShape","setLocalScaling","capRadius","btCapsuleShape","btCylinderShape","btBoxShape","onCreateCustomMeshImpostor","triMesh","btBvhTriangleMeshShape","onCreateCustomConvexHullImpostor","convexHull","setTransformationFromPhysicsBody","getMotionState","getWorldTransform","set","getRotation","toEulerAnglesToRef","setPhysicsBodyTransformation","newPosition","newRotation","trans","abs","setWorldTransform","motionState","undefined","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","result","getAngularVelocity","setBodyMass","setTotalMass","setMassProps","getBodyMass","getBodyFriction","friction","set_kDF","setFriction","getBodyRestitution","restitution","setRestitution","getBodyPressure","pressure","set_kPR","getBodyStiffness","stiffness","get_m_materials","set_m_kLST","getBodyVelocityIterations","velocityIterations","set_viterations","getBodyPositionIterations","positionIterations","set_piterations","appendAnchor","width","height","influence","noCollisionBetweenLinkedBodies","round","appendHook","sleepBody","forceActivationState","wakeUpBody","updateDistanceJoint","setMotor","speed","maxForce","enableAngularMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","getBoxSizeToRef","extents","raycast","from","to","raycastToRef","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance","scene","physicObject","jsonObject","PhysicsImpostor","physicsImpostor","physicsMass","physicsFriction","physicsRestitution","isDisposed","_isDisposed","_physicsEngine","getPhysicsPlugin","value","setMass","plugin","constructor","_options","_scene","_bodyUpdateRequired","_onBeforePhysicsStepCallbacks","_onAfterPhysicsStepCallbacks","_deltaPosition","_tmpQuat","_tmpQuat2","translate","_deltaRotationConjugated","multiplyToRef","getParentsRotation","disableBidirectionalTransformation","func","conjugateInPlace","setAbsolutePosition","_deltaRotation","applyRotationQuaternionToRef","_TmpVecs","onCollideEvent","e","getImpostorWithPhysicsBody","filter","obj","indexOf","callback","getScene","getPhysicsEngine","margin","damping","_joints","ignoreParent","_init","removeImpostor","_parent","_getPhysicsParent","addImpostor","_physicsBody","setScalingUpdated","resetUpdateFlags","q","IDENTITY_QUATERNION","worldMatrix","extendSize","scale","multiplyInPlace","DEFAULT_OBJECT_SIZE","getObjectCenter","paramName","setParam","executeNativeFunction","registerBeforePhysicsStep","unregisterBeforePhysicsStep","index","splice","registerAfterPhysicsStep","unregisterAfterPhysicsStep","registerOnPhysicsCollide","collideAgainst","collidedAgainstList","unregisterOnPhysicsCollide","some","cbDef","idx","sameList","every","copyFromFloats","createJoint","jointType","addJoint","addAnchor","addHook","sleep","wakeUp","newObject","j","setDeltaRotation","conjugate","syncBoneWithImpostor","bone","boneMesh","jointPivot","distToJoint","adjustRotation","tempVec","tempQuat","_TmpQuat","setRotationQuaternion","getDirectionToRef","getParent","addInPlace","syncImpostorWithBone","boneAxis","getRotationQuaternionToRef","pos","boneDir","getAbsolutePositionToRef","NoImpostor","SphereImpostor","BoxImpostor","PlaneImpostor","MeshImpostor","CapsuleImpostor","CylinderImpostor","ParticleImpostor","HeightmapImpostor","ConvexHullImpostor","CustomImpostor","RopeImpostor","ClothImpostor","SoftbodyImpostor"],"sourceRoot":""}