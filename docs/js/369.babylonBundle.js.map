{"version":3,"file":"js/369.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Culling/ray.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/capsuleBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/cylinderBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/decalBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/discBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/geodesicBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/goldbergBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/icoSphereBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/latheBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/polygonBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/polyhedronBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/textBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/tiledBoxBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/tiledPlaneBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/torusBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/torusKnotBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/Builders/tubeBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Maths/math.isovector.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/geodesicMesh.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/goldbergMesh.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/meshBuilder.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Meshes/polygonMesh.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Navigation/Plugins/recastJSPlugin.ts"],"sourcesContent":["import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const direction = end.subtract(origin);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = EngineStore.LastCreatedEngine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): PickingInfo;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        viewport.width,\r\n        viewport.height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos = new Array<PickingInfo>();\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n","import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsuleVertexData(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n    }\r\n): VertexData {\r\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\r\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\r\n    const height = Math.max(options.height ? options.height : 1, 0);\r\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\r\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\r\n\r\n    const radialSegments = tessellation;\r\n    const heightSegments = subdivisions;\r\n\r\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\r\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\r\n\r\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    const thetaStart = 0.0;\r\n    const thetaLength = 2.0 * Math.PI;\r\n\r\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    let indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    let index = 0;\r\n    const indexArray = [],\r\n        halfHeight = heightMinusCaps * 0.5;\r\n    const pi2 = Math.PI * 0.5;\r\n\r\n    let x, y;\r\n    const normal = Vector3.Zero();\r\n    const vertex = Vector3.Zero();\r\n\r\n    const cosAlpha = Math.cos(alpha);\r\n    const sinAlpha = Math.sin(alpha);\r\n\r\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\r\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\r\n        .length();\r\n\r\n    // Total length for v texture coord\r\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\r\n\r\n    let v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n        const indexRow = [];\r\n\r\n        const a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += (radiusTop * alpha) / capsTopSegments;\r\n\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        const indexRow = [];\r\n        v += coneLength / heightSegments;\r\n        // calculate the radius of the current row\r\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        const indexRow = [];\r\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += (radiusBottom * alpha) / capsBottomSegments;\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\r\n            // we use the index array to access the correct indices\r\n            const i1 = indexArray[y][x];\r\n            const i2 = indexArray[y + 1][x];\r\n            const i3 = indexArray[y + 1][x + 1];\r\n            const i4 = indexArray[y][x + 1];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        const m = new Matrix();\r\n        options.orientation\r\n            .clone()\r\n            .scale(Math.PI * 0.5)\r\n            .cross(Vector3.Up())\r\n            .toQuaternion()\r\n            .toRotationMatrix(m);\r\n        const v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    const vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n}\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions {\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions?: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation?: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height?: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius?: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions?: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n\r\n    /** Internal geometry is supposed to change once created. */\r\n    updatable?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh\r\n * @param options The constructors options.\r\n * @param scene The scene the mesh is scoped to.\r\n * @returns Capsule Mesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsule(\r\n    name: string,\r\n    options: ICreateCapsuleOptions = {\r\n        orientation: Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n        updatable: false,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const capsule = new Mesh(name, scene);\r\n    const vertexData = CreateCapsuleVertexData(options);\r\n    vertexData.applyToMesh(capsule, options.updatable);\r\n    return capsule;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateCapsule directly\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const CapsuleBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCapsule,\r\n};\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\n(Mesh as any).CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh => {\r\n    return CreateCapsule(name, options, scene);\r\n};\r\n\r\nVertexData.CreateCapsule = CreateCapsuleVertexData;\r\n","import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = options.tessellation || 24;\r\n    const subdivisions: number = options.subdivisions || 1;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    const colors = new Array<number>();\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.updatable\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\n(Mesh as any).CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n","import type { Nullable, IndicesArray, FloatArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\nconst xpAxis = new Vector3(1, 0, 0);\r\nconst xnAxis = new Vector3(-1, 0, 0);\r\nconst ypAxis = new Vector3(0, 1, 0);\r\nconst ynAxis = new Vector3(0, -1, 0);\r\nconst zpAxis = new Vector3(0, 0, 1);\r\nconst znAxis = new Vector3(0, 0, -1);\r\n\r\n/** @internal */\r\nclass DecalVertex {\r\n    constructor(\r\n        public position: Vector3 = Vector3.Zero(),\r\n        public normal: Vector3 = Vector3.Up(),\r\n        public uv: Vector2 = Vector2.Zero(),\r\n        public vertexIdx: number = 0,\r\n        public vertexIdxForBones: number = 0,\r\n        public localPositionOverride: Nullable<number[]> = null,\r\n        public localNormalOverride: Nullable<number[]> = null,\r\n        public matrixIndicesOverride: Nullable<number[]> = null,\r\n        public matrixWeightsOverride: Nullable<number[]> = null\r\n    ) {}\r\n    public clone(): DecalVertex {\r\n        return new DecalVertex(\r\n            this.position.clone(),\r\n            this.normal.clone(),\r\n            this.uv.clone(),\r\n            this.vertexIdx,\r\n            this.vertexIdxForBones,\r\n            this.localPositionOverride?.slice(),\r\n            this.localNormalOverride?.slice(),\r\n            this.matrixIndicesOverride?.slice(),\r\n            this.matrixWeightsOverride?.slice()\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\r\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\r\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\r\n * Note: Meshes with morph targets are not supported!\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @param options.position\r\n * @param options.normal\r\n * @param options.size\r\n * @param options.angle\r\n * @param options.captureUVS\r\n * @param options.cullBackFaces\r\n * @param options.localMode\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\r\n */\r\nexport function CreateDecal(\r\n    name: string,\r\n    sourceMesh: AbstractMesh,\r\n    options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean; cullBackFaces?: boolean; localMode?: boolean }\r\n): Mesh {\r\n    const hasSkeleton = !!sourceMesh.skeleton;\r\n    const useLocalComputation = options.localMode || hasSkeleton;\r\n    const meshHasOverridenMaterial = (sourceMesh as Mesh).overrideMaterialSideOrientation !== null && (sourceMesh as Mesh).overrideMaterialSideOrientation !== undefined;\r\n\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\r\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\r\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\r\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\r\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\r\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\r\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number, transformMatrix: Matrix): DecalVertex => {\r\n        const result = new DecalVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n\r\n        result.vertexIdx = vertexId * 3;\r\n        result.vertexIdxForBones = vertexId * 4;\r\n\r\n        // Send vector to decal local world\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const emptyArray = [0, 0, 0, 0];\r\n\r\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: DecalVertex[], axis: Vector3): Nullable<DecalVertex[]> => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const indexOf = (arr: FloatArray | number[], val: number, start: number, num: number) => {\r\n            for (let i = 0; i < num; ++i) {\r\n                if (arr[start + i] === val) {\r\n                    return start + i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n        const clipVertices = (v0: DecalVertex, v1: DecalVertex): DecalVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            let indices = emptyArray;\r\n            let weights = emptyArray;\r\n\r\n            if (matIndices && matWeights) {\r\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\r\n                const v0Indices = v0.matrixIndicesOverride ?? matIndices;\r\n                const v0Weights = v0.matrixWeightsOverride ?? matWeights;\r\n\r\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\r\n                const v1Indices = v1.matrixIndicesOverride ?? matIndices;\r\n                const v1Weights = v1.matrixWeightsOverride ?? matWeights;\r\n\r\n                indices = [0, 0, 0, 0];\r\n                weights = [0, 0, 0, 0];\r\n\r\n                let index = 0;\r\n                for (let i = 0; i < 4; ++i) {\r\n                    if (v0Weights[mat0Index + i] > 0) {\r\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\r\n                        indices[index] = v0Indices[mat0Index + i];\r\n                        weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\r\n                        index++;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < 4 && index < 4; ++i) {\r\n                    const ind = v1Indices[mat1Index + i];\r\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\r\n\r\n                    indices[index] = ind;\r\n                    weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\r\n                    index++;\r\n                }\r\n\r\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\r\n\r\n                weights[0] /= sumw;\r\n                weights[1] /= sumw;\r\n                weights[2] /= sumw;\r\n                weights[3] /= sumw;\r\n            }\r\n\r\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\r\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\r\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\r\n\r\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\r\n\r\n            return new DecalVertex(\r\n                Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(),\r\n                Vector2.Lerp(v0.uv, v1.uv, clipFactor),\r\n                -1,\r\n                -1,\r\n                localPositions\r\n                    ? [\r\n                          v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\r\n                          v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\r\n                          v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\r\n                      ]\r\n                    : null,\r\n                localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null,\r\n                indices,\r\n                weights\r\n            );\r\n        };\r\n\r\n        let clipResult: Nullable<DecalVertex[]> = null;\r\n\r\n        if (vertices.length > 3) {\r\n            clipResult = new Array<DecalVertex>();\r\n        }\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<DecalVertex> = null;\r\n            let nV2: Nullable<DecalVertex> = null;\r\n            let nV3: Nullable<DecalVertex> = null;\r\n            let nV4: Nullable<DecalVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    if (vertices.length > 3) {\r\n                        clipResult!.push(vertices[index]);\r\n                        clipResult!.push(vertices[index + 1]);\r\n                        clipResult!.push(vertices[index + 2]);\r\n                    } else {\r\n                        clipResult = vertices;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        clipResult.push(nV3);\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV1.clone());\r\n\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        clipResult.push(nV1.clone());\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3);\r\n\r\n                        clipResult.push(nV4);\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return clipResult;\r\n    };\r\n\r\n    const sourceMeshAsMesh = sourceMesh as Mesh;\r\n    const matrixData = sourceMeshAsMesh._thinInstanceDataStorage.matrixData;\r\n\r\n    const numMatrices = sourceMeshAsMesh.thinInstanceCount || 1;\r\n    const thinInstanceMatrix = TmpVectors.Matrix[0];\r\n\r\n    thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\r\n\r\n    for (let m = 0; m < numMatrices; ++m) {\r\n        if (sourceMeshAsMesh.hasThinInstances && matrixData) {\r\n            const ofst = m * 16;\r\n\r\n            thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\r\n            thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\r\n            thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\r\n            thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\r\n        }\r\n\r\n        // Matrix\r\n        const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n        const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n        const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\r\n\r\n        const oneFaceVertices = new Array<DecalVertex>(3);\r\n\r\n        for (let index = 0; index < indices.length; index += 3) {\r\n            let faceVertices: Nullable<DecalVertex[]> = oneFaceVertices;\r\n\r\n            faceVertices[0] = extractDecalVector3(index, transformMatrix);\r\n            if (meshHasOverridenMaterial && useLocalComputation) {\r\n                faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);\r\n            } else {\r\n                faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\r\n                faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\r\n            }\r\n\r\n            if (options.cullBackFaces) {\r\n                // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\r\n                // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\r\n                if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Clip\r\n            faceVertices = clip(faceVertices, xpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, xnAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ypAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ynAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, zpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, znAxis);\r\n            if (!faceVertices) continue;\r\n\r\n            // Add UVs and get back to world\r\n            for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                const vertex = faceVertices[vIndex];\r\n\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n                if (useLocalComputation) {\r\n                    if (vertex.localPositionOverride) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\r\n                    } else if (localPositions) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\r\n                    }\r\n                    if (vertex.localNormalOverride) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\r\n                    } else if (localNormals) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\r\n                    }\r\n                } else {\r\n                    vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                    vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                }\r\n                if (vertexData.matricesIndices && vertexData.matricesWeights) {\r\n                    if (vertex.matrixIndicesOverride) {\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\r\n                    } else {\r\n                        if (matIndices) {\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matIndicesExtra && vertexData.matricesIndicesExtra) {\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                    if (vertex.matrixWeightsOverride) {\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\r\n                    } else {\r\n                        if (matWeights) {\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matWeightsExtra && vertexData.matricesWeightsExtra) {\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!options.captureUVS) {\r\n                    (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                    const v = 0.5 + vertex.position.y / size.y;\r\n                    (<number[]>vertexData.uvs).push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                } else {\r\n                    vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n                }\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\r\n    if (vertexData.indices.length === 0) vertexData.indices = null;\r\n    if (vertexData.positions.length === 0) vertexData.positions = null;\r\n    if (vertexData.normals.length === 0) vertexData.normals = null;\r\n    if (vertexData.uvs.length === 0) vertexData.uvs = null;\r\n    if (vertexData.matricesIndices?.length === 0) vertexData.matricesIndices = null;\r\n    if (vertexData.matricesWeights?.length === 0) vertexData.matricesWeights = null;\r\n    if (vertexData.matricesIndicesExtra?.length === 0) vertexData.matricesIndicesExtra = null;\r\n    if (vertexData.matricesWeightsExtra?.length === 0) vertexData.matricesWeightsExtra = null;\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    if (useLocalComputation) {\r\n        decal.skeleton = sourceMesh.skeleton;\r\n        decal.parent = sourceMesh;\r\n    } else {\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n    }\r\n\r\n    decal.computeWorldMatrix(true);\r\n    decal.refreshBoundingInfo(true, true);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\n(Mesh as any).CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the Disc or regular Polygon\r\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n * * radius the radius of the disc, optional default 0.5\r\n * * tessellation the number of polygon sides, optional, default 64\r\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.arc\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the box\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateDiscVertexData(options: {\r\n    radius?: number;\r\n    tessellation?: number;\r\n    arc?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    const radius = options.radius || 0.5;\r\n    const tessellation = options.tessellation || 64;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0); // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    const theta = Math.PI * 2 * arc;\r\n    const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    let a = 0;\r\n    for (let t = 0; t < tessellation; t++) {\r\n        const x = Math.cos(a);\r\n        const y = Math.sin(a);\r\n        const u = (x + 1) / 2;\r\n        const v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    const vertexNb = positions.length / 3;\r\n    for (let i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane polygonal mesh.  By default, this is a disc\r\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the plane polygonal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#disc-or-regular-polygon\r\n */\r\nexport function CreateDisc(\r\n    name: string,\r\n    options: { radius?: number; tessellation?: number; arc?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const disc = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateDiscVertexData(options);\r\n\r\n    vertexData.applyToMesh(disc, options.updatable);\r\n\r\n    return disc;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateDisc directly\r\n */\r\nexport const DiscBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDisc,\r\n};\r\n\r\nVertexData.CreateDisc = CreateDiscVertexData;\r\n\r\n(Mesh as any).CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateDisc(name, options, scene);\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { CreatePolyhedron } from \"./polyhedronBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\n\r\n/**\r\n * Creates the Mesh for a Geodesic Polyhedron\r\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/geodesic_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * m number of horizontal steps along an isogrid\r\n * * n number of angled steps along an isogrid\r\n * * size the size of the Geodesic, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.n\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.m\r\n * @param scene defines the hosting scene\r\n * @returns Geodesic mesh\r\n */\r\nexport function CreateGeodesic(\r\n    name: string,\r\n    options: {\r\n        m?: number;\r\n        n?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n\r\n    const geoOptions: object = {\r\n        custom: geodesicData,\r\n        size: options.size,\r\n        sizeX: options.sizeX,\r\n        sizeY: options.sizeY,\r\n        sizeZ: options.sizeZ,\r\n        faceUV: options.faceUV,\r\n        faceColors: options.faceColors,\r\n        flat: options.flat,\r\n        updatable: options.updatable,\r\n        sideOrientation: options.sideOrientation,\r\n        frontUVs: options.frontUVs,\r\n        backUVs: options.backUVs,\r\n    };\r\n    const geodesic = CreatePolyhedron(name, geoOptions, scene);\r\n\r\n    return geodesic;\r\n}\r\n","import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { PolyhedronData } from \"../geodesicMesh\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\nimport { GoldbergMesh } from \"../goldbergMesh\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Defines the set of data required to create goldberg vertex data.\r\n */\r\nexport type GoldbergVertexDataOption = {\r\n    /**\r\n     * the size of the Goldberg, optional default 1\r\n     */\r\n    size?: number;\r\n    /**\r\n     * allows stretching in the x direction, optional, default size\r\n     */\r\n    sizeX?: number;\r\n    /**\r\n     * allows stretching in the y direction, optional, default size\r\n     */\r\n    sizeY?: number;\r\n    /**\r\n     * allows stretching in the z direction, optional, default size\r\n     */\r\n    sizeZ?: number;\r\n    /**\r\n     * optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     */\r\n    sideOrientation?: number;\r\n};\r\n\r\n/**\r\n * Defines the set of data required to create a goldberg mesh.\r\n */\r\nexport type GoldbergCreationOption = {\r\n    /**\r\n     * number of horizontal steps along an isogrid\r\n     */\r\n    m?: number;\r\n    /**\r\n     * number of angled steps along an isogrid\r\n     */\r\n    n?: number;\r\n    /**\r\n     * defines if the mesh must be flagged as updatable\r\n     */\r\n    updatable?: boolean;\r\n} & GoldbergVertexDataOption;\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\r\n * @returns GoldbergSphere mesh\r\n */\r\nexport function CreateGoldbergVertexData(options: GoldbergVertexDataOption, goldbergData: PolyhedronData): VertexData {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    let minX = Infinity;\r\n    let maxX = -Infinity;\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    for (let v = 0; v < goldbergData.vertex.length; v++) {\r\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\r\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\r\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\r\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\r\n    }\r\n\r\n    let index: number = 0;\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        for (let v = 0; v < verts.length; v++) {\r\n            normals.push(norm.x, norm.y, norm.z);\r\n            const pdata = goldbergData.vertex[verts[v]];\r\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\r\n            const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\r\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\r\n        }\r\n        for (let v = 0; v < verts.length - 2; v++) {\r\n            indices.push(index, index + v + 2, index + v + 1);\r\n        }\r\n        index += verts.length;\r\n    }\r\n\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param scene defines the hosting scene\r\n * @returns Goldberg mesh\r\n */\r\nexport function CreateGoldberg(name: string, options: GoldbergCreationOption, scene: Nullable<Scene> = null): GoldbergMesh {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n    const goldbergData = geodesicData.toGoldbergPolyhedronData();\r\n\r\n    const goldberg = new GoldbergMesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateGoldbergVertexData(options, goldbergData);\r\n\r\n    vertexData.applyToMesh(goldberg, options.updatable);\r\n\r\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\r\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\r\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\r\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\r\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\r\n    for (let f = 0; f < geodesicData.vertex.length; f++) {\r\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\r\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\r\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\r\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\r\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\r\n    }\r\n\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        const z = Vector3.Cross(ca, norm).normalize();\r\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\r\n        goldberg.goldbergData.faceYaxis.push(norm);\r\n        goldberg.goldbergData.faceZaxis.push(z);\r\n    }\r\n\r\n    return goldberg;\r\n}\r\n\r\n(Mesh as any).CreateGoldberg = CreateGoldberg;\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the IcoSphere\r\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n * * radius the radius of the IcoSphere, optional default 1\r\n * * radiusX allows stretching in the x direction, optional, default radius\r\n * * radiusY allows stretching in the y direction, optional, default radius\r\n * * radiusZ allows stretching in the z direction, optional, default radius\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the IcoSphere\r\n */\r\nexport function CreateIcoSphereVertexData(options: {\r\n    radius?: number;\r\n    radiusX?: number;\r\n    radiusY?: number;\r\n    radiusZ?: number;\r\n    flat?: boolean;\r\n    subdivisions?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const radius = options.radius || 1;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const subdivisions = options.subdivisions || 4;\r\n    const radiusX = options.radiusX || radius;\r\n    const radiusY = options.radiusY || radius;\r\n    const radiusZ = options.radiusZ || radius;\r\n\r\n    const t = (1 + Math.sqrt(5)) / 2;\r\n\r\n    // 12 vertex x,y,z\r\n    const icoVertices = [\r\n        -1,\r\n        t,\r\n        -0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0, // v0-3\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1,\r\n        t,\r\n        0,\r\n        1,\r\n        t, // v4-7\r\n        t,\r\n        0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1, // v8-11\r\n    ];\r\n\r\n    // index of 3 vertex makes a face of icopshere\r\n    const ico_indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\r\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    const vertices_unalias_id = [\r\n        0,\r\n        1,\r\n        2,\r\n        3,\r\n        4,\r\n        5,\r\n        6,\r\n        7,\r\n        8,\r\n        9,\r\n        10,\r\n        11,\r\n        // vertex alias\r\n        0, // 12: 0 + 12\r\n        2, // 13: 2 + 11\r\n        3, // 14: 3 + 11\r\n        3, // 15: 3 + 12\r\n        3, // 16: 3 + 13\r\n        4, // 17: 4 + 13\r\n        7, // 18: 7 + 11\r\n        8, // 19: 8 + 11\r\n        9, // 20: 9 + 11\r\n        9, // 21: 9 + 12\r\n        10, // 22: A + 12\r\n        11, // 23: B + 12\r\n    ];\r\n\r\n    // uv as integer step (not pixels !)\r\n    const ico_vertexuv = [\r\n        5,\r\n        1,\r\n        3,\r\n        1,\r\n        6,\r\n        4,\r\n        0,\r\n        0, // v0-3\r\n        5,\r\n        3,\r\n        4,\r\n        2,\r\n        2,\r\n        2,\r\n        4,\r\n        0, // v4-7\r\n        2,\r\n        0,\r\n        1,\r\n        1,\r\n        6,\r\n        0,\r\n        6,\r\n        2, // v8-11\r\n        // vertex alias (for same vertex on different faces)\r\n        0,\r\n        4, // 12: 0 + 12\r\n        3,\r\n        3, // 13: 2 + 11\r\n        4,\r\n        4, // 14: 3 + 11\r\n        3,\r\n        1, // 15: 3 + 12\r\n        4,\r\n        2, // 16: 3 + 13\r\n        4,\r\n        4, // 17: 4 + 13\r\n        0,\r\n        2, // 18: 7 + 11\r\n        1,\r\n        1, // 19: 8 + 11\r\n        2,\r\n        2, // 20: 9 + 11\r\n        3,\r\n        3, // 21: 9 + 12\r\n        1,\r\n        3, // 22: A + 12\r\n        2,\r\n        4, // 23: B + 12\r\n    ];\r\n\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    const ustep = 138 / 1024;\r\n    const vstep = 239 / 1024;\r\n    const uoffset = 60 / 1024;\r\n    const voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    const island_u_offset = -40 / 1024;\r\n    const island_v_offset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    const island = [\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1, //  0 - 4\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  5 - 9\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  10 - 14\r\n        0,\r\n        1,\r\n        1,\r\n        1,\r\n        0, //  15 - 19\r\n    ];\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    let current_indice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    const face_vertex_pos = new Array(3);\r\n    const face_vertex_uv = new Array(3);\r\n    let v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        face_vertex_pos[v012] = Vector3.Zero();\r\n        face_vertex_uv[v012] = Vector2.Zero();\r\n    }\r\n    // create all with normals\r\n    for (let face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            const v_id = ico_indices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            face_vertex_pos[v012].copyFromFloats(\r\n                icoVertices[3 * vertices_unalias_id[v_id]],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 1],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 2]\r\n            );\r\n            // Normalize to get normal\r\n            face_vertex_pos[v012].normalize();\r\n\r\n            // uv Coordinates from vertex ID\r\n            face_vertex_uv[v012].copyFromFloats(\r\n                ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset,\r\n                ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset\r\n            );\r\n        }\r\n\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n\r\n        const interp_vertex = (i1: number, i2: number, c1: number, c2: number) => {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\r\n            pos_interp.normalize();\r\n\r\n            let vertex_normal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\r\n                const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\r\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\r\n            } else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertex_normal.x /= radiusX;\r\n            vertex_normal.y /= radiusY;\r\n            vertex_normal.z /= radiusZ;\r\n            vertex_normal.normalize();\r\n\r\n            const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\r\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\r\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\r\n            uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(current_indice);\r\n            current_indice++;\r\n        };\r\n\r\n        for (let i2 = 0; i2 < subdivisions; i2++) {\r\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.radiusX\r\n * @param options.radiusY\r\n * @param options.radiusZ\r\n * @param options.flat\r\n * @param options.subdivisions\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the icosahedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\r\n */\r\nexport function CreateIcoSphere(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateIcoSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const IcoSphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateIcoSphere,\r\n};\r\n\r\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\r\n\r\n(Mesh as any).CreateIcoSphere = (\r\n    name: string,\r\n    options: { radius?: number; flat?: boolean; subdivisions?: number; sideOrientation?: number; updatable?: boolean },\r\n    scene: Scene\r\n): Mesh => {\r\n    return CreateIcoSphere(name, options, scene);\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Creates lathe mesh.\r\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.clip\r\n * @param options.arc\r\n * @param options.closed\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.cap\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the lathe mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\r\n */\r\nexport function CreateLathe(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        clip?: number;\r\n        arc?: number;\r\n        closed?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        cap?: number;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const arc: number = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\r\n    const closed: boolean = options.closed === undefined ? true : options.closed;\r\n    const shape = options.shape;\r\n    const radius = options.radius || 1;\r\n    const tessellation = options.tessellation || 64;\r\n    const clip = options.clip || 0;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const cap = options.cap || Mesh.NO_CAP;\r\n    const pi2 = Math.PI * 2;\r\n    const paths = new Array();\r\n    const invertUV = options.invertUV || false;\r\n\r\n    let i = 0;\r\n    let p = 0;\r\n    const step = (pi2 / tessellation) * arc;\r\n    let rotated;\r\n    let path: Array<Vector3>;\r\n    for (i = 0; i <= tessellation - clip; i++) {\r\n        path = [];\r\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(0, shape[0].y, 0));\r\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n        }\r\n        for (p = 0; p < shape.length; p++) {\r\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n            path.push(rotated);\r\n        }\r\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n        }\r\n        paths.push(path);\r\n    }\r\n\r\n    // lathe ribbon\r\n    const lathe = CreateRibbon(\r\n        name,\r\n        { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs },\r\n        scene\r\n    );\r\n    return lathe;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function direction from the module\r\n */\r\nexport const LatheBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateLathe,\r\n};\r\n\r\n(Mesh as any).CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateLathe(name, options, scene);\r\n};\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n * All parameters are provided by CreatePolygon as needed\r\n * @param polygon a mesh built from polygonTriangulation.build()\r\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n * @returns the VertexData of the Polygon\r\n */\r\nexport function CreatePolygonVertexData(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    const faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    const faceColors = fColors;\r\n    const colors = [];\r\n    const wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    const indices = <IndicesArray>polygon.getIndices();\r\n    const startIndex = positions.length / 9;\r\n    let disp = 0;\r\n    let distX = 0;\r\n    let distZ = 0;\r\n    let dist = 0;\r\n    let totalLen = 0;\r\n    const cumulate = [0];\r\n    if (wrap) {\r\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    let idx: number = 0;\r\n    let face: number = 0;\r\n    for (let index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            } else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\r\n            } else {\r\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\r\n            }\r\n        } else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\r\n            }\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polygon mesh\r\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n * * Remember you can only change the shape positions, not their number when updating a polygon\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.smoothingThreshold\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function CreatePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        smoothingThreshold?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const shape = options.shape;\r\n    const holes = options.holes || [];\r\n    const depth = options.depth || 0;\r\n    const smoothingThreshold = options.smoothingThreshold || 2;\r\n    const contours: Array<Vector2> = [];\r\n    let hole: Array<Vector2> = [];\r\n\r\n    for (let i = 0; i < shape.length; i++) {\r\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n    }\r\n    const epsilon = 0.00000001;\r\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n        contours.pop();\r\n    }\r\n\r\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n    for (let hNb = 0; hNb < holes.length; hNb++) {\r\n        hole = [];\r\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n        }\r\n        polygonTriangulation.addHole(hole);\r\n    }\r\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\r\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\r\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n    vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n    return polygon;\r\n}\r\n\r\n/**\r\n * Creates an extruded polygon mesh, with depth in the Y direction.\r\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.holes\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function ExtrudePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const PolygonBuilder = {\r\n    ExtrudePolygon,\r\n    CreatePolygon,\r\n};\r\n\r\nVertexData.CreatePolygon = CreatePolygonVertexData;\r\n(Mesh as any).CreatePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\n(Mesh as any).ExtrudePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    depth: number,\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n/**\r\n * Creates the VertexData for a Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * type provided types are:\r\n *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n * * size the size of the IcoSphere, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.type\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.custom\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Polyhedron\r\n */\r\nexport function CreatePolyhedronVertexData(options: {\r\n    type?: number;\r\n    size?: number;\r\n    sizeX?: number;\r\n    sizeY?: number;\r\n    sizeZ?: number;\r\n    custom?: any;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    flat?: boolean;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    // provided polyhedron types :\r\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n    const polyhedra: { vertex: number[][]; face: number[][] }[] = [];\r\n    polyhedra[0] = {\r\n        vertex: [\r\n            [0, 0, 1.732051],\r\n            [1.632993, 0, -0.5773503],\r\n            [-0.8164966, 1.414214, -0.5773503],\r\n            [-0.8164966, -1.414214, -0.5773503],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 1],\r\n            [1, 3, 2],\r\n        ],\r\n    };\r\n    polyhedra[1] = {\r\n        vertex: [\r\n            [0, 0, 1.414214],\r\n            [1.414214, 0, 0],\r\n            [0, 1.414214, 0],\r\n            [-1.414214, 0, 0],\r\n            [0, -1.414214, 0],\r\n            [0, 0, -1.414214],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 1],\r\n            [1, 4, 5],\r\n            [1, 5, 2],\r\n            [2, 5, 3],\r\n            [3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[2] = {\r\n        vertex: [\r\n            [0, 0, 1.070466],\r\n            [0.7136442, 0, 0.7978784],\r\n            [-0.3568221, 0.618034, 0.7978784],\r\n            [-0.3568221, -0.618034, 0.7978784],\r\n            [0.7978784, 0.618034, 0.3568221],\r\n            [0.7978784, -0.618034, 0.3568221],\r\n            [-0.9341724, 0.381966, 0.3568221],\r\n            [0.1362939, 1, 0.3568221],\r\n            [0.1362939, -1, 0.3568221],\r\n            [-0.9341724, -0.381966, 0.3568221],\r\n            [0.9341724, 0.381966, -0.3568221],\r\n            [0.9341724, -0.381966, -0.3568221],\r\n            [-0.7978784, 0.618034, -0.3568221],\r\n            [-0.1362939, 1, -0.3568221],\r\n            [-0.1362939, -1, -0.3568221],\r\n            [-0.7978784, -0.618034, -0.3568221],\r\n            [0.3568221, 0.618034, -0.7978784],\r\n            [0.3568221, -0.618034, -0.7978784],\r\n            [-0.7136442, 0, -0.7978784],\r\n            [0, 0, -1.070466],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 7, 2],\r\n            [0, 2, 6, 9, 3],\r\n            [0, 3, 8, 5, 1],\r\n            [1, 5, 11, 10, 4],\r\n            [2, 7, 13, 12, 6],\r\n            [3, 9, 15, 14, 8],\r\n            [4, 10, 16, 13, 7],\r\n            [5, 8, 14, 17, 11],\r\n            [6, 12, 18, 15, 9],\r\n            [10, 11, 17, 19, 16],\r\n            [12, 13, 16, 19, 18],\r\n            [14, 15, 18, 19, 17],\r\n        ],\r\n    };\r\n    polyhedra[3] = {\r\n        vertex: [\r\n            [0, 0, 1.175571],\r\n            [1.051462, 0, 0.5257311],\r\n            [0.3249197, 1, 0.5257311],\r\n            [-0.8506508, 0.618034, 0.5257311],\r\n            [-0.8506508, -0.618034, 0.5257311],\r\n            [0.3249197, -1, 0.5257311],\r\n            [0.8506508, 0.618034, -0.5257311],\r\n            [0.8506508, -0.618034, -0.5257311],\r\n            [-0.3249197, 1, -0.5257311],\r\n            [-1.051462, 0, -0.5257311],\r\n            [-0.3249197, -1, -0.5257311],\r\n            [0, 0, -1.175571],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 5],\r\n            [0, 5, 1],\r\n            [1, 5, 7],\r\n            [1, 7, 6],\r\n            [1, 6, 2],\r\n            [2, 6, 8],\r\n            [2, 8, 3],\r\n            [3, 8, 9],\r\n            [3, 9, 4],\r\n            [4, 9, 10],\r\n            [4, 10, 5],\r\n            [5, 10, 7],\r\n            [6, 7, 11],\r\n            [6, 11, 8],\r\n            [7, 10, 11],\r\n            [8, 11, 9],\r\n            [9, 11, 10],\r\n        ],\r\n    };\r\n    polyhedra[4] = {\r\n        vertex: [\r\n            [0, 0, 1.070722],\r\n            [0.7148135, 0, 0.7971752],\r\n            [-0.104682, 0.7071068, 0.7971752],\r\n            [-0.6841528, 0.2071068, 0.7971752],\r\n            [-0.104682, -0.7071068, 0.7971752],\r\n            [0.6101315, 0.7071068, 0.5236279],\r\n            [1.04156, 0.2071068, 0.1367736],\r\n            [0.6101315, -0.7071068, 0.5236279],\r\n            [-0.3574067, 1, 0.1367736],\r\n            [-0.7888348, -0.5, 0.5236279],\r\n            [-0.9368776, 0.5, 0.1367736],\r\n            [-0.3574067, -1, 0.1367736],\r\n            [0.3574067, 1, -0.1367736],\r\n            [0.9368776, -0.5, -0.1367736],\r\n            [0.7888348, 0.5, -0.5236279],\r\n            [0.3574067, -1, -0.1367736],\r\n            [-0.6101315, 0.7071068, -0.5236279],\r\n            [-1.04156, -0.2071068, -0.1367736],\r\n            [-0.6101315, -0.7071068, -0.5236279],\r\n            [0.104682, 0.7071068, -0.7971752],\r\n            [0.6841528, -0.2071068, -0.7971752],\r\n            [0.104682, -0.7071068, -0.7971752],\r\n            [-0.7148135, 0, -0.7971752],\r\n            [0, 0, -1.070722],\r\n        ],\r\n        face: [\r\n            [0, 2, 3],\r\n            [1, 6, 5],\r\n            [4, 9, 11],\r\n            [7, 15, 13],\r\n            [8, 16, 10],\r\n            [12, 14, 19],\r\n            [17, 22, 18],\r\n            [20, 21, 23],\r\n            [0, 1, 5, 2],\r\n            [0, 3, 9, 4],\r\n            [0, 4, 7, 1],\r\n            [1, 7, 13, 6],\r\n            [2, 5, 12, 8],\r\n            [2, 8, 10, 3],\r\n            [3, 10, 17, 9],\r\n            [4, 11, 15, 7],\r\n            [5, 6, 14, 12],\r\n            [6, 13, 20, 14],\r\n            [8, 12, 19, 16],\r\n            [9, 17, 18, 11],\r\n            [10, 16, 22, 17],\r\n            [11, 18, 21, 15],\r\n            [13, 15, 21, 20],\r\n            [14, 20, 23, 19],\r\n            [16, 19, 23, 22],\r\n            [18, 22, 23, 21],\r\n        ],\r\n    };\r\n    polyhedra[5] = {\r\n        vertex: [\r\n            [0, 0, 1.322876],\r\n            [1.309307, 0, 0.1889822],\r\n            [-0.9819805, 0.8660254, 0.1889822],\r\n            [0.1636634, -1.299038, 0.1889822],\r\n            [0.3273268, 0.8660254, -0.9449112],\r\n            [-0.8183171, -0.4330127, -0.9449112],\r\n        ],\r\n        face: [\r\n            [0, 3, 1],\r\n            [2, 4, 5],\r\n            [0, 1, 4, 2],\r\n            [0, 2, 5, 3],\r\n            [1, 3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[6] = {\r\n        vertex: [\r\n            [0, 0, 1.159953],\r\n            [1.013464, 0, 0.5642542],\r\n            [-0.3501431, 0.9510565, 0.5642542],\r\n            [-0.7715208, -0.6571639, 0.5642542],\r\n            [0.6633206, 0.9510565, -0.03144481],\r\n            [0.8682979, -0.6571639, -0.3996071],\r\n            [-1.121664, 0.2938926, -0.03144481],\r\n            [-0.2348831, -1.063314, -0.3996071],\r\n            [0.5181548, 0.2938926, -0.9953061],\r\n            [-0.5850262, -0.112257, -0.9953061],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 9, 7],\r\n            [5, 7, 9, 8],\r\n            [0, 3, 7, 5, 1],\r\n            [2, 4, 8, 9, 6],\r\n        ],\r\n    };\r\n    polyhedra[7] = {\r\n        vertex: [\r\n            [0, 0, 1.118034],\r\n            [0.8944272, 0, 0.6708204],\r\n            [-0.2236068, 0.8660254, 0.6708204],\r\n            [-0.7826238, -0.4330127, 0.6708204],\r\n            [0.6708204, 0.8660254, 0.2236068],\r\n            [1.006231, -0.4330127, -0.2236068],\r\n            [-1.006231, 0.4330127, 0.2236068],\r\n            [-0.6708204, -0.8660254, -0.2236068],\r\n            [0.7826238, 0.4330127, -0.6708204],\r\n            [0.2236068, -0.8660254, -0.6708204],\r\n            [-0.8944272, 0, -0.6708204],\r\n            [0, 0, -1.118034],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 10, 7],\r\n            [5, 9, 11, 8],\r\n            [7, 10, 11, 9],\r\n            [0, 3, 7, 9, 5, 1],\r\n            [2, 4, 8, 11, 10, 6],\r\n        ],\r\n    };\r\n    polyhedra[8] = {\r\n        vertex: [\r\n            [-0.729665, 0.670121, 0.319155],\r\n            [-0.655235, -0.29213, -0.754096],\r\n            [-0.093922, -0.607123, 0.537818],\r\n            [0.702196, 0.595691, 0.485187],\r\n            [0.776626, -0.36656, -0.588064],\r\n        ],\r\n        face: [\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [3, 0, 2],\r\n            [4, 3, 2],\r\n            [4, 1, 0, 3],\r\n        ],\r\n    };\r\n    polyhedra[9] = {\r\n        vertex: [\r\n            [-0.868849, -0.100041, 0.61257],\r\n            [-0.329458, 0.976099, 0.28078],\r\n            [-0.26629, -0.013796, -0.477654],\r\n            [-0.13392, -1.034115, 0.229829],\r\n            [0.738834, 0.707117, -0.307018],\r\n            [0.859683, -0.535264, -0.338508],\r\n        ],\r\n        face: [\r\n            [3, 0, 2],\r\n            [5, 3, 2],\r\n            [4, 5, 2],\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [0, 3, 5, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[10] = {\r\n        vertex: [\r\n            [-0.610389, 0.243975, 0.531213],\r\n            [-0.187812, -0.48795, -0.664016],\r\n            [-0.187812, 0.9759, -0.664016],\r\n            [0.187812, -0.9759, 0.664016],\r\n            [0.798201, 0.243975, 0.132803],\r\n        ],\r\n        face: [\r\n            [1, 3, 0],\r\n            [3, 4, 0],\r\n            [3, 1, 4],\r\n            [0, 2, 1],\r\n            [0, 4, 2],\r\n            [2, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[11] = {\r\n        vertex: [\r\n            [-1.028778, 0.392027, -0.048786],\r\n            [-0.640503, -0.646161, 0.621837],\r\n            [-0.125162, -0.395663, -0.540059],\r\n            [0.004683, 0.888447, -0.651988],\r\n            [0.125161, 0.395663, 0.540059],\r\n            [0.632925, -0.791376, 0.433102],\r\n            [1.031672, 0.157063, -0.354165],\r\n        ],\r\n        face: [\r\n            [3, 2, 0],\r\n            [2, 1, 0],\r\n            [2, 5, 1],\r\n            [0, 4, 3],\r\n            [0, 1, 4],\r\n            [4, 1, 5],\r\n            [2, 3, 6],\r\n            [3, 4, 6],\r\n            [5, 2, 6],\r\n            [4, 5, 6],\r\n        ],\r\n    };\r\n    polyhedra[12] = {\r\n        vertex: [\r\n            [-0.669867, 0.334933, -0.529576],\r\n            [-0.669867, 0.334933, 0.529577],\r\n            [-0.4043, 1.212901, 0],\r\n            [-0.334933, -0.669867, -0.529576],\r\n            [-0.334933, -0.669867, 0.529577],\r\n            [0.334933, 0.669867, -0.529576],\r\n            [0.334933, 0.669867, 0.529577],\r\n            [0.4043, -1.212901, 0],\r\n            [0.669867, -0.334933, -0.529576],\r\n            [0.669867, -0.334933, 0.529577],\r\n        ],\r\n        face: [\r\n            [8, 9, 7],\r\n            [6, 5, 2],\r\n            [3, 8, 7],\r\n            [5, 0, 2],\r\n            [4, 3, 7],\r\n            [0, 1, 2],\r\n            [9, 4, 7],\r\n            [1, 6, 2],\r\n            [9, 8, 5, 6],\r\n            [8, 3, 0, 5],\r\n            [3, 4, 1, 0],\r\n            [4, 9, 6, 1],\r\n        ],\r\n    };\r\n    polyhedra[13] = {\r\n        vertex: [\r\n            [-0.931836, 0.219976, -0.264632],\r\n            [-0.636706, 0.318353, 0.692816],\r\n            [-0.613483, -0.735083, -0.264632],\r\n            [-0.326545, 0.979634, 0],\r\n            [-0.318353, -0.636706, 0.692816],\r\n            [-0.159176, 0.477529, -0.856368],\r\n            [0.159176, -0.477529, -0.856368],\r\n            [0.318353, 0.636706, 0.692816],\r\n            [0.326545, -0.979634, 0],\r\n            [0.613482, 0.735082, -0.264632],\r\n            [0.636706, -0.318353, 0.692816],\r\n            [0.931835, -0.219977, -0.264632],\r\n        ],\r\n        face: [\r\n            [11, 10, 8],\r\n            [7, 9, 3],\r\n            [6, 11, 8],\r\n            [9, 5, 3],\r\n            [2, 6, 8],\r\n            [5, 0, 3],\r\n            [4, 2, 8],\r\n            [0, 1, 3],\r\n            [10, 4, 8],\r\n            [1, 7, 3],\r\n            [10, 11, 9, 7],\r\n            [11, 6, 5, 9],\r\n            [6, 2, 0, 5],\r\n            [2, 4, 1, 0],\r\n            [4, 10, 7, 1],\r\n        ],\r\n    };\r\n    polyhedra[14] = {\r\n        vertex: [\r\n            [-0.93465, 0.300459, -0.271185],\r\n            [-0.838689, -0.260219, -0.516017],\r\n            [-0.711319, 0.717591, 0.128359],\r\n            [-0.710334, -0.156922, 0.080946],\r\n            [-0.599799, 0.556003, -0.725148],\r\n            [-0.503838, -0.004675, -0.969981],\r\n            [-0.487004, 0.26021, 0.48049],\r\n            [-0.460089, -0.750282, -0.512622],\r\n            [-0.376468, 0.973135, -0.325605],\r\n            [-0.331735, -0.646985, 0.084342],\r\n            [-0.254001, 0.831847, 0.530001],\r\n            [-0.125239, -0.494738, -0.966586],\r\n            [0.029622, 0.027949, 0.730817],\r\n            [0.056536, -0.982543, -0.262295],\r\n            [0.08085, 1.087391, 0.076037],\r\n            [0.125583, -0.532729, 0.485984],\r\n            [0.262625, 0.599586, 0.780328],\r\n            [0.391387, -0.726999, -0.716259],\r\n            [0.513854, -0.868287, 0.139347],\r\n            [0.597475, 0.85513, 0.326364],\r\n            [0.641224, 0.109523, 0.783723],\r\n            [0.737185, -0.451155, 0.538891],\r\n            [0.848705, -0.612742, -0.314616],\r\n            [0.976075, 0.365067, 0.32976],\r\n            [1.072036, -0.19561, 0.084927],\r\n        ],\r\n        face: [\r\n            [15, 18, 21],\r\n            [12, 20, 16],\r\n            [6, 10, 2],\r\n            [3, 0, 1],\r\n            [9, 7, 13],\r\n            [2, 8, 4, 0],\r\n            [0, 4, 5, 1],\r\n            [1, 5, 11, 7],\r\n            [7, 11, 17, 13],\r\n            [13, 17, 22, 18],\r\n            [18, 22, 24, 21],\r\n            [21, 24, 23, 20],\r\n            [20, 23, 19, 16],\r\n            [16, 19, 14, 10],\r\n            [10, 14, 8, 2],\r\n            [15, 9, 13, 18],\r\n            [12, 15, 21, 20],\r\n            [6, 12, 16, 10],\r\n            [3, 6, 2, 0],\r\n            [9, 3, 1, 7],\r\n            [9, 15, 12, 6, 3],\r\n            [22, 17, 11, 5, 4, 8, 14, 19, 23, 24],\r\n        ],\r\n    };\r\n\r\n    const type: number = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const data: { vertex: number[][]; face: number[][]; name?: string; category?: string } = options.custom || polyhedra[type];\r\n    const nbfaces = data.face.length;\r\n    const faceUV = options.faceUV || new Array(nbfaces);\r\n    const faceColors = options.faceColors;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    const colors = new Array<number>();\r\n    let index = 0;\r\n    let faceIdx = 0; // face cursor in the array \"indexes\"\r\n    const indexes = new Array<number>();\r\n    let i = 0;\r\n    let f = 0;\r\n    let u: number, v: number, ang: number, x: number, y: number, tmp: number;\r\n\r\n    // default face colors and UV if undefined\r\n    if (flat) {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            if (faceColors && faceColors[f] === undefined) {\r\n                faceColors[f] = new Color4(1, 1, 1, 1);\r\n            }\r\n            if (faceUV && faceUV[f] === undefined) {\r\n                faceUV[f] = new Vector4(0, 0, 1, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!flat) {\r\n        for (i = 0; i < data.vertex.length; i++) {\r\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\r\n            uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0);\r\n        }\r\n        for (f = 0; f < nbfaces; f++) {\r\n            for (i = 0; i < data.face[f].length - 2; i++) {\r\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\r\n            }\r\n        }\r\n    } else {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            const fl = data.face[f].length; // number of vertices of the current face\r\n            ang = (2 * Math.PI) / fl;\r\n            x = 0.5 * Math.tan(ang / 2);\r\n            y = 0.5;\r\n\r\n            // positions, uvs, colors\r\n            for (i = 0; i < fl; i++) {\r\n                // positions\r\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\r\n                indexes.push(index);\r\n                index++;\r\n                // uvs\r\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\r\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\r\n                uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\r\n                y = x * Math.sin(ang) + y * Math.cos(ang);\r\n                x = tmp;\r\n                // colors\r\n                if (faceColors) {\r\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n                }\r\n            }\r\n\r\n            // indices from indexes\r\n            for (i = 0; i < fl - 2; i++) {\r\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\r\n            }\r\n            faceIdx += fl;\r\n        }\r\n    }\r\n\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors && flat) {\r\n        vertexData.colors = colors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polyhedron mesh\r\n * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n * * The parameter `size` (positive float, default 1) sets the polygon size\r\n * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`\r\n * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.type\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.custom\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the polyhedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra\r\n */\r\nexport function CreatePolyhedron(\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const polyhedron = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    polyhedron._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePolyhedronVertexData(options);\r\n\r\n    vertexData.applyToMesh(polyhedron, options.updatable);\r\n\r\n    return polyhedron;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PolyhedronBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePolyhedron,\r\n};\r\n\r\nVertexData.CreatePolyhedron = CreatePolyhedronVertexData;\r\n\r\n(Mesh as any).CreatePolyhedron = (\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n    },\r\n    scene: Scene\r\n): Mesh => {\r\n    return CreatePolyhedron(name, options, scene);\r\n};\r\n","import { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /** Create a bezier curve from the virtual cursor to a given coordinate */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\nfunction CreateShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene\r\n            );\r\n            meshes.push(mesh);\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to center\r\n        const bbox = newMesh?.getBoundingInfo();\r\n        newMesh.position.x = -bbox?.boundingBox.extendSizeWorld._x;\r\n        newMesh.position.y = -bbox?.boundingBox.extendSizeWorld._y;\r\n        newMesh.position.z = -bbox?.boundingBox.extendSizeWorld._z;\r\n        newMesh.name = name;\r\n\r\n        newMesh.rotation.x = -Math.PI / 2;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled box\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * @param options.pattern\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @returns the VertexData of the TiledBox\r\n */\r\nexport function CreateTiledBoxVertexData(options: {\r\n    pattern?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n    const halfDepth = depth / 2;\r\n\r\n    const faceVertexData: Array<VertexData> = [];\r\n\r\n    for (let f = 0; f < 2; f++) {\r\n        //front and back\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    for (let f = 2; f < 4; f++) {\r\n        //sides\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    } else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (let f = 4; f < 6; f++) {\r\n        //top and bottom\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let positions: Array<number> = [];\r\n    let normals: Array<number> = [];\r\n    let uvs: Array<number> = [];\r\n    let indices: Array<number> = [];\r\n    const colors: Array<number> = [];\r\n    const facePositions: Array<Array<Vector3>> = [];\r\n    const faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    const newFaceUV: Array<Array<number>> = [];\r\n    let lu: number = 0;\r\n\r\n    let li: number = 0;\r\n\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        const len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (let p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (let i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\r\n            }\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    const vec0 = new Vector3(0, 0, halfDepth);\r\n    const mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    normals = faceNormals[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    positions = positions.concat(\r\n        facePositions[1]\r\n            .map((entry) => entry.subtract(vec0))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []));\r\n\r\n    const vec2 = new Vector3(halfWidth, 0, 0);\r\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    const vec4 = new Vector3(0, halfHeight, 0);\r\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled box mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param options.pattern\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledBox(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledBox instead\r\n */\r\nexport const TiledBoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledBox,\r\n};\r\n\r\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled plane\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the tiled plane\r\n */\r\nexport function CreateTiledPlaneVertexData(options: {\r\n    pattern?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const tilesX = Math.floor(width / tileWidth);\r\n    let offsetX = width - tilesX * tileWidth;\r\n\r\n    const height = options.height || options.size || 1;\r\n    const tilesY = Math.floor(height / tileHeight);\r\n    let offsetY = height - tilesY * tileHeight;\r\n\r\n    const halfWidth = (tileWidth * tilesX) / 2;\r\n    const halfHeight = (tileHeight * tilesY) / 2;\r\n\r\n    let adjustX = 0;\r\n    let adjustY = 0;\r\n    let startX = 0;\r\n    let startY = 0;\r\n    let endX = 0;\r\n    let endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        endX = halfWidth;\r\n        endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    let uvs: Array<number> = [];\r\n    const colors = [];\r\n    const indices = [];\r\n    let index = 0;\r\n    for (let y = 0; y < tilesY; y++) {\r\n        for (let x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\r\n            } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            } else {\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        const partialBottomRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\r\n        const partialTopRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\r\n        const partialLeftCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\r\n        const partialRightCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\r\n        let uvPart: Array<number> = [];\r\n        let a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) {\r\n            //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) {\r\n            //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {\r\n            //top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) {\r\n            //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            const uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            const uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            const uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            const uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledPlane(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledPlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledPlane instead\r\n */\r\nexport const TiledPlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledPlane,\r\n};\r\n\r\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a torus\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * diameter the diameter of the torus, optional default 1\r\n * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the torus\r\n */\r\nexport function CreateTorusVertexData(options: { diameter?: number; thickness?: number; tessellation?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }) {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const diameter = options.diameter || 1;\r\n    const thickness = options.thickness || 0.5;\r\n    const tessellation = options.tessellation || 16;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const stride = tessellation + 1;\r\n\r\n    for (let i = 0; i <= tessellation; i++) {\r\n        const u = i / tessellation;\r\n\r\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\r\n\r\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\r\n\r\n        for (let j = 0; j <= tessellation; j++) {\r\n            const v = 1 - j / tessellation;\r\n\r\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\r\n            const dx = Math.cos(innerAngle);\r\n            const dy = Math.sin(innerAngle);\r\n\r\n            // Create a vertex.\r\n            let normal = new Vector3(dx, dy, 0);\r\n            let position = normal.scale(thickness / 2);\r\n            const textureCoordinate = new Vector2(u, v);\r\n\r\n            position = Vector3.TransformCoordinates(position, transform);\r\n            normal = Vector3.TransformNormal(normal, transform);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\r\n\r\n            // And create indices for two triangles.\r\n            const nextI = (i + 1) % stride;\r\n            const nextJ = (j + 1) % stride;\r\n\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\r\n */\r\nexport function CreateTorus(\r\n    name: string,\r\n    options: { diameter?: number; thickness?: number; tessellation?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torus = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torus._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusVertexData(options);\r\n\r\n    vertexData.applyToMesh(torus, options.updatable);\r\n\r\n    return torus;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorus instead\r\n */\r\nexport const TorusBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorus,\r\n};\r\n\r\nVertexData.CreateTorus = CreateTorusVertexData;\r\n\r\n(Mesh as any).CreateTorus = (name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        diameter,\r\n        thickness,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorus(name, options, scene);\r\n};\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n * * radius the radius of the torus knot, optional, default 2\r\n * * tube the thickness of the tube, optional, default 0.5\r\n * * radialSegments the number of sides on each tube segments, optional, default 32\r\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n * * p the number of windings around the z axis, optional,  default 2\r\n * * q the number of windings around the x axis, optional,  default 3\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: {\r\n    radius?: number;\r\n    tube?: number;\r\n    radialSegments?: number;\r\n    tubularSegments?: number;\r\n    p?: number;\r\n    q?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    const radius = options.radius || 2;\r\n    const tube = options.tube || 0.5;\r\n    const radialSegments = options.radialSegments || 32;\r\n    const tubularSegments = options.tubularSegments || 32;\r\n    const p = options.p || 2;\r\n    const q = options.q || 3;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    const getPos = (angle: number) => {\r\n        const cu = Math.cos(angle);\r\n        const su = Math.sin(angle);\r\n        const quOverP = (q / p) * angle;\r\n        const cs = Math.cos(quOverP);\r\n\r\n        const tx = radius * (2 + cs) * 0.5 * cu;\r\n        const ty = radius * (2 + cs) * su * 0.5;\r\n        const tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    let i: number;\r\n    let j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        const modI = i % radialSegments;\r\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\r\n        const p1 = getPos(u);\r\n        const p2 = getPos(u + 0.01);\r\n        const tang = p2.subtract(p1);\r\n        let n = p2.add(p1);\r\n\r\n        const bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const modJ = j % tubularSegments;\r\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\r\n            const cx = -tube * Math.cos(v);\r\n            const cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const jNext = (j + 1) % tubularSegments;\r\n            const a = i * tubularSegments + j;\r\n            const b = (i + 1) * tubularSegments + j;\r\n            const c = (i + 1) * tubularSegments + jNext;\r\n            const d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\r\n */\r\nexport function CreateTorusKnot(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorusKnot,\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\n(Mesh as any).CreateTorusKnot = (\r\n    name: string,\r\n    radius: number,\r\n    tube: number,\r\n    radialSegments: number,\r\n    tubularSegments: number,\r\n    p: number,\r\n    q: number,\r\n    scene?: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates a tube mesh.\r\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\r\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.path\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.radiusFunction\r\n * @param options.cap\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the tube mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\r\n */\r\nexport function CreateTube(\r\n    name: string,\r\n    options: {\r\n        path: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        radiusFunction?: { (i: number, distance: number): number };\r\n        cap?: number;\r\n        arc?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    let instance = options.instance;\r\n    let radius = 1.0;\r\n\r\n    if (options.radius !== undefined) {\r\n        radius = options.radius;\r\n    } else if (instance) {\r\n        radius = instance._creationDataStorage!.radius;\r\n    }\r\n\r\n    const tessellation = options.tessellation || 64 | 0;\r\n    const radiusFunction = options.radiusFunction || null;\r\n    let cap = options.cap || Mesh.NO_CAP;\r\n    const invertUV = options.invertUV || false;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n    // tube geometry\r\n    const tubePathArray = (\r\n        path: Vector3[],\r\n        path3D: Path3D,\r\n        circlePaths: Vector3[][],\r\n        radius: number,\r\n        tessellation: number,\r\n        radiusFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        arc: number\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const distances = path3D.getDistances();\r\n        const pi2 = Math.PI * 2;\r\n        const step = (pi2 / tessellation) * arc;\r\n        const returnRadius: { (i: number, distance: number): number } = () => radius;\r\n        const radiusFunctionFinal: { (i: number, distance: number): number } = radiusFunction || returnRadius;\r\n\r\n        let circlePath: Vector3[];\r\n        let rad: number;\r\n        let normal: Vector3;\r\n        let rotated: Vector3;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        for (let i = 0; i < path.length; i++) {\r\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n            circlePath = Array<Vector3>(); // current circle array\r\n            normal = normals[i]; // current normal\r\n            for (let t = 0; t < tessellation; t++) {\r\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                circlePath[t] = rotated;\r\n            }\r\n            circlePaths[index] = circlePath;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n            const pointCap = Array<Vector3>();\r\n            for (let i = 0; i < nbPoints; i++) {\r\n                pointCap.push(path[pathIndex]);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                break;\r\n            case Mesh.CAP_END:\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return circlePaths;\r\n    };\r\n\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // tube update\r\n        const storage = instance._creationDataStorage!;\r\n        const arc = options.arc || storage.arc;\r\n        path3D = storage.path3D.update(path);\r\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n        // Update mode, no need to recreate the storage.\r\n        storage.path3D = path3D;\r\n        storage.pathArray = pathArray;\r\n        storage.arc = arc;\r\n        storage.radius = radius;\r\n\r\n        return instance;\r\n    }\r\n\r\n    // tube creation\r\n    path3D = <any>new Path3D(path);\r\n    const newPathArray = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n    const tube = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closePath: true,\r\n            closeArray: false,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            invertUV: invertUV,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs,\r\n        },\r\n        scene\r\n    );\r\n    tube._creationDataStorage!.pathArray = pathArray;\r\n    tube._creationDataStorage!.path3D = path3D;\r\n    tube._creationDataStorage!.tessellation = tessellation;\r\n    tube._creationDataStorage!.cap = cap;\r\n    tube._creationDataStorage!.arc = options.arc;\r\n    tube._creationDataStorage!.radius = radius;\r\n\r\n    return tube;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTube directly\r\n */\r\nexport const TubeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTube,\r\n};\r\n\r\n(Mesh as any).CreateTube = (\r\n    name: string,\r\n    path: Vector3[],\r\n    radius: number,\r\n    tessellation: number,\r\n    radiusFunction: { (i: number, distance: number): number },\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n    };\r\n    return CreateTube(name, options, scene);\r\n};\r\n","import { Logger } from \"../Misc/logger\";\r\nimport { Vector3 } from \"./math.vector\";\r\n\r\n/**\r\n * Class representing an isovector a vector containing 2 INTEGER coordinates\r\n * x axis is horizontal\r\n * y axis is 60 deg counter clockwise from positive y axis\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IsoVector {\r\n    /**\r\n     * Creates a new isovector from the given x and y coordinates\r\n     * @param x defines the first coordinate, must be an integer\r\n     * @param y defines the second coordinate, must be an integer\r\n     */\r\n    constructor(\r\n        /** defines the first coordinate */\r\n        public x: number = 0,\r\n        /** defines the second coordinate */\r\n        public y: number = 0\r\n    ) {\r\n        if (x !== Math.floor(x)) {\r\n            x === Math.floor(x);\r\n            Logger.Warn(\"x is not an integer, floor(x) used\");\r\n        }\r\n        if (y !== Math.floor(y)) {\r\n            y === Math.floor(y);\r\n            Logger.Warn(\"y is not an integer, floor(y) used\");\r\n        }\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Gets a new IsoVector copied from the IsoVector\r\n     * @returns a new IsoVector\r\n     */\r\n    public clone(): _IsoVector {\r\n        return new _IsoVector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees counter clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector a center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate60About(other: _IsoVector) {\r\n        //other IsoVector\r\n        const x: number = this.x;\r\n        this.x = other.x + other.y - this.y;\r\n        this.y = x + this.y - other.x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector as center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg60About(other: _IsoVector) {\r\n        const x = this.x;\r\n        this.x = x + this.y - other.y;\r\n        this.y = other.x + other.y - x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m === Math.floor(m);\r\n            Logger.Warn(\"m not an integer only floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n === Math.floor(n);\r\n            Logger.Warn(\"n not an integer only floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = m - x - this.y;\r\n        this.y = n + x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m === Math.floor(m);\r\n            Logger.Warn(\"m is not an integer, floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n === Math.floor(n);\r\n            Logger.Warn(\"n is not an integer,   floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = this.y - n;\r\n        this.y = m + n - x - this.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms an IsoVector to one in Cartesian 3D space based on an isovector\r\n     * @param origin an IsoVector\r\n     * @param isoGridSize\r\n     * @returns Point as a Vector3\r\n     */\r\n    public toCartesianOrigin(origin: _IsoVector, isoGridSize: number) {\r\n        const point = Vector3.Zero();\r\n        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;\r\n        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;\r\n        return point;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Gets a new IsoVector(0, 0)\r\n     * @returns a new IsoVector\r\n     */\r\n    public static Zero(): _IsoVector {\r\n        return new _IsoVector(0, 0);\r\n    }\r\n}\r\n","import { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { PHI } from \"../Maths/math.constants\";\r\nimport { _IsoVector } from \"../Maths/math.isovector\";\r\n\r\n/**\r\n * Class representing data for one face OAB of an equilateral icosahedron\r\n * When O is the isovector (0, 0), A is isovector (m, n)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _PrimaryIsoTriangle {\r\n    //properties\r\n    public m: number;\r\n    public n: number;\r\n    public cartesian: Vector3[] = [];\r\n    public vertices: _IsoVector[] = [];\r\n    public max: number[] = [];\r\n    public min: number[] = [];\r\n    public vecToidx: { [key: string]: number };\r\n    public vertByDist: { [key: string]: number[] };\r\n    public closestTo: number[][] = [];\r\n\r\n    public innerFacets: string[][] = [];\r\n    public isoVecsABOB: _IsoVector[][] = [];\r\n    public isoVecsOBOA: _IsoVector[][] = [];\r\n    public isoVecsBAOA: _IsoVector[][] = [];\r\n    public vertexTypes: number[][] = [];\r\n\r\n    public coau: number;\r\n    public cobu: number;\r\n    public coav: number;\r\n    public cobv: number;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public IDATA: PolyhedronData = new PolyhedronData(\r\n        \"icosahedron\",\r\n        \"Regular\",\r\n        [\r\n            [0, PHI, -1],\r\n            [-PHI, 1, 0],\r\n            [-1, 0, -PHI],\r\n            [1, 0, -PHI],\r\n            [PHI, 1, 0],\r\n            [0, PHI, 1],\r\n            [-1, 0, PHI],\r\n            [-PHI, -1, 0],\r\n            [0, -PHI, -1],\r\n            [PHI, -1, 0],\r\n            [1, 0, PHI],\r\n            [0, -PHI, 1],\r\n        ],\r\n        [\r\n            [0, 2, 1],\r\n            [0, 3, 2],\r\n            [0, 4, 3],\r\n            [0, 5, 4],\r\n            [0, 1, 5],\r\n            [7, 6, 1],\r\n            [8, 7, 2],\r\n            [9, 8, 3],\r\n            [10, 9, 4],\r\n            [6, 10, 5],\r\n            [2, 7, 1],\r\n            [3, 8, 2],\r\n            [4, 9, 3],\r\n            [5, 10, 4],\r\n            [1, 6, 5],\r\n            [11, 6, 7],\r\n            [11, 7, 8],\r\n            [11, 8, 9],\r\n            [11, 9, 10],\r\n            [11, 10, 6],\r\n        ]\r\n    );\r\n\r\n    /**\r\n     * Creates the PrimaryIsoTriangle Triangle OAB\r\n     * @param m an integer\r\n     * @param n an integer\r\n     */\r\n\r\n    //operators\r\n    public setIndices() {\r\n        let indexCount = 12; // 12 vertices already assigned\r\n        const vecToidx: { [key: string]: number } = {}; //maps iso-vectors to indexCount;\r\n        const m = this.m;\r\n        const n = this.n;\r\n        let g = m; // hcf of m, n when n != 0\r\n        let m1 = 1;\r\n        let n1 = 0;\r\n        if (n !== 0) {\r\n            g = Scalar.HCF(m, n);\r\n        }\r\n        m1 = m / g;\r\n        n1 = n / g;\r\n\r\n        let fr: number | string; //face to the right of current face\r\n        let rot: number | string; //rotation about which vertex for fr\r\n        let O: number;\r\n        let A: number;\r\n        let B: number;\r\n        const oVec: _IsoVector = _IsoVector.Zero();\r\n        const aVec = new _IsoVector(m, n);\r\n        const bVec = new _IsoVector(-n, m + n);\r\n        const oaVec: _IsoVector = _IsoVector.Zero();\r\n        const abVec: _IsoVector = _IsoVector.Zero();\r\n        const obVec: _IsoVector = _IsoVector.Zero();\r\n        let verts: number[] = [];\r\n        let idx: string;\r\n        let idxR: string;\r\n        let isoId: string;\r\n        let isoIdR: string;\r\n\r\n        const closestTo: number[][] = [];\r\n        const vDist = this.vertByDist;\r\n\r\n        const matchIdx = (f: number, fr: number, isoId: string, isoIdR: string) => {\r\n            idx = f + \"|\" + isoId;\r\n            idxR = fr + \"|\" + isoIdR;\r\n            if (!(idx in vecToidx || idxR in vecToidx)) {\r\n                vecToidx[idx] = indexCount;\r\n                vecToidx[idxR] = indexCount;\r\n                indexCount++;\r\n            } else if (idx in vecToidx && !(idxR in vecToidx)) {\r\n                vecToidx[idxR] = vecToidx[idx];\r\n            } else if (idxR in vecToidx && !(idx in vecToidx)) {\r\n                vecToidx[idx] = vecToidx[idxR];\r\n            }\r\n            if (vDist[isoId][0] > 2) {\r\n                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n            } else {\r\n                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n            }\r\n        };\r\n\r\n        this.IDATA.edgematch = [\r\n            [1, \"B\"],\r\n            [2, \"B\"],\r\n            [3, \"B\"],\r\n            [4, \"B\"],\r\n            [0, \"B\"],\r\n            [10, \"O\", 14, \"A\"],\r\n            [11, \"O\", 10, \"A\"],\r\n            [12, \"O\", 11, \"A\"],\r\n            [13, \"O\", 12, \"A\"],\r\n            [14, \"O\", 13, \"A\"],\r\n            [0, \"O\"],\r\n            [1, \"O\"],\r\n            [2, \"O\"],\r\n            [3, \"O\"],\r\n            [4, \"O\"],\r\n            [19, \"B\", 5, \"A\"],\r\n            [15, \"B\", 6, \"A\"],\r\n            [16, \"B\", 7, \"A\"],\r\n            [17, \"B\", 8, \"A\"],\r\n            [18, \"B\", 9, \"A\"],\r\n        ];\r\n\r\n        /***edges AB to OB***** rotation about B*/\r\n        for (let f = 0; f < 20; f++) {\r\n            //f current face\r\n\r\n            verts = this.IDATA.face[f];\r\n            O = verts[2];\r\n            A = verts[1];\r\n            B = verts[0];\r\n\r\n            isoId = oVec.x + \"|\" + oVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = O;\r\n                closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = aVec.x + \"|\" + aVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = A;\r\n                closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = bVec.x + \"|\" + bVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = B;\r\n                closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            //for edge vertices\r\n            fr = <number>this.IDATA.edgematch[f][0];\r\n            rot = <string>this.IDATA.edgematch[f][1];\r\n            if (rot === \"B\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    abVec.x = m - i * (m1 + n1);\r\n                    abVec.y = n + i * m1;\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    isoId = abVec.x + \"|\" + abVec.y;\r\n                    isoIdR = obVec.x + \"|\" + obVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            if (rot === \"O\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    isoId = obVec.x + \"|\" + obVec.y;\r\n                    isoIdR = oaVec.x + \"|\" + oaVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            fr = <number>this.IDATA.edgematch[f][2];\r\n            rot = <string>this.IDATA.edgematch[f][3];\r\n            if (rot && rot === \"A\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\r\n                    abVec.y = n + (g - i) * m1; //reversed for BA\r\n                    isoId = oaVec.x + \"|\" + oaVec.y;\r\n                    isoIdR = abVec.x + \"|\" + abVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this.vertices.length; i++) {\r\n                isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n                idx = f + \"|\" + isoId;\r\n                if (!(idx in vecToidx)) {\r\n                    vecToidx[idx] = indexCount++;\r\n                    if (vDist[isoId][0] > 2) {\r\n                        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n                    } else {\r\n                        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.closestTo = closestTo;\r\n        this.vecToidx = vecToidx;\r\n    }\r\n\r\n    public calcCoeffs() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        const thirdR3 = Math.sqrt(3) / 3;\r\n\r\n        const LSQD = m * m + n * n + m * n;\r\n\r\n        this.coau = (m + n) / LSQD;\r\n        this.cobu = -n / LSQD;\r\n        this.coav = (-thirdR3 * (m - n)) / LSQD;\r\n        this.cobv = (thirdR3 * (2 * m + n)) / LSQD;\r\n    }\r\n\r\n    public createInnerFacets() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        for (let y = 0; y < n + m + 1; y++) {\r\n            for (let x = this.min[y]; x < this.max[y] + 1; x++) {\r\n                if (x < this.max[y] && x < this.max[y + 1] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\r\n                }\r\n                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public edgeVecsABOB() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n\r\n        const B = new _IsoVector(-n, m + n);\r\n\r\n        for (let y = 1; y < m + n; y++) {\r\n            const point = new _IsoVector(this.min[y], y);\r\n            const prev = new _IsoVector(this.min[y - 1], y - 1);\r\n            const next = new _IsoVector(this.min[y + 1], y + 1);\r\n            const pointR = point.clone();\r\n            const prevR = prev.clone();\r\n            const nextR = next.clone();\r\n\r\n            pointR.rotate60About(B);\r\n            prevR.rotate60About(B);\r\n            nextR.rotate60About(B);\r\n\r\n            const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\r\n            const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\r\n            const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\r\n\r\n            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\r\n                if (pointR.x !== maxPrev.x) {\r\n                    // type2\r\n                    //up\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\r\n                } else if (pointR.y === nextR.y) {\r\n                    // type1\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 1]);\r\n                    this.isoVecsABOB.push([point, maxPrev, next]);\r\n                } else {\r\n                    // type 0\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxPoint]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapABOBtoOBOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 0) {\r\n                    point.rotateNeg120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsOBOA.push(temp);\r\n        }\r\n    }\r\n\r\n    public mapABOBtoBAOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 1) {\r\n                    point.rotate120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsBAOA.push(temp);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public MapToFace(faceNb: number, geodesicData: PolyhedronData) {\r\n        const F = this.IDATA.face[faceNb];\r\n        const oidx = F[2];\r\n        const aidx = F[1];\r\n        const bidx = F[0];\r\n\r\n        const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\r\n        const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\r\n        const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\r\n\r\n        const OA = A.subtract(O);\r\n        const OB = B.subtract(O);\r\n\r\n        const x: Vector3 = OA.scale(this.coau).add(OB.scale(this.cobu));\r\n        const y: Vector3 = OA.scale(this.coav).add(OB.scale(this.cobv));\r\n\r\n        const mapped = [];\r\n\r\n        let idx: string;\r\n        let tempVec: Vector3 = TmpVectors.Vector3[0];\r\n        for (let i = 0; i < this.cartesian.length; i++) {\r\n            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\r\n            mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\r\n            idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n            geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\r\n        }\r\n    }\r\n\r\n    //statics\r\n    /**Creates a primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public build(m: number, n: number) {\r\n        const vertices = new Array<_IsoVector>();\r\n\r\n        const O: _IsoVector = _IsoVector.Zero();\r\n        const A: _IsoVector = new _IsoVector(m, n);\r\n        const B: _IsoVector = new _IsoVector(-n, m + n);\r\n        vertices.push(O, A, B);\r\n\r\n        //max internal isoceles triangle vertices\r\n        for (let y = n; y < m + 1; y++) {\r\n            for (let x = 0; x < m + 1 - y; x++) {\r\n                vertices.push(new _IsoVector(x, y));\r\n            }\r\n        }\r\n\r\n        //shared vertices along edges when needed\r\n        if (n > 0) {\r\n            const g = Scalar.HCF(m, n);\r\n            const m1 = m / g;\r\n            const n1 = n / g;\r\n\r\n            for (let i = 1; i < g; i++) {\r\n                vertices.push(new _IsoVector(i * m1, i * n1)); //OA\r\n                vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\r\n                vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\r\n            }\r\n\r\n            //lower rows vertices and their rotations\r\n            const ratio = m / n;\r\n            for (let y = 1; y < n; y++) {\r\n                for (let x = 0; x < y * ratio; x++) {\r\n                    vertices.push(new _IsoVector(x, y));\r\n                    vertices.push(new _IsoVector(x, y).rotate120(m, n));\r\n                    vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\r\n                }\r\n            }\r\n        }\r\n        //order vertices by x and then y\r\n        vertices.sort((a, b) => {\r\n            return a.x - b.x;\r\n        });\r\n\r\n        vertices.sort((a, b) => {\r\n            return a.y - b.y;\r\n        });\r\n\r\n        const min = new Array<number>(m + n + 1);\r\n        const max = new Array<number>(m + n + 1);\r\n        for (let i = 0; i < min.length; i++) {\r\n            min[i] = Infinity;\r\n            max[i] = -Infinity;\r\n        }\r\n\r\n        let y: number = 0;\r\n        let x: number = 0;\r\n\r\n        const len: number = vertices.length;\r\n        for (let i = 0; i < len; i++) {\r\n            x = vertices[i].x;\r\n            y = vertices[i].y;\r\n            min[y] = Math.min(x, min[y]);\r\n            max[y] = Math.max(x, max[y]);\r\n        }\r\n\r\n        //calculates the distance of a vertex from a given primary vertex\r\n        const distFrom = (vert: _IsoVector, primVert: string) => {\r\n            const v = vert.clone();\r\n            if (primVert === \"A\") {\r\n                v.rotateNeg120(m, n);\r\n            }\r\n            if (primVert === \"B\") {\r\n                v.rotate120(m, n);\r\n            }\r\n            if (v.x < 0) {\r\n                return v.y;\r\n            }\r\n            return v.x + v.y;\r\n        };\r\n\r\n        const cartesian: Vector3[] = [];\r\n        const distFromO: number[] = [];\r\n        const distFromA: number[] = [];\r\n        const distFromB: number[] = [];\r\n        const vertByDist: { [key: string]: number[] } = {};\r\n        const vertData: number[][] = [];\r\n        let closest: number = -1;\r\n        let dist: number = -1;\r\n        for (let i = 0; i < len; i++) {\r\n            cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\r\n            distFromO[i] = distFrom(vertices[i], \"O\");\r\n            distFromA[i] = distFrom(vertices[i], \"A\");\r\n            distFromB[i] = distFrom(vertices[i], \"B\");\r\n\r\n            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\r\n                closest = 3;\r\n                dist = distFromO[i];\r\n            } else if (distFromO[i] === distFromA[i]) {\r\n                closest = 4;\r\n                dist = distFromO[i];\r\n            } else if (distFromA[i] === distFromB[i]) {\r\n                closest = 5;\r\n                dist = distFromA[i];\r\n            } else if (distFromB[i] === distFromO[i]) {\r\n                closest = 6;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\r\n                closest = 2;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\r\n                closest = 1;\r\n                dist = distFromA[i];\r\n            }\r\n            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\r\n                closest = 0;\r\n                dist = distFromB[i];\r\n            }\r\n            vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\r\n        }\r\n\r\n        vertData.sort((a, b) => {\r\n            return a[2] - b[2];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[1] - b[1];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        for (let v = 0; v < vertData.length; v++) {\r\n            vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\r\n        }\r\n\r\n        this.m = m;\r\n        this.n = n;\r\n        this.vertices = vertices;\r\n        this.vertByDist = vertByDist;\r\n        this.cartesian = cartesian;\r\n        this.min = min;\r\n        this.max = max;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/** Builds Polyhedron Data\r\n * @internal\r\n */\r\n\r\nexport class PolyhedronData {\r\n    public edgematch: (number | string)[][];\r\n\r\n    constructor(public name: string, public category: string, public vertex: number[][], public face: number[][]) {}\r\n}\r\n\r\n/**\r\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\r\n */\r\nexport class GeodesicData extends PolyhedronData {\r\n    /**\r\n     * @internal\r\n     */\r\n    public edgematch: (number | string)[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public adjacentFaces: number[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public sharedNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public poleNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public innerToData(face: number, primTri: _PrimaryIsoTriangle) {\r\n        for (let i = 0; i < primTri.innerFacets.length; i++) {\r\n            this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapABOBtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 0) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapOBOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapBAOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][2];\r\n        for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public orderData(primTri: _PrimaryIsoTriangle) {\r\n        const nearTo: number[][][] = [];\r\n        for (let i = 0; i < 13; i++) {\r\n            nearTo[i] = [];\r\n        }\r\n        const close: number[][] = primTri.closestTo;\r\n        for (let i = 0; i < close.length; i++) {\r\n            if (close[i][0] > -1) {\r\n                if (close[i][1] > 0) {\r\n                    nearTo[close[i][0]].push([i, close[i][1]]);\r\n                }\r\n            } else {\r\n                nearTo[12].push([i, close[i][0]]);\r\n            }\r\n        }\r\n\r\n        const near: number[] = [];\r\n        for (let i = 0; i < 12; i++) {\r\n            near[i] = i;\r\n        }\r\n        let nearIndex = 12;\r\n        for (let i = 0; i < 12; i++) {\r\n            nearTo[i].sort((a: number[], b: number[]) => {\r\n                return a[1] - b[1];\r\n            });\r\n            for (let j = 0; j < nearTo[i].length; j++) {\r\n                near[nearTo[i][j][0]] = nearIndex++;\r\n            }\r\n        }\r\n\r\n        for (let j = 0; j < nearTo[12].length; j++) {\r\n            near[nearTo[12][j][0]] = nearIndex++;\r\n        }\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].push(near[i]);\r\n        }\r\n\r\n        this.vertex.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].pop();\r\n        }\r\n\r\n        for (let i = 0; i < this.face.length; i++) {\r\n            for (let j = 0; j < this.face[i].length; j++) {\r\n                this.face[i][j] = near[this.face[i][j]];\r\n            }\r\n        }\r\n\r\n        this.sharedNodes = nearTo[12].length;\r\n        this.poleNodes = this.vertex.length - this.sharedNodes;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setOrder(m: number, faces: number[]) {\r\n        const adjVerts: number[] = [];\r\n        const dualFaces: number[] = [];\r\n        let face: number = <number>faces.pop();\r\n        dualFaces.push(face);\r\n        let index = this.face[face].indexOf(m);\r\n        index = (index + 2) % 3;\r\n        let v = this.face[face][index];\r\n        adjVerts.push(v);\r\n        let f = 0;\r\n        while (faces.length > 0) {\r\n            face = faces[f];\r\n            if (this.face[face].indexOf(v) > -1) {\r\n                // v is a vertex of face f\r\n                index = (this.face[face].indexOf(v) + 1) % 3;\r\n                v = this.face[face][index];\r\n                adjVerts.push(v);\r\n                dualFaces.push(face);\r\n                faces.splice(f, 1);\r\n                f = 0;\r\n            } else {\r\n                f++;\r\n            }\r\n        }\r\n        this.adjacentFaces.push(adjVerts);\r\n        return dualFaces;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public toGoldbergPolyhedronData(): PolyhedronData {\r\n        const goldbergPolyhedronData: PolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\r\n        goldbergPolyhedronData.name = \"GD dual\";\r\n        const verticesNb: number = this.vertex.length;\r\n        const map = new Array(verticesNb);\r\n        for (let v = 0; v < verticesNb; v++) {\r\n            map[v] = [];\r\n        }\r\n        for (let f = 0; f < this.face.length; f++) {\r\n            for (let i = 0; i < 3; i++) {\r\n                map[this.face[f][i]].push(f);\r\n            }\r\n        }\r\n        let cx = 0;\r\n        let cy = 0;\r\n        let cz = 0;\r\n        let face = [];\r\n        let vertex = [];\r\n        this.adjacentFaces = [];\r\n        for (let m = 0; m < map.length; m++) {\r\n            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\r\n            map[m].forEach((el: number) => {\r\n                cx = 0;\r\n                cy = 0;\r\n                cz = 0;\r\n                face = this.face[el];\r\n                for (let i = 0; i < 3; i++) {\r\n                    vertex = this.vertex[face[i]];\r\n                    cx += vertex[0];\r\n                    cy += vertex[1];\r\n                    cz += vertex[2];\r\n                }\r\n                goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\r\n            });\r\n        }\r\n        return goldbergPolyhedronData;\r\n    }\r\n\r\n    //statics\r\n    /**Builds the data for a Geodesic Polyhedron from a primary triangle\r\n     * @param primTri the primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public static BuildGeodesicData(primTri: _PrimaryIsoTriangle) {\r\n        const geodesicData = new GeodesicData(\r\n            \"Geodesic-m-n\",\r\n            \"Geodesic\",\r\n            [\r\n                [0, PHI, -1],\r\n                [-PHI, 1, 0],\r\n                [-1, 0, -PHI],\r\n                [1, 0, -PHI],\r\n                [PHI, 1, 0],\r\n                [0, PHI, 1],\r\n                [-1, 0, PHI],\r\n                [-PHI, -1, 0],\r\n                [0, -PHI, -1],\r\n                [PHI, -1, 0],\r\n                [1, 0, PHI],\r\n                [0, -PHI, 1],\r\n            ],\r\n            []\r\n        );\r\n\r\n        primTri.setIndices();\r\n        primTri.calcCoeffs();\r\n        primTri.createInnerFacets();\r\n        primTri.edgeVecsABOB();\r\n        primTri.mapABOBtoOBOA();\r\n        primTri.mapABOBtoBAOA();\r\n\r\n        for (let f = 0; f < primTri.IDATA.face.length; f++) {\r\n            primTri.MapToFace(f, geodesicData);\r\n            geodesicData.innerToData(f, primTri);\r\n            if (primTri.IDATA.edgematch[f][1] === \"B\") {\r\n                geodesicData.mapABOBtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][1] === \"O\") {\r\n                geodesicData.mapOBOAtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][3] === \"A\") {\r\n                geodesicData.mapBAOAtoDATA(f, primTri);\r\n            }\r\n        }\r\n\r\n        geodesicData.orderData(primTri);\r\n        const radius = 1;\r\n        geodesicData.vertex = geodesicData.vertex.map(function (el) {\r\n            const a = el[0];\r\n            const b = el[1];\r\n            const c = el[2];\r\n            const d = Math.sqrt(a * a + b * b + c * c);\r\n            el[0] *= radius / d;\r\n            el[1] *= radius / d;\r\n            el[2] *= radius / d;\r\n            return el;\r\n        });\r\n\r\n        return geodesicData;\r\n    }\r\n}\r\n","import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { CreateRibbon } from \"./Builders/ribbonBuilder\";\r\nimport { CreateDisc } from \"./Builders/discBuilder\";\r\nimport { CreateBox } from \"./Builders/boxBuilder\";\r\nimport { CreateTiledBox } from \"./Builders/tiledBoxBuilder\";\r\nimport { CreateSphere } from \"./Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"./Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"./Builders/torusBuilder\";\r\nimport { CreateTorusKnot } from \"./Builders/torusKnotBuilder\";\r\nimport { CreateDashedLines, CreateLineSystem, CreateLines } from \"./Builders/linesBuilder\";\r\nimport { CreatePolygon, ExtrudePolygon } from \"./Builders/polygonBuilder\";\r\nimport { ExtrudeShape, ExtrudeShapeCustom } from \"./Builders/shapeBuilder\";\r\nimport { CreateLathe } from \"./Builders/latheBuilder\";\r\nimport { CreatePlane } from \"./Builders/planeBuilder\";\r\nimport { CreateTiledPlane } from \"./Builders/tiledPlaneBuilder\";\r\nimport { CreateGround, CreateGroundFromHeightMap, CreateTiledGround } from \"./Builders/groundBuilder\";\r\nimport { CreateTube } from \"./Builders/tubeBuilder\";\r\nimport { CreatePolyhedron } from \"./Builders/polyhedronBuilder\";\r\nimport { CreateIcoSphere } from \"./Builders/icoSphereBuilder\";\r\nimport { CreateDecal } from \"./Builders/decalBuilder\";\r\nimport { CreateCapsule } from \"./Builders/capsuleBuilder\";\r\nimport { CreateGeodesic } from \"./Builders/geodesicBuilder\";\r\nimport { CreateGoldberg } from \"./Builders/goldbergBuilder\";\r\nimport { CreateText } from \"./Builders/textBuilder\";\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport const MeshBuilder = {\r\n    CreateBox,\r\n    CreateTiledBox,\r\n    CreateSphere,\r\n    CreateDisc,\r\n    CreateIcoSphere,\r\n    CreateRibbon,\r\n    CreateCylinder,\r\n    CreateTorus,\r\n    CreateTorusKnot,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n    CreateDashedLines,\r\n    ExtrudeShape,\r\n    ExtrudeShapeCustom,\r\n    CreateLathe,\r\n    CreateTiledPlane,\r\n    CreatePlane,\r\n    CreateGround,\r\n    CreateTiledGround,\r\n    CreateGroundFromHeightMap,\r\n    CreatePolygon,\r\n    ExtrudePolygon,\r\n    CreateTube,\r\n    CreatePolyhedron,\r\n    CreateGeodesic,\r\n    CreateGoldberg,\r\n    CreateDecal,\r\n    CreateCapsule,\r\n    CreateText,\r\n};\r\n","import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = new Array<IndexedVector2>();\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result = new Array<IndexedVector2>();\r\n        originalPoints.forEach((point) => {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result = new Array<Vector2>();\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals = new Array<number>();\r\n        const positions = new Array<number>();\r\n        const uvs = new Array<number>();\r\n\r\n        const bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        const indices = new Array<number>();\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vc_norm = vc.normalizeToNew();\r\n            let vp_norm = vp.normalizeToNew();\r\n            let vn_norm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vp_norm, vc_norm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vp_norm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vp_norm = vc_norm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vn_norm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vn_norm = vc_norm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n","import type { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters, IObstacle } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n    private _timeFactor: number = 1;\r\n\r\n    private _tempVec1: any;\r\n    private _tempVec2: any;\r\n\r\n    private _worker: Nullable<Worker> = null;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n\r\n        this._tempVec1 = new this.bjsRECAST.Vec3();\r\n        this._tempVec2 = new this.bjsRECAST.Vec3();\r\n    }\r\n\r\n    /**\r\n     * Set worker URL to be used when generating a new navmesh\r\n     * @param workerURL url string\r\n     * @returns boolean indicating if worker is created\r\n     */\r\n    public setWorkerURL(workerURL: string): boolean {\r\n        if (window && window.Worker) {\r\n            this._worker = new Worker(workerURL);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\r\n     * @param value the time factor applied at update\r\n     */\r\n    public set timeFactor(value: number) {\r\n        this._timeFactor = Math.max(value, 0);\r\n    }\r\n\r\n    /**\r\n     * Get the time factor used for crowd agent update\r\n     * @returns the time factor\r\n     */\r\n    public get timeFactor(): number {\r\n        return this._timeFactor;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigation mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     * @param completion callback when data is available from the worker. Not used without a worker\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters, completion?: (navmeshData: Uint8Array) => void): void {\r\n        if (this._worker && !completion) {\r\n            console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\r\n        } else if (!this._worker && completion) {\r\n            console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\r\n        }\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        let index: number;\r\n        let tri: number;\r\n        let pt: number;\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        let offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                const mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const worldMatrices = [];\r\n                const worldMatrix = mesh.computeWorldMatrix(true);\r\n\r\n                if (mesh.hasThinInstances) {\r\n                    const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                    for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\r\n                        const tmpMatrix = new Matrix();\r\n                        const thinMatrix = thinMatrices[instanceIndex];\r\n                        thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\r\n                        worldMatrices.push(tmpMatrix);\r\n                    }\r\n                } else {\r\n                    worldMatrices.push(worldMatrix);\r\n                }\r\n\r\n                for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\r\n                    const wm = worldMatrices[matrixIndex];\r\n                    for (tri = 0; tri < meshIndices.length; tri++) {\r\n                        indices.push(meshIndices[tri] + offset);\r\n                    }\r\n\r\n                    const transformed = Vector3.Zero();\r\n                    const position = Vector3.Zero();\r\n                    for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                        Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                        Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                        positions.push(transformed.x, transformed.y, transformed.z);\r\n                    }\r\n\r\n                    offset += meshPositions.length / 3;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._worker && completion) {\r\n            // spawn worker and send message\r\n            this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\r\n            this._worker.onmessage = function (e) {\r\n                completion(e.data);\r\n            };\r\n        } else {\r\n            // blocking calls\r\n            const rc = new this.bjsRECAST.rcConfig();\r\n            rc.cs = parameters.cs;\r\n            rc.ch = parameters.ch;\r\n            rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\r\n            rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\r\n            rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n            rc.walkableHeight = parameters.walkableHeight;\r\n            rc.walkableClimb = parameters.walkableClimb;\r\n            rc.walkableRadius = parameters.walkableRadius;\r\n            rc.maxEdgeLen = parameters.maxEdgeLen;\r\n            rc.maxSimplificationError = parameters.maxSimplificationError;\r\n            rc.minRegionArea = parameters.minRegionArea;\r\n            rc.mergeRegionArea = parameters.mergeRegionArea;\r\n            rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n            rc.detailSampleDist = parameters.detailSampleDist;\r\n            rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n            this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        let tri: number;\r\n        let pt: number;\r\n        const debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        const triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++) {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++) {\r\n            for (pt = 0; pt < 3; pt++) {\r\n                const point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        const mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[] {\r\n        let pt: number;\r\n        this._tempVec1.x = start.x;\r\n        this._tempVec1.y = start.y;\r\n        this._tempVec1.z = start.z;\r\n        this._tempVec2.x = end.x;\r\n        this._tempVec2.y = end.y;\r\n        this._tempVec2.z = end.z;\r\n        const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\r\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        this._tempVec1.x = extent.x;\r\n        this._tempVec1.y = extent.y;\r\n        this._tempVec1.z = extent.z;\r\n        this.navMesh.setDefaultQueryExtent(this._tempVec1);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void {\r\n        const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        const dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        const buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array {\r\n        const navmeshData = this.navMesh.getNavmeshData();\r\n        const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        const ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {}\r\n\r\n    /**\r\n     * Creates a cylinder obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addCylinderObstacle(position: Vector3, radius: number, height: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\r\n    }\r\n\r\n    /**\r\n     * Creates an oriented box obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param extent box size\r\n     * @param angle angle in radians of the box orientation on Y axis\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addBoxObstacle(position: Vector3, extent: Vector3, angle: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = extent.x;\r\n        this._tempVec2.y = extent.y;\r\n        this._tempVec2.z = extent.z;\r\n        return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\r\n    }\r\n\r\n    /**\r\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\r\n     * @param obstacle obstacle to remove from the navigation\r\n     */\r\n    removeObstacle(obstacle: IObstacle): void {\r\n        this.navMesh.removeObstacle(obstacle);\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * agents reach radius\r\n     */\r\n    public reachRadii: number[] = new Array<number>();\r\n    /**\r\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\r\n     */\r\n    private _agentDestinationArmed: boolean[] = new Array<boolean>();\r\n    /**\r\n     * agent current target\r\n     */\r\n    private _agentDestination: Vector3[] = new Array<Vector3>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Fires each time an agent is in reach radius of its destination\r\n     */\r\n    public onReachTargetObservable = new Observable<{ agentIndex: number; destination: Vector3 }>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number {\r\n        const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\r\n        this._agentDestinationArmed.push(false);\r\n        this._agentDestination.push(new Vector3(0, 0, 0));\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n\r\n        // arm observer\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this._agentDestinationArmed[item] = true;\r\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        const agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n            this.reachRadii.splice(item, 1);\r\n            this._agentDestinationArmed.splice(item, 1);\r\n            this._agentDestination.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update obstacles\r\n        this.bjsRECASTPlugin.navMesh.update();\r\n\r\n        if (deltaTime <= Epsilon) {\r\n            return;\r\n        }\r\n        // update crowd\r\n        const timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            let iterationCount = Math.floor(deltaTime / timeStep);\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n\r\n            const step = deltaTime / iterationCount;\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(step);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            // update transform position\r\n            const agentIndex = this.agents[index];\r\n            const agentPosition = this.getAgentPosition(agentIndex);\r\n            this.transforms[index].position = agentPosition;\r\n            // check agent reach destination\r\n            if (this._agentDestinationArmed[index]) {\r\n                const dx = agentPosition.x - this._agentDestination[index].x;\r\n                const dz = agentPosition.z - this._agentDestination[index].z;\r\n                const radius = this.reachRadii[index];\r\n                const groundY = this._agentDestination[index].y - this.reachRadii[index];\r\n                const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\r\n                const distanceXZSquared = dx * dx + dz * dz;\r\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\r\n                    this.onReachTargetObservable.notifyObservers({ agentIndex: agentIndex, destination: this._agentDestination[index] });\r\n                    this._agentDestinationArmed[index] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the next corner points composing the path (max 4 points)\r\n     * @param index agent index returned by addAgent\r\n     * @returns array containing world position composing the path\r\n     */\r\n    getCorners(index: number): Vector3[] {\r\n        let pt: number;\r\n        const navPath = this.recastCrowd.getCorners(index);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n        this.onReachTargetObservable.clear();\r\n    }\r\n}\r\n"],"names":["Ray","constructor","origin","direction","length","Number","MAX_VALUE","clone","this","intersectsBoxMinMax","minimum","maximum","intersectionTreshold","newMinimum","_TmpVector3","copyFromFloats","x","y","z","newMaximum","inv","min","max","temp","d","maxValue","Math","abs","Infinity","intersectsBox","box","intersectsSphere","sphere","center","pyth","radius","rr","dot","intersectsTriangle","vertex0","vertex1","vertex2","edge1","edge2","pvec","tvec","qvec","subtractToRef","det","invdet","bv","bw","distance","intersectsPlane","plane","result1","normal","result2","intersectsAxis","axis","offset","t","intersectsMesh","mesh","fastCheck","tm","getWorldMatrix","invertToRef","_tmpRay","TransformToRef","Transform","intersects","intersectsMeshes","meshes","results","i","pickInfo","hit","push","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","intersectionSegment","sega","segb","threshold","o","u","rsegb","v","w","scaleToRef","_Rayl","addToRef","a","b","c","e","D","sN","tN","sD","tD","_Smallnum","sc","tc","qtc","qsc","addInPlace","dP","lengthSquared","update","viewportWidth","viewportHeight","world","view","projection","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","static","end","subtract","sqrt","normalize","ray","matrix","result","dir","len","num","sourceX","sourceY","multiplyToRef","invert","nearScreenSource","isNDCHalfZRange","farScreenSource","nearVec3","farVec3","copyFrom","camera","cameraViewSpace","createPickingRayToRef","engine","getEngine","activeCamera","viewport","toGlobal","getRenderWidth","getRenderHeight","getHardwareScalingLevel","height","width","getViewMatrix","getProjectionMatrix","createPickingRayInCameraSpaceToRef","Error","identity","pickingInfo","rayFunction","onlyBoundingInfo","trianglePredicate","skipBoundingInfo","predicate","computeWorldMatrixForCamera","activeCameras","cameraToUseForPointers","currentCamera","meshIndex","isEnabled","isVisible","isPickable","forceCompute","isWorldMatrixCameraDependent","computeWorldMatrix","hasThinInstances","thinInstanceEnablePicking","_internalPickForMesh","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","index","thinInstanceIndex","pickingInfos","Array","_internalPick","_tempPickingRay","createPickingRay","Object","defineProperty","get","enumerable","configurable","_enableDistantPicking","_pickWithRayInverseMatrix","_cachedRayForTransform","_internalMultiPick","transform","getForwardRayToRef","refRay","position","_scene","useRightHandedSystem","CreateCapsuleVertexData","options","subdivisions","tessellation","capSubdivisions","capDetail","radialSegments","heightSegments","radiusTop","radiusBottom","heightMinusCaps","thetaLength","PI","capsTopSegments","topCapSubdivisions","capsBottomSegments","bottomCapSubdivisions","alpha","acos","indices","vertices","normals","uvs","indexArray","halfHeight","pi2","vertex","cosAlpha","cos","sinAlpha","sin","coneLength","vl","indexRow","cosA","sinA","_radius","theta","sinTheta","cosTheta","set","coneHeight","slope","i1","i2","i3","i4","reverse","orientation","equals","m","scale","cross","toQuaternion","toRotationMatrix","vDat","positions","CreateCapsule","name","updatable","scene","capsule","applyToMesh","CapsuleBuilder","CreateCylinderVertexData","diameterTop","diameter","diameterBottom","hasRings","enclose","cap","arc","sideOrientation","faceUV","faceColors","surfaceNb","f","undefined","colors","angleStep","angle","h","tan","ringVertex","ringNormal","ringFirstVertex","ringFirstNormal","quadNormal","Y","j","r","ringIdx","s","cs","g","i0","createCylinderCap","isTop","circleVector","vbase","textureScale","textureCoordinate","frontUVs","backUVs","vertexData","CreateCylinder","cylinder","_originalBuilderSideOrientation","CylinderBuilder","xpAxis","xnAxis","ypAxis","ynAxis","zpAxis","znAxis","DecalVertex","uv","vertexIdx","vertexIdxForBones","localPositionOverride","localNormalOverride","matrixIndicesOverride","matrixWeightsOverride","slice","CreateDecal","sourceMesh","hasSkeleton","skeleton","useLocalComputation","localMode","meshHasOverridenMaterial","overrideMaterialSideOrientation","getIndices","getPositionData","getVerticesData","getNormalsData","localPositions","localNormals","matIndices","matWeights","matIndicesExtra","matWeightsExtra","size","target","getScene","cameraWorldTarget","globalPosition","yaw","atan2","pitch","matricesIndices","matricesWeights","matricesIndicesExtra","matricesWeightsExtra","currentVertexDataIndex","extractDecalVector3","indexId","transformMatrix","vertexId","captureUVS","emptyArray","clip","clipSize","indexOf","arr","val","start","clipVertices","v0","v1","clipFactor","weights","mat0Index","v0Indices","v0Weights","mat1Index","v1Indices","v1Weights","idx","ind","sumw","v0LocalPositionX","v0LocalPositionY","v0LocalPositionZ","v1LocalPositionX","v1LocalPositionY","v1LocalPositionZ","v0LocalNormalX","v0LocalNormalY","v0LocalNormalZ","interpNormalX","interpNormalY","interpNormalZ","norm","clipResult","total","nV1","nV2","nV3","nV4","v1Out","v2Out","v3Out","sourceMeshAsMesh","matrixData","_thinInstanceDataStorage","numMatrices","thinInstanceCount","thinInstanceMatrix","ofst","setRowFromFloats","decalWorldMatrix","multiply","inverseDecalWorldMatrix","meshWorldMatrix","oneFaceVertices","faceVertices","cullBackFaces","vIndex","toArray","decal","parent","rotation","refreshBoundingInfo","DecalBuilder","CreateDiscVertexData","step","vertexNb","CreateDisc","disc","DiscBuilder","CreateGeodesic","floor","n","primTri","build","geoOptions","custom","sizeX","sizeY","sizeZ","flat","CreateGoldbergVertexData","goldbergData","minX","maxX","minY","maxY","face","verts","ba","ca","pdata","vCoord","CreateGoldberg","geodesicData","toGoldbergPolyhedronData","goldberg","nbSharedFaces","sharedNodes","nbUnsharedFaces","poleNodes","adjacentFaces","nbFaces","nbFacesAtPole","faceCenters","faceXaxis","faceYaxis","faceZaxis","CreateIcoSphereVertexData","radiusX","radiusY","radiusZ","icoVertices","ico_indices","vertices_unalias_id","ico_vertexuv","island","current_indice","face_vertex_pos","face_vertex_uv","v012","v_id","interp_vertex","c1","c2","pos_x0","pos_x1","pos_interp","vertex_normal","centroid_x0","centroid_x1","uv_x0","uv_x1","uv_interp","CreateIcoSphere","IcoSphereBuilder","CreateLathe","closed","shape","paths","invertUV","p","rotated","path","pathArray","closeArray","LatheBuilder","CreatePolygonVertexData","polygon","fUV","fColors","wrp","wrap","startIndex","disp","distX","distZ","dist","totalLen","cumulate","totalColors","concat","CreatePolygon","earcutInjection","earcut","holes","depth","smoothingThreshold","contours","hole","equalsWithEpsilon","pop","polygonTriangulation","hNb","hPoint","addHole","ExtrudePolygon","PolygonBuilder","CreatePolyhedronVertexData","polyhedra","type","data","nbfaces","faceIdx","indexes","ang","tmp","fl","CreatePolyhedron","polyhedron","PolyhedronBuilder","ShapePath","resolution","_paths","_tempPaths","_holes","_resolution","moveTo","_currentPath","lineTo","addLineTo","quadraticCurveTo","cpx","cpy","addQuadraticCurveTo","bezierCurveTo","cpx1","cpy1","cpx2","cpy2","addBezierCurveTo","extractHoles","area","CreateShapePath","char","offsetX","offsetY","fontData","glyph","glyphs","shapePath","outline","split","l","parseInt","ha","CreateText","text","shapePaths","chars","from","line_height","boundingBox","yMax","yMin","underlineThickness","ret","CreateShapePaths","holeVectors","shapeVectors","points","getPoints","point","localHolesCopy","found","isPointInside","holePoints","splice","newMesh","bbox","getBoundingInfo","extendSizeWorld","_x","_y","_z","bakeCurrentTransformIntoVertices","CreateTiledBoxVertexData","flipTile","pattern","tileWidth","tileSize","tileHeight","alignH","alignHorizontal","alignV","alignVertical","halfWidth","halfDepth","faceVertexData","baseAlignV","facePositions","faceNormals","newFaceUV","lu","li","map","vec0","mtrx0","entry","add","reduce","accumulator","currentValue","vec2","mtrx2","mtrx3","vec4","mtrx4","mtrx5","CreateTiledBox","TiledBoxBuilder","CreateTiledPlaneVertexData","tilesX","tilesY","adjustX","adjustY","startX","startY","endX","endY","uvBase","partialBottomRow","partialTopRow","partialLeftCol","partialRightCol","uvPart","uvBaseBR","uvBaseTR","uvBaseLC","uvBaseRC","CreateTiledPlane","TiledPlaneBuilder","CreateTorusVertexData","thickness","stride","outerAngle","innerAngle","dx","dy","nextI","nextJ","CreateTorus","torus","TorusBuilder","CreateTorusKnotVertexData","tube","tubularSegments","q","getPos","cu","su","quOverP","tx","ty","tz","p1","p2","tang","bitan","cx","cy","jNext","CreateTorusKnot","torusKnot","TorusKnotBuilder","CreateTube","instance","_creationDataStorage","radiusFunction","tubePathArray","path3D","circlePaths","tangents","getTangents","getNormals","distances","getDistances","radiusFunctionFinal","circlePath","rad","rotationMatrix","scaleInPlace","capPath","nbPoints","pathIndex","pointCap","storage","closePath","TubeBuilder","_IsoVector","rotate60About","other","rotateNeg60About","rotate120","rotateNeg120","toCartesianOrigin","isoGridSize","_PrimaryIsoTriangle","cartesian","closestTo","innerFacets","isoVecsABOB","isoVecsOBOA","isoVecsBAOA","vertexTypes","IDATA","PolyhedronData","setIndices","indexCount","vecToidx","fr","rot","O","A","B","m1","n1","oVec","aVec","bVec","oaVec","abVec","obVec","idxR","isoId","isoIdR","vDist","vertByDist","matchIdx","edgematch","calcCoeffs","thirdR3","LSQD","coau","cobu","coav","cobv","createInnerFacets","edgeVecsABOB","prev","next","pointR","prevR","nextR","maxPoint","maxPrev","maxLeftPrev","mapABOBtoOBOA","mapABOBtoBAOA","MapToFace","faceNb","F","oidx","aidx","bidx","OA","OB","mapped","tempVec","ratio","distFrom","vert","primVert","distFromO","distFromA","distFromB","vertData","closest","category","GeodesicData","innerToData","el","mapABOBtoDATA","mapOBOAtoDATA","mapBAOAtoDATA","orderData","nearTo","close","near","nearIndex","setOrder","faces","adjVerts","dualFaces","goldbergPolyhedronData","verticesNb","cz","forEach","parsedMesh","GoldbergMesh","Parse","relatedGoldbergFace","poleOrShared","fromPole","_changeGoldbergFaceColors","colorRange","col","newCols","setGoldbergFaceColors","setVerticesData","updateGoldbergFaceColors","updateVerticesData","_changeGoldbergFaceUVs","uvRange","points5","points6","setGoldbergFaceUVs","newUVs","updateGoldbergFaceUVs","placeOnGoldbergFaceAt","serialize","serializationObject","super","color","asArray","vector","MeshBuilder","CreateBox","CreateSphere","CreateRibbon","CreateLineSystem","CreateLines","CreateDashedLines","ExtrudeShape","ExtrudeShapeCustom","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","IndexedVector2","original","PolygonPoints","elements","originalPoints","newPoint","computeBounds","lmin","lmax","Polygon","xmin","ymin","xmax","ymax","numberOfSides","increment","input","floats","parseFloat","filter","isNaN","PolygonMeshBuilder","_addToepoint","_epoints","_points","_outlinepoints","_eholes","bjsEarcut","_name","holepoints","buildVertexData","bounds","res","positionscount","totalCount","_addSide","flip","ulength","p0","vc","vp","vn","vc_norm","normalizeToNew","vp_norm","vn_norm","dotp","dotn","RecastJSPlugin","recastInjection","Recast","bjsRECAST","_maximumSubStepCount","_timeStep","_timeFactor","_worker","isSupported","setTimeStep","_tempVec1","Vec3","_tempVec2","setWorkerURL","workerURL","window","Worker","newTimeStep","getTimeStep","setMaximumSubStepCount","newStepCount","getMaximumSubStepCount","timeFactor","value","createNavMesh","parameters","completion","tri","pt","console","warn","navMesh","NavMesh","meshIndices","meshPositions","worldMatrices","worldMatrix","instanceIndex","matrixIndex","wm","transformed","postMessage","onmessage","rc","rcConfig","ch","borderSize","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","createDebugNavMesh","debugNavMesh","getDebugNavMesh","triangleCount","getTriangleCount","getTriangle","getPoint","getClosestPoint","getClosestPointToRef","getRandomPointAround","maxRadius","getRandomPointAroundToRef","moveAlong","destination","moveAlongToRef","computePath","navPath","pointCount","getPointCount","createCrowd","maxAgents","maxAgentRadius","RecastJSCrowd","setDefaultQueryExtent","extent","getDefaultQueryExtent","buildFromNavmeshData","nDataBytes","BYTES_PER_ELEMENT","dataPtr","_malloc","dataHeap","Uint8Array","HEAPU8","buffer","buf","NavmeshData","dataPointer","byteOffset","_free","getNavmeshData","navmeshData","arrView","freeNavmeshData","getDefaultQueryExtentToRef","dispose","addCylinderObstacle","addBoxObstacle","removeObstacle","obstacle","plugin","recastCrowd","transforms","agents","reachRadii","_agentDestinationArmed","_agentDestination","_onBeforeAnimationsObserver","onReachTargetObservable","bjsRECASTPlugin","Crowd","getNavMesh","onBeforeAnimationsObservable","getDeltaTime","addAgent","pos","agentParams","dtCrowdAgentParams","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","updateFlags","obstacleAvoidanceType","queryFilterType","userData","agentIndex","reachRadius","getAgentPosition","agentPos","getAgentPositionToRef","getAgentVelocity","agentVel","getAgentVelocityToRef","getAgentNextTargetPath","pathTargetPos","getAgentNextTargetPathToRef","getAgentState","overOffmeshConnection","agentGoto","item","agentTeleport","updateAgentParameters","getAgentParameters","setAgentParameters","removeAgent","getAgents","deltaTime","timeStep","maxStepCount","iterationCount","agentPosition","dz","groundY","ceilingY","distanceXZSquared","notifyObservers","ext","getCorners","destroy","remove","clear"],"sourceRoot":""}