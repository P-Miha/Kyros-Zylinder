{"version":3,"file":"js/417.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/scenes/exampleScenes/defaultWithTexture ORIGINAL.ts","webpack://babylonjs-typescript-webpack-template/./assets/grass.jpg","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/Shadows/shadowGeneratorSceneComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/sphereBuilder.ts"],"sourcesContent":["import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { CreateSphere } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../../createScene\";\r\n\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\n// import \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport grassTextureUrl from \"../../../assets/grass.jpg\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\r\n\r\nimport \"@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent\";\r\n\r\nexport class DefaultSceneWithTexture implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\r\n            \"my first camera\",\r\n            0,\r\n            Math.PI / 3,\r\n            10,\r\n            new Vector3(0, 0, 0),\r\n            scene\r\n        );\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        // const light = new HemisphericLight(\r\n        //     \"light\",\r\n        //     new Vector3(0, 1, 0),\r\n        //     scene\r\n        // );\r\n\r\n        // // Default intensity is 1. Let's dim the light a small amount\r\n        // light.intensity = 0.7;\r\n\r\n        // Our built-in 'sphere' shape.\r\n        const sphere = CreateSphere(\r\n            \"sphere\",\r\n            { diameter: 2, segments: 32 },\r\n            scene\r\n        );\r\n\r\n        // Move the sphere upward 1/2 its height\r\n        sphere.position.y = 1;\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\r\n            \"ground\",\r\n            { width: 6, height: 6 },\r\n            scene\r\n        );\r\n\r\n        // Load a texture to be used as the ground material\r\n        const groundMaterial = new StandardMaterial(\"ground material\", scene);\r\n        groundMaterial.diffuseTexture = new Texture(grassTextureUrl, scene);\r\n\r\n        ground.material = groundMaterial;\r\n        ground.receiveShadows = true;\r\n\r\n        const light = new DirectionalLight(\r\n            \"light\",\r\n            new Vector3(0, -1, 1),\r\n            scene\r\n        );\r\n        light.intensity = 0.5;\r\n        light.position.y = 10;\r\n\r\n        const shadowGenerator = new ShadowGenerator(512, light)\r\n        shadowGenerator.useBlurExponentialShadowMap = true;\r\n        shadowGenerator.blurScale = 2;\r\n        shadowGenerator.setDarkness(0.2);\r\n\r\n        shadowGenerator.getShadowMap()!.renderList!.push(sphere);\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new DefaultSceneWithTexture();\r\n","export default __webpack_public_path__ + \"9b31293ea96c8dfa518b45622da82a13.jpg\";","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n"],"names":["DefaultSceneWithTexture","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Math","PI","setTarget","Zero","attachControl","sphere","diameter","segments","position","y","ground","width","height","groundMaterial","diffuseTexture","material","receiveShadows","light","intensity","shadowGenerator","useBlurExponentialShadowMap","blurScale","setDarkness","getShadowMap","renderList","push","AddParser","NAME_SHADOWGENERATOR","parsedData","shadowGenerators","index","cache","length","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","name","this","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","getShadowGenerators","iterator","values","key","next","done","value","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent","CreateSphereVertexData","options","diameterX","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","normalize","x","z","UseOpenGLOrientationForUV","verticesCount","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","CreateSphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","SphereBuilder"],"sourceRoot":""}