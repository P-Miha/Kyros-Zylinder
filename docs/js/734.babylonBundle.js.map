{"version":3,"file":"js/734.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/directionalLight.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/shadowLight.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/kernelBlurFragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/kernelBlurFragment2.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/kernelBlur.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/kernelBlurVertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/kernelBlur.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/blurPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/packingFunctions.ts"],"sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = -Number.MAX_VALUE;\r\n            this._orthoTop = -Number.MAX_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = -Number.MAX_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n","import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n/**\r\n * Interface describing all the common properties and methods a shadow light needs to implement.\r\n * This helps both the shadow generator and materials to generate the corresponding shadow maps\r\n * as well as binding the different shadow properties to the effects.\r\n */\r\nexport interface IShadowLight extends Light {\r\n    /**\r\n     * The light id in the scene (used in scene.getLightById for instance)\r\n     */\r\n    id: string;\r\n    /**\r\n     * The position the shadow will be casted from.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * In 2d mode (needCube being false), the direction used to cast the shadow.\r\n     */\r\n    direction: Vector3;\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    transformedPosition: Vector3;\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    transformedDirection: Vector3;\r\n    /**\r\n     * The friendly name of the light in the scene.\r\n     */\r\n    name: string;\r\n    /**\r\n     * Defines the shadow projection clipping minimum z value.\r\n     */\r\n    shadowMinZ: number;\r\n    /**\r\n     * Defines the shadow projection clipping maximum z value.\r\n     */\r\n    shadowMaxZ: number;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    computeTransformedInformation(): boolean;\r\n\r\n    /**\r\n     * Gets the scene the light belongs to.\r\n     * @returns The scene\r\n     */\r\n    getScene(): Scene;\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;\r\n\r\n    /**\r\n     * Gets the current depth scale used in ESM.\r\n     * @returns The scale\r\n     */\r\n    getDepthScale(): number;\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    needCube(): boolean;\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    needProjectionMatrixCompute(): boolean;\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    forceProjectionMatrixCompute(): void;\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    getShadowDirection(faceIndex?: number): Vector3;\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    getDepthMinZ(activeCamera: Camera): number;\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    getDepthMaxZ(activeCamera: Camera): number;\r\n}\r\n\r\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\r\n */\r\nexport abstract class ShadowLight extends Light implements IShadowLight {\r\n    protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;\r\n\r\n    protected _position: Vector3;\r\n    protected _setPosition(value: Vector3) {\r\n        this._position = value;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._setPosition(value);\r\n    }\r\n\r\n    protected _direction: Vector3;\r\n    protected _setDirection(value: Vector3) {\r\n        this._direction = value;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    public set direction(value: Vector3) {\r\n        this._setDirection(value);\r\n    }\r\n\r\n    protected _shadowMinZ: number;\r\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMinZ(): number {\r\n        return this._shadowMinZ;\r\n    }\r\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\r\n    public set shadowMinZ(value: number) {\r\n        this._shadowMinZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    protected _shadowMaxZ: number;\r\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMaxZ(): number {\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        this._shadowMaxZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    public customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    public transformedPosition: Vector3;\r\n\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    public transformedDirection: Vector3;\r\n\r\n    private _needProjectionMatrixCompute: boolean = true;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    public computeTransformedInformation(): boolean {\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            if (!this.transformedPosition) {\r\n                this.transformedPosition = Vector3.Zero();\r\n            }\r\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\r\n\r\n            // In case the direction is present.\r\n            if (this.direction) {\r\n                if (!this.transformedDirection) {\r\n                    this.transformedDirection = Vector3.Zero();\r\n                }\r\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the depth scale used for the shadow map.\r\n     * @returns the depth scale.\r\n     */\r\n    public getDepthScale(): number {\r\n        return 50.0;\r\n    }\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        return this.transformedDirection ? this.transformedDirection : this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the ShadowLight absolute position in the World.\r\n     * @returns the position vector in world space\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return this.transformedPosition ? this.transformedPosition : this.position;\r\n    }\r\n\r\n    /**\r\n     * Sets the ShadowLight direction toward the passed target.\r\n     * @param target The point to target in local space\r\n     * @returns the updated ShadowLight direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(this.position));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the light rotation in euler definition.\r\n     * @returns the x y z rotation in local space.\r\n     */\r\n    public getRotation(): Vector3 {\r\n        this.direction.normalize();\r\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\r\n        const yaxis = Vector3.Cross(xaxis, this.direction);\r\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    public needCube(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    public needProjectionMatrixCompute(): boolean {\r\n        return this._needProjectionMatrixCompute;\r\n    }\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    public forceProjectionMatrixCompute(): void {\r\n        this._needProjectionMatrixCompute = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = Vector3.Zero();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        if (!this._cache.position.equals(this.position)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(force?: boolean): Matrix {\r\n        if (!force && this.isSynchronized()) {\r\n            this._currentRenderId = this.getScene().getRenderId();\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        this._updateCache();\r\n        this._cache.position.copyFrom(this.position);\r\n\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\r\n\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\r\n\r\n            this._markSyncedWithParent();\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n    }\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    public setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight {\r\n        if (this.customProjectionMatrixBuilder) {\r\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\r\n        } else {\r\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.parent || !this.parent.getWorldMatrix) {\r\n            (this.transformedPosition as any) = null;\r\n            (this.transformedDirection as any) = null;\r\n        }\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"kernelBlurVaryingDeclaration\";\nconst shader = `varying vec2 sampleCoord{X};`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVaryingDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"kernelBlurFragment\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(sampleCoord{X}); \ncomputedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurFragment = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"kernelBlurFragment2\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurFragment2 = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration\";\nimport \"./ShadersInclude/packingFunctions\";\nimport \"./ShadersInclude/kernelBlurFragment\";\nimport \"./ShadersInclude/kernelBlurFragment2\";\n\nconst name = \"kernelBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT; \nfloat factor=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"kernelBlurVertex\";\nconst shader = `sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVertex = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration\";\nimport \"./ShadersInclude/kernelBlurVertex\";\n\nconst name = \"kernelBlurVertexShader\";\nconst shader = `attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const kernelBlurVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/kernelBlur.fragment\";\r\nimport \"../Shaders/kernelBlur.vertex\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    @serialize(\"kernel\")\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    @serialize(\"packedFloat\")\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        defines = \"\",\r\n        private _blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(\r\n            name,\r\n            \"kernelBlur\",\r\n            [\"delta\", \"direction\"],\r\n            [\"circleOfConfusionSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            \"kernelBlur\",\r\n            { varyingCount: 0, depCount: 0 },\r\n            true,\r\n            textureFormat\r\n        );\r\n        this._staticDefines = defines;\r\n        this.direction = direction;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (this._outputTexture) {\r\n                effect.setFloat2(\"delta\", (1 / this._outputTexture.width) * this.direction.x, (1 / this._outputTexture.height) * this.direction.y);\r\n            } else {\r\n                effect.setFloat2(\"delta\", (1 / this.width) * this.direction.x, (1 / this.height) * this.direction.y);\r\n            }\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    protected _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this._blockCompilation = false;\r\n        super.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"packingFunctions\";\nconst shader = `vec4 pack(float depth)\n{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const packingFunctions = { name, shader };\n"],"names":["N","AddNodeConstructor","name","scene","DirectionalLight","Zero","shadowFrustumSize","this","_shadowFrustumSize","value","forceProjectionMatrixCompute","shadowOrthoScale","_shadowOrthoScale","orthoLeft","_orthoLeft","left","orthoRight","_orthoRight","right","orthoTop","_orthoTop","top","orthoBottom","_orthoBottom","bottom","constructor","direction","super","autoUpdateExtends","autoCalcShadowZBounds","Number","MAX_VALUE","MIN_VALUE","position","scale","getClassName","getTypeID","LIGHTTYPEID_DIRECTIONALLIGHT","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","renderList","_setDefaultFixedFrustumShadowProjectionMatrix","_setDefaultAutoExtendShadowProjectionMatrix","activeCamera","getScene","OrthoLHToRef","undefined","shadowMinZ","minZ","shadowMaxZ","maxZ","getEngine","isNDCHalfZRange","tempVector3","meshIndex","length","mesh","boundingBox","getBoundingInfo","index","vectorsWorld","TransformCoordinatesToRef","x","y","z","_shadowMinZ","_shadowMaxZ","xOffset","yOffset","useReverseDepthBuffer","OrthoOffCenterLHToRef","_buildUniformLayout","_uniformBuffer","addUniform","create","transferToEffect","effect","lightIndex","computeTransformedInformation","updateFloat4","transformedDirection","transferToNodeMaterialEffect","lightDataUniformName","setFloat3","getDepthMinZ","engine","_scene","getDepthMaxZ","prepareLightSpecificDefines","defines","ShadowLight","_needProjectionMatrixCompute","_setPosition","_position","_setDirection","_direction","parent","getWorldMatrix","transformedPosition","TransformNormalToRef","getDepthScale","getShadowDirection","faceIndex","getAbsolutePosition","setDirectionToTarget","target","Normalize","subtract","getRotation","normalize","xaxis","Cross","Y","yaxis","RotationFromAxis","needCube","needProjectionMatrixCompute","_initCache","_cache","_isSynchronized","equals","computeWorldMatrix","force","isSynchronized","_currentRenderId","getRenderId","_worldMatrix","_updateCache","copyFrom","Identity","TranslationToRef","multiplyToRef","_markSyncedWithParent","_worldMatrixDeterminantIsDirty","setShadowProjectionMatrix","customProjectionMatrixBuilder","_syncParentEnabledState","IncludesShadersStore","ShadersStore","BlurPostProcess","kernel","v","_idealKernel","Math","max","_kernel","_nearestBestKernel","_blockCompilation","_updateParameters","packedFloat","_packedFloat","options","camera","samplingMode","BILINEAR_SAMPLINGMODE","reusable","textureType","varyingCount","depCount","textureFormat","_staticDefines","onApplyObservable","add","_outputTexture","setFloat2","width","height","updateEffect","uniforms","samplers","indexParameters","onCompiled","onError","centerIndex","offsets","weights","totalWeight","i","u","w","_gaussianWeight","linearSamplingWeights","linearSamplingOffsets","linearSamplingMap","j","min","floor","push","o","sharedCell","weightLinear","offsetLinear","maxVaryingRows","getCaps","maxVaryingVectors","freeVaryingVec2","indexOf","_glslFloat","idealKernel","round","k","sigma","exponent","sqrt","PI","exp","decimalFigures","toFixed","replace","_Parse","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode"],"sourceRoot":""}