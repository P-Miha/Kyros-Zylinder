{"version":3,"file":"js/745.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Culling/ray.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/geodesicBuilder.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/textBuilder.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/goldbergMesh.ts"],"sourcesContent":["import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const direction = end.subtract(origin);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): PickingInfo;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        viewport.width,\r\n        viewport.height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos = new Array<PickingInfo>();\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { CreatePolyhedron } from \"./polyhedronBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\n\r\n/**\r\n * Creates the Mesh for a Geodesic Polyhedron\r\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/geodesic_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * m number of horizontal steps along an isogrid\r\n * * n number of angled steps along an isogrid\r\n * * size the size of the Geodesic, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.n\r\n * @param options.size\r\n * @param options.sizeX\r\n * @param options.sizeY\r\n * @param options.sizeZ\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.flat\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.m\r\n * @param scene defines the hosting scene\r\n * @returns Geodesic mesh\r\n */\r\nexport function CreateGeodesic(\r\n    name: string,\r\n    options: {\r\n        m?: number;\r\n        n?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n\r\n    const geoOptions: object = {\r\n        custom: geodesicData,\r\n        size: options.size,\r\n        sizeX: options.sizeX,\r\n        sizeY: options.sizeY,\r\n        sizeZ: options.sizeZ,\r\n        faceUV: options.faceUV,\r\n        faceColors: options.faceColors,\r\n        flat: options.flat,\r\n        updatable: options.updatable,\r\n        sideOrientation: options.sideOrientation,\r\n        frontUVs: options.frontUVs,\r\n        backUVs: options.backUVs,\r\n    };\r\n    const geodesic = CreatePolyhedron(name, geoOptions, scene);\r\n\r\n    return geodesic;\r\n}\r\n","import type { Color4 } from \"../../Maths/math.color\";\r\nimport { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /** Create a bezier curve from the virtual cursor to a given coordinate */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\n/**\r\n * Creates shape paths from a text and font\r\n * @param text the text\r\n * @param size size of the font\r\n * @param resolution resolution of the font\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @returns array of ShapePath objects\r\n */\r\nexport function CreateTextShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        perLetterFaceUV?: (letterIndex: number) => Vector4[];\r\n        perLetterFaceColors?: (letterIndex: number) => Color4[];\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    let letterIndex = 0;\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // There is at least a hole but it was unaffected\r\n            if (!holeVectors.length && holes.length) {\r\n                for (const hole of holes) {\r\n                    const points = hole.getPoints();\r\n                    const holePoints: Vector3[] = [];\r\n                    for (const point of points) {\r\n                        holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                    }\r\n                    holeVectors.push(holePoints);\r\n                }\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\r\n                    faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene,\r\n                earcutInjection\r\n            );\r\n            meshes.push(mesh);\r\n            letterIndex++;\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to center\r\n        const bbox = newMesh?.getBoundingInfo();\r\n        newMesh.position.x = -bbox?.boundingBox.extendSizeWorld._x;\r\n        newMesh.position.y = -bbox?.boundingBox.extendSizeWorld._y;\r\n        newMesh.position.z = -bbox?.boundingBox.extendSizeWorld._z;\r\n        newMesh.name = name;\r\n\r\n        newMesh.rotation.x = -Math.PI / 2;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n","import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n"],"names":["Ray","constructor","origin","direction","length","Number","MAX_VALUE","clone","this","intersectsBoxMinMax","minimum","maximum","intersectionTreshold","newMinimum","_TmpVector3","copyFromFloats","x","y","z","newMaximum","inv","min","max","temp","d","maxValue","Math","abs","Infinity","intersectsBox","box","intersectsSphere","sphere","center","pyth","radius","rr","dot","intersectsTriangle","vertex0","vertex1","vertex2","edge1","edge2","pvec","tvec","qvec","subtractToRef","CrossToRef","det","Dot","invdet","bv","bw","distance","intersectsPlane","plane","result1","normal","result2","intersectsAxis","axis","offset","t","intersectsMesh","mesh","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","tm","Matrix","getWorldMatrix","invertToRef","_tmpRay","TransformToRef","Transform","intersects","intersectsMeshes","meshes","results","i","pickInfo","hit","push","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","intersectionSegment","sega","segb","threshold","o","u","Vector3","rsegb","v","w","scaleToRef","_Rayl","addToRef","a","b","c","e","D","sN","tN","sD","tD","_Smallnum","sc","tc","qtc","qsc","addInPlace","dP","lengthSquared","update","viewportWidth","viewportHeight","world","view","projection","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","IdentityReadOnly","CreateNew","CreateNewFromTo","end","subtract","sqrt","normalize","ray","matrix","result","TransformCoordinatesToRef","TransformNormalToRef","dir","len","num","sourceX","sourceY","multiplyToRef","invert","engine","LastCreatedEngine","nearScreenSource","useReverseDepthBuffer","isNDCHalfZRange","farScreenSource","nearVec3","farVec3","_UnprojectFromInvertedMatrixToRef","copyFrom","BuildArray","prototype","createPickingRay","camera","cameraViewSpace","createPickingRayToRef","getEngine","activeCamera","viewport","toGlobal","getRenderWidth","getRenderHeight","getHardwareScalingLevel","height","width","getViewMatrix","getProjectionMatrix","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","Error","identity","Identity","_internalPickForMesh","pickingInfo","rayFunction","_internalPick","predicate","computeWorldMatrixForCamera","activeCameras","cameraToUseForPointers","currentCamera","meshIndex","isEnabled","isVisible","isPickable","forceCompute","isWorldMatrixCameraDependent","computeWorldMatrix","hasThinInstances","thinInstanceEnablePicking","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","index","thinInstanceIndex","_internalMultiPick","pickingInfos","Array","pickWithBoundingInfo","_tempPickingRay","Object","defineProperty","get","enumerable","configurable","pick","_enableDistantPicking","pickWithRay","_pickWithRayInverseMatrix","_cachedRayForTransform","multiPick","multiPickWithRay","getForwardRay","transform","getForwardRayToRef","refRay","position","set","_scene","useRightHandedSystem","NormalizeToRef","CreateGeodesic","name","options","scene","m","floor","Warn","n","primTri","build","geoOptions","custom","BuildGeodesicData","size","sizeX","sizeY","sizeZ","faceUV","faceColors","flat","updatable","sideOrientation","frontUVs","backUVs","ShapePath","resolution","_paths","_tempPaths","_holes","_resolution","moveTo","_currentPath","lineTo","addLineTo","quadraticCurveTo","cpx","cpy","addQuadraticCurveTo","bezierCurveTo","cpx1","cpy1","cpx2","cpy2","addBezierCurveTo","extractHoles","path","area","paths","holes","CreateShapePath","char","scale","offsetX","offsetY","fontData","glyph","glyphs","shapePath","outline","split","l","parseInt","ha","CreateTextShapePaths","text","chars","from","line_height","boundingBox","yMax","yMin","underlineThickness","shapePaths","ret","CreateText","depth","earcutInjection","earcut","letterIndex","slice","holeVectors","shapeVectors","points","getPoints","point","localHolesCopy","hole","found","isPointInside","holePoints","splice","indexOf","shape","undefined","perLetterFaceUV","perLetterFaceColors","_GetDefaultSideOrientation","DOUBLESIDE","newMesh","MergeMeshes","bbox","getBoundingInfo","extendSizeWorld","_x","_y","_z","rotation","PI","bakeCurrentTransformIntoVertices","_GoldbergMeshParser","parsedMesh","GoldbergMesh","Parse","goldbergData","faceCenters","faceZaxis","faceXaxis","faceYaxis","nbSharedFaces","nbUnsharedFaces","nbFaces","nbFacesAtPole","adjacentFaces","relatedGoldbergFace","poleOrShared","fromPole","_changeGoldbergFaceColors","colorRange","col","f","newCols","r","g","setGoldbergFaceColors","setVerticesData","ColorKind","updateGoldbergFaceColors","updateVerticesData","_changeGoldbergFaceUVs","uvRange","uvs","getVerticesData","UVKind","angle","points5","points6","p","cos","sin","setGoldbergFaceUVs","newUVs","updateGoldbergFaceUVs","placeOnGoldbergFaceAt","face","orientation","RotationFromAxis","add","serialize","serializationObject","super","type","color","asArray","vector","map","el","FromArray","goldberg"],"sourceRoot":""}