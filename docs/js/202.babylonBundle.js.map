{"version":3,"file":"js/202.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/externals/havok.ts","webpack://babylonjs-typescript-webpack-template/./src/scenes/collisions.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleMoveablePiece.glb","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/Shadows/shadowGeneratorSceneComponent.ts"],"sourcesContent":["import HavokPlugin from \"@babylonjs/havok\";\r\n\r\nexport const havokModule = HavokPlugin();\r\n","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { CreateSphere } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\r\n// Needed for .glb import support via SceneLoader\r\nimport \"@babylonjs/loaders/glTF\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\nimport \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { havokModule } from \"../externals/havok\";\r\nimport { PhysicsShapeBox, PhysicsShapeConvexHull, PhysicsShapeSphere } from \"@babylonjs/core/Physics/v2/physicsShape\";\r\nimport { PhysicsBody } from \"@babylonjs/core/Physics/v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"@babylonjs/core/Physics/v2/IPhysicsEnginePlugin\";\r\nimport { HavokPlugin } from \"@babylonjs/core/Physics/v2/Plugins/havokPlugin\";\r\nimport { Color3, CreateBox, CreateIcoSphere, CreateTorus, SceneLoader, Sound, StandardMaterial } from \"@babylonjs/core\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\n\r\n// Meshes\r\nimport MoveablePiece from \"../../assets/glb/AlphaPuzzleMoveablePiece.glb\";\r\n\r\nclass Collisions implements CreateSceneClass {\r\n    preTasks = [havokModule];\r\n\r\n    // eslint-disable-next-line no-undef\r\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\r\n        // Boilerplate Code\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        // Enable Inspector and Scene Exlporer\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        // Inspector and Scene Explorer End\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        // MeshCreation Code\r\n        // Our built-in 'sphere' shape.\r\n        //const sphere = CreateSphere(\"sphere\", { diameter: 2, segments: 32 }, scene);\r\n\r\n        // Move the sphere upward at 4 units\r\n        //sphere.position.y = 4;\r\n        // Sphere body\r\n        //const sphereBody = new PhysicsBody(sphere, PhysicsMotionType.DYNAMIC, false, scene);\r\n        // Set shape material properties\r\n        //sphereShape.material = { friction: 0.2, restitution: 0.6 };\r\n        // Associate shape and body\r\n        //sphereBody.shape = sphereShape;\r\n        // And body mass\r\n        //sphereBody.setMassProperties({ mass: 1 });\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\"ground\", { width: 10, height: 10 }, scene);\r\n        \r\n        // PHYSICS!\r\n        const physicsPlugin = new HavokPlugin(true, await havokModule);\r\n        scene.enablePhysics(null, physicsPlugin);\r\n        // Create a sphere shape\r\n        // const sphereShape = new PhysicsShapeSphere(new Vector3(0, 0, 0)\r\n        //     , 1\r\n        //     , scene);\r\n    \r\n\r\n\r\n        // Preparing Sounds for collisions\r\n        const buzzer = new Sound(\"buzzer\", \"sounds/Buzzer.wav\", scene);\r\n        buzzer.play();\r\n\r\n        // Create a static box shape\r\n        const groundShape = new PhysicsShapeBox(new Vector3(0, 0, 0)\r\n            , Quaternion.Identity()\r\n            , new Vector3(10, 0.1, 10)\r\n            , scene);\r\n\r\n        // Create a body and attach it to the ground. Set it as Static.\r\n        const groundBody = new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n\r\n        // Set material properties\r\n        groundShape.material = { friction: 0.2, restitution: 0.8 };\r\n\r\n        // Associate the body and the shape\r\n        groundBody.shape = groundShape;\r\n\r\n        // Set the mass to 0\r\n        groundBody.setMassProperties({ mass: 0 });\r\n\r\n        // Settin up list for objects to check collisions with\r\n        const objectsToCollideWith: Mesh[] = [];\r\n\r\n        const icoSphere = CreateIcoSphere(\"icoSphere\")\r\n        icoSphere.position = new Vector3(0, 2, 0);\r\n        icoSphere.showBoundingBox = true;\r\n        objectsToCollideWith.push(icoSphere);\r\n\r\n        const torusMesh = CreateTorus(\"torusMesh\")\r\n        torusMesh.position = new Vector3(0, 2, 3);\r\n        torusMesh.showBoundingBox = true;\r\n        objectsToCollideWith.push(torusMesh);\r\n\r\n        const stick = CreateBox(\"stick\", { width: 0.25, height: 2, depth: 0.25 }, scene);\r\n        stick.position = new Vector3(0, 2, -3);\r\n        stick.showBoundingBox = true;\r\n        objectsToCollideWith.push(stick);\r\n\r\n        // Detecting Collisions of Meshes with PhysicsBodys\r\n        // Create Mesh\r\n        const stickPhysic = CreateBox(\"stickPhysic\", { width: 0.25, height: 2, depth: 0.25 }, scene);\r\n        stickPhysic.position = new Vector3(0, 2, -6);\r\n        stickPhysic.showBoundingBox = true;\r\n        const stickPhysicBody = new PhysicsBody(stickPhysic, PhysicsMotionType.DYNAMIC, false, scene);\r\n        // Set to Floating / disable Gravity for this object\r\n        stickPhysicBody.setMassProperties({ mass: 0 });\r\n        // Overwrite default shape to the shape of a single line of the mesh\r\n        stickPhysicBody.shape = new PhysicsShapeBox(stickPhysic.absolutePosition, stickPhysic.absoluteRotationQuaternion, new Vector3(0.25, 2, 0.25), scene);\r\n\r\n        const moveablePieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", MoveablePiece, scene, undefined);\r\n        // Casting Loadresult (ISceneLoaderAsyncResult) to Mesh for easier handling and enabling useage of updateFacetData()\r\n        // [0] is the rootnode of the mesh (Empty Parent), [1] is the actual mesh)\r\n        const moveablePiece = moveablePieceLoad.meshes[1] as Mesh;\r\n        moveablePiece.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        //moveablePiece.position = new Vector3(0, 2, -9);\r\n        // Physics boilerplate for moveablePiece, setting shape and linking\r\n        const moveablePiecePhysicsShape = new PhysicsShapeConvexHull(moveablePiece, scene); \r\n        const moveablePiecePhysics = new PhysicsBody(moveablePiece, PhysicsMotionType.DYNAMIC, false, scene)\r\n        \r\n        moveablePiecePhysics.shape = moveablePiecePhysicsShape;\r\n        // Physics Properties\r\n        moveablePiecePhysics.setMassProperties({ mass: 0 });\r\n        const toDraw = physicsPlugin.getBoundingBox(moveablePiecePhysicsShape);\r\n        //toDraw.showBoundingBox = true;\r\n        /**\r\n         * Function to check for collisions between objectsToCollideWith and stickPhysic\r\n         * where objectsToCollideWith is an array of Meshes, previously defined and filled with meshes which should be checked for collisions\r\n         */\r\n        function checkForCollision(){\r\n            const currentlyColliding: Mesh[] = []\r\n            for(let i = 0; i < objectsToCollideWith.length; i++){\r\n                \r\n                objectsToCollideWith.forEach((mesh) => {\r\n                    if (objectsToCollideWith[i] != mesh && objectsToCollideWith[i].intersectsMesh(mesh, true)){\r\n                            objectsToCollideWith[i].material = materialCollision\r\n                            mesh.material = materialCollision\r\n                            console.log(objectsToCollideWith[i].name, mesh.name)\r\n                            currentlyColliding.push(objectsToCollideWith[i], mesh)\r\n                        }\r\n\r\n                    else{\r\n                        // Currently not colliding with compared Mesh\r\n                        // If Object has already collided with something, but not with the currently compared mesh, do not change color again\r\n                        if (currentlyColliding.includes(objectsToCollideWith[i])){\r\n                            null;\r\n                        }\r\n                        // If Object has not collided with anything, change color back to green (not anymore colliding)\r\n                        else{\r\n                            objectsToCollideWith[i].material = materialNoCollision\r\n                        }\r\n                        // Check if objectsToCollideWith[i] is no longer colliding with anything\r\n\r\n                    }\r\n                })\r\n            }  \r\n        }\r\n        // Collision checking logic\r\n        // Prepare materials for colorchange based on collision\r\n        const materialCollision = new StandardMaterial(\"materialCollision\", scene);\r\n        materialCollision.diffuseColor = Color3.Red();\r\n\r\n        const materialNoCollision = new StandardMaterial(\"materialNoCollision\", scene);\r\n        materialNoCollision.diffuseColor = Color3.Green();\r\n        // if Object A collides with Object B, and A != B then play sound and change color\r\n        \r\n        scene.onBeforeRenderObservable.add(() => {\r\n            checkForCollision();\r\n        });\r\n\r\n\r\n        // WebXR Code\r\n        const options = {\r\n            floorMeshes: [ground],\r\n        }\r\n        const xrHelper = await scene.createDefaultXRExperienceAsync(options);\r\n        \r\n\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new Collisions();\r\n","export default __webpack_public_path__ + \"87c16888db5ebec0fb7b6c3bb705d897.glb\";","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"names":["havokModule","preTasks","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Math","PI","setTarget","Zero","attachControl","intensity","ground","width","height","physicsPlugin","enablePhysics","Sound","play","groundShape","Identity","groundBody","STATIC","material","friction","restitution","shape","setMassProperties","mass","objectsToCollideWith","icoSphere","CreateIcoSphere","position","showBoundingBox","push","torusMesh","CreateTorus","stick","CreateBox","depth","stickPhysic","stickPhysicBody","DYNAMIC","absolutePosition","absoluteRotationQuaternion","moveablePiece","SceneLoader","ImportMeshAsync","meshes","scaling","moveablePiecePhysicsShape","moveablePiecePhysics","getBoundingBox","materialCollision","StandardMaterial","diffuseColor","Color3","Red","materialNoCollision","Green","onBeforeRenderObservable","add","currentlyColliding","i","length","forEach","mesh","intersectsMesh","name","includes","checkForCollision","options","floorMeshes","createDefaultXRExperienceAsync","AddParser","NAME_SHADOWGENERATOR","parsedData","shadowGenerators","index","cache","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","this","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","light","getShadowGenerators","iterator","values","key","next","done","shadowGenerator","value","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":""}