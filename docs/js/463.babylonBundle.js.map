{"version":3,"file":"js/463.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./assets/meshes/Nagel1.stl","webpack://babylonjs-typescript-webpack-template/./src/scenes/nagelPuzzle.ts","webpack://babylonjs-typescript-webpack-template/./src/sdfParser.ts","webpack://babylonjs-typescript-webpack-template/./assets/grass.jpg","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/Shadows/shadowGeneratorSceneComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/sphereBuilder.ts"],"sourcesContent":["export default __webpack_public_path__ + \"628b10094e62129397fc4859ae7349d6.stl\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { Axis, BoundingInfo, Color3, HighlightLayer, Mesh, MeshBuilder, Nullable, SceneLoader, TransformNode, WebXRControllerComponent } from \"@babylonjs/core\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\n// import \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport grassTextureUrl from \"../../assets/grass.jpg\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\r\nimport \"@babylonjs/loaders/STL/stlFileLoader\";\r\nimport \"@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent\";\r\n\r\n// Custom Importe / \r\nimport { STLFileLoader } from \"@babylonjs/loaders/STL/stlFileLoader\";\r\n// Laden und Parsen von SDF Dateien\r\nimport { loadSDFFile, parseSDFFileContent } from '../sdfParser';\r\nimport { loadOffFile, parseOffFileContent } from '../offParser';\r\nimport NagelPuzzleStatic from \"../../assets/meshes/Nagel1.stl\";\r\nimport { AdvancedDynamicTexture, Button } from \"@babylonjs/gui\";\r\n\r\n\r\n\r\n\r\n\r\nexport class DefaultSceneWithTexture implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n        /*********************************************************\r\n         * Anzeigen von Debug-Layern\r\n         *********************************************************/\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Berechnet den Mittelpunkt eines Meshes, um diesen zum Pivotverschiebung zu nutzen\r\n     * @param mesh \r\n     * @returns centerpoint in local coordinates\r\n     */\r\n    function calculateCenter(mesh: Mesh): Vector3 {\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n        const boundingBox = boundingInfo.boundingBox;\r\n        const center = boundingBox.center;\r\n        //debug\r\n        const centerMesh = MeshBuilder.CreateBox(\"centerMesh\", {size: 0.1})\r\n        centerMesh.position = center;\r\n        return center;\r\n    }\r\n\r\n    /*********************************************************\r\n     * Einlesen von SDF & OFF Datein, sowie loaden von Meshes und deren Properties \r\n     *********************************************************/\r\n    STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = true;\r\n    /*******************************************************************\r\n     * Neue Implementations-Idee:\r\n     * Anstatt einfach zu Skalieren nutzen wir 2 paar Meshes\r\n     * 1. Paar: Nicht Skalierte Meshes (moveable & Static) mit welche wir Berechnungen\r\n     *          und Kollisionsabfragen und erkennung durchführen\r\n     * 2. Paar: Skalierte Meshes (moveable & Static) welche wir zur Darstellung nutzen\r\n     * \r\n     * Dabei wird das 1. Paar als Hidden Meshes gesetzt und das 2. Paar als Visible\r\n     * 2te Paar wird geparented an das 1te Paar um die Positionen und Rotationen zu übernehmen\r\n     * evnt muss dies \"manuell\" gemacht werden, da die Skalierung auch auf die bewegte Strecke\r\n     * angewendet werden muss.\r\n     *******************************************************************/\r\n    // Import Nagel Puzzle Mesh via STL\r\n    \r\n    // Visible wird zur Darstellung genutzt und runter skaliert\r\n    // Hidden wird für die Kollisionsabfrage genutzt und bleibt in Originalgröße\r\n    \r\n    // Visible:\r\n    const nagelPuzzleStaticLoadVisible = await SceneLoader.ImportMeshAsync(\r\n        \"\",\r\n        \"\",\r\n        NagelPuzzleStatic,\r\n        scene, \r\n        undefined,\r\n        \".stl\"\r\n    );\r\n\r\n    const nagelPuzzleStaticVisible = nagelPuzzleStaticLoadVisible.meshes[0] as Mesh;\r\n\r\n    // Hidden: \r\n    const nagelPuzzleStaticLoadVisibleHidden = await SceneLoader.ImportMeshAsync(\r\n        \"\",\r\n        \"\",\r\n        NagelPuzzleStatic,\r\n        scene, \r\n        undefined,\r\n        \".stl\"\r\n    );\r\n    const nagelPuzzleStaticHidden = nagelPuzzleStaticLoadVisibleHidden.meshes[0] as Mesh;\r\n\r\n    // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n    // nagelPuzzleStatic.scaling = new Vector3(1, 1, -1);\r\n\r\n    // Visible wird zur Darstellung genutzt und runter skaliert\r\n    // Hidden wird für die Kollisionsabfrage genutzt und bleibt in Originalgröße\r\n    // Visible:\r\n    const nagelPuzzleMoveableLoadVisible = await SceneLoader.ImportMeshAsync(\r\n        \"\",\r\n        \"\",\r\n        NagelPuzzleStatic,\r\n        scene,\r\n        undefined,\r\n        \".stl\"\r\n        \r\n    );\r\n    \r\n    const nagelPuzzleMoveableVisible = nagelPuzzleMoveableLoadVisible.meshes[0] as Mesh;\r\n    nagelPuzzleMoveableVisible.name = \"MoveableVisible\";\r\n    nagelPuzzleMoveableVisible.visibility = 1;\r\n    // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n    //nagelPuzzleMoveableVisible.scaling = new Vector3(1, 1, 1);\r\n\r\n    // Hidden:\r\n    const nagelPuzzleMoveableLoadHidden = await SceneLoader.ImportMeshAsync(\r\n        \"\",\r\n        \"\",\r\n        NagelPuzzleStatic,\r\n        scene,\r\n        undefined,\r\n        \".stl\"\r\n        \r\n    );\r\n    const nagelPuzzleMoveableHidden = nagelPuzzleMoveableLoadHidden.meshes[0] as Mesh;\r\n    nagelPuzzleMoveableHidden.name = \"MoveableHidden\";\r\n    nagelPuzzleMoveableHidden.visibility = 1; // Temp visible for Debugging\r\n    \r\n\r\n\r\n    // Erstelle leere Mesh um die Punkte zu speichern\r\n    // dabei sind die Punkte, die Punkte der Oberfläche des moveable Meshes\r\n    // Hierachie von Kind zu Parent Notiert: nagelPuzzleMoveableHidden <- nagelPunkte <-- Punkt0, Punkt1, Punkt2,\r\n    const nagelPunkte = new Mesh(\"NagelPunkte\", scene);\r\n    nagelPunkte.parent = nagelPuzzleMoveableHidden;\r\n    // const punkteInfo: Promise<string> = loadOffFile(\"https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.noff\");\r\n    // const offInfo = parseOffFileContent(await punkteInfo);\r\n    // const punkte = offInfo.vertices\r\n    // const normals = offInfo.normals\r\n\r\n\r\n\r\n    //nagelPuzzleMoveableVisible.position = new Vector3(-0.5, 1, 0); // Wird von Renderloop überschrieben\r\n    nagelPuzzleStaticVisible.position = new Vector3(0, 0, 0);\r\n\r\n    // Drehe Moveable Mesh um 180°\r\n    nagelPuzzleMoveableVisible.rotationQuaternion = Quaternion.FromEulerVector( new Vector3(Math.PI / 2, Math.PI, 0));\r\n\r\n\r\n    // Scaling der Meshe für WebXr\r\n    // Dabei hier sind dies die Darstellungsstücke und nicht die Kollisionsstücke,\r\n    // welche zur Berechnung genutzt werden\r\n    nagelPuzzleMoveableVisible.scaling = new Vector3(0.01, 0.01, 0.01);\r\n    nagelPuzzleStaticVisible.scaling = new Vector3(0.01, 0.01, 0.01);\r\n\r\n    function placeMeshInCenter(mesh: Mesh): TransformNode {\r\n        // Schritt 1: Neue TransformNode erstellen\r\n        const centerNode = new TransformNode('CenterNode', mesh.getScene());\r\n      \r\n        // Schritt 2: Den Mittelpunkt des Meshes berechnen\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n        const meshCenter = boundingInfo.boundingBox.center.clone();\r\n      \r\n        // Schritt 3: Das Mesh zum Ursprung verschieben\r\n        const meshToOrigin = meshCenter.scaleInPlace(-1);\r\n        mesh.position.addInPlace(meshToOrigin);\r\n      \r\n        // Schritt 4: Das Mesh als Kind zur TransformNode hinzufügen\r\n        //mesh.parent = centerNode;\r\n      \r\n        // Schritt 5: Die TransformNode zum ursprünglichen Mittelpunkt des Meshes zurückverschieben\r\n        centerNode.position = meshCenter;\r\n      \r\n        // Schritt 6: Optional - Den falschen Center des Meshes zurücksetzen\r\n        mesh.setPivotMatrix(Matrix.Identity());\r\n      \r\n        // Die TransformNode zurückgeben, falls du sie später noch verwenden möchtest\r\n        return centerNode;\r\n      }\r\n\r\n    const npmvTransformNode = placeMeshInCenter(nagelPuzzleMoveableHidden);\r\n    const temp = nagelPuzzleMoveableHidden.getBoundingInfo().boundingBox;\r\n    // const temp2 = temp.maximum.subtract(temp.minimum);\r\n    //npmvTransformNode.position = new Vector3(temp2.x, temp2.y, temp2.z)\r\n    nagelPuzzleMoveableHidden.parent = npmvTransformNode;\r\n\r\n    npmvTransformNode.rotationQuaternion = Quaternion.FromEulerVector( new Vector3(Math.PI / 2, Math.PI, 0));\r\n\r\n    // ******************** Fix positioning **********************//\r\n    npmvTransformNode.position = new Vector3(59.047, 0.126, -10.105);\r\n\r\n    // Die URL der SDF-Datei\r\n    const sdfFileUrl = 'https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.sdf';\r\n    // Definiert in einer ausgelagerten Datei\r\n    // Laded die SDF-Datei aus dem Internet und Parset diese in ein SDFData-Objekt\r\n    const loadFile = loadSDFFile(sdfFileUrl);\r\n    const sdfContent = parseSDFFileContent(await loadFile);\r\n\r\n    // //Print SDF-Data\r\n    // console.log(\"SDF-Data: \", sdfContent);\r\n    \r\n    // Erstelle empty mesh um eine Custom boundingbox zu erstellen\r\n    const boundingBox = new Mesh(\"boundingBox\", scene);\r\n    boundingBox.setBoundingInfo(new BoundingInfo(sdfContent.bbox.min, sdfContent.bbox.max));\r\n    boundingBox.showBoundingBox = true;\r\n    \r\n    // This creates and positions a free camera (non-mesh)\r\n    const camera = new ArcRotateCamera(\r\n        \"my first camera\",\r\n        0,\r\n        Math.PI / 3,\r\n        10,\r\n        new Vector3(0, 0, 0),\r\n        scene\r\n    );\r\n\r\n    // Setzen der Kamera initally auf den Ursprung des NagelPuzzles (Visible),\r\n    // Manuell, damit die Kamera noch \"Panning\" kann\r\n    // camera.setTarget(new Vector3(21.27, 9.95, 0));\r\n    camera.alpha = 4.735\r\n    camera.beta = 1.284\r\n    camera.inertia = 0.01\r\n\r\n    // This attaches the camera to the canvas\r\n    camera.attachControl(canvas, true);\r\n\r\n    // Our built-in 'ground' shape.\r\n    const ground = CreateGround(\r\n        \"ground\",\r\n        { width: 6, height: 6 },\r\n        scene\r\n    );\r\n    //ground.position = new Vector3(21.33, 9.27, 0);\r\n    ground.position.y = -0.5\r\n    // Load a texture to be used as the ground material\r\n    const groundMaterial = new StandardMaterial(\"ground material\", scene);\r\n    groundMaterial.diffuseTexture = new Texture(grassTextureUrl, scene);\r\n\r\n    ground.material = groundMaterial;\r\n    ground.receiveShadows = true;\r\n\r\n    const light = new DirectionalLight(\r\n        \"light\",\r\n        new Vector3(0, -1, 1),\r\n        scene\r\n    );\r\n    light.intensity = 0.5;\r\n    light.position.y = 10;\r\n\r\n    const shadowGenerator = new ShadowGenerator(512, light)\r\n    shadowGenerator.useBlurExponentialShadowMap = true;\r\n    shadowGenerator.blurScale = 2;\r\n    shadowGenerator.setDarkness(0.2);\r\n\r\n    //shadowGenerator.getShadowMap()!.renderList!.push(sphere);\r\n    //Erstelle Material für Kollision mit Farbe Rot und Kollisionsfrei mit Farbe Grün\r\n    const collisionMaterial = new StandardMaterial(\"collisionMaterial\", scene);\r\n    collisionMaterial.diffuseColor = new Color3(1, 0, 0);\r\n\r\n    const noCollisionMaterial = new StandardMaterial(\"noCollisionMaterial\", scene);\r\n    noCollisionMaterial.diffuseColor = new Color3(0, 1, 0);\r\n    \r\n    const moveableNagelPunkte = nagelPunkte.getChildMeshes()\r\n\r\n    /************************************************************\r\n     * GUI-Interface zum setzen der Kollisionsvariable zum Debug\r\n     *************************************************************/\r\n    // Button Textur & Properties\r\n    const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    const button = Button.CreateSimpleButton(\"toggleCollisionCorrection\", \"Toggle Collision Correction\");\r\n    button.width = \"150px\";\r\n    button.height = \"40px\";\r\n    button.background = \"red\"; // Startzustand\r\n    button.color = \"white\";\r\n    button.left = \"35%\"; \r\n    button.top = \"-45%\"; \r\n\r\n    // Var für Kollisionsabfrage\r\n    let collisionCorrectionEnabled = false;\r\n    \r\n    // Funktion für den Button\r\n    function toggleCollisionCorrection() {\r\n        collisionCorrectionEnabled = !collisionCorrectionEnabled;\r\n        // Update Button-Background\r\n        if (collisionCorrectionEnabled) {\r\n            button.background = \"green\";\r\n        } else {\r\n            button.background = \"red\";\r\n        }\r\n    }\r\n    // Button Event-Handler\r\n    button.onPointerClickObservable.add(() => {\r\n        toggleCollisionCorrection();\r\n    })\r\n    // Hinzufügen vom Button zur GUI-Texture\r\n    advancedTexture.addControl(button);\r\n\r\n\r\n    /*********************************************************\r\n     * VR Implementation (Variablen sowie Event-Handler für den Controller) \r\n     *********************************************************/\r\n    // VR-Integration, \"WebXR\"\r\n    const xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });\r\n\r\n    // XR-Sitzung abrufen\r\n    const xrSession = xr.baseExperience.sessionManager.session;\r\n    const xrCamera = xr.baseExperience.camera;\r\n    xrCamera.position = new Vector3(0, 0, 0);\r\n    \r\n    const targetMesh = nagelPuzzleMoveableHidden;\r\n\r\n    // Vorherigen Status des Controllers speichern\r\n    let previousPosition: Nullable<Vector3> = null;\r\n    let previousRotation: Nullable<Quaternion> = null;\r\n\r\n    // Controller-Status für \"Dragging\" speichern\r\n    let isDragging = false;\r\n\r\n    // Event-Handler für den rechten Controller hinzufügen\r\n    xr.input.onControllerAddedObservable.add((controller) => {\r\n    // Überprüfen, ob der Controller der rechte Controller ist\r\n    if (controller.inputSource.handedness === 'right') {\r\n        // Event-Handler für den Trigger hinzufügen\r\n        controller.onMotionControllerInitObservable.add(() => {\r\n        // Event-Handler für den Trigger\r\n        const triggerComponent = controller.motionController?.getComponent('xr-standard-trigger');\r\n        // Wird ausgelöst, wenn wir in WebXR bzw VR sind, daher die großen Modelle zum Berechnen ausblenden\r\n        // und kleine Modelle zum Anzeigen einblenden\r\n        nagelPuzzleMoveableHidden.isVisible = false;\r\n        nagelPuzzleStaticHidden.isVisible = false;\r\n\r\n        if (triggerComponent) {\r\n            triggerComponent.onButtonStateChangedObservable.add((buttonValue) => {\r\n            if (buttonValue.value > 0.5) {\r\n                // Trigger ist gedrückt\r\n                isDragging = true;\r\n            } else {\r\n                // Trigger ist nicht gedrückt\r\n                isDragging = false;\r\n                previousPosition = null;\r\n                previousRotation = null;\r\n            }\r\n            });\r\n        }\r\n        });\r\n    }\r\n    });       \r\n\r\n    // erstelle Worker\r\n    let workerHasJob = false;\r\n    const worker = new Worker(new URL('../nagelWorker.ts', import.meta.url))\r\n    const fps = engine.getFps();\r\n    console.log(\"FPS: \", fps)\r\n    let workerTimer = 0; // Assuming 60 FPS\r\n    function checkIfWorkerMessageLost(workerHasJob: boolean){\r\n       if (workerHasJob){\r\n           workerTimer++;\r\n           // if 2 seconds passed, reset workerHasJob aka send new message\r\n           if (workerTimer > 144 * 5){\r\n                console.log(\"Worker Message lost, sending new Message\")\r\n                workerHasJob = false;\r\n                workerTimer = 0;\r\n           }\r\n       }\r\n       if (!workerHasJob){\r\n           workerTimer = 0;\r\n       }\r\n       return workerHasJob;\r\n       \r\n    }\r\n    /*******************************************************************\r\n     * Each Frame Check: (2)Beinhaltet Kollisionserkennung und behebung\r\n     *                   (1)sowie das Bewegen des Moveable Meshes durch VR\r\n     *******************************************************************/\r\n    // (1)\r\n    // Checke Punkte per Frame\r\n    let frameCounter = 0;\r\n    scene.onBeforeRenderObservable.add(() => { \r\n        frameCounter++;\r\n        const fps = engine.getFps();\r\n        // Controller Movement\r\n        // Überprüfen, ob der Trigger gedrückt ist und \"Dragging\" aktiv ist\r\n        if (isDragging) {\r\n            // Controller infos abrufen und unter controller speichern\r\n            const controller = xr.input.controllers.find((c) => c.inputSource.handedness === 'right');\r\n\r\n            // Überprüfen, ob der Controller gefunden wurde und die Komponenten vorhanden sind\r\n            if (controller && controller.grip && controller.grip.position && controller.grip.rotationQuaternion) {\r\n                // Aktuelle Position und Rotation des Controllers abrufen\r\n                const currentPosition = controller.grip.absolutePosition;\r\n                const currentRotation = controller.grip.rotationQuaternion;\r\n\r\n                // Prüfen, ob die Position und Rotation definiert sind und der vorherige Status vorhanden ist\r\n                if (currentPosition && currentRotation && previousPosition && previousRotation) {\r\n                    // Skalierung und Rotation des Ziel-Meshes berücksichtigen\r\n                    // const scaledPositionDelta = currentPosition.subtract(previousPosition).divide(targetMesh.scaling);\r\n\r\n                    // Erstelle TransformNode und appliere Orientierung der VR Camera\r\n                    const xrTransformNode = new TransformNode(\"xrTransformNode\", scene);\r\n                    xrTransformNode.position = nagelPuzzleMoveableHidden.getBoundingInfo().boundingBox.centerWorld;\r\n                    xrTransformNode.rotationQuaternion = new Quaternion(0, 0, 0, 0); // Standart, prevent null\r\n                    xrTransformNode.rotationQuaternion = controller.grip.rotationQuaternion;\r\n                    // Setze XrTransformNode als Parent des Moveable Meshes(TransformNode)\r\n\r\n                    // Rotation des Controllers in das Koordinatensystem des Weltursprungs umwandeln\r\n                    const worldOriginRotation = Quaternion.Identity();\r\n                    const controllerRotation = worldOriginRotation.multiply(currentRotation).multiply(previousRotation.conjugate());\r\n\r\n                    // Berechne die Änderung der Position und Rotation des Controllers im Vergleich zum vorherigen Frame\r\n                    const positionDelta = currentPosition.subtract(previousPosition);\r\n                    //const rotationDelta = currentRotation.multiply(previousRotation.conjugate());\r\n                    let rotationDelta = previousRotation.conjugate().multiply(currentRotation);\r\n                    rotationDelta = rotationDelta.invert();\r\n                    // Apply Parent, Move(Scaled), Rotate(Scaled), Remove Parent-Link, dispose TransformNode\r\n                    // TransformNode wird für jede Beweung neu erstellt, da sonst perspektive der Rotation nicht stimmt(XR Camera-Ansicht)\r\n                    npmvTransformNode.setParent(xrTransformNode)\r\n                    //console.log(xrCamera.absoluteRotation)\r\n\r\n                    npmvTransformNode.position = npmvTransformNode.position.addInPlace(positionDelta.scaleInPlace(50));\r\n                    xrTransformNode.rotationQuaternion = xrTransformNode.rotationQuaternion.multiply(rotationDelta.conjugate())\r\n                    //npmvTransformNode.setParent(null)\r\n                    // Setze Visible Mesh's Position und Rotation auf Hidden Mesh's Position und Rotation skaliert mit dem Scaling des Visible Meshes\r\n                    nagelPuzzleMoveableVisible.position = (nagelPuzzleMoveableHidden.absolutePosition).multiply(nagelPuzzleMoveableVisible.scaling);\r\n                    //nagelPuzzleMoveableVisible.rotationQuaternion = npmvTransformNode.rotationQuaternion;\r\n                    npmvTransformNode.setParent(null)\r\n                    xrTransformNode.dispose()\r\n                }\r\n\r\n        // Vorherigen Status aktualisieren\r\n        previousPosition = currentPosition.clone();\r\n        previousRotation = currentRotation.clone();\r\n        }\r\n    }\r\n    // Controller Movement Ende\r\n\r\n        /**********************************************************************\r\n         * Kollisionsabfrage und Behebung (2)\r\n        **********************************************************************/\r\n        // Kollisionsabfrage und Behebung via Worker\r\n        // Checke ob worker bereits am updaten ist\r\n        workerHasJob = checkIfWorkerMessageLost(workerHasJob);\r\n        if (!workerHasJob && fps / 50 < frameCounter) {\r\n            frameCounter = 0;\r\n            const worldMatrixStatic = nagelPuzzleStaticHidden.getWorldMatrix();\r\n            const worldMatrixMoveble = nagelPuzzleMoveableHidden.getWorldMatrix();\r\n            // Send Message, if Worker is not busy\r\n            //console.log(\"Sending Message to Worker\", workerHasJob)\r\n            worker.postMessage([worldMatrixMoveble.asArray(), worldMatrixStatic.asArray()]);\r\n            // update workerHasJob\r\n            workerHasJob = true;\r\n        }\r\n     \r\n\r\n    // Setze Visible Mesh's Position und Rotation auf Hidden Mesh's Position und Rotation skaliert mit dem Scaling des Visible Meshes\r\n    nagelPuzzleMoveableVisible.position = (nagelPuzzleMoveableHidden.absolutePosition).multiply(nagelPuzzleMoveableVisible.scaling);\r\n    nagelPuzzleMoveableVisible.rotationQuaternion = npmvTransformNode.rotationQuaternion;\r\n\r\n    //Safty Check: Setze Scaling auf 1,1,1 falls es sich verändert hat\r\n    // bzw 0,01 für die kleinen Modelle\r\n    nagelPuzzleMoveableVisible.scaling = new Vector3(0.01, 0.01, 0.01);\r\n    nagelPuzzleStaticVisible.scaling = new Vector3(0.01, 0.01, 0.01);\r\n    nagelPuzzleMoveableHidden.scaling = new Vector3(1, 1, 1);\r\n    nagelPuzzleStaticHidden.scaling = new Vector3(1, 1, 1);\r\n    npmvTransformNode.scaling = new Vector3(1, 1, 1);\r\n\r\n    }) // Ende onBeforeRenderObservable\r\n        ;\r\n\r\n    // Worker Event-Handler\r\n    worker.onmessage = (event) => {\r\n        const errorFlag = event.data[2];\r\n        //console.log(\"Worker Message received\", errorFlag)\r\n        if (errorFlag === 1 || errorFlag === -1) {\r\n            workerHasJob = false;\r\n        }\r\n\r\n        // Apply Result to Mesh\r\n        if (collisionCorrectionEnabled && errorFlag === 1) {\r\n            const positionDelta = Vector3.FromArray(event.data[0]);\r\n            const orientationDelta = Quaternion.FromArray(event.data[1]);\r\n            const currentPosition = npmvTransformNode.position;\r\n            // Kollision\r\n            //console.log(\"Enter Collision\");\r\n            nagelPuzzleMoveableHidden.material = collisionMaterial;\r\n            // Rotate anc Move via transformNode\r\n            const newPosition = currentPosition.add(positionDelta);\r\n\r\n            npmvTransformNode.position = newPosition\r\n            npmvTransformNode.rotationQuaternion = npmvTransformNode.rotationQuaternion!.add(orientationDelta);\r\n        }\r\n        };\r\n    \r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new DefaultSceneWithTexture();\r\n\r\n","import { Vector3 } from \"@babylonjs/core\";\r\n\r\nexport async function loadSDFFile(url: string): Promise<string> {\r\n    try {\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return text;\r\n    } catch (error) {\r\n    console.error('Fehler beim Laden der SDF-Datei:', error);\r\n    throw error;\r\n    }\r\n}\r\n\r\nexport interface SDFData {\r\n    bbox: {\r\n      min: Vector3,\r\n      max: Vector3\r\n    },\r\n    cellSize: number,\r\n    res: Vector3,\r\n    numCells: number,\r\n    distances: number[]\r\n  }\r\n  \r\n  export  function parseSDFFileContent(sdfContent: string): SDFData {\r\n    const lines = sdfContent.trim().split('\\n');\r\n    const data: SDFData = {\r\n      bbox: {\r\n        min: Vector3.Zero(),\r\n        max: Vector3.Zero()\r\n      },\r\n      cellSize: 0,\r\n      res: Vector3.Zero(),\r\n      numCells: 0,\r\n      distances: []\r\n    };\r\n  \r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      \r\n      // Kommentare ignorieren\r\n      const commentIndex = line.indexOf('#');\r\n      if (commentIndex !== -1) {\r\n        // Nur den Teil der Zeile vor dem Kommentar extrahieren\r\n        const cleanedLine = line.substring(0, commentIndex).trim();\r\n        \r\n        if (cleanedLine.length === 0) {\r\n          continue;\r\n        }\r\n  \r\n        const values = cleanedLine.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      } else {\r\n        const values = line.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    return data;\r\n  }","export default __webpack_public_path__ + \"9b31293ea96c8dfa518b45622da82a13.jpg\";","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n"],"names":["DefaultSceneWithTexture","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","DO_NOT_ALTER_FILE_COORDINATES","nagelPuzzleStaticVisible","SceneLoader","ImportMeshAsync","meshes","nagelPuzzleStaticHidden","nagelPuzzleMoveableVisible","name","visibility","nagelPuzzleMoveableHidden","nagelPunkte","Mesh","parent","position","rotationQuaternion","FromEulerVector","Math","PI","scaling","npmvTransformNode","mesh","centerNode","TransformNode","getScene","meshCenter","getBoundingInfo","boundingBox","center","clone","meshToOrigin","scaleInPlace","addInPlace","setPivotMatrix","Identity","placeMeshInCenter","loadFile","url","response","fetch","text","error","loadSDFFile","sdfContent","lines","trim","split","data","bbox","min","Vector3","Zero","max","cellSize","res","numCells","distances","i","length","line","commentIndex","indexOf","cleanedLine","substring","values","map","parseFloat","FromArray","push","parseSDFFileContent","setBoundingInfo","BoundingInfo","showBoundingBox","camera","alpha","beta","inertia","attachControl","ground","width","height","y","groundMaterial","diffuseTexture","grass","material","receiveShadows","light","intensity","shadowGenerator","useBlurExponentialShadowMap","blurScale","setDarkness","collisionMaterial","diffuseColor","Color3","getChildMeshes","advancedTexture","AdvancedDynamicTexture","CreateFullscreenUI","button","Button","CreateSimpleButton","background","color","left","top","collisionCorrectionEnabled","onPointerClickObservable","add","addControl","xr","createDefaultXRExperienceAsync","floorMeshes","baseExperience","sessionManager","session","previousPosition","previousRotation","isDragging","input","onControllerAddedObservable","controller","inputSource","handedness","onMotionControllerInitObservable","triggerComponent","motionController","getComponent","isVisible","onButtonStateChangedObservable","buttonValue","value","workerHasJob","worker","Worker","URL","fps","getFps","workerTimer","frameCounter","onBeforeRenderObservable","controllers","find","c","grip","currentPosition","absolutePosition","currentRotation","xrTransformNode","centerWorld","multiply","conjugate","positionDelta","subtract","rotationDelta","invert","setParent","dispose","checkIfWorkerMessageLost","worldMatrixStatic","getWorldMatrix","worldMatrixMoveble","postMessage","asArray","onmessage","event","errorFlag","orientationDelta","newPosition","AddParser","NAME_SHADOWGENERATOR","parsedData","shadowGenerators","index","cache","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","this","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","getShadowGenerators","iterator","key","next","done","addFromContainer","container","removeFromContainer","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","_SceneComponentInitialization","component","_getComponent","_addComponent","CreateSphereVertexData","options","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","normal","divide","normalize","x","z","UseOpenGLOrientationForUV","verticesCount","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","CreateSphere","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","SphereBuilder"],"sourceRoot":""}