{"version":3,"file":"js/488.babylonBundle.js","mappings":"gXAuBA,MAAMA,EAA0E,GAEzE,MAAMC,EAAb,cACI,KAAAC,YAAcC,MACVC,EACAC,KAGA,MAAMC,QAAe,MAEfC,EAAQ,IAAI,IAAMH,GAClBI,EAAmB,IAAI,IAAeF,GAC5CE,EAAiBC,aAAa,sBAG9B,MAAMC,EAAS,IAAI,IAAW,UAAW,IAAI,KAAS,EAAG,GAAI,GAAIH,GAEjEG,EAAOC,UAAU,IAAQC,QAEzBF,EAAOG,cAAcR,GAAQ,GAGf,IAAI,IAAiB,SAAU,IAAI,IAAQ,EAAG,EAAG,GAAIE,GAE7DO,UAAY,GAElB,MAAMC,EAmHd,SAA0BR,GACtB,MAAMS,EAAS,IAAYC,aAAa,UAAW,CAC/CC,MAAO,EACPC,OAAQ,EACRC,aAAc,GACfb,GAGGc,EAAO,IAAI,IAAiB,OAAQd,GAC1Cc,EAAKC,aAAe,IAAI,KAAO,EAAG,EAAG,GAErC,MAAMC,EAAS,IAAYC,aAAa,UAAW,CAAEC,SAAU,EAAGC,SAAU,IAAMnB,GAClFgB,EAAOI,SAAWN,EAClBE,EAAOK,SAASC,EAAI,EAEpB,MAAMC,EAAO,IAAYC,UAAU,OAAQ,CAAEC,KAAM,EAAGb,OAAQ,GAAKZ,GACnEuB,EAAKF,SAAW,IAAI,IAAQ,EAAG,IAAK,GAGpC,MAAMK,EAAO,KAAKC,YAAY,CAACX,EAAQO,EAAMd,IAC7C,IAAKiB,EACD,MAAM,IAAIE,MAAM,0BAEpB,OAAOF,CACX,CA3I2BG,CAAiB7B,GA+GpC,OA9FAC,EAAiB6B,cAAc,CAACtB,GAhBN,CACtBuB,GAAI,GACJC,GAAI,GACJC,mBAAoB,GACpBC,eAAgB,EAChBC,cAAe,EACfC,eAAgB,EAChBC,WAAY,GACZC,uBAAwB,IACxBC,cAAe,EACfC,gBAAiB,GACjBC,gBAAiB,EACjBC,iBAAkB,EAClBC,qBAAsB,IAGuCC,IAC7DC,QAAQC,IAAI,kBAAmBF,GAC/B3C,EAAiB8C,qBAAqBH,GACtC,MAAMI,EAAe/C,EAAiBgD,mBAAmBjD,GACzDgD,EAAa3B,SAAW,IAAI,IAAQ,EAAG,IAAM,GAE7C,MAAM6B,EAAW,IAAI,IAAiB,WAAYlD,GAClDkD,EAASnC,aAAe,IAAI,KAAO,GAAK,GAAK,GAC7CmC,EAASC,MAAQ,GACjBH,EAAa5B,SAAW8B,EAGxB,MAAME,EAAQnD,EAAiBoD,YAAY,GAAI,GAAKrD,GACpD,IAAIsD,EACJ,MAAMC,EAAc,CAChBC,OAAQ,GACR5C,OAAQ,GACR6C,gBAAiB,EACjBC,SAAU,EACVC,oBAAqB,GACrBC,sBAAuB,EACvBC,iBAAkB,GAGtB,IAAKP,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACpB,MAAM3C,EAAQ,GACRmD,EAAY,IAAYtC,UAAU,OAAQ,CAAEC,KAAMd,EAAOC,OAAQD,GAASX,GAC1E+D,EAAa,IAAYvC,UAAU,OAAQ,CAAEC,KAAM,GAAKb,OAAQ,IAAOZ,GACvEgE,EAAW,IAAI,IAAiB,OAAQhE,GACxCiE,EAAYC,KAAKC,SACvBH,EAASjD,aAAe,IAAI,KAAO,GAAkB,GAAZkD,EAAiB,GAAK,EAAkB,GAAZA,GACrEH,EAAU1C,SAAW4C,EACrB,MAAMI,EAAYnE,EAAiBoE,qBAAqB,IAAI,KAAS,EAAK,IAAM,KAAM,IAChFC,EAAY,IAAI,IAAc,aAE9BC,EAAanB,EAAMoB,SAASJ,EAAWb,EAAae,GAC1D7E,EAAOgF,KAAK,CAAEC,IAAKH,EAAYI,IAAKL,EAAW5C,KAAMoC,EAAWc,OAAQb,G,CAG5E,IAAIc,EACAC,EACAC,EA2BJ/E,EAAMgF,oBAAoBC,KAAKC,IACnBA,EAAYC,OACX,KAAkBC,aACfF,GAAaG,UAAUC,aACvBzC,QAAQC,IAAI,eAAgBoC,EAAYG,SAASC,WAAWC,MArBxD,SAAU7D,GAG1B,GAFAoD,EAAcpD,EACdmD,EAXsB,WACtB,MAAMW,EAAWxF,EAAMyF,KAAKzF,EAAM0F,SAAU1F,EAAM2F,UAClD,OAAIH,GAAUI,IACHJ,EAASK,YAGb,IACX,CAIoBC,GACZjB,EAAe,CACfkB,YAAW,WACP5F,EAAO6F,eACX,GAAG,GACH,MAAMvG,EAAS2D,EAAM6C,YACrB,IAAI3C,EACJ,IAAKA,EAAI,EAAGA,EAAI7D,EAAOyG,OAAQ5C,IAC3BF,EAAM+C,UAAU1G,EAAO6D,GAAIrD,EAAiBmG,gBAAgBvB,IAEhE,MAAMwB,EAAapG,EAAiBqG,YAAYlD,EAAMmD,iBAAiB9G,EAAO,IAAKQ,EAAiBmG,gBAAgBvB,IACpHE,EAAW,IAAYyB,kBAAkB,SAAU,CAAEC,OAAQJ,EAAYK,WAAW,EAAMC,SAAU5B,GAAY/E,E,CAExH,CAOgB4G,CAAY1B,EAAYG,SAASC,Y,IAMjDtF,EAAM6G,yBAAyB5B,KAAI,KAC/B,MAAM6B,EAAarH,EAAOyG,OAC1B,IAAK,IAAI5C,EAAI,EAAGA,EAAIwD,EAAYxD,IAAK,CACjC,MAAMyD,EAAKtH,EAAO6D,GAClByD,EAAGrF,KAAKL,SAAW+B,EAAMmD,iBAAiBQ,EAAGrC,KAC7C,MAAMsC,EAAM5D,EAAM6D,iBAAiBF,EAAGrC,KAEtC,GADAtB,EAAM8D,4BAA4BH,EAAGrC,IAAKqC,EAAGnC,OAAOvD,UAChD2F,EAAId,SAAW,GAAK,CACpBc,EAAIG,YACJ,MAAMC,EAAkBlD,KAAKmD,MAAML,EAAIM,EAAGN,EAAIO,GAC9CR,EAAGrF,KAAK8F,SAASlG,EAAIyF,EAAGrF,KAAK8F,SAASlG,EAA6C,KAAxC8F,EAAkBL,EAAGrF,KAAK8F,SAASlG,E,KAGxF,IAECtB,CAAK,CAEpB,EA4BA,YAAmBN,C","sources":["webpack://babylonjs-typescript-webpack-template/./src/scenes/exampleScenes/navigationMeshRecast.ts"],"sourcesContent":["import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../../createScene\";\r\n\r\nimport { RecastJSPlugin } from \"@babylonjs/core/Navigation/Plugins/recastJSPlugin\";\r\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\r\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\n\r\nimport Recast from \"recast-detour\";\r\nimport { PointerEventTypes } from \"@babylonjs/core/Events/pointerEvents\";\r\nimport { LinesMesh } from \"@babylonjs/core/Meshes/linesMesh\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\n\r\nimport \"@babylonjs/core/Culling/ray\";\r\n\r\n// import * as GUI from \"@babylonjs/gui\";\r\n\r\nconst agents: { idx: number, trf: TransformNode, mesh: Mesh, target: Mesh }[] = [];\r\n\r\nexport class NavigationMeshRecast implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // Casting to any will not be required in future versions of the recast plugin\r\n        const recast = await Recast()\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n        const navigationPlugin = new RecastJSPlugin(recast);\r\n        navigationPlugin.setWorkerURL(\"./navMeshWorker.js\");\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new FreeCamera(\"camera1\", new Vector3(-6, 4, -8), scene);\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light1\", new Vector3(0, 1, 0), scene);\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        const staticMesh = createStaticMesh(scene);\r\n        const navmeshParameters = {\r\n            cs: 0.2,\r\n            ch: 0.2,\r\n            walkableSlopeAngle: 90,\r\n            walkableHeight: 1.0,\r\n            walkableClimb: 1,\r\n            walkableRadius: 1,\r\n            maxEdgeLen: 12.,\r\n            maxSimplificationError: 1.3,\r\n            minRegionArea: 8,\r\n            mergeRegionArea: 20,\r\n            maxVertsPerPoly: 6,\r\n            detailSampleDist: 6,\r\n            detailSampleMaxError: 1,\r\n        };\r\n\r\n        navigationPlugin.createNavMesh([staticMesh], navmeshParameters, (navmeshData) => {\r\n            console.log(\"got worker data\", navmeshData);\r\n            navigationPlugin.buildFromNavmeshData(navmeshData);\r\n            const navmeshdebug = navigationPlugin.createDebugNavMesh(scene);\r\n            navmeshdebug.position = new Vector3(0, 0.01, 0);\r\n\r\n            const matdebug = new StandardMaterial('matdebug', scene);\r\n            matdebug.diffuseColor = new Color3(0.1, 0.2, 1);\r\n            matdebug.alpha = 0.2;\r\n            navmeshdebug.material = matdebug;\r\n\r\n            // crowd\r\n            const crowd = navigationPlugin.createCrowd(10, 0.1, scene);\r\n            let i;\r\n            const agentParams = {\r\n                radius: 0.1,\r\n                height: 0.2,\r\n                maxAcceleration: 4.0,\r\n                maxSpeed: 1.0,\r\n                collisionQueryRange: 0.5,\r\n                pathOptimizationRange: 0.0,\r\n                separationWeight: 1.0\r\n            };\r\n\r\n            for (i = 0; i < 1; i++) {\r\n                const width = 0.20;\r\n                const agentCube = MeshBuilder.CreateBox(\"cube\", { size: width, height: width }, scene);\r\n                const targetCube = MeshBuilder.CreateBox(\"cube\", { size: 0.1, height: 0.1 }, scene);\r\n                const matAgent = new StandardMaterial('mat2', scene);\r\n                const variation = Math.random();\r\n                matAgent.diffuseColor = new Color3(0.4 + variation * 0.6, 0.3, 1.0 - variation * 0.3);\r\n                agentCube.material = matAgent;\r\n                const randomPos = navigationPlugin.getRandomPointAround(new Vector3(-2.0, 0.1, -1.8), 0.5);\r\n                const transform = new TransformNode(\"transform\");\r\n                //agentCube.parent = transform;\r\n                const agentIndex = crowd.addAgent(randomPos, agentParams, transform);\r\n                agents.push({ idx: agentIndex, trf: transform, mesh: agentCube, target: targetCube });\r\n            }\r\n\r\n            let startingPoint: Vector3 | null;\r\n            let currentMesh: AbstractMesh;\r\n            let pathLine: LinesMesh;\r\n            const getGroundPosition = function () {\r\n                const pickinfo = scene.pick(scene.pointerX, scene.pointerY);\r\n                if (pickinfo?.hit) {\r\n                    return pickinfo.pickedPoint;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            const pointerDown = function (mesh: AbstractMesh) {\r\n                currentMesh = mesh;\r\n                startingPoint = getGroundPosition();\r\n                if (startingPoint) { // we need to disconnect camera from canvas\r\n                    setTimeout(function () {\r\n                        camera.detachControl();\r\n                    }, 0);\r\n                    const agents = crowd.getAgents();\r\n                    let i;\r\n                    for (i = 0; i < agents.length; i++) {\r\n                        crowd.agentGoto(agents[i], navigationPlugin.getClosestPoint(startingPoint));\r\n                    }\r\n                    const pathPoints = navigationPlugin.computePath(crowd.getAgentPosition(agents[0]), navigationPlugin.getClosestPoint(startingPoint));\r\n                    pathLine = MeshBuilder.CreateDashedLines(\"ribbon\", { points: pathPoints, updatable: true, instance: pathLine }, scene);\r\n                }\r\n            }\r\n\r\n            scene.onPointerObservable.add((pointerInfo) => {\r\n                switch (pointerInfo.type) {\r\n                    case PointerEventTypes.POINTERDOWN:\r\n                        if (pointerInfo?.pickInfo?.pickedMesh) {\r\n                            console.log(\"pointer down\", pointerInfo.pickInfo.pickedMesh.name);\r\n                            pointerDown(pointerInfo.pickInfo.pickedMesh)\r\n                        }\r\n                        break;\r\n                }\r\n            });\r\n\r\n            scene.onBeforeRenderObservable.add(() => {\r\n                const agentCount = agents.length;\r\n                for (let i = 0; i < agentCount; i++) {\r\n                    const ag = agents[i];\r\n                    ag.mesh.position = crowd.getAgentPosition(ag.idx);\r\n                    const vel = crowd.getAgentVelocity(ag.idx);\r\n                    crowd.getAgentNextTargetPathToRef(ag.idx, ag.target.position);\r\n                    if (vel.length() > 0.2) {\r\n                        vel.normalize();\r\n                        const desiredRotation = Math.atan2(vel.x, vel.z);\r\n                        ag.mesh.rotation.y = ag.mesh.rotation.y + (desiredRotation - ag.mesh.rotation.y) * 0.05;\r\n                    }\r\n                }\r\n            });\r\n        }); // worker\r\n        return scene;\r\n    };\r\n}\r\n\r\nfunction createStaticMesh(scene: Scene): Mesh {\r\n    const ground = MeshBuilder.CreateGround(\"ground1\", {\r\n        width: 6,\r\n        height: 6,\r\n        subdivisions: 2\r\n    }, scene);\r\n\r\n    // Materials\r\n    const mat1 = new StandardMaterial('mat1', scene);\r\n    mat1.diffuseColor = new Color3(1, 1, 1);\r\n\r\n    const sphere = MeshBuilder.CreateSphere(\"sphere1\", { diameter: 2, segments: 16 }, scene);\r\n    sphere.material = mat1;\r\n    sphere.position.y = 1;\r\n\r\n    const cube = MeshBuilder.CreateBox(\"cube\", { size: 1, height: 3 }, scene);\r\n    cube.position = new Vector3(1, 1.5, 0);\r\n    //cube.material = mat2;\r\n\r\n    const mesh = Mesh.MergeMeshes([sphere, cube, ground]);\r\n    if (!mesh) {\r\n        throw new Error(\"Could not merge meshes\");\r\n    }\r\n    return mesh;\r\n}\r\n\r\nexport default new NavigationMeshRecast();\r\n"],"names":["agents","NavigationMeshRecast","createScene","async","engine","canvas","recast","scene","navigationPlugin","setWorkerURL","camera","setTarget","Zero","attachControl","intensity","staticMesh","ground","CreateGround","width","height","subdivisions","mat1","diffuseColor","sphere","CreateSphere","diameter","segments","material","position","y","cube","CreateBox","size","mesh","MergeMeshes","Error","createStaticMesh","createNavMesh","cs","ch","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","navmeshData","console","log","buildFromNavmeshData","navmeshdebug","createDebugNavMesh","matdebug","alpha","crowd","createCrowd","i","agentParams","radius","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","agentCube","targetCube","matAgent","variation","Math","random","randomPos","getRandomPointAround","transform","agentIndex","addAgent","push","idx","trf","target","startingPoint","currentMesh","pathLine","onPointerObservable","add","pointerInfo","type","POINTERDOWN","pickInfo","pickedMesh","name","pickinfo","pick","pointerX","pointerY","hit","pickedPoint","getGroundPosition","setTimeout","detachControl","getAgents","length","agentGoto","getClosestPoint","pathPoints","computePath","getAgentPosition","CreateDashedLines","points","updatable","instance","pointerDown","onBeforeRenderObservable","agentCount","ag","vel","getAgentVelocity","getAgentNextTargetPathToRef","normalize","desiredRotation","atan2","x","z","rotation"],"sourceRoot":""}