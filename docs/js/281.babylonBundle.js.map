{"version":3,"file":"js/281.babylonBundle.js","mappings":"8KAEO,MAAMA,GAAc,E,QAAA,I,wLCF3B,QAAe,IAA0B,uC,aC0RzC,YApQA,oBACI,KAAAC,SAAW,CAACC,EAAA,GAEZ,KAAAC,YAAcC,MAAOC,EAAgBC,KAEjC,MAAMC,EAAQ,IAAI,IAAMF,GAElBG,QAAQC,IAAI,CACd,uCACA,6DACDC,MAAMC,IACLC,QAAQC,IAAIF,GACZJ,EAAMO,WAAWC,KAAK,CAClBC,cAAc,EACdC,SAAS,EACTC,WAAYC,SAASC,eAAe,eAAYC,GAClD,IAWN,MAAMC,EAAS,IAAI,IAAgB,kBAAmB,EAAGC,KAAKC,GAAK,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAIjB,GAGhGe,EAAOG,UAAU,YAGjBH,EAAOI,cAAcpB,GAAQ,GAGf,IAAI,IAAiB,QAAS,IAAI,IAAQ,EAAG,EAAG,GAAIC,GAG5DoB,UAAY,GAGlB,MAAMC,GAAS,QAAa,SAAU,CAAEC,MAAO,GAAIC,OAAQ,IAAMvB,GAGjEA,EAAMwB,cAAc,KAAM,IAAI,KAAY,QAAY7B,EAAA,IAGtD,MAAM8B,EAAc,IAAI,KAAgB,IAAI,IAAQ,EAAG,EAAG,GACpD,gBACA,IAAI,IAAQ,GAAI,GAAK,IACrBzB,GAGA0B,EAAa,IAAI,IAAYL,EAAQ,aAA0B,EAAOrB,GAW5E,SAAS2B,EAAqBC,GAE1B,MAAMC,EAAqB,IAAI,EAAAC,iBAAiB,WAAY9B,GAC5D6B,EAAmBE,aAAe,IAAI,EAAAC,OAAO,GAAK,EAAG,IACrD,MAAMC,EAAoB,IAAI,EAAAH,iBAAiB,WAAY9B,GAC3DiC,EAAkBF,aAAe,IAAI,EAAAC,OAAO,GAAK,GAAK,IAGlC,aAAhBJ,EAAOM,KACPN,EAAOO,SAAWN,EAElBD,EAAOO,SAAWF,EAGtBL,EAAOQ,QAAU,IAAI,IAAQ,IAAM,IAAM,KAEzCR,EAAOS,SAAW,IAAI,IAAQ,EAAG,EAAG,GAEpC,MAAMC,EAAqB,IAAI,IAAQ,EAAG,EAAG,GAC7CA,EAAmBC,WAAWX,EAAOS,UACrCtB,EAAOG,UAAUoB,EACrB,CA7BAb,EAAYU,SAAW,CAAEK,SAAU,GAAKC,YAAa,IAGrDf,EAAWgB,MAAQjB,EAGnBC,EAAWiB,kBAAkB,CAAEC,KAAM,IAgJrC,MAAMC,QAA0B,EAAAC,YAAA,gBAA4B,GAAG,GAAI,IAAe9C,OAAOc,GACnFiC,QAAwB,EAAAD,YAAA,gBAA4B,GAAG,GAAI,EAAa9C,OAAOc,EAAW,QAG1FkC,EAAgBH,EAAkBjB,OAAO,GACzCqB,EAAcF,EAAgBnB,OAAO,GA4C3C,OA3CAD,EAAqBqB,GACrBrB,EAAqBsB,GACrBD,EAAcE,kBACdD,EAAYC,kBAED,IAAI,EAAAC,eAAe,MAAOnD,GAQViD,EAAYG,aAGTJ,EAAcK,QAjC5C,SAA0BC,GACtB,MAAMC,EAAyB,GACzBC,EAAaF,EAAKG,gBAAgB,EAAAC,aAAA,cACxC,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAKD,QAASM,IAC9BJ,EAAYK,KAAK,cAAkBJ,EAAgB,EAAJG,GAGvD,CA+BkCE,CAAiBZ,GAItBD,EAAcc,iBAAiB,GAkBrD9D,CAAK,CAEpB,E,kCCxRA,QAAe,IAA0B,sC","sources":["webpack://babylonjs-typescript-webpack-template/./src/externals/havok.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleStaticPiece.glb","webpack://babylonjs-typescript-webpack-template/./src/scenes/alphaPuzzle.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleMoveablePiece.glb"],"sourcesContent":["import HavokPlugin from \"@babylonjs/havok\";\r\n\r\nexport const havokModule = HavokPlugin();\r\n","export default __webpack_public_path__ + \"af84c650d8f3c742962ce5d36ec5bb3f.glb\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\r\nimport \"@babylonjs/loaders/glTF\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\nimport \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { havokModule } from \"../externals/havok\";\r\nimport { PhysicsShapeBox } from \"@babylonjs/core/Physics/v2/physicsShape\";\r\nimport { PhysicsBody } from \"@babylonjs/core/Physics/v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"@babylonjs/core/Physics/v2/IPhysicsEnginePlugin\";\r\nimport { HavokPlugin } from \"@babylonjs/core/Physics/v2/Plugins/havokPlugin\";\r\n\r\n// Import AlphaPuzzle Pieces\r\nimport MoveablePiece from \"../../assets/glb/AlphaPuzzleMoveablePiece.glb\";\r\nimport StaticPiece from \"../../assets/glb/AlphaPuzzleStaticPiece.glb\";\r\nimport {Color3, FloatArray, HighlightLayer, IndicesArray, Mesh, MeshBuilder, SceneLoader, StandardMaterial, VertexBuffer, float } from \"@babylonjs/core\";\r\n\r\nclass AlphaPuzzle implements CreateSceneClass {\r\n    preTasks = [havokModule];\r\n\r\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n         // Enable Inspector and Scene Exlporer\r\n         void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        // Inspector and Scene Explorer End\r\n\r\n        // Generate both Meshes via Sceneloader\r\n      \r\n        // function generatePhysicsContainer(): PhysicsBody{\r\n        //     // Placeholder for now\r\n        //     return new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n        // }\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\r\n\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\"ground\", { width: 10, height: 10 }, scene);\r\n        \r\n        // PHYSICS!\r\n        scene.enablePhysics(null, new HavokPlugin(true, await havokModule));\r\n\r\n        // Create a static box shape\r\n        const groundShape = new PhysicsShapeBox(new Vector3(0, 0, 0)\r\n            , Quaternion.Identity()\r\n            , new Vector3(10, 0.1, 10)\r\n            , scene);\r\n\r\n        // Create a body and attach it to the ground. Set it as Static.\r\n        const groundBody = new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n\r\n        // Set material properties\r\n        groundShape.material = { friction: 0.2, restitution: 0.8 };\r\n\r\n        // Associate the body and the shape\r\n        groundBody.shape = groundShape;\r\n\r\n        // Set the mass to 0\r\n        groundBody.setMassProperties({ mass: 0 });\r\n\r\n        function importedMeshSettings(meshes: Mesh){\r\n            // Preparing material for colouring\r\n            const materialLightGreen = new StandardMaterial(\"material\", scene);\r\n            materialLightGreen.diffuseColor = new Color3(0.5, 1, 0.5);\r\n            const materialLightGray = new StandardMaterial(\"material\", scene);\r\n            materialLightGray.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n\r\n            // Setting Colour based in Childname (since Rootnode is in both called __root__)\r\n            if (meshes.name === \"moveable\") {\r\n                meshes.material = materialLightGreen;\r\n            } else {\r\n                meshes.material = materialLightGray;\r\n            }\r\n            // Setting Scaling for both meshes\r\n            meshes.scaling = new Vector3(0.08, 0.08, 0.08);\r\n            // Translating Mesh out of ground\r\n            meshes.position = new Vector3(0, 2, 0);\r\n            // Setting new Camera Focus\r\n            const initCameraPosition = new Vector3(0, 0, 0);\r\n            initCameraPosition.addInPlace(meshes.position);\r\n            camera.setTarget(initCameraPosition);\r\n        }\r\n        function randomInt(min: number, max: number){\r\n            return Math.floor(Math.random() * (max - min + 1)) + min;\r\n         }\r\n         \r\n        /**\r\n         * Generates small Meshboxes on multiple facets of the mesh, as a visual indicator / highlight\r\n         * this SHOULD NOT be included in the final version, since it is only for debugging purposes and creates\r\n         * a lot of overhead!\r\n         * \r\n        */ \r\n        function createFacetHightlights(mesh: Mesh, percentage: float) {\r\n            // Getting position of facets\r\n            const facetPositions = mesh.getFacetLocalPositions();\r\n            // Saving location for already used facet positions, to avoid duplicates at the same location\r\n            const usedFacetNumbers: number[] = []\r\n            let generatedBoxes = 0;\r\n            // Preparing Material for Highlighting\r\n            const materialHighlight = new StandardMaterial(\"material\", scene);\r\n            materialHighlight.diffuseColor = Color3.Yellow();\r\n            console.log(\"Before for loop\")\r\n            while (generatedBoxes <= mesh.facetNb * percentage) {\r\n                const randomIndex = randomInt(0, mesh.facetNb);\r\n                if (randomIndex in usedFacetNumbers) {\r\n                    console.log(\"in if Branch\")\r\n                    continue;\r\n                } else {\r\n                    //usedFacetNumbers.push(randomIndex)\r\n                    console.log(\"in else Branch\")\r\n                    const box = MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.5 }, scene);\r\n                    box.material = materialHighlight;\r\n                    box.position = facetPositions[generatedBoxes];\r\n                    box.parent = mesh;\r\n                    generatedBoxes++;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Function in order to find out if a given point is inside a facet of a mesh\r\n         * where the facet is in form of a triangle.\r\n         * \r\n         * @param p Point to check\r\n         * @param a First point of triangle\r\n         * @param b Second point of triangle\r\n         * @param c Third point of triangle\r\n         * dependend on (helper)functions: sign, dot, dot2, clamp\r\n         * \r\n         * @return positive float if outside, negative float if inside\r\n         * \r\n         * Math taken from https://iquilezles.org/articles/distfunctions/ and rewritten to work in typescript & babylonjs\r\n         */\r\n        function udTriangle(p: Vector3, a: Vector3, b: Vector3, c: Vector3 ){\r\n            // Definitions and Vectorcombinations\r\n            const ba: Vector3 = b.subtract(a); \r\n            const cb: Vector3 = c.subtract(b); \r\n            const ac: Vector3 = a.subtract(c); \r\n            const nor: Vector3 = ba.cross(ac);\r\n\r\n            const pa: Vector3 = p.subtract(a);\r\n            const pb: Vector3 = p.subtract(b);\r\n            const pc: Vector3 = p.subtract(c);\r\n            return Math.sqrt(\r\n                (sign(dot(ba.cross(nor),pa)) +\r\n                sign(dot(cb.cross(nor),pb)) +\r\n                sign(dot(ac.cross(nor),pc)) < 2.0)\r\n                ?\r\n                Math.min( Math.min(\r\n                dot2((ba.scale(clamp(dot(ba,pa)/dot2(ba),0.0,1.0))).subtract(pa)),\r\n                dot2((cb.scale(clamp(dot(cb,pb)/dot2(cb),0.0,1.0))).subtract(pb))),\r\n                dot2((ac.scale(clamp(dot(ac,pc)/dot2(ac),0.0,1.0))).subtract(pc)))\r\n                :\r\n                dot(nor,pa) * dot(nor,pa) / dot2(nor) );\r\n        }\r\n\r\n        /**\r\n         * Helperfunctions to calculate the dotproduct of a vector with another vector\r\n        */\r\n        function dot(a: Vector3, b: Vector3){\r\n            return a.x*b.x + a.y*b.y + a.z*b.z;\r\n        }\r\n\r\n        function dot2(a: Vector3){\r\n            return dot(a,a);\r\n        }\r\n\r\n        /**\r\n         * Helperfunctions to \"extract the sign of the parameter\" source-definition: https://registry.khronos.org/OpenGL-Refpages/gl4/html/sign.xhtml\r\n         * own implementation in typescript, since the glsl function is not available in typescript\r\n         * \r\n         * @param x float to check\r\n         * @return -1 if x < 0, 0 if x == 0, 1 if x > 0\r\n         */\r\n        function sign(x: float){\r\n            if (x < 0.0) {\r\n                return -1;\r\n            } else if (x == 0.0) {\r\n                return 0;\r\n            } else {\r\n                return 1;\r\n            }\r\n        }\r\n        function clamp(x: float, min: float, max: float){\r\n            return Math.min(Math.max(x, min), max);\r\n        }\r\n\r\n        /**\r\n         * Function to get the facet vertices in world coordinates in form of an Vector3 array\r\n         * @param mesh\r\n         * @return Vector3 array of facet vertices\r\n         */\r\n        function getFacetVertices(mesh: Mesh){\r\n            const returnArray: Vector3[] = [];\r\n            const vertexInfo = mesh.getVerticesData(VertexBuffer.PositionKind) as FloatArray;\r\n            for (let i = 0; i < mesh.facetNb; i++) {\r\n                returnArray.push(Vector3.FromArray(vertexInfo, i * 3));\r\n            }\r\n            return returnArray;\r\n        }\r\n\r\n\r\n        // Loading Meshes\r\n        const moveablePieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", MoveablePiece, scene, undefined);\r\n        const staticPieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", StaticPiece, scene, undefined, \".glb\");\r\n        // Casting Loadresult (ISceneLoaderAsyncResult) to Mesh for easier handling and enabling useage of updateFacetData()\r\n        // [0] is the rootnode of the mesh (Empty Parent), [1] is the actual mesh\r\n        const moveablePiece = moveablePieceLoad.meshes[1] as Mesh;\r\n        const staticPiece = staticPieceLoad.meshes[1] as Mesh;\r\n        importedMeshSettings(moveablePiece);\r\n        importedMeshSettings(staticPiece);\r\n        moveablePiece.updateFacetData();\r\n        staticPiece.updateFacetData();\r\n        // Creating Highlight Layer\r\n        const hl = new HighlightLayer(\"hl1\", scene);\r\n        // Highlighting Current Debug Facet\r\n        // hl.addMesh(moveablePiece, Color3.Green());\r\n\r\n        //createFacetHightlights(moveablePiece, 0.99);\r\n\r\n        // Saving Facets Coordinates of Staticpiece for later use\r\n        //const staticPieceFacetCoordinates = staticPiece.getFacetPosition();\r\n        const staticPieceIndices = staticPiece.getIndices() as IndicesArray;\r\n        \r\n        // Pre-Rendering, called once before the first frame\r\n        const moveablePieceNbFacets = moveablePiece.facetNb;\r\n        //console.log(\"Temp \", staticPositions);\r\n        //console.log(\"facetNb \", staticPiece.facetNb);\r\n        //console.log(\"indices \", staticPieceIndices?.length);\r\n        // Getting all Facet Positions of the static piece\r\n        const staticPieceFacetPositions = getFacetVertices(staticPiece);\r\n        //console.log(\"staticFacetPositions \", staticPieceFacetPositions);\r\n\r\n        // Placeholder, to be used to be overwritten per frame with the current position of the moving piece of the to be checked facet\r\n        const currentFacetPosition = moveablePiece.getFacetPosition(0); \r\n        // Renderfunction, called every frame\r\n        // scene.onBeforeRenderObservable.add(() => {\r\n        //     // Get current position of facets of moveablePiece\r\n        //     // Check if any of the points of the moving Piece is inside a facet of the static piece\r\n        //     // Currently we \"place\" a point to check for collision at the center of each facet of the moving piece\r\n        //      for(let i = 0; i < (moveablePieceNbFacets - 800); i++){\r\n        //         // Check if the currently selected facet-middle is inside of one of the staticPiece facets\r\n        //         moveablePiece.getFacetPositionToRef(i, currentFacetPosition);\r\n        //         for (let j = 0; j < staticPiece.facetNb; j++){\r\n        //             const staticIndex = staticPieceIndices[j * 3];\r\n        //             if (udTriangle(currentFacetPosition, staticPieceFacetPositions[staticIndex], staticPieceFacetPositions[staticIndex + 1], staticPieceFacetPositions[staticIndex + 2]) < 0){\r\n        //                 console.log(\"Collision\");\r\n        //             }\r\n        //         }\r\n        //      }\r\n        // });\r\n        \r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new AlphaPuzzle();\r\n","export default __webpack_public_path__ + \"87c16888db5ebec0fb7b6c3bb705d897.glb\";"],"names":["havokModule","preTasks","havok","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Math","PI","setTarget","attachControl","intensity","ground","width","height","enablePhysics","groundShape","groundBody","importedMeshSettings","meshes","materialLightGreen","StandardMaterial","diffuseColor","Color3","materialLightGray","name","material","scaling","position","initCameraPosition","addInPlace","friction","restitution","shape","setMassProperties","mass","moveablePieceLoad","SceneLoader","staticPieceLoad","moveablePiece","staticPiece","updateFacetData","HighlightLayer","getIndices","facetNb","mesh","returnArray","vertexInfo","getVerticesData","VertexBuffer","i","push","getFacetVertices","getFacetPosition"],"sourceRoot":""}