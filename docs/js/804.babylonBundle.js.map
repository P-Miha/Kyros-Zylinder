{"version":3,"file":"js/804.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Actions/action.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Actions/actionManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Animations/runtimeAnimation.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Audio/soundTrack.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Behaviors/Meshes/pointerDragBehavior.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Buffers/storageBuffer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/arcRotateCameraGamepadInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/flyCameraKeyboardInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/flyCameraMouseInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/followCameraKeyboardMoveInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/followCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/followCameraPointersInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/RigModes/stereoscopicAnaglyphRigMode.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/RigModes/stereoscopicRigMode.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/RigModes/vrRigMode.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/RigModes/webVRRigMode.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/VR/vrCameraMetrics.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/VR/vrDeviceOrientationFreeCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/VR/webVRCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/deviceOrientationCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/flyCameraInputsManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/followCameraInputsManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/gamepadCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/touchCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/universalCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Collisions/collider.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Compute/computeEffect.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Compute/computeShader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Culling/Octrees/octree.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Culling/Octrees/octreeBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Decorators/nodeDecorator.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.computeShader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.debugging.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.dynamicTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.externalTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.multiRender.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.multiview.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.storageBuffer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.textureSampler.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.textureSelector.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.videoTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.webVR.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Native/nativeDataStream.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Native/nativeHardwareTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Native/nativePipelineContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Native/nativeRenderTargetWrapper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.alpha.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputeContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuComputePipelineContext.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.computeShader.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.cubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.debugging.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.dynamicBuffer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.dynamicTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuExternalTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.externalTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.multiRender.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.rawTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.query.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.readTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/webgpuRenderTargetWrapper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.renderTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.renderTargetCube.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.textureSampler.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.storageBuffer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/WebGPU/Extensions/engine.videoTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Gamepads/Controllers/genericController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Gamepads/Controllers/poseEnabledController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Gamepads/Controllers/webVRController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Gamepads/gamepadManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Helpers/textureDome.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Instrumentation/timeToken.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/glowMapGeneration.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/glowMapGeneration.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Layers/effectLayer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Layers/glowLayer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/LensFlares/lensFlare.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/lensFlare.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/lensFlare.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/LensFlares/lensFlareSystem.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Dual/currentScreenBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Dual/imageSourceBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Fragment/TBNBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Input/animatedInputBlockTypes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Input/inputBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/anisotropyBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/clearCoatBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/iridescenceBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/reflectionBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/refractionBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/sheenBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/PBR/subSurfaceBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Particle/particleRampGradientBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Particle/particleTextureBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Vertex/morphTargetsBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/Vertex/vertexOutputBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/colorSplitterBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/multiplyBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/remapBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/transformBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/triPlanarBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/trigonometryBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/vectorMergerBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Blocks/viewDirectionBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Enums/nodeMaterialBlockConnectionPointMode.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Enums/nodeMaterialBlockTargets.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Enums/nodeMaterialModes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/Enums/nodeMaterialSystemValues.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/nodeMaterialBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/nodeMaterialBlockConnectionPoint.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/nodeMaterialBuildState.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/nodeMaterialBuildStateSharedData.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Node/nodeMaterialConnectionPointCustomObject.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/PBR/pbrBaseSimpleMaterial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/hdrFiltering.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/hdrFiltering.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Filtering/hdrFiltering.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/MultiviewRenderTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Packer/frame.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/procedural.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/dynamicTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/hdrCubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/multiRenderTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/videoTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/greasedLine.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/greasedLine.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/greasedLineSimpleMaterial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/standardMaterial.decalMap.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/PBR/pbrMaterial.decalMap.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/uniformBufferEffectCommonAccessor.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/Blocks/Sources/boxBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/Blocks/geometryInputBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/Blocks/geometryOutputBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/Enums/nodeGeometryConnectionPointTypes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/Enums/nodeGeometryContextualSources.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/nodeGeometryBlock.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Node/nodeGeometryBuildState.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/abstractMesh.decalMap.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/subMesh.project.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/HighDynamicRange/hdr.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/HighDynamicRange/panoramaToCubemap.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/PerformanceViewer/dynamicFloat32Array.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/PerformanceViewer/performanceViewerCollector.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/PerformanceViewer/performanceViewerSceneExtension.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/dds.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/gradients.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/greasedLineTools.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/khronosTextureContainer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/observableCoroutine.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/pivotTools.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/sceneSerializer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/virtualJoystick.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/boxParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/coneParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/customParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/cylinderParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/hemisphericParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/meshParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/pointParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/EmitterTypes/sphereParticleEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/baseParticleSystem.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/gpuRenderParticles.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/gpuRenderParticles.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/gpuParticleSystem.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/particle.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/particles.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/particleSystem.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/particleSystemComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/particleSystemSet.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Particles/subEmitter.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/Plugins/cannonJSPlugin.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/Plugins/oimoJSPlugin.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/RenderPipeline/postProcessRenderEffect.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipeline.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/anaglyph.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/anaglyphPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/bloomEffect.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/bloomMerge.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/bloomMergePostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/chromaticAberrationPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/circleOfConfusion.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/circleOfConfusionPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/depthOfFieldBlurPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/depthOfFieldEffect.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/depthOfFieldMerge.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/depthOfFieldMergePostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/extractHighlights.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/extractHighlightsPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fxaa.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fxaa.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/fxaaPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/grain.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/grainPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/imageProcessingPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/motionBlurConfiguration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/motionBlur.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/motionBlurPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/screenSpaceReflectionsConfiguration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/screenSpaceReflection.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/screenSpaceReflectionPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/sharpen.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/sharpenPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/vrDistortionCorrection.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/vrDistortionCorrectionPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/vrMultiviewToSingleview.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/vrMultiviewToSingleviewPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Probes/reflectionProbe.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/oitFinal.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/oitBackBlend.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/depthPeelingRenderer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/fluidRenderer/fluidRenderingDepthTextureCopy.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/fluidRenderer/fluidRenderingObject.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/fluidRenderer/fluidRenderingObjectCustomParticles.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/fluidRenderer/fluidRenderingObjectParticleSystem.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/fluidRenderer/fluidRenderingTextures.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/mrtFragmentDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/geometry.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/geometryVertexDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/geometryUboDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/geometry.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/geometryBufferRenderer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/prePassRenderTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/prePassRenderer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/screenSpaceReflections2Configuration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/ssao2Configuration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/fibonacci.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/diffusionProfile.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/subSurfaceScattering.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/PostProcesses/subSurfaceScatteringPostProcess.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/subSurfaceConfiguration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Rendering/utilityLayerRenderer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/ShadersWGSL/gpuUpdateParticles.compute.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/boundingBoxRendererUboDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/imageProcessingCompatibility.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/screenSpaceRayTrace.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/blackAndWhite.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/boundingBoxRendererFragmentDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/boundingBoxRenderer.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/boundingBoxRendererVertexDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/boundingBoxRenderer.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/chromaticAberration.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/colorCorrection.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/convolution.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/copyTextureToTexture.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/depthOfField.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/displayPass.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/filter.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingBilateralBlur.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleDepth.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleDepth.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleDiffuse.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleDiffuse.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleThickness.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingParticleThickness.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingRender.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/fluidRenderingStandardBlur.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/glowBlurPostProcess.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/glowMapMerge.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/glowMapMerge.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/gpuUpdateParticles.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/gpuUpdateParticles.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/highlights.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/imageProcessing.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/layer.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/layer.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/lensHighlights.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/line.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/line.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/meshUVSpaceRenderer.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/meshUVSpaceRenderer.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/noise.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/outline.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/outline.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/particles.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/refraction.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/screenSpaceCurvature.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/screenSpaceReflection2.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/screenSpaceReflection2Blur.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/screenSpaceReflection2BlurCombiner.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/spriteMap.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/spriteMap.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ssao.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ssao2.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ssaoCombine.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/standard.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/stereoscopicInterlace.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/tonemap.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/velocity.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/velocity.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/volumetricLightScattering.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/volumetricLightScatteringPass.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/volumetricLightScatteringPass.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Sprites/thinSprite.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Sprites/sprite.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/sprites.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/sprites.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Sprites/spriteRenderer.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Sprites/spriteSceneComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/features/WebXRAbstractFeature.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/features/WebXRControllerPointerSelection.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/features/WebXRControllerTeleportation.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/motionController/webXRAbstractMotionController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/motionController/webXRControllerComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/motionController/webXRGenericMotionController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/motionController/webXRMotionControllerManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/motionController/webXRProfiledMotionController.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRExperienceHelper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRFeaturesManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRInputSource.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRLayerWrapper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRManagedOutputCanvas.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRRenderTargetTextureProvider.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRSessionManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRTypes.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/XR/webXRWebGLLayer.ts"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Condition } from \"./condition\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { AbstractActionManager } from \"./abstractActionManager\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Material } from \"../Materials/material\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { ActionManager } from \"./actionManager\";\r\nimport type { ActionEvent } from \"./actionEvent\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Interface used to define Action\r\n */\r\nexport interface IAction {\r\n    /**\r\n     * Trigger for the action\r\n     */\r\n    trigger: number;\r\n\r\n    /** Options of the trigger */\r\n    triggerOptions: any;\r\n\r\n    /**\r\n     * Gets the trigger parameters\r\n     * @returns the trigger parameters\r\n     */\r\n    getTriggerParameter(): any;\r\n\r\n    /**\r\n     * Internal only - executes current action event\r\n     * @internal\r\n     */\r\n    _executeCurrent(evt?: ActionEvent): void;\r\n\r\n    /**\r\n     * Serialize placeholder for child classes\r\n     * @param parent of child\r\n     * @returns the serialized object\r\n     */\r\n    serialize(parent: any): any;\r\n\r\n    /**\r\n     * Internal only\r\n     * @internal\r\n     */\r\n    _prepare(): void;\r\n\r\n    /**\r\n     * Internal only - manager for action\r\n     * @internal\r\n     */\r\n    _actionManager: Nullable<AbstractActionManager>;\r\n\r\n    /**\r\n     * Adds action to chain of actions, may be a DoNothingAction\r\n     * @param action defines the next action to execute\r\n     * @returns The action passed in\r\n     * @see https://www.babylonjs-playground.com/#1T30HR#0\r\n     */\r\n    then(action: IAction): IAction;\r\n}\r\n\r\n/**\r\n * The action to be carried out following a trigger\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#available-actions\r\n */\r\nexport class Action implements IAction {\r\n    /**\r\n     * Trigger for the action\r\n     */\r\n    public trigger: number;\r\n\r\n    /**\r\n     * Internal only - manager for action\r\n     * @internal\r\n     */\r\n    public _actionManager: ActionManager;\r\n\r\n    private _nextActiveAction: Action;\r\n    private _child: Action;\r\n    private _condition?: Condition;\r\n    private _triggerParameter: any;\r\n\r\n    /**\r\n     * An event triggered prior to action being executed.\r\n     */\r\n    public onBeforeExecuteObservable = new Observable<Action>();\r\n\r\n    /**\r\n     * Creates a new Action\r\n     * @param triggerOptions the trigger, with or without parameters, for the action\r\n     * @param condition an optional determinant of action\r\n     */\r\n    constructor(\r\n        /** the trigger, with or without parameters, for the action */\r\n        public triggerOptions: any,\r\n        condition?: Condition\r\n    ) {\r\n        if (triggerOptions.parameter) {\r\n            this.trigger = triggerOptions.trigger;\r\n            this._triggerParameter = triggerOptions.parameter;\r\n        } else if (triggerOptions.trigger) {\r\n            this.trigger = triggerOptions.trigger;\r\n        } else {\r\n            this.trigger = triggerOptions;\r\n        }\r\n\r\n        this._nextActiveAction = this;\r\n        this._condition = condition;\r\n    }\r\n\r\n    /**\r\n     * Internal only\r\n     * @internal\r\n     */\r\n    public _prepare(): void {}\r\n\r\n    /**\r\n     * Gets the trigger parameter\r\n     * @returns the trigger parameter\r\n     */\r\n    public getTriggerParameter(): any {\r\n        return this._triggerParameter;\r\n    }\r\n\r\n    /**\r\n     * Sets the trigger parameter\r\n     * @param value defines the new trigger parameter\r\n     */\r\n    public setTriggerParameter(value: any) {\r\n        this._triggerParameter = value;\r\n    }\r\n\r\n    /**\r\n     * Internal only - Returns if the current condition allows to run the action\r\n     * @internal\r\n     */\r\n    public _evaluateConditionForCurrentFrame(): boolean {\r\n        const condition = this._condition;\r\n        if (!condition) {\r\n            return true;\r\n        }\r\n\r\n        const currentRenderId = this._actionManager.getScene().getRenderId();\r\n\r\n        // We cache the current evaluation for the current frame\r\n        if (condition._evaluationId !== currentRenderId) {\r\n            condition._evaluationId = currentRenderId;\r\n            condition._currentResult = condition.isValid();\r\n        }\r\n\r\n        return condition._currentResult;\r\n    }\r\n\r\n    /**\r\n     * Internal only - executes current action event\r\n     * @internal\r\n     */\r\n    public _executeCurrent(evt?: ActionEvent): void {\r\n        const isConditionValid = this._evaluateConditionForCurrentFrame();\r\n        if (!isConditionValid) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeExecuteObservable.notifyObservers(this);\r\n        this._nextActiveAction.execute(evt);\r\n\r\n        this.skipToNextActiveAction();\r\n    }\r\n\r\n    /**\r\n     * Execute placeholder for child classes\r\n     * @param evt optional action event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public execute(evt?: ActionEvent): void {}\r\n\r\n    /**\r\n     * Skips to next active action\r\n     */\r\n    public skipToNextActiveAction(): void {\r\n        if (this._nextActiveAction._child) {\r\n            if (!this._nextActiveAction._child._actionManager) {\r\n                this._nextActiveAction._child._actionManager = this._actionManager;\r\n            }\r\n\r\n            this._nextActiveAction = this._nextActiveAction._child;\r\n        } else {\r\n            this._nextActiveAction = this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds action to chain of actions, may be a DoNothingAction\r\n     * @param action defines the next action to execute\r\n     * @returns The action passed in\r\n     * @see https://www.babylonjs-playground.com/#1T30HR#0\r\n     */\r\n    public then(action: Action): Action {\r\n        this._child = action;\r\n\r\n        action._actionManager = this._actionManager;\r\n        action._prepare();\r\n\r\n        return action;\r\n    }\r\n\r\n    /**\r\n     * Internal only\r\n     * @internal\r\n     */\r\n    public _getProperty(propertyPath: string): string {\r\n        return this._actionManager._getProperty(propertyPath);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getEffectiveTarget(target: any, propertyPath: string): any {\r\n        return this._actionManager._getEffectiveTarget(target, propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Serialize placeholder for child classes\r\n     * @param parent of child\r\n     * @returns the serialized object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public serialize(parent: any): any {}\r\n\r\n    /**\r\n     * Internal only called by serialize\r\n     * @internal\r\n     */\r\n    protected _serialize(serializedAction: any, parent?: any): any {\r\n        const serializationObject: any = {\r\n            type: 1,\r\n            children: [],\r\n            name: serializedAction.name,\r\n            properties: serializedAction.properties || [],\r\n        };\r\n\r\n        // Serialize child\r\n        if (this._child) {\r\n            this._child.serialize(serializationObject);\r\n        }\r\n\r\n        // Check if \"this\" has a condition\r\n        if (this._condition) {\r\n            const serializedCondition = this._condition.serialize();\r\n            serializedCondition.children.push(serializationObject);\r\n\r\n            if (parent) {\r\n                parent.children.push(serializedCondition);\r\n            }\r\n            return serializedCondition;\r\n        }\r\n\r\n        if (parent) {\r\n            parent.children.push(serializationObject);\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Internal only\r\n     * @internal\r\n     */\r\n    public static _SerializeValueAsString = (value: any): string => {\r\n        if (typeof value === \"number\") {\r\n            return value.toString();\r\n        }\r\n\r\n        if (typeof value === \"boolean\") {\r\n            return value ? \"true\" : \"false\";\r\n        }\r\n\r\n        if (value instanceof Vector2) {\r\n            return value.x + \", \" + value.y;\r\n        }\r\n        if (value instanceof Vector3) {\r\n            return value.x + \", \" + value.y + \", \" + value.z;\r\n        }\r\n\r\n        if (value instanceof Color3) {\r\n            return value.r + \", \" + value.g + \", \" + value.b;\r\n        }\r\n        if (value instanceof Color4) {\r\n            return value.r + \", \" + value.g + \", \" + value.b + \", \" + value.a;\r\n        }\r\n\r\n        return value; // string\r\n    };\r\n\r\n    /**\r\n     * Internal only\r\n     * @internal\r\n     */\r\n    public static _GetTargetProperty = (target: Scene | Node | Material) => {\r\n        return {\r\n            name: \"target\",\r\n            targetType: (<Mesh>target)._isMesh\r\n                ? \"MeshProperties\"\r\n                : (<Light>target)._isLight\r\n                ? \"LightProperties\"\r\n                : (<Camera>target)._isCamera\r\n                ? \"CameraProperties\"\r\n                : (<Material>target)._isMaterial\r\n                ? \"MaterialProperties\"\r\n                : \"SceneProperties\",\r\n            value: (<Scene>target)._isScene ? \"Scene\" : (<Node>target).name,\r\n        };\r\n    };\r\n}\r\n\r\nRegisterClass(\"BABYLON.Action\", Action);\r\n","import type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Condition, ValueCondition } from \"./condition\";\r\nimport type { IAction } from \"./action\";\r\nimport { Action } from \"./action\";\r\nimport { DoNothingAction } from \"./directActions\";\r\n\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IActionEvent } from \"../Actions/actionEvent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { AbstractActionManager } from \"./abstractActionManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\r\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n */\r\nexport class ActionManager extends AbstractActionManager {\r\n    /**\r\n     * Nothing\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly NothingTrigger = Constants.ACTION_NothingTrigger;\r\n\r\n    /**\r\n     * On pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickTrigger = Constants.ACTION_OnPickTrigger;\r\n\r\n    /**\r\n     * On left pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnLeftPickTrigger = Constants.ACTION_OnLeftPickTrigger;\r\n\r\n    /**\r\n     * On right pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnRightPickTrigger = Constants.ACTION_OnRightPickTrigger;\r\n\r\n    /**\r\n     * On center pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnCenterPickTrigger = Constants.ACTION_OnCenterPickTrigger;\r\n\r\n    /**\r\n     * On pick down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickDownTrigger = Constants.ACTION_OnPickDownTrigger;\r\n\r\n    /**\r\n     * On double pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnDoublePickTrigger = Constants.ACTION_OnDoublePickTrigger;\r\n\r\n    /**\r\n     * On pick up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickUpTrigger = Constants.ACTION_OnPickUpTrigger;\r\n    /**\r\n     * On pick out.\r\n     * This trigger will only be raised if you also declared a OnPickDown\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickOutTrigger = Constants.ACTION_OnPickOutTrigger;\r\n\r\n    /**\r\n     * On long press\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnLongPressTrigger = Constants.ACTION_OnLongPressTrigger;\r\n\r\n    /**\r\n     * On pointer over\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPointerOverTrigger = Constants.ACTION_OnPointerOverTrigger;\r\n\r\n    /**\r\n     * On pointer out\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPointerOutTrigger = Constants.ACTION_OnPointerOutTrigger;\r\n\r\n    /**\r\n     * On every frame\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnEveryFrameTrigger = Constants.ACTION_OnEveryFrameTrigger;\r\n    /**\r\n     * On intersection enter\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnIntersectionEnterTrigger = Constants.ACTION_OnIntersectionEnterTrigger;\r\n\r\n    /**\r\n     * On intersection exit\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnIntersectionExitTrigger = Constants.ACTION_OnIntersectionExitTrigger;\r\n\r\n    /**\r\n     * On key down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnKeyDownTrigger = Constants.ACTION_OnKeyDownTrigger;\r\n\r\n    /**\r\n     * On key up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnKeyUpTrigger = Constants.ACTION_OnKeyUpTrigger;\r\n\r\n    // Members\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new action manager\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        super();\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n\r\n        scene.actionManagers.push(this);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const sceneIndex = this._scene.actionManagers.indexOf(this);\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const action = this.actions[i];\r\n            ActionManager.Triggers[action.trigger]--;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n        }\r\n\r\n        this.actions.length = 0;\r\n\r\n        if (sceneIndex > -1) {\r\n            this._scene.actionManagers.splice(sceneIndex, 1);\r\n        }\r\n\r\n        const ownerMesh = this._scene.meshes.find((m) => m.actionManager === this);\r\n        if (ownerMesh) {\r\n            ownerMesh.actionManager = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets hosting scene\r\n     * @returns the hosting scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers\r\n     * @param triggers defines the triggers to be tested\r\n     * @returns a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers(triggers: number[]): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggers.indexOf(action.trigger) > -1) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\r\n     * speed.\r\n     * @param triggerA defines the trigger to be tested\r\n     * @param triggerB defines the trigger to be tested\r\n     * @returns a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers2(triggerA: number, triggerB: number): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggerA == action.trigger || triggerB == action.trigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of a given trigger\r\n     * @param trigger defines the trigger to be tested\r\n     * @param parameterPredicate defines an optional predicate to filter triggers by parameter\r\n     * @returns whether the trigger is handled\r\n     */\r\n    public hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (parameterPredicate) {\r\n                    if (parameterPredicate(action.getTriggerParameter())) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pointer triggers\r\n     */\r\n    public get hasPointerTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pick triggers\r\n     */\r\n    public get hasPickTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Registers an action to this action manager\r\n     * @param action defines the action to be registered\r\n     * @returns the action amended (prepared) after registration\r\n     */\r\n    public registerAction(action: IAction): Nullable<IAction> {\r\n        if (action.trigger === ActionManager.OnEveryFrameTrigger) {\r\n            if (this.getScene().actionManager !== this) {\r\n                Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        this.actions.push(action);\r\n        this.getScene()._registeredActions++;\r\n\r\n        if (ActionManager.Triggers[action.trigger]) {\r\n            ActionManager.Triggers[action.trigger]++;\r\n        } else {\r\n            ActionManager.Triggers[action.trigger] = 1;\r\n        }\r\n\r\n        action._actionManager = this;\r\n        action._prepare();\r\n\r\n        return action;\r\n    }\r\n\r\n    /**\r\n     * Unregisters an action to this action manager\r\n     * @param action defines the action to be unregistered\r\n     * @returns a boolean indicating whether the action has been unregistered\r\n     */\r\n    public unregisterAction(action: IAction): Boolean {\r\n        const index = this.actions.indexOf(action);\r\n        if (index !== -1) {\r\n            this.actions.splice(index, 1);\r\n            ActionManager.Triggers[action.trigger] -= 1;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n            action._actionManager = null;\r\n            this.getScene()._registeredActions--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Process a specific trigger\r\n     * @param trigger defines the trigger to process\r\n     * @param evt defines the event details to be processed\r\n     */\r\n    public processTrigger(trigger: number, evt?: IActionEvent): void {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (evt) {\r\n                    if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\r\n                        const parameter = action.getTriggerParameter();\r\n\r\n                        if (typeof parameter === \"function\") {\r\n                            if (!parameter(evt)) {\r\n                                continue;\r\n                            }\r\n                        } else if (parameter && parameter !== evt.sourceEvent.keyCode) {\r\n                            if (!parameter.toLowerCase) {\r\n                                continue;\r\n                            }\r\n                            const lowerCase = parameter.toLowerCase();\r\n\r\n                            if (lowerCase !== evt.sourceEvent.key) {\r\n                                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\r\n                                const actualkey = String.fromCharCode(unicode).toLowerCase();\r\n                                if (actualkey !== lowerCase) {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                action._executeCurrent(evt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getEffectiveTarget(target: any, propertyPath: string): any {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        for (let index = 0; index < properties.length - 1; index++) {\r\n            target = target[properties[index]];\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getProperty(propertyPath: string): string {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        return properties[properties.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Serialize this manager to a JSON object\r\n     * @param name defines the property name to store this manager\r\n     * @returns a JSON representation of this manager\r\n     */\r\n    public serialize(name: string): any {\r\n        const root = {\r\n            children: new Array(),\r\n            name: name,\r\n            type: 3, // Root node\r\n            properties: new Array(), // Empty for root but required\r\n        };\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const triggerObject = {\r\n                type: 0, // Trigger\r\n                children: new Array(),\r\n                name: ActionManager.GetTriggerName(this.actions[i].trigger),\r\n                properties: new Array(),\r\n            };\r\n\r\n            const triggerOptions = this.actions[i].triggerOptions;\r\n\r\n            if (triggerOptions && typeof triggerOptions !== \"number\") {\r\n                if (triggerOptions.parameter instanceof Node) {\r\n                    triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\r\n                } else if (typeof triggerOptions.parameter === \"object\") {\r\n                    const parameter = <any>{};\r\n                    DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\r\n\r\n                    if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\r\n                        parameter._meshId = triggerOptions.parameter.mesh.id;\r\n                    }\r\n\r\n                    triggerObject.properties.push({ name: \"parameter\", targetType: null, value: parameter });\r\n                } else {\r\n                    triggerObject.properties.push({ name: \"parameter\", targetType: null, value: triggerOptions.parameter });\r\n                }\r\n            }\r\n\r\n            // Serialize child action, recursively\r\n            this.actions[i].serialize(triggerObject);\r\n\r\n            // Add serialized trigger\r\n            root.children.push(triggerObject);\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ActionManager from a JSON data\r\n     * @param parsedActions defines the JSON data to read from\r\n     * @param object defines the hosting mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public static Parse(parsedActions: any, object: Nullable<AbstractMesh>, scene: Scene): void {\r\n        const actionManager = new ActionManager(scene);\r\n        if (object === null) {\r\n            scene.actionManager = actionManager;\r\n        } else {\r\n            object.actionManager = actionManager;\r\n        }\r\n\r\n        // instantiate a new object\r\n        const instantiate = (name: string, params: Array<any>): any => {\r\n            const internalClassType = GetClass(\"BABYLON.\" + name);\r\n            return internalClassType && new internalClassType(...params);\r\n        };\r\n\r\n        const parseParameter = (name: string, value: string, target: any, propertyPath: Nullable<string>): any => {\r\n            if (propertyPath === null) {\r\n                // String, boolean or float\r\n                const floatValue = parseFloat(value);\r\n\r\n                if (value === \"true\" || value === \"false\") {\r\n                    return value === \"true\";\r\n                } else {\r\n                    return isNaN(floatValue) ? value : floatValue;\r\n                }\r\n            }\r\n\r\n            const effectiveTarget = propertyPath.split(\".\");\r\n            const values = value.split(\",\");\r\n\r\n            // Get effective Target\r\n            for (let i = 0; i < effectiveTarget.length; i++) {\r\n                target = target[effectiveTarget[i]];\r\n            }\r\n\r\n            // Return appropriate value with its type\r\n            if (typeof target === \"boolean\") {\r\n                return values[0] === \"true\";\r\n            }\r\n\r\n            if (typeof target === \"string\") {\r\n                return values[0];\r\n            }\r\n\r\n            // Parameters with multiple values such as Vector3 etc.\r\n            const split = new Array<number>();\r\n            for (let i = 0; i < values.length; i++) {\r\n                split.push(parseFloat(values[i]));\r\n            }\r\n\r\n            if (target instanceof Vector3) {\r\n                return Vector3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Vector4) {\r\n                return Vector4.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color3) {\r\n                return Color3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color4) {\r\n                return Color4.FromArray(split);\r\n            }\r\n\r\n            return parseFloat(values[0]);\r\n        };\r\n\r\n        // traverse graph per trigger\r\n        const traverse = (parsedAction: any, trigger: any, condition: Nullable<Condition>, action: Nullable<Action>, combineArray: Nullable<Array<Action>> = null) => {\r\n            if (parsedAction.detached) {\r\n                return;\r\n            }\r\n\r\n            const parameters = new Array<any>();\r\n            let target: any = null;\r\n            let propertyPath: Nullable<string> = null;\r\n            const combine = parsedAction.combine && parsedAction.combine.length > 0;\r\n\r\n            // Parameters\r\n            if (parsedAction.type === 2) {\r\n                parameters.push(actionManager);\r\n            } else {\r\n                parameters.push(trigger);\r\n            }\r\n\r\n            if (combine) {\r\n                const actions = new Array<Action>();\r\n                for (let j = 0; j < parsedAction.combine.length; j++) {\r\n                    traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\r\n                }\r\n                parameters.push(actions);\r\n            } else {\r\n                for (let i = 0; i < parsedAction.properties.length; i++) {\r\n                    let value = parsedAction.properties[i].value;\r\n                    const name = parsedAction.properties[i].name;\r\n                    const targetType = parsedAction.properties[i].targetType;\r\n\r\n                    if (name === \"target\") {\r\n                        if (targetType === \"SceneProperties\") {\r\n                            value = target = scene;\r\n                        } else if (targetType === \"MaterialProperties\") {\r\n                            value = target = scene.getMaterialByName(value);\r\n                        } else {\r\n                            value = target = scene.getNodeByName(value);\r\n                        }\r\n                    } else if (name === \"parent\") {\r\n                        value = scene.getNodeByName(value);\r\n                    } else if (name === \"sound\") {\r\n                        // Can not externalize to component, so only checks for the presence off the API.\r\n                        if (scene.getSoundByName) {\r\n                            value = scene.getSoundByName(value);\r\n                        }\r\n                    } else if (name !== \"propertyPath\") {\r\n                        if (parsedAction.type === 2 && name === \"operator\") {\r\n                            value = (<any>ValueCondition)[value];\r\n                        } else {\r\n                            value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\r\n                        }\r\n                    } else {\r\n                        propertyPath = value;\r\n                    }\r\n\r\n                    parameters.push(value);\r\n                }\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                parameters.push(condition);\r\n            } else {\r\n                parameters.push(null);\r\n            }\r\n\r\n            // If interpolate value action\r\n            if (parsedAction.name === \"InterpolateValueAction\") {\r\n                const param = parameters[parameters.length - 2];\r\n                parameters[parameters.length - 1] = param;\r\n                parameters[parameters.length - 2] = condition;\r\n            }\r\n\r\n            // Action or condition(s) and not CombineAction\r\n            let newAction = instantiate(parsedAction.name, parameters);\r\n\r\n            if (newAction instanceof Condition && condition !== null) {\r\n                const nothing = new DoNothingAction(trigger, condition);\r\n\r\n                if (action) {\r\n                    action.then(nothing);\r\n                } else {\r\n                    actionManager.registerAction(nothing);\r\n                }\r\n\r\n                action = nothing;\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                if (newAction instanceof Condition) {\r\n                    condition = newAction;\r\n                    newAction = action;\r\n                } else {\r\n                    condition = null;\r\n                    if (action) {\r\n                        action.then(newAction);\r\n                    } else {\r\n                        actionManager.registerAction(newAction);\r\n                    }\r\n                }\r\n            } else {\r\n                combineArray.push(newAction);\r\n            }\r\n\r\n            for (let i = 0; i < parsedAction.children.length; i++) {\r\n                traverse(parsedAction.children[i], trigger, condition, newAction, null);\r\n            }\r\n        };\r\n\r\n        // triggers\r\n        for (let i = 0; i < parsedActions.children.length; i++) {\r\n            let triggerParams: any;\r\n            const trigger = parsedActions.children[i];\r\n\r\n            if (trigger.properties.length > 0) {\r\n                const param = trigger.properties[0].value;\r\n                const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\r\n\r\n                if (value._meshId) {\r\n                    value.mesh = scene.getMeshById(value._meshId);\r\n                }\r\n\r\n                triggerParams = { trigger: (<any>ActionManager)[trigger.name], parameter: value };\r\n            } else {\r\n                triggerParams = (<any>ActionManager)[trigger.name];\r\n            }\r\n\r\n            for (let j = 0; j < trigger.children.length; j++) {\r\n                if (!trigger.detached) {\r\n                    traverse(trigger.children[j], triggerParams, null, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a trigger name by index\r\n     * @param trigger defines the trigger index\r\n     * @returns a trigger name\r\n     */\r\n    public static GetTriggerName(trigger: number): string {\r\n        switch (trigger) {\r\n            case Constants.ACTION_NothingTrigger:\r\n                return \"NothingTrigger\";\r\n            case Constants.ACTION_OnPickTrigger:\r\n                return \"OnPickTrigger\";\r\n            case Constants.ACTION_OnLeftPickTrigger:\r\n                return \"OnLeftPickTrigger\";\r\n            case Constants.ACTION_OnRightPickTrigger:\r\n                return \"OnRightPickTrigger\";\r\n            case Constants.ACTION_OnCenterPickTrigger:\r\n                return \"OnCenterPickTrigger\";\r\n            case Constants.ACTION_OnPickDownTrigger:\r\n                return \"OnPickDownTrigger\";\r\n            case Constants.ACTION_OnDoublePickTrigger:\r\n                return \"OnDoublePickTrigger\"; // start;\r\n            case Constants.ACTION_OnPickUpTrigger:\r\n                return \"OnPickUpTrigger\";\r\n            case Constants.ACTION_OnLongPressTrigger:\r\n                return \"OnLongPressTrigger\";\r\n            case Constants.ACTION_OnPointerOverTrigger:\r\n                return \"OnPointerOverTrigger\";\r\n            case Constants.ACTION_OnPointerOutTrigger:\r\n                return \"OnPointerOutTrigger\";\r\n            case Constants.ACTION_OnEveryFrameTrigger:\r\n                return \"OnEveryFrameTrigger\";\r\n            case Constants.ACTION_OnIntersectionEnterTrigger:\r\n                return \"OnIntersectionEnterTrigger\";\r\n            case Constants.ACTION_OnIntersectionExitTrigger:\r\n                return \"OnIntersectionExitTrigger\";\r\n            case Constants.ACTION_OnKeyDownTrigger:\r\n                return \"OnKeyDownTrigger\";\r\n            case Constants.ACTION_OnKeyUpTrigger:\r\n                return \"OnKeyUpTrigger\";\r\n            case Constants.ACTION_OnPickOutTrigger:\r\n                return \"OnPickOutTrigger\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n}\r\n","import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport { Animation } from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\n\r\nimport type { Animatable } from \"./animatable\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { Size } from \"../Maths/math.size\";\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nconst _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nconst _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nconst _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nconst _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nconst _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target[targetPropertyPath[0]];\r\n\r\n            for (let index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getRestPose && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getRestPose();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, -1);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const frameRange = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n        let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n        let highLimitValue = 0;\r\n\r\n        // Apply the yoyo function if required\r\n        if (loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO) {\r\n            const position = (absoluteFrame - from) / frameRange;\r\n\r\n            // Apply the yoyo curve\r\n            const yoyoPosition = Math.abs(Math.sin(position * Math.PI));\r\n\r\n            // Map the yoyo position back to the range\r\n            absoluteFrame = yoyoPosition * frameRange + from;\r\n        }\r\n\r\n        this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n        this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n        if (!loop && to >= from && absoluteFrame >= frameRange) {\r\n            // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && from >= to && absoluteFrame <= frameRange) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            const keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                const fromValue = animation._interpolate(from, this._animationState);\r\n                const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + frameRange * hostNormalizedFrame;\r\n        } else {\r\n            if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n            } else {\r\n                currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n            }\r\n        }\r\n\r\n        const events = this._events;\r\n\r\n        // Reset event/state if looping\r\n        if ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame)) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset event, the animation is looping\r\n                    events[index].isDone = false;\r\n                }\r\n            }\r\n\r\n            this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n","import type { Sound } from \"./sound\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\n/**\r\n * Options allowed during the creation of a sound track.\r\n */\r\nexport interface ISoundTrackOptions {\r\n    /**\r\n     * The volume the sound track should take during creation\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * Define if the sound track is the main sound track of the scene\r\n     */\r\n    mainTrack?: boolean;\r\n}\r\n\r\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n */\r\nexport class SoundTrack {\r\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\r\n    public id: number = -1;\r\n    /**\r\n     * The list of sounds included in the sound track.\r\n     */\r\n    public soundCollection: Array<Sound>;\r\n\r\n    private _outputAudioNode: Nullable<GainNode>;\r\n    private _scene: Scene;\r\n    private _connectedAnalyser: Analyser;\r\n    private _options: ISoundTrackOptions;\r\n    private _isInitialized = false;\r\n\r\n    /**\r\n     * Creates a new sound track.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n     * @param scene Define the scene the sound track belongs to\r\n     * @param options\r\n     */\r\n    constructor(scene?: Nullable<Scene>, options: ISoundTrackOptions = {}) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        this.soundCollection = new Array();\r\n        this._options = options;\r\n\r\n        if (!this._options.mainTrack && this._scene.soundTracks) {\r\n            this._scene.soundTracks.push(this);\r\n            this.id = this._scene.soundTracks.length - 1;\r\n        }\r\n    }\r\n\r\n    private _initializeSoundTrackAudioGraph() {\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._outputAudioNode = Engine.audioEngine.audioContext.createGain();\r\n            this._outputAudioNode.connect(Engine.audioEngine.masterGain);\r\n\r\n            if (this._options) {\r\n                if (this._options.volume) {\r\n                    this._outputAudioNode.gain.value = this._options.volume;\r\n                }\r\n            }\r\n\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound track and its associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (Engine.audioEngine && Engine.audioEngine.canUseWebAudio) {\r\n            if (this._connectedAnalyser) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n            }\r\n            while (this.soundCollection.length) {\r\n                this.soundCollection[0].dispose();\r\n            }\r\n            if (this._outputAudioNode) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a sound to this sound track\r\n     * @param sound define the sound to add\r\n     * @ignoreNaming\r\n     */\r\n    public addSound(sound: Sound): void {\r\n        if (!this._isInitialized) {\r\n            this._initializeSoundTrackAudioGraph();\r\n        }\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\r\n        }\r\n        if (sound.soundTrackId) {\r\n            if (sound.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(sound);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\r\n            }\r\n        }\r\n\r\n        this.soundCollection.push(sound);\r\n        sound.soundTrackId = this.id;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound to this sound track\r\n     * @param sound define the sound to remove\r\n     * @ignoreNaming\r\n     */\r\n    public removeSound(sound: Sound): void {\r\n        const index = this.soundCollection.indexOf(sound);\r\n        if (index !== -1) {\r\n            this.soundCollection.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global volume for the full sound track.\r\n     * @param newVolume Define the new volume of the sound track\r\n     */\r\n    public setVolume(newVolume: number): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF(): void {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower(): void {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the sound track to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        this._connectedAnalyser = analyser;\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Engine.audioEngine.masterGain);\r\n        }\r\n    }\r\n}\r\n","import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PivotTools } from \"../../Misc/pivotTools\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CreatePlane } from \"../../Meshes/Builders/planeBuilder\";\r\n\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events\r\n */\r\nexport class PointerDragBehavior implements Behavior<AbstractMesh> {\r\n    private static _AnyMouseId = -2;\r\n    /**\r\n     * Abstract mesh the behavior is set on\r\n     */\r\n    public attachedNode: AbstractMesh;\r\n    protected _dragPlane: Mesh;\r\n    private _scene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private static _PlaneScene: Scene;\r\n    private _useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;\r\n    private _activeDragButton: number = -1;\r\n    private _activePointerInfo: Nullable<PointerInfo>;\r\n    /**\r\n     * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)\r\n     */\r\n    public maxDragAngle = 0;\r\n    /**\r\n     * Butttons that can be used to initiate a drag\r\n     */\r\n    public dragButtons = [0, 1, 2];\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useAlternatePickedPointAboveMaxDragAngle = false;\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public currentDraggingPointerId = -1;\r\n    /**\r\n     * The last position where the pointer hit the drag plane in world space\r\n     */\r\n    public lastDragPosition: Vector3;\r\n    /**\r\n     * If the behavior is currently in a dragging state\r\n     */\r\n    public dragging = false;\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n    /**\r\n     * If the drag plane orientation should be updated during the dragging (Default: true)\r\n     */\r\n    public updateDragPlane = true;\r\n    // Debug mode will display drag planes to help visualize behavior\r\n    private _debugMode = false;\r\n    private _moving = false;\r\n    /**\r\n     *  Fires each time the attached mesh is dragged with the pointer\r\n     *  * delta between last drag position and current drag position in world space\r\n     *  * dragDistance along the drag axis\r\n     *  * dragPlaneNormal normal of the current drag plane used during the drag\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragObservable = new Observable<{\r\n        delta: Vector3;\r\n        dragPlanePoint: Vector3;\r\n        dragPlaneNormal: Vector3;\r\n        dragDistance: number;\r\n        pointerId: number;\r\n        pointerInfo: Nullable<PointerInfo>;\r\n    }>();\r\n    /**\r\n     *  Fires each time a drag begins (eg. mouse down on mesh)\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragStartObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number; pointerInfo: Nullable<PointerInfo> }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragEndObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number; pointerInfo: Nullable<PointerInfo> }>();\r\n    /**\r\n     *  Fires each time behavior enabled state changes\r\n     */\r\n    public onEnabledObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     *  If the attached mesh should be moved when dragged\r\n     */\r\n    public moveAttached = true;\r\n\r\n    /**\r\n     *  If the drag behavior will react to drag events (Default: true)\r\n     */\r\n    public set enabled(value: boolean) {\r\n        if (value != this._enabled) {\r\n            this.onEnabledObservable.notifyObservers(value);\r\n        }\r\n        this._enabled = value;\r\n    }\r\n\r\n    public get enabled() {\r\n        return this._enabled;\r\n    }\r\n    private _enabled = true;\r\n\r\n    /**\r\n     * If pointer events should start and release the drag (Default: true)\r\n     */\r\n    public startAndReleaseDragOnPointerEvents = true;\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)\r\n     */\r\n    public useObjectOrientationForDragging = true;\r\n\r\n    private _options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 };\r\n\r\n    /**\r\n     * Gets the options used by the behavior\r\n     */\r\n    public get options(): { dragAxis?: Vector3; dragPlaneNormal?: Vector3 } {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Sets the options used by the behavior\r\n     */\r\n    public set options(options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Creates a pointer drag behavior that can be attached to a mesh\r\n     * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)\r\n     * @param options.dragAxis\r\n     * @param options.dragPlaneNormal\r\n     */\r\n    constructor(options?: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options ? options : {};\r\n\r\n        let optionCount = 0;\r\n        if (this._options.dragAxis) {\r\n            optionCount++;\r\n        }\r\n        if (this._options.dragPlaneNormal) {\r\n            optionCount++;\r\n        }\r\n        if (optionCount > 1) {\r\n            throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predicate to determine if it is valid to move the object to a new position when it is moved\r\n     * @param targetPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public validateDrag = (targetPosition: Vector3) => {\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"PointerDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _alternatePickedPoint = new Vector3(0, 0, 0);\r\n    private _worldDragAxis = new Vector3(0, 0, 0);\r\n    private _targetPosition = new Vector3(0, 0, 0);\r\n    private _attachedToElement: boolean = false;\r\n    /**\r\n     * Attaches the drag behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     * @param predicate Predicate to use for pick filtering\r\n     */\r\n    public attach(ownerNode: AbstractMesh, predicate?: (m: AbstractMesh) => boolean): void {\r\n        this._scene = ownerNode.getScene();\r\n        ownerNode.isNearGrabbable = true;\r\n        this.attachedNode = ownerNode;\r\n\r\n        // Initialize drag plane to not interfere with existing scene\r\n        if (!PointerDragBehavior._PlaneScene) {\r\n            if (this._debugMode) {\r\n                PointerDragBehavior._PlaneScene = this._scene;\r\n            } else {\r\n                PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n                PointerDragBehavior._PlaneScene.detachControl();\r\n                this._scene.onDisposeObservable.addOnce(() => {\r\n                    PointerDragBehavior._PlaneScene.dispose();\r\n                    (<any>PointerDragBehavior._PlaneScene) = null;\r\n                });\r\n            }\r\n        }\r\n        this._dragPlane = CreatePlane(\r\n            \"pointerDragPlane\",\r\n            { size: this._debugMode ? 1 : 10000, updatable: false, sideOrientation: Mesh.DOUBLESIDE },\r\n            PointerDragBehavior._PlaneScene\r\n        );\r\n\r\n        // State of the drag\r\n        this.lastDragPosition = new Vector3(0, 0, 0);\r\n\r\n        const pickPredicate = predicate\r\n            ? predicate\r\n            : (m: AbstractMesh) => {\r\n                  return this.attachedNode == m || m.isDescendantOf(this.attachedNode);\r\n              };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.enabled) {\r\n                // If behavior is disabled before releaseDrag is ever called, call it now.\r\n                if (this._attachedToElement) {\r\n                    this.releaseDrag();\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    !this.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {\r\n                        this._activeDragButton = pointerInfo.event.button;\r\n                        this._activePointerInfo = pointerInfo;\r\n                        this._startDrag((<IPointerEvent>pointerInfo.event).pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);\r\n                    }\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    this.currentDraggingPointerId == (<IPointerEvent>pointerInfo.event).pointerId &&\r\n                    (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)\r\n                ) {\r\n                    this.releaseDrag();\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n\r\n                // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved\r\n                if (this.currentDraggingPointerId === PointerDragBehavior._AnyMouseId && pointerId !== PointerDragBehavior._AnyMouseId) {\r\n                    const evt = <IPointerEvent>pointerInfo.event;\r\n                    const isMouseEvent = evt.pointerType === \"mouse\" || (!this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent);\r\n                    if (isMouseEvent) {\r\n                        if (this._lastPointerRay[this.currentDraggingPointerId]) {\r\n                            this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];\r\n                            delete this._lastPointerRay[this.currentDraggingPointerId];\r\n                        }\r\n                        this.currentDraggingPointerId = pointerId;\r\n                    }\r\n                }\r\n\r\n                // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()\r\n                if (!this._lastPointerRay[pointerId]) {\r\n                    this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());\r\n                }\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {\r\n                    this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);\r\n\r\n                    if (this.currentDraggingPointerId == pointerId && this.dragging) {\r\n                        this._moveDrag(pointerInfo.pickInfo.ray);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (this._moving && this.moveAttached) {\r\n                let needMatrixUpdate = false;\r\n                PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n                // Slowly move mesh to avoid jitter\r\n                this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(this.dragDeltaRatio);\r\n                this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);\r\n                if (this.validateDrag(this._tmpVector)) {\r\n                    this.attachedNode.setAbsolutePosition(this._tmpVector);\r\n                    needMatrixUpdate = true;\r\n                }\r\n                PivotTools._RestorePivotPoint(this.attachedNode);\r\n                if (needMatrixUpdate) {\r\n                    this.attachedNode.computeWorldMatrix();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force release the drag action by code.\r\n     */\r\n    public releaseDrag() {\r\n        if (this.dragging) {\r\n            this.dragging = false;\r\n            this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });\r\n        }\r\n\r\n        this.currentDraggingPointerId = -1;\r\n        this._activeDragButton = -1;\r\n        this._activePointerInfo = null;\r\n        this._moving = false;\r\n\r\n        // Reattach camera controls\r\n        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {\r\n            if (this._scene.activeCamera.getClassName() === \"ArcRotateCamera\") {\r\n                const arcRotateCamera = this._scene.activeCamera as ArcRotateCamera;\r\n                arcRotateCamera.attachControl(\r\n                    arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true,\r\n                    arcRotateCamera._useCtrlForPanning,\r\n                    arcRotateCamera._panningMouseButton\r\n                );\r\n            } else {\r\n                this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);\r\n            }\r\n            this._attachedToElement = false;\r\n        }\r\n    }\r\n\r\n    private _startDragRay = new Ray(new Vector3(), new Vector3());\r\n    private _lastPointerRay: { [key: number]: Ray } = {};\r\n    /**\r\n     * Simulates the start of a pointer drag event on the behavior\r\n     * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)\r\n     * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)\r\n     * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)\r\n     */\r\n    public startDrag(pointerId: number = PointerDragBehavior._AnyMouseId, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        this._startDrag(pointerId, fromRay, startPickedPoint);\r\n\r\n        let lastRay = this._lastPointerRay[pointerId];\r\n        if (pointerId === PointerDragBehavior._AnyMouseId) {\r\n            lastRay = this._lastPointerRay[<any>Object.keys(this._lastPointerRay)[0]];\r\n        }\r\n\r\n        if (lastRay) {\r\n            // if there was a last pointer ray drag the object there\r\n            this._moveDrag(lastRay);\r\n        }\r\n    }\r\n\r\n    protected _startDrag(pointerId: number, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {\r\n            return;\r\n        }\r\n\r\n        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n        // Create start ray from the camera to the object\r\n        if (fromRay) {\r\n            this._startDragRay.direction.copyFrom(fromRay.direction);\r\n            this._startDragRay.origin.copyFrom(fromRay.origin);\r\n        } else {\r\n            this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);\r\n            this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);\r\n            this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);\r\n        }\r\n\r\n        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);\r\n\r\n        const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);\r\n        if (pickedPoint) {\r\n            this.dragging = true;\r\n            this.currentDraggingPointerId = pointerId;\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n            this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });\r\n            this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n            // Detatch camera controls\r\n            if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {\r\n                if (this._scene.activeCamera.inputs.attachedToElement) {\r\n                    this._scene.activeCamera.detachControl();\r\n                    this._attachedToElement = true;\r\n                } else {\r\n                    this._attachedToElement = false;\r\n                }\r\n            }\r\n        } else {\r\n            this.releaseDrag();\r\n        }\r\n        PivotTools._RestorePivotPoint(this.attachedNode);\r\n    }\r\n\r\n    private _dragDelta = new Vector3();\r\n    protected _moveDrag(ray: Ray) {\r\n        this._moving = true;\r\n        const pickedPoint = this._pickWithRayOnDragPlane(ray);\r\n\r\n        if (pickedPoint) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n\r\n            if (this.updateDragPlane) {\r\n                this._updateDragPlanePosition(ray, pickedPoint);\r\n            }\r\n            let dragLength = 0;\r\n            // depending on the drag mode option drag accordingly\r\n            if (this._options.dragAxis) {\r\n                // Convert local drag axis to world if useObjectOrientationForDragging\r\n                this.useObjectOrientationForDragging\r\n                    ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis)\r\n                    : this._worldDragAxis.copyFrom(this._options.dragAxis);\r\n\r\n                // Project delta drag from the drag plane onto the drag axis\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);\r\n                dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);\r\n                this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);\r\n            } else {\r\n                dragLength = this._dragDelta.length();\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);\r\n            }\r\n            this._targetPosition.addInPlace(this._dragDelta);\r\n            this.onDragObservable.notifyObservers({\r\n                dragDistance: dragLength,\r\n                delta: this._dragDelta,\r\n                dragPlanePoint: pickedPoint,\r\n                dragPlaneNormal: this._dragPlane.forward,\r\n                pointerId: this.currentDraggingPointerId,\r\n                pointerInfo: this._activePointerInfo,\r\n            });\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n\r\n            PivotTools._RestorePivotPoint(this.attachedNode);\r\n        }\r\n    }\r\n\r\n    private _pickWithRayOnDragPlane(ray: Nullable<Ray>) {\r\n        if (!ray) {\r\n            return null;\r\n        }\r\n\r\n        // Calculate angle between plane normal and ray\r\n        let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));\r\n        // Correct if ray is casted from oposite side\r\n        if (angle > Math.PI / 2) {\r\n            angle = Math.PI - angle;\r\n        }\r\n\r\n        // If the angle is too perpendicular to the plane pick another point on the plane where it is looking\r\n        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {\r\n            if (this._useAlternatePickedPointAboveMaxDragAngle) {\r\n                // Invert ray direction along the towards object axis\r\n                this._tmpVector.copyFrom(ray.direction);\r\n                this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.normalize();\r\n                this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));\r\n                this._tmpVector.addInPlace(this._alternatePickedPoint);\r\n\r\n                // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point\r\n                const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);\r\n                this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.addInPlace(this._tmpVector);\r\n                this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);\r\n                return this._alternatePickedPoint;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const pickResult = PointerDragBehavior._PlaneScene.pickWithRay(ray, (m) => {\r\n            return m == this._dragPlane;\r\n        });\r\n        if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {\r\n            return pickResult.pickedPoint;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Variables to avoid instantiation in the below method\r\n    private _pointA = new Vector3(0, 0, 0);\r\n    private _pointC = new Vector3(0, 0, 0);\r\n    private _localAxis = new Vector3(0, 0, 0);\r\n    private _lookAt = new Vector3(0, 0, 0);\r\n    // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera\r\n    private _updateDragPlanePosition(ray: Ray, dragPlanePosition: Vector3) {\r\n        this._pointA.copyFrom(dragPlanePosition);\r\n        if (this._options.dragAxis) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragAxis);\r\n\r\n            // Calculate plane normal that is the cross product of local axis and (eye-dragPlanePosition)\r\n            ray.origin.subtractToRef(this._pointA, this._pointC);\r\n            this._pointC.normalize();\r\n            if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {\r\n                // the drag axis is colinear with the (eye to position) ray. The cross product will give jittered values.\r\n                // A new axis vector need to be computed\r\n                if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {\r\n                    this._lookAt.copyFrom(Vector3.Right());\r\n                } else {\r\n                    this._lookAt.copyFrom(Vector3.UpReadOnly);\r\n                }\r\n            } else {\r\n                Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);\r\n                // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendicular to camera\r\n                Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);\r\n                this._lookAt.normalize();\r\n            }\r\n\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._lookAt, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else if (this._options.dragPlaneNormal) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragPlaneNormal);\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._localAxis, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else {\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._dragPlane.lookAt(ray.origin);\r\n        }\r\n        // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)\r\n        this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n        this._dragPlane.computeWorldMatrix(true);\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._lastPointerRay = {};\r\n        if (this.attachedNode) {\r\n            this.attachedNode.isNearGrabbable = false;\r\n        }\r\n        if (this._pointerObserver) {\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._beforeRenderObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n        if (this._dragPlane) {\r\n            this._dragPlane.dispose();\r\n        }\r\n        this.releaseDrag();\r\n    }\r\n}\r\n","import type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { DataArray } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This class is a small wrapper around a native buffer that can be read and/or written\r\n */\r\nexport class StorageBuffer {\r\n    private _engine: ThinEngine;\r\n    private _buffer: DataBuffer;\r\n    private _bufferSize: number;\r\n    private _creationFlags: number;\r\n\r\n    /**\r\n     * Creates a new storage buffer instance\r\n     * @param engine The engine the buffer will be created inside\r\n     * @param size The size of the buffer in bytes\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.\r\n     */\r\n    constructor(engine: ThinEngine, size: number, creationFlags = Constants.BUFFER_CREATIONFLAG_READWRITE) {\r\n        this._engine = engine;\r\n        this._engine._storageBuffers.push(this);\r\n        this._create(size, creationFlags);\r\n    }\r\n\r\n    private _create(size: number, creationFlags: number): void {\r\n        this._bufferSize = size;\r\n        this._creationFlags = creationFlags;\r\n        this._buffer = this._engine.createStorageBuffer(size, creationFlags);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._create(this._bufferSize, this._creationFlags);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): DataBuffer {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Updates the storage buffer\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public update(data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);\r\n    }\r\n\r\n    /**\r\n     * Reads data from the storage buffer\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    public read(offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n        return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer);\r\n    }\r\n\r\n    /**\r\n     * Disposes the storage buffer\r\n     */\r\n    public dispose(): void {\r\n        const storageBuffers = this._engine._storageBuffers;\r\n        const index = storageBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            storageBuffers[index] = storageBuffers[storageBuffers.length - 1];\r\n            storageBuffers.pop();\r\n        }\r\n\r\n        this._engine._releaseBuffer(this._buffer);\r\n        this._buffer = null as any;\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n/**\r\n * Manage the gamepad inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the gamepad the input is gathering event from.\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadRotationSensibility = 80;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad) {\r\n            const camera = this.camera;\r\n            const rsValues = this.gamepad.rightStick;\r\n\r\n            if (rsValues) {\r\n                if (rsValues.x != 0) {\r\n                    const normalizedRX = rsValues.x / this.gamepadRotationSensibility;\r\n                    if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\r\n                        camera.inertialAlphaOffset += normalizedRX;\r\n                    }\r\n                }\r\n\r\n                if (rsValues.y != 0) {\r\n                    const normalizedRY = (rsValues.y / this.gamepadRotationSensibility) * this._yAxisScale;\r\n                    if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\r\n                        camera.inertialBetaOffset += normalizedRY;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (lsValues && lsValues.y != 0) {\r\n                const normalizedLY = lsValues.y / this.gamepadMoveSensibility;\r\n                if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\r\n                    this.camera.inertialRadiusOffset -= normalizedLY;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Listen to keyboard events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraKeyboardInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysForward = [87];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysBackward = [83];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [69];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [81];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [68];\r\n\r\n    /**\r\n     * The list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [65];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                if (\r\n                    this.keysForward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysRight.indexOf(evt.keyCode) !== -1\r\n                ) {\r\n                    const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                    if (index === -1) {\r\n                        this._keys.push(evt.keyCode);\r\n                    }\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n            } else {\r\n                if (\r\n                    this.keysForward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysBackward.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                    this.keysRight.indexOf(evt.keyCode) !== -1\r\n                ) {\r\n                    const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                    if (index >= 0) {\r\n                        this._keys.splice(index, 1);\r\n                    }\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraKeyboardInput\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysForward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysBackward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraKeyboardInput\"] = FlyCameraKeyboardInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Pitch control.\r\n     */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n     * Assign buttons for Roll control.\r\n     */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n    private _noPreventDefault: boolean | undefined;\r\n    private _element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p: any) => {\r\n            this._pointerInput(p);\r\n        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.camera.rollCorrect) {\r\n                this.camera.restoreRoll(this.camera.rollCorrect);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this._previousPosition = null;\r\n            this._noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any): void {\r\n        const e = <IPointerEvent>p.event;\r\n\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        const srcElement = <HTMLElement>e.target;\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN) {\r\n            try {\r\n                srcElement?.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n                this._element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        }\r\n        // Mouse up.\r\n        else if (p.type === PointerEventTypes.POINTERUP) {\r\n            try {\r\n                srcElement?.releasePointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.activeButton = -1;\r\n\r\n            this._previousPosition = null;\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        // Mouse move.\r\n        else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n            if (!this._previousPosition) {\r\n                if (engine.isPointerLock) {\r\n                    this._onMouseMove(p.event);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            const offsetX = e.clientX - this._previousPosition.x;\r\n            const offsetY = e.clientY - this._previousPosition.y;\r\n\r\n            this._rotateCamera(offsetX, offsetY);\r\n\r\n            this._previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n            };\r\n\r\n            if (!this._noPreventDefault) {\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        const camera = this.camera;\r\n        const engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        const offsetX = e.movementX;\r\n        const offsetY = e.movementY;\r\n\r\n        this._rotateCamera(offsetX, offsetY);\r\n\r\n        this._previousPosition = null;\r\n\r\n        if (!this._noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    private _rotateCamera(offsetX: number, offsetY: number): void {\r\n        const camera = this.camera;\r\n        const scene = this.camera.getScene();\r\n\r\n        if (scene.useRightHandedSystem) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        const x = offsetX / this.angularSensibility;\r\n        const y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\r\n        let rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (\r\n            this.buttonsPitch.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (\r\n            this.buttonsYaw.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90 plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                const bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (\r\n            this.buttonsRoll.some((v) => {\r\n                return v === this.activeButton;\r\n            })\r\n        ) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n","import type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of a follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraKeyboardMoveInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetIncr = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetDecr = [40];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)\r\n     */\r\n    @serialize()\r\n    public keysHeightOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetIncr = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetDecr = [39];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierAlt: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)\r\n     */\r\n    @serialize()\r\n    public keysRotationOffsetModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-in action (decrease radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusIncr = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the zoom-out action (increase radius)\r\n     */\r\n    @serialize()\r\n    public keysRadiusDecr = [38];\r\n\r\n    /**\r\n     * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierAlt: boolean = true;\r\n\r\n    /**\r\n     * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierCtrl: boolean = false;\r\n\r\n    /**\r\n     * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)\r\n     */\r\n    @serialize()\r\n    public keysRadiusModifierShift: boolean = false;\r\n\r\n    /**\r\n     * Defines the rate of change of heightOffset.\r\n     */\r\n    @serialize()\r\n    public heightSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of rotationOffset.\r\n     */\r\n    @serialize()\r\n    public rotationSensibility: number = 1;\r\n\r\n    /**\r\n     * Defines the rate of change of radius.\r\n     */\r\n    @serialize()\r\n    public radiusSensibility: number = 1;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _shiftPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n                    this._shiftPressed = evt.shiftKey;\r\n\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRadiusDecr.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            this._keys.forEach((keyCode) => {\r\n                if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset += this.heightSensibility;\r\n                } else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {\r\n                    this.camera.heightOffset -= this.heightSensibility;\r\n                } else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset += this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {\r\n                    this.camera.rotationOffset -= this.rotationSensibility;\r\n                    this.camera.rotationOffset %= 360;\r\n                } else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius += this.radiusSensibility;\r\n                } else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {\r\n                    this.camera.radius -= this.radiusSensibility;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the heightOffset value.\r\n     */\r\n    private _modifierHeightOffset(): boolean {\r\n        return (\r\n            this.keysHeightOffsetModifierAlt === this._altPressed &&\r\n            this.keysHeightOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysHeightOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the rotationOffset value.\r\n     */\r\n    private _modifierRotationOffset(): boolean {\r\n        return (\r\n            this.keysRotationOffsetModifierAlt === this._altPressed &&\r\n            this.keysRotationOffsetModifierCtrl === this._ctrlPressed &&\r\n            this.keysRotationOffsetModifierShift === this._shiftPressed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to\r\n     * allow modification of the radius value.\r\n     */\r\n    private _modifierRadius(): boolean {\r\n        return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraKeyboardMoveInput\"] = FollowCameraKeyboardMoveInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraMouseWheelInput implements ICameraInput<FollowCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera moves in\r\n     * relation to mouseWheel events.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n\r\n            const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));\r\n            if (this.wheelDeltaPercentage) {\r\n                console.assert(\r\n                    <number>(<unknown>this.axisControlRadius) + <number>(<unknown>this.axisControlHeight) + <number>(<unknown>this.axisControlRotation) <= 1,\r\n                    \"wheelDeltaPercentage only usable when mouse wheel \" +\r\n                        \"controls ONE axis. \" +\r\n                        \"Currently enabled: \" +\r\n                        \"axisControlRadius: \" +\r\n                        this.axisControlRadius +\r\n                        \", axisControlHeightOffset: \" +\r\n                        this.axisControlHeight +\r\n                        \", axisControlRotationOffset: \" +\r\n                        this.axisControlRotation\r\n                );\r\n\r\n                if (this.axisControlRadius) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;\r\n                } else if (this.axisControlHeight) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;\r\n                } else if (this.axisControlRotation) {\r\n                    delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;\r\n                }\r\n            } else {\r\n                delta = wheelDelta * this.wheelPrecision;\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.axisControlRadius) {\r\n                    this.camera.radius += delta;\r\n                } else if (this.axisControlHeight) {\r\n                    this.camera.heightOffset -= delta;\r\n                } else if (this.axisControlRotation) {\r\n                    this.camera.rotationOffset -= delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FollowCameraMouseWheelInput\"] = FollowCameraMouseWheelInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FollowCamera } from \"../../Cameras/followCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an follow camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FollowCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the X axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     * A negative number will reverse the axis direction.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 10000.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisXControlRotation: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRadius: boolean = false;\r\n\r\n    /**\r\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlHeight: boolean = true;\r\n\r\n    /**\r\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisYControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRadius: boolean = true;\r\n\r\n    /**\r\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlHeight: boolean = false;\r\n\r\n    /**\r\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\r\n     */\r\n    @serialize()\r\n    public axisPinchControlRotation: boolean = false;\r\n\r\n    /**\r\n     * Log error messages if basic misconfiguration has occurred.\r\n     */\r\n    public warningEnable: boolean = true;\r\n\r\n    public onTouch(pointA: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        this._warning();\r\n\r\n        if (this.axisXControlRotation) {\r\n            this.camera.rotationOffset += offsetX / this.angularSensibilityX;\r\n        } else if (this.axisYControlRotation) {\r\n            this.camera.rotationOffset += offsetY / this.angularSensibilityX;\r\n        }\r\n\r\n        if (this.axisXControlHeight) {\r\n            this.camera.heightOffset += offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlHeight) {\r\n            this.camera.heightOffset += offsetY / this.angularSensibilityY;\r\n        }\r\n\r\n        if (this.axisXControlRadius) {\r\n            this.camera.radius -= offsetX / this.angularSensibilityY;\r\n        } else if (this.axisYControlRadius) {\r\n            this.camera.radius -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    public onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / ((this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n\r\n        if (this.pinchDeltaPercentage) {\r\n            pinchDelta *= 0.01 * this.pinchDeltaPercentage;\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\r\n            }\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\r\n            }\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta * this.camera.radius;\r\n            }\r\n        } else {\r\n            if (this.axisPinchControlRotation) {\r\n                this.camera.rotationOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlHeight) {\r\n                this.camera.heightOffset += pinchDelta;\r\n            }\r\n\r\n            if (this.axisPinchControlRadius) {\r\n                this.camera.radius -= pinchDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Check for obvious misconfiguration. */\r\n    private _warningCounter: number = 0;\r\n    private _warning(): void {\r\n        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\r\n            return;\r\n        }\r\n        const warn =\r\n            \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\r\n\r\n        console.assert(\r\n            <number>(<unknown>this.axisXControlRotation) + <number>(<unknown>this.axisXControlHeight) + <number>(<unknown>this.axisXControlRadius) <= 1,\r\n            warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisYControlRotation) + <number>(<unknown>this.axisYControlHeight) + <number>(<unknown>this.axisYControlRadius) <= 1,\r\n            warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius\r\n        );\r\n        console.assert(\r\n            <number>(<unknown>this.axisPinchControlRotation) + <number>(<unknown>this.axisPinchControlHeight) + <number>(<unknown>this.axisPinchControlRadius) <= 1,\r\n            warn +\r\n                \"axisPinchControlRotation: \" +\r\n                this.axisPinchControlRotation +\r\n                \", axisPinchControlHeight: \" +\r\n                this.axisPinchControlHeight +\r\n                \", axisPinchControlRadius: \" +\r\n                this.axisPinchControlRadius\r\n        );\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Manage the gamepad inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Define the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Define the Gamepad controlling the input\r\n     */\r\n    public gamepad: Nullable<Gamepad>;\r\n\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadAngularSensibility = 200;\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for for to prevent jittering.\r\n     */\r\n    @serialize()\r\n    public gamepadMoveSensibility = 40;\r\n\r\n    /**\r\n     * Defines the minimum value at which any analog stick input is ignored.\r\n     * Note: This value should only be a value between 0 and 1.\r\n     */\r\n    public deadzoneDelta = 0.1;\r\n\r\n    private _yAxisScale = 1.0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted\r\n     */\r\n    public get invertYAxis() {\r\n        return this._yAxisScale !== 1.0;\r\n    }\r\n\r\n    public set invertYAxis(value: boolean) {\r\n        this._yAxisScale = value ? -1.0 : 1.0;\r\n    }\r\n\r\n    // private members\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _cameraTransform: Matrix = Matrix.Identity();\r\n    private _deltaTransform: Vector3 = Vector3.Zero();\r\n    private _vector3: Vector3 = Vector3.Zero();\r\n    private _vector2: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     */\r\n    public attachControl(): void {\r\n        const manager = this.camera.getScene().gamepadManager;\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n                // prioritize XBOX gamepads.\r\n                if (!this.gamepad || gamepad.type === Gamepad.XBOX) {\r\n                    this.gamepad = gamepad;\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (this.gamepad === gamepad) {\r\n                this.gamepad = null;\r\n            }\r\n        });\r\n\r\n        // check if there are already other controllers connected\r\n        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);\r\n        // if no xbox controller was found, but there are gamepad controllers, take the first one\r\n        if (!this.gamepad && manager.gamepads.length) {\r\n            this.gamepad = manager.gamepads[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n        this.gamepad = null;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this.gamepad && this.gamepad.leftStick) {\r\n            const camera = this.camera;\r\n            const lsValues = this.gamepad.leftStick;\r\n            if (this.gamepadMoveSensibility !== 0) {\r\n                lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;\r\n                lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;\r\n            }\r\n\r\n            let rsValues = this.gamepad.rightStick;\r\n            if (rsValues && this.gamepadAngularSensibility !== 0) {\r\n                rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;\r\n                rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;\r\n            } else {\r\n                rsValues = { x: 0, y: 0 };\r\n            }\r\n\r\n            if (!camera.rotationQuaternion) {\r\n                Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\r\n            } else {\r\n                camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\r\n            }\r\n\r\n            const speed = camera._computeLocalCameraSpeed() * 50.0;\r\n            this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);\r\n\r\n            Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\r\n            camera.cameraDirection.addInPlace(this._deltaTransform);\r\n            this._vector2.copyFromFloats(rsValues.y, rsValues.x);\r\n            camera.cameraRotation.addInPlace(this._vector2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraGamepadInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"gamepad\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\r\n","import type { Camera } from \"../camera\";\r\nimport { PassPostProcess } from \"../../PostProcesses/passPostProcess\";\r\nimport { AnaglyphPostProcess } from \"../../PostProcesses/anaglyphPostProcess\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setStereoscopicAnaglyphRigMode(camera: Camera) {\r\n    camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\r\n    camera._rigCameras[1]._rigPostProcess = new AnaglyphPostProcess(camera.name + \"_anaglyph\", 1.0, camera._rigCameras);\r\n}\r\n","import { Camera } from \"../camera\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport { PassPostProcess } from \"../../PostProcesses/passPostProcess\";\r\nimport { StereoscopicInterlacePostProcessI } from \"../../PostProcesses/stereoscopicInterlacePostProcess\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setStereoscopicRigMode(camera: Camera): void {\r\n    const isStereoscopicHoriz =\r\n        camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    const isCrossEye = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    const isInterlaced = camera.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_INTERLACED;\r\n    // Use post-processors for interlacing\r\n    if (isInterlaced) {\r\n        camera._rigCameras[0]._rigPostProcess = new PassPostProcess(camera.name + \"_passthru\", 1.0, camera._rigCameras[0]);\r\n        camera._rigCameras[1]._rigPostProcess = new StereoscopicInterlacePostProcessI(camera.name + \"_stereoInterlace\", camera._rigCameras, false, true);\r\n    }\r\n    // Otherwise, create appropriate viewports\r\n    else {\r\n        camera._rigCameras[isCrossEye ? 1 : 0].viewport = new Viewport(0, 0, isStereoscopicHoriz ? 0.5 : 1.0, isStereoscopicHoriz ? 1.0 : 0.5);\r\n        camera._rigCameras[isCrossEye ? 0 : 1].viewport = new Viewport(\r\n            isStereoscopicHoriz ? 0.5 : 0,\r\n            isStereoscopicHoriz ? 0 : 0.5,\r\n            isStereoscopicHoriz ? 0.5 : 1.0,\r\n            isStereoscopicHoriz ? 1.0 : 0.5\r\n        );\r\n    }\r\n}\r\n","import type { Camera } from \"../camera\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { VRDistortionCorrectionPostProcess } from \"../../PostProcesses/vrDistortionCorrectionPostProcess\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { VRCameraMetrics } from \"../VR/vrCameraMetrics\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setVRRigMode(camera: Camera, rigParams: any) {\r\n    const metrics = <VRCameraMetrics>rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();\r\n\r\n    camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\r\n    camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\r\n    camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;\r\n\r\n    camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\r\n    camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\r\n    camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;\r\n\r\n    // For multiview on a webVR camera\r\n    // First multiview will be rendered to camera._multiviewTexture\r\n    // Then this postprocess will run on each eye to copy the right texture to each eye\r\n    if (metrics.multiviewEnabled) {\r\n        if (!camera.getScene().getEngine().getCaps().multiview) {\r\n            Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n            metrics.multiviewEnabled = false;\r\n        } else {\r\n            camera._useMultiviewToSingleView = true;\r\n            camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", camera, metrics.postProcessScaleFactor);\r\n        }\r\n    }\r\n\r\n    if (metrics.compensateDistortion) {\r\n        camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", camera._rigCameras[0], false, metrics);\r\n        camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", camera._rigCameras[1], true, metrics);\r\n    }\r\n}\r\n","import type { Camera } from \"../camera\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setWebVRRigMode(camera: Camera, rigParams: any) {\r\n    if (rigParams.vrDisplay) {\r\n        const leftEye = rigParams.vrDisplay.getEyeParameters(\"left\");\r\n        const rightEye = rigParams.vrDisplay.getEyeParameters(\"right\");\r\n\r\n        //Left eye\r\n        camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        camera._rigCameras[0].setCameraRigParameter(\"left\", true);\r\n        //leaving this for future reference\r\n        camera._rigCameras[0].setCameraRigParameter(\"specs\", rigParams.specs);\r\n        camera._rigCameras[0].setCameraRigParameter(\"eyeParameters\", leftEye);\r\n        camera._rigCameras[0].setCameraRigParameter(\"frameData\", rigParams.frameData);\r\n        camera._rigCameras[0].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\r\n        camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n        camera._rigCameras[0].getProjectionMatrix = camera._getWebVRProjectionMatrix;\r\n        camera._rigCameras[0].parent = camera;\r\n        camera._rigCameras[0]._getViewMatrix = camera._getWebVRViewMatrix;\r\n\r\n        //Right eye\r\n        camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        camera._rigCameras[1].setCameraRigParameter(\"eyeParameters\", rightEye);\r\n        camera._rigCameras[1].setCameraRigParameter(\"specs\", rigParams.specs);\r\n        camera._rigCameras[1].setCameraRigParameter(\"frameData\", rigParams.frameData);\r\n        camera._rigCameras[1].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\r\n        camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n        camera._rigCameras[1].getProjectionMatrix = camera._getWebVRProjectionMatrix;\r\n        camera._rigCameras[1].parent = camera;\r\n        camera._rigCameras[1]._getViewMatrix = camera._getWebVRViewMatrix;\r\n    }\r\n}\r\n","import { Matrix } from \"../../Maths/math.vector\";\r\n/**\r\n * This represents all the required metrics to create a VR camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#device-orientation-camera\r\n */\r\nexport class VRCameraMetrics {\r\n    /**\r\n     * Define the horizontal resolution off the screen.\r\n     */\r\n    public hResolution: number;\r\n    /**\r\n     * Define the vertical resolution off the screen.\r\n     */\r\n    public vResolution: number;\r\n    /**\r\n     * Define the horizontal screen size.\r\n     */\r\n    public hScreenSize: number;\r\n    /**\r\n     * Define the vertical screen size.\r\n     */\r\n    public vScreenSize: number;\r\n    /**\r\n     * Define the vertical screen center position.\r\n     */\r\n    public vScreenCenter: number;\r\n    /**\r\n     * Define the distance of the eyes to the screen.\r\n     */\r\n    public eyeToScreenDistance: number;\r\n    /**\r\n     * Define the distance between both lenses\r\n     */\r\n    public lensSeparationDistance: number;\r\n    /**\r\n     * Define the distance between both viewer's eyes.\r\n     */\r\n    public interpupillaryDistance: number;\r\n    /**\r\n     * Define the distortion factor of the VR postprocess.\r\n     * Please, touch with care.\r\n     */\r\n    public distortionK: number[];\r\n    /**\r\n     * Define the chromatic aberration correction factors for the VR post process.\r\n     */\r\n    public chromaAbCorrection: number[];\r\n    /**\r\n     * Define the scale factor of the post process.\r\n     * The smaller the better but the slower.\r\n     */\r\n    public postProcessScaleFactor: number;\r\n    /**\r\n     * Define an offset for the lens center.\r\n     */\r\n    public lensCenterOffset: number;\r\n    /**\r\n     * Define if the current vr camera should compensate the distortion of the lens or not.\r\n     */\r\n    public compensateDistortion = true;\r\n\r\n    /**\r\n     * Defines if multiview should be enabled when rendering (Default: false)\r\n     */\r\n    public multiviewEnabled = false;\r\n\r\n    /**\r\n     * Gets the rendering aspect ratio based on the provided resolutions.\r\n     */\r\n    public get aspectRatio(): number {\r\n        return this.hResolution / (2 * this.vResolution);\r\n    }\r\n\r\n    /**\r\n     * Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.\r\n     */\r\n    public get aspectRatioFov(): number {\r\n        return 2 * Math.atan((this.postProcessScaleFactor * this.vScreenSize) / (2 * this.eyeToScreenDistance));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get leftHMatrix(): Matrix {\r\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\r\n        const h = (4 * meters) / this.hScreenSize;\r\n\r\n        return Matrix.Translation(h, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get rightHMatrix(): Matrix {\r\n        const meters = this.hScreenSize / 4 - this.lensSeparationDistance / 2;\r\n        const h = (4 * meters) / this.hScreenSize;\r\n\r\n        return Matrix.Translation(-h, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get leftPreViewMatrix(): Matrix {\r\n        return Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get rightPreViewMatrix(): Matrix {\r\n        return Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Get the default VRMetrics based on the most generic setup.\r\n     * @returns the default vr metrics\r\n     */\r\n    public static GetDefault(): VRCameraMetrics {\r\n        const result = new VRCameraMetrics();\r\n\r\n        result.hResolution = 1280;\r\n        result.vResolution = 800;\r\n        result.hScreenSize = 0.149759993;\r\n        result.vScreenSize = 0.0935999975;\r\n        result.vScreenCenter = 0.0467999987;\r\n        result.eyeToScreenDistance = 0.0410000011;\r\n        result.lensSeparationDistance = 0.063500002;\r\n        result.interpupillaryDistance = 0.064000003;\r\n        result.distortionK = [1.0, 0.219999999, 0.239999995, 0.0];\r\n        result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0.0];\r\n        result.postProcessScaleFactor = 1.714605507808412;\r\n        result.lensCenterOffset = 0.151976421;\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Camera } from \"../../Cameras/camera\";\r\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera\";\r\nimport { VRCameraMetrics } from \"./vrCameraMetrics\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { setVRRigMode } from \"../RigModes/vrRigMode\";\r\n\r\nNode.AddNodeConstructor(\"VRDeviceOrientationFreeCamera\", (name, scene) => {\r\n    return () => new VRDeviceOrientationFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * Camera used to simulate VR rendering (based on FreeCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#vr-device-orientation-cameras\r\n */\r\nexport class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {\r\n    /**\r\n     * Creates a new VRDeviceOrientationFreeCamera\r\n     * @param name defines camera name\r\n     * @param position defines the start position of the camera\r\n     * @param scene defines the scene the camera belongs to\r\n     * @param compensateDistortion defines if the camera needs to compensate the lens distortion\r\n     * @param vrCameraMetrics defines the vr metrics associated to the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, compensateDistortion = true, vrCameraMetrics: VRCameraMetrics = VRCameraMetrics.GetDefault()) {\r\n        super(name, position, scene);\r\n\r\n        vrCameraMetrics.compensateDistortion = compensateDistortion;\r\n        this.setCameraRigMode(Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns VRDeviceOrientationFreeCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDeviceOrientationFreeCamera\";\r\n    }\r\n\r\n    protected _setRigMode = setVRRigMode.bind(null, this);\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\r\nimport type { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\r\nimport type { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport { Node } from \"../../node\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode\";\r\n\r\n// Side effect import to add webvr support to engine\r\nimport \"../../Engines/Extensions/engine.webVR\";\r\n\r\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose\r\n * IMPORTANT!! The data is right-hand data.\r\n * @export\r\n * @interface DevicePose\r\n */\r\nexport interface DevicePose {\r\n    /**\r\n     * The position of the device, values in array are [x,y,z].\r\n     */\r\n    readonly position: Nullable<Float32Array>;\r\n    /**\r\n     * The linearVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The linearAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearAcceleration: Nullable<Float32Array>;\r\n\r\n    /**\r\n     * The orientation of the device in a quaternion array, values in array are [x,y,z,w].\r\n     */\r\n    readonly orientation: Nullable<Float32Array>;\r\n    /**\r\n     * The angularVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The angularAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularAcceleration: Nullable<Float32Array>;\r\n}\r\n\r\n/**\r\n * Interface representing a pose controlled object in Babylon.\r\n * A pose controlled object has both regular pose values as well as pose values\r\n * from an external device such as a VR head mounted display\r\n */\r\nexport interface PoseControlled {\r\n    /**\r\n     * The position of the object in babylon space.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation quaternion of the object in babylon space.\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n    /**\r\n     * The position of the device in babylon space.\r\n     */\r\n    devicePosition?: Vector3;\r\n    /**\r\n     * The rotation quaternion of the device in babylon space.\r\n     */\r\n    deviceRotationQuaternion: Quaternion;\r\n    /**\r\n     * The raw pose coming from the device.\r\n     */\r\n    rawPose: Nullable<DevicePose>;\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    deviceScaleFactor: number;\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData the pose data to update the object with\r\n     */\r\n    updateFromDevice(poseData: DevicePose): void;\r\n}\r\n\r\n/**\r\n * Set of options to customize the webVRCamera\r\n */\r\nexport interface WebVROptions {\r\n    /**\r\n     * Sets if the webVR camera should be tracked to the vrDevice. (default: true)\r\n     */\r\n    trackPosition?: boolean;\r\n    /**\r\n     * Sets the scale of the vrDevice in babylon space. (default: 1)\r\n     */\r\n    positionScale?: number;\r\n    /**\r\n     * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)\r\n     */\r\n    displayName?: string;\r\n    /**\r\n     * Should the native controller meshes be initialized. (default: true)\r\n     */\r\n    controllerMeshes?: boolean;\r\n    /**\r\n     * Creating a default HemiLight only on controllers. (default: true)\r\n     */\r\n    defaultLightingOnControllers?: boolean;\r\n    /**\r\n     * If you don't want to use the default VR button of the helper. (default: false)\r\n     */\r\n    useCustomVRButton?: boolean;\r\n\r\n    /**\r\n     * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)\r\n     */\r\n    customVRButton?: HTMLButtonElement;\r\n\r\n    /**\r\n     * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)\r\n     */\r\n    rayLength?: number;\r\n\r\n    /**\r\n     * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)\r\n     */\r\n    defaultHeight?: number;\r\n\r\n    /**\r\n     * If multiview should be used if available (default: false)\r\n     */\r\n    useMultiview?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/features/featuresDeepDive/webXR\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRCamera\r\n */\r\nexport class WebVRFreeCamera extends FreeCamera implements PoseControlled {\r\n    /**\r\n     * @internal\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\r\n    public _vrDevice: any = null;\r\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\r\n    public rawPose: Nullable<DevicePose> = null;\r\n    private _onVREnabled: (success: boolean) => void;\r\n    private _specsVersion: string = \"1.1\";\r\n    private _attached: boolean = false;\r\n\r\n    private _frameData: any;\r\n\r\n    protected _descendants: Array<Node> = [];\r\n\r\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\r\n    private _deviceRoomPosition = Vector3.Zero();\r\n    /** @internal */\r\n    public _deviceRoomRotationQuaternion = Quaternion.Identity();\r\n\r\n    private _standingMatrix: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Represents device position in babylon space.\r\n     */\r\n    public devicePosition = Vector3.Zero();\r\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\r\n    public deviceRotationQuaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    public deviceScaleFactor: number = 1;\r\n\r\n    private _deviceToWorld = Matrix.Identity();\r\n    private _worldToDevice = Matrix.Identity();\r\n\r\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\r\n    public controllers: Array<WebVRController> = [];\r\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\r\n    public onControllersAttachedObservable = new Observable<Array<WebVRController>>();\r\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\r\n    public onControllerMeshLoadedObservable = new Observable<WebVRController>();\r\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\r\n    public onPoseUpdatedFromDeviceObservable = new Observable<any>();\r\n    private _poseSet = false;\r\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\r\n    public rigParenting: boolean = true;\r\n\r\n    private _lightOnControllers: HemisphericLight;\r\n\r\n    private _defaultHeight?: number = undefined;\r\n\r\n    /**\r\n     * Instantiates a WebVRFreeCamera.\r\n     * @param name The name of the WebVRFreeCamera\r\n     * @param position The starting anchor position for the camera\r\n     * @param scene The scene the camera belongs to\r\n     * @param _webVROptions a set of customizable options for the webVRCamera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, private _webVROptions: WebVROptions = {}) {\r\n        super(name, position, scene);\r\n        this._cache.position = Vector3.Zero();\r\n        if (_webVROptions.defaultHeight) {\r\n            this._defaultHeight = _webVROptions.defaultHeight;\r\n            this.position.y = this._defaultHeight;\r\n        }\r\n\r\n        this.minZ = 0.1;\r\n\r\n        //legacy support - the compensation boolean was removed.\r\n        if (arguments.length === 5) {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            this._webVROptions = arguments[4];\r\n        }\r\n\r\n        // default webVR options\r\n        if (this._webVROptions.trackPosition == undefined) {\r\n            this._webVROptions.trackPosition = true;\r\n        }\r\n        if (this._webVROptions.controllerMeshes == undefined) {\r\n            this._webVROptions.controllerMeshes = true;\r\n        }\r\n        if (this._webVROptions.defaultLightingOnControllers == undefined) {\r\n            this._webVROptions.defaultLightingOnControllers = true;\r\n        }\r\n\r\n        this.rotationQuaternion = new Quaternion();\r\n\r\n        if (this._webVROptions && this._webVROptions.positionScale) {\r\n            this.deviceScaleFactor = this._webVROptions.positionScale;\r\n        }\r\n\r\n        //enable VR\r\n        const engine = this.getEngine();\r\n        this._onVREnabled = (success: boolean) => {\r\n            if (success) {\r\n                this.initControllers();\r\n            }\r\n        };\r\n        engine.onVRRequestPresentComplete.add(this._onVREnabled);\r\n        engine.initWebVR().add((event: IDisplayChangedEventArgs) => {\r\n            if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\r\n                return;\r\n            }\r\n\r\n            this._vrDevice = event.vrDisplay;\r\n\r\n            //reset the rig parameters.\r\n            this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });\r\n\r\n            if (this._attached) {\r\n                this.getEngine().enableVR(this._webVROptions);\r\n            }\r\n        });\r\n\r\n        if (typeof VRFrameData !== \"undefined\") {\r\n            this._frameData = new VRFrameData();\r\n        }\r\n\r\n        if (_webVROptions.useMultiview) {\r\n            if (!this.getScene().getEngine().getCaps().multiview) {\r\n                Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n                this._useMultiviewToSingleView = false;\r\n            } else {\r\n                this._useMultiviewToSingleView = true;\r\n                this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The idea behind the following lines:\r\n         * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n         * the second will not show it correctly.\r\n         *\r\n         * To solve this - each object that has the camera as parent will be added to a protected array.\r\n         * When the rig camera renders, it will take this array and set all of those to be its children.\r\n         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n         * Amazing!\r\n         */\r\n        this.getScene().onBeforeCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants = this.getDescendants(true, (n) => {\r\n                    // don't take the cameras or the controllers!\r\n                    const isController = this.controllers.some((controller) => {\r\n                        return controller._mesh === n;\r\n                    });\r\n                    const isRigCamera = this._rigCameras.indexOf(<Camera>n) !== -1;\r\n                    return !isController && !isRigCamera;\r\n                });\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = camera;\r\n                });\r\n            }\r\n        });\r\n\r\n        this.getScene().onAfterCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = this;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _setRigMode = setWebVRRigMode.bind(null, this);\r\n\r\n    /**\r\n     * Gets the device distance from the ground in meters.\r\n     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n     */\r\n    public deviceDistanceToRoomGround(): number {\r\n        if (this._standingMatrix) {\r\n            // Add standing matrix offset to get real offset from ground in room\r\n            this._standingMatrix.getTranslationToRef(this._workingVector);\r\n            return this._deviceRoomPosition.y + this._workingVector.y;\r\n        }\r\n        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\r\n        return this._defaultHeight || 0;\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public useStandingMatrix(callback = (bool: boolean) => {}) {\r\n        // Use standing matrix if available\r\n        this.getEngine()\r\n            .initWebVRAsync()\r\n            .then((result) => {\r\n                if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {\r\n                    callback(false);\r\n                } else {\r\n                    this._standingMatrix = new Matrix();\r\n                    Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\r\n                    if (!this.getScene().useRightHandedSystem) {\r\n                        if (this._standingMatrix) {\r\n                            this._standingMatrix.toggleModelMatrixHandInPlace();\r\n                        }\r\n                    }\r\n                    callback(true);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @returns A promise with a boolean set to if the standing matrix is supported.\r\n     */\r\n    public useStandingMatrixAsync(): Promise<boolean> {\r\n        return new Promise((res) => {\r\n            this.useStandingMatrix((supported) => {\r\n                res(supported);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the camera\r\n     */\r\n    public dispose(): void {\r\n        this._detachIfAttached();\r\n        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\r\n        if (this._updateCacheWhenTrackingDisabledObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets a vrController by name.\r\n     * @param name The name of the controller to retrieve\r\n     * @returns the controller matching the name specified or null if not found\r\n     */\r\n    public getControllerByName(name: string): Nullable<WebVRController> {\r\n        for (const gp of this.controllers) {\r\n            if (gp.hand === name) {\r\n                return gp;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _leftController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\r\n    public get leftController(): Nullable<WebVRController> {\r\n        if (!this._leftController) {\r\n            this._leftController = this.getControllerByName(\"left\");\r\n        }\r\n\r\n        return this._leftController;\r\n    }\r\n\r\n    private _rightController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\r\n    public get rightController(): Nullable<WebVRController> {\r\n        if (!this._rightController) {\r\n            this._rightController = this.getControllerByName(\"right\");\r\n        }\r\n\r\n        return this._rightController;\r\n    }\r\n\r\n    /**\r\n     * Casts a ray forward from the vrCamera's gaze.\r\n     * @param length Length of the ray (default: 100)\r\n     * @returns the ray corresponding to the gaze\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (this.leftCamera) {\r\n            // Use left eye to avoid computation to compute center on every call\r\n            return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\r\n        } else {\r\n            return super.getForwardRay(length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the camera based on device's frame data\r\n     */\r\n    public _checkInputs(): void {\r\n        if (this._vrDevice && this._vrDevice.isPresenting) {\r\n            this._vrDevice.getFrameData(this._frameData);\r\n\r\n            this.updateFromDevice(this._frameData.pose);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData Pose coming from the device\r\n     */\r\n    updateFromDevice(poseData: DevicePose) {\r\n        if (poseData && poseData.orientation && poseData.orientation.length === 4) {\r\n            this.rawPose = poseData;\r\n            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                this._deviceRoomRotationQuaternion.z *= -1;\r\n                this._deviceRoomRotationQuaternion.w *= -1;\r\n            }\r\n            if (this._webVROptions.trackPosition && this.rawPose.position) {\r\n                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\r\n                if (this.getScene().useRightHandedSystem) {\r\n                    this._deviceRoomPosition.z *= -1;\r\n                }\r\n            }\r\n            this._poseSet = true;\r\n        }\r\n    }\r\n\r\n    private _detachIfAttached = () => {\r\n        const vrDisplay = this.getEngine().getVRDevice();\r\n        if (vrDisplay && !vrDisplay.isPresenting) {\r\n            this.detachControl();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * WebVR's attach control will start broadcasting frames to the device.\r\n     * Note that in certain browsers (chrome for example) this function must be called\r\n     * within a user-interaction callback. Example:\r\n     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n     *\r\n     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        super.attachControl(noPreventDefault);\r\n        this._attached = true;\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n\r\n        if (this._vrDevice) {\r\n            this.getEngine().enableVR(this._webVROptions);\r\n        }\r\n\r\n        const hostWindow = this._scene.getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n\r\n        super.detachControl();\r\n        this._attached = false;\r\n        this.getEngine().disableVR();\r\n        window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n    }\r\n\r\n    /**\r\n     * @returns the name of this class\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebVRFreeCamera\";\r\n    }\r\n\r\n    /**\r\n     * Calls resetPose on the vrDisplay\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n     */\r\n    public resetToCurrentRotation() {\r\n        //uses the vrDisplay's \"resetPose()\".\r\n        //pitch and roll won't be affected.\r\n        this._vrDevice.resetPose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the rig cameras (left and right eye)\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n\r\n        camLeft.position.copyFrom(this._deviceRoomPosition);\r\n        camRight.position.copyFrom(this._deviceRoomPosition);\r\n    }\r\n\r\n    private _workingVector = Vector3.Zero();\r\n    private _oneVector = Vector3.One();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    private _updateCacheCalled: boolean;\r\n\r\n    // Remove translation from 6dof headset if trackposition is set to false\r\n    private _correctPositionIfNotTrackPosition(matrix: Matrix, isViewMatrix = false) {\r\n        if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\r\n            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\r\n            if (!isViewMatrix) {\r\n                this._tmpMatrix.invert();\r\n            }\r\n            this._tmpMatrix.multiplyToRef(matrix, matrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the cached values of the camera\r\n     * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\r\n            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\r\n            if (!this._updateCacheCalled) {\r\n                // make sure it is only called once per loop. this.update() might cause an infinite loop.\r\n                this._updateCacheCalled = true;\r\n                this.update();\r\n            }\r\n\r\n            // Set working vector to the device position in room space rotated by the new rotation\r\n            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\r\n            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\r\n\r\n            // Subtract this vector from the current device position in world to get the translation for the device world matrix\r\n            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\r\n            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\r\n\r\n            // Add translation from anchor position\r\n            this._deviceToWorld.getTranslationToRef(this._workingVector);\r\n            this._workingVector.addInPlace(this.position);\r\n            this._workingVector.subtractInPlace(this._cache.position);\r\n            this._deviceToWorld.setTranslation(this._workingVector);\r\n\r\n            // Set an inverted matrix to be used when updating the camera\r\n            this._deviceToWorld.invertToRef(this._worldToDevice);\r\n\r\n            // Update the gamepad to ensure the mesh is updated on the same frame as camera\r\n            this.controllers.forEach((controller) => {\r\n                controller._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\r\n                controller.update();\r\n            });\r\n        }\r\n\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n        this._updateCacheCalled = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Get current device position in babylon world\r\n     */\r\n    public _computeDevicePosition() {\r\n        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\r\n    }\r\n\r\n    /**\r\n     * Updates the current device position and rotation in the babylon world\r\n     */\r\n    public update() {\r\n        this._computeDevicePosition();\r\n\r\n        // Get current device rotation in babylon world\r\n        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\r\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\r\n\r\n        if (this._poseSet) {\r\n            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\r\n        }\r\n        super.update();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n     * @returns an identity matrix\r\n     */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * This function is called by the two RIG cameras.\r\n     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n     * @internal\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        // Update the parent camera prior to using a child camera to avoid desynchronization\r\n        const parentCamera: WebVRFreeCamera = this._cameraRigParams[\"parentCamera\"];\r\n        parentCamera._updateCache();\r\n\r\n        //WebVR 1.1\r\n        const viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\r\n\r\n        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\r\n\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._webvrViewMatrix.toggleModelMatrixHandInPlace();\r\n        }\r\n\r\n        // update the camera rotation matrix\r\n        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n\r\n        // should the view matrix be updated with scale and position offset?\r\n        if (parentCamera.deviceScaleFactor !== 1) {\r\n            this._webvrViewMatrix.invert();\r\n            // scale the position, if set\r\n            if (parentCamera.deviceScaleFactor) {\r\n                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\r\n            }\r\n\r\n            this._webvrViewMatrix.invert();\r\n        }\r\n\r\n        // Remove translation from 6dof headset if trackposition is set to false\r\n        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\r\n\r\n        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\r\n\r\n        // Compute global position\r\n        this._workingMatrix = this._workingMatrix || Matrix.Identity();\r\n        this._webvrViewMatrix.invertToRef(this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\r\n        this._workingMatrix.getTranslationToRef(this._globalPosition);\r\n        this._markSyncedWithParent();\r\n\r\n        return this._webvrViewMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n        const parentCamera = <WebVRFreeCamera>this.parent;\r\n\r\n        parentCamera._vrDevice.depthNear = parentCamera.minZ;\r\n        parentCamera._vrDevice.depthFar = parentCamera.maxZ;\r\n\r\n        const projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\r\n        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\r\n\r\n        //babylon compatible matrix\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n        }\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _updateCacheWhenTrackingDisabledObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * Initializes the controllers and their meshes\r\n     */\r\n    public initControllers() {\r\n        this.controllers.length = 0;\r\n\r\n        const manager = this.getScene().gamepadManager;\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n\r\n                if (webVrController.defaultModel) {\r\n                    webVrController.defaultModel.setEnabled(false);\r\n                }\r\n\r\n                if (webVrController.hand === \"right\") {\r\n                    this._rightController = null;\r\n                }\r\n                if (webVrController.hand === \"left\") {\r\n                    this._leftController = null;\r\n                }\r\n                const controllerIndex = this.controllers.indexOf(webVrController);\r\n                if (controllerIndex !== -1) {\r\n                    this.controllers.splice(controllerIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n                if (!this._webVROptions.trackPosition) {\r\n                    webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\r\n                    // Cache must be updated before rendering controllers to avoid them being one frame behind\r\n                    if (!this._updateCacheWhenTrackingDisabledObserver) {\r\n                        this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n                            this._updateCache();\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.deviceScaleFactor = this.deviceScaleFactor;\r\n                webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\r\n\r\n                if (this._webVROptions.controllerMeshes) {\r\n                    if (webVrController.defaultModel) {\r\n                        webVrController.defaultModel.setEnabled(true);\r\n                    } else {\r\n                        // Load the meshes\r\n                        webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {\r\n                            loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\r\n                            this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\r\n                            if (this._webVROptions.defaultLightingOnControllers) {\r\n                                if (!this._lightOnControllers) {\r\n                                    this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\r\n                                }\r\n                                const activateLightOnSubMeshes = function (mesh: AbstractMesh, light: HemisphericLight) {\r\n                                    const children = mesh.getChildren();\r\n                                    if (children && children.length !== 0) {\r\n                                        children.forEach((mesh) => {\r\n                                            light.includedOnlyMeshes.push(<AbstractMesh>mesh);\r\n                                            activateLightOnSubMeshes(<AbstractMesh>mesh, light);\r\n                                        });\r\n                                    }\r\n                                };\r\n                                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\r\n                                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.attachToPoseControlledCamera(this);\r\n\r\n                // since this is async - sanity check. Is the controller already stored?\r\n                if (this.controllers.indexOf(webVrController) === -1) {\r\n                    //add to the controllers array\r\n                    this.controllers.push(webVrController);\r\n\r\n                    // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\r\n                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\r\n                    // So we're overriding setting left & right manually to be sure\r\n                    let firstViveWandDetected = false;\r\n\r\n                    for (let i = 0; i < this.controllers.length; i++) {\r\n                        if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\r\n                            if (!firstViveWandDetected) {\r\n                                firstViveWandDetected = true;\r\n                                this.controllers[i].hand = \"left\";\r\n                            } else {\r\n                                this.controllers[i].hand = \"right\";\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //did we find enough controllers? Great! let the developer know.\r\n                    if (this.controllers.length >= 2) {\r\n                        this.onControllersAttachedObservable.notifyObservers(this.controllers);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { FreeCamera } from \"./freeCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nimport \"./Inputs/freeCameraDeviceOrientationInput\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n\r\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\r\n    return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// We're mainly based on the logic defined into the FreeCamera code\r\n/**\r\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\r\n * being tilted forward or back and left or right.\r\n */\r\nexport class DeviceOrientationCamera extends FreeCamera {\r\n    private _initialQuaternion: Quaternion;\r\n    private _quaternionCache: Quaternion;\r\n    private _tmpDragQuaternion = new Quaternion();\r\n    private _disablePointerInputWhenUsingDeviceOrientation = true;\r\n\r\n    /**\r\n     * Creates a new device orientation camera\r\n     * @param name The name of the camera\r\n     * @param position The start position camera\r\n     * @param scene The scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this._quaternionCache = new Quaternion();\r\n        this.inputs.addDeviceOrientation();\r\n\r\n        // When the orientation sensor fires it's first event, disable mouse input\r\n        if (this.inputs._deviceOrientationInput) {\r\n            this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\r\n                if (this._disablePointerInputWhenUsingDeviceOrientation) {\r\n                    if (this.inputs._mouseInput) {\r\n                        this.inputs._mouseInput._allowCameraRotation = false;\r\n                        this.inputs._mouseInput.onPointerMovedObservable.add((e) => {\r\n                            if (this._dragFactor != 0) {\r\n                                if (!this._initialQuaternion) {\r\n                                    this._initialQuaternion = new Quaternion();\r\n                                }\r\n                                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\r\n                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\r\n                                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\r\n     */\r\n    public get disablePointerInputWhenUsingDeviceOrientation() {\r\n        return this._disablePointerInputWhenUsingDeviceOrientation;\r\n    }\r\n\r\n    public set disablePointerInputWhenUsingDeviceOrientation(value: boolean) {\r\n        this._disablePointerInputWhenUsingDeviceOrientation = value;\r\n    }\r\n\r\n    private _dragFactor = 0;\r\n    /**\r\n     * Enabled turning on the y axis when the orientation sensor is active\r\n     * @param dragFactor the factor that controls the turn speed (default: 1/300)\r\n     */\r\n    public enableHorizontalDragging(dragFactor = 1 / 300) {\r\n        this._dragFactor = dragFactor;\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"DeviceOrientationCamera\").\r\n     * This helps avoiding instanceof at run time.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DeviceOrientationCamera\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Checks and applies the current values of the inputs to the camera. (Internal use only)\r\n     */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._quaternionCache.copyFrom(this.rotationQuaternion);\r\n        if (this._initialQuaternion) {\r\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the camera to its default orientation on the specified axis only.\r\n     * @param axis The axis to reset\r\n     */\r\n    public resetToCurrentRotation(axis: Axis = Axis.Y): void {\r\n        //can only work if this camera has a rotation quaternion already.\r\n        if (!this.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        if (!this._initialQuaternion) {\r\n            this._initialQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\r\n\r\n        [\"x\", \"y\", \"z\"].forEach((axisName) => {\r\n            if (!(<any>axis)[axisName]) {\r\n                (<any>this._initialQuaternion)[axisName] = 0;\r\n            } else {\r\n                (<any>this._initialQuaternion)[axisName] *= -1;\r\n            }\r\n        });\r\n        this._initialQuaternion.normalize();\r\n        //force rotation update\r\n        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n    }\r\n}\r\n","import type { FlyCamera } from \"./flyCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput\";\r\nimport { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput\";\r\n\r\n/**\r\n * Default Inputs manager for the FlyCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FlyCameraInputsManager extends CameraInputsManager<FlyCamera> {\r\n    /**\r\n     * Instantiates a new FlyCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to.\r\n     */\r\n    constructor(camera: FlyCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the new FlyCameraKeyboardMoveInput().\r\n     */\r\n    addKeyboard(): FlyCameraInputsManager {\r\n        this.add(new FlyCameraKeyboardInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @returns the new FlyCameraMouseInput().\r\n     */\r\n    addMouse(): FlyCameraInputsManager {\r\n        this.add(new FlyCameraMouseInput());\r\n        return this;\r\n    }\r\n}\r\n","import { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport type { FollowCamera } from \"./followCamera\";\r\nimport { FollowCameraKeyboardMoveInput } from \"./Inputs/followCameraKeyboardMoveInput\";\r\nimport { FollowCameraMouseWheelInput } from \"./Inputs/followCameraMouseWheelInput\";\r\nimport { FollowCameraPointersInput } from \"./Inputs/followCameraPointersInput\";\r\n\r\n/**\r\n * Default Inputs manager for the FollowCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FollowCameraInputsManager extends CameraInputsManager<FollowCamera> {\r\n    /**\r\n     * Instantiates a new FollowCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FollowCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): FollowCameraInputsManager {\r\n        this.add(new FollowCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add orientation input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addVRDeviceOrientation(): FollowCameraInputsManager {\r\n        console.warn(\"DeviceOrientation support not yet implemented for FollowCamera.\");\r\n        return this;\r\n    }\r\n}\r\n","import { UniversalCamera } from \"./universalCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nNode.AddNodeConstructor(\"GamepadCamera\", (name, scene) => {\r\n    return () => new GamepadCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera. This is only here for back compat purpose.\r\n * Please use the UniversalCamera instead as both are identical.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class GamepadCamera extends UniversalCamera {\r\n    /**\r\n     * Instantiates a new Gamepad Camera\r\n     * This represents a FPS type of camera. This is only here for back compat purpose.\r\n     * Please use the UniversalCamera instead as both are identical.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GamepadCamera\";\r\n    }\r\n}\r\n","import { FreeCamera } from \"./freeCamera\";\r\nimport type { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TouchCamera\", (name, scene) => {\r\n    return () => new TouchCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents a FPS type of camera controlled by touch.\r\n * This is like a universal camera minus the Gamepad controls.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class TouchCamera extends FreeCamera {\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    public get touchAngularSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchAngularSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    public get touchMoveSensibility(): number {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            return touch.touchMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set touchMoveSensibility(value: number) {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        if (touch) {\r\n            touch.touchMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new touch camera.\r\n     * This represents a FPS type of camera controlled by touch.\r\n     * This is like a universal camera minus the Gamepad controls.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addTouch();\r\n\r\n        this._setupInputs();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TouchCamera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {\r\n        const touch = <FreeCameraTouchInput>this.inputs.attached[\"touch\"];\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.touchEnabled = false;\r\n        } else {\r\n            touch.allowMouse = true;\r\n        }\r\n    }\r\n}\r\n","import { TouchCamera } from \"./touchCamera\";\r\nimport { Node } from \"../node\";\r\nimport type { FreeCameraGamepadInput } from \"../Cameras/Inputs/freeCameraGamepadInput\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"./camera\";\r\n\r\nimport \"../Gamepads/gamepadSceneComponent\";\r\n\r\nNode.AddNodeConstructor(\"FreeCamera\", (name, scene) => {\r\n    // Forcing to use the Universal camera\r\n    return () => new UniversalCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n * which still works and will still be found in many Playgrounds.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class UniversalCamera extends TouchCamera {\r\n    /**\r\n     * Defines the gamepad rotation sensibility.\r\n     * This is the threshold from when rotation starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadAngularSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadAngularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadAngularSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadAngularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the gamepad move sensibility.\r\n     * This is the threshold from when moving starts to be accounted for to prevent jittering.\r\n     */\r\n    public get gamepadMoveSensibility(): number {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            return gamepad.gamepadMoveSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set gamepadMoveSensibility(value: number) {\r\n        const gamepad = <FreeCameraGamepadInput>this.inputs.attached[\"gamepad\"];\r\n        if (gamepad) {\r\n            gamepad.gamepadMoveSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,\r\n     * which still works and will still be found in many Playgrounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, position, scene);\r\n        this.inputs.addGamepad();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"UniversalCamera\";\r\n    }\r\n}\r\n\r\nCamera._CreateDefaultParsedCamera = (name: string, scene: Scene) => {\r\n    return new UniversalCamera(name, Vector3.Zero(), scene);\r\n};\r\n","import type { Nullable, IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\nconst intersectBoxAASphere = (boxMin: Vector3, boxMax: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean => {\r\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst getLowestRoot: (a: number, b: number, c: number, maxR: number) => { root: number; found: boolean } = (function () {\r\n    const result = { root: 0, found: false };\r\n    return function (a: number, b: number, c: number, maxR: number) {\r\n        result.root = 0;\r\n        result.found = false;\r\n        const determinant = b * b - 4.0 * a * c;\r\n        if (determinant < 0) {\r\n            return result;\r\n        }\r\n\r\n        const sqrtD = Math.sqrt(determinant);\r\n        let r1 = (-b - sqrtD) / (2.0 * a);\r\n        let r2 = (-b + sqrtD) / (2.0 * a);\r\n\r\n        if (r1 > r2) {\r\n            const temp = r2;\r\n            r2 = r1;\r\n            r1 = temp;\r\n        }\r\n\r\n        if (r1 > 0 && r1 < maxR) {\r\n            result.root = r1;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        if (r2 > 0 && r2 < maxR) {\r\n            result.root = r2;\r\n            result.found = true;\r\n            return result;\r\n        }\r\n\r\n        return result;\r\n    };\r\n})();\r\n\r\n/** @internal */\r\nexport class Collider {\r\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\r\n    // https://www.peroxide.dk/papers/collision/collision.pdf\r\n\r\n    /** Define if a collision was found */\r\n    public collisionFound: boolean;\r\n\r\n    /**\r\n     * Define last intersection point in local space\r\n     */\r\n    public intersectionPoint: Vector3;\r\n\r\n    /**\r\n     * Define last collided mesh\r\n     */\r\n    public collidedMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * If true, it check for double sided faces and only returns 1 collision instead of 2\r\n     */\r\n    public static DoubleSidedCheck = false;\r\n\r\n    private _collisionPoint = Vector3.Zero();\r\n    private _planeIntersectionPoint = Vector3.Zero();\r\n    private _tempVector = Vector3.Zero();\r\n    private _tempVector2 = Vector3.Zero();\r\n    private _tempVector3 = Vector3.Zero();\r\n    private _tempVector4 = Vector3.Zero();\r\n    private _edge = Vector3.Zero();\r\n    private _baseToVertex = Vector3.Zero();\r\n    private _destinationPoint = Vector3.Zero();\r\n    private _slidePlaneNormal = Vector3.Zero();\r\n    private _displacementVector = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _radius = Vector3.One();\r\n    /** @internal */\r\n    public _retry = 0;\r\n    private _velocity: Vector3;\r\n    private _basePoint: Vector3;\r\n    private _epsilon: number;\r\n    /** @internal */\r\n    public _velocityWorldLength: number;\r\n    /** @internal */\r\n    public _basePointWorld = Vector3.Zero();\r\n    private _velocityWorld = Vector3.Zero();\r\n    private _normalizedVelocity = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialVelocity: Vector3;\r\n    /** @internal */\r\n    public _initialPosition: Vector3;\r\n    private _nearestDistance: number;\r\n\r\n    private _collisionMask = -1;\r\n    private _velocitySquaredLength: number;\r\n    private _nearestDistanceSquared: number;\r\n\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\r\n    public get slidePlaneNormal(): Vector3 {\r\n        return this._slidePlaneNormal;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _initialize(source: Vector3, dir: Vector3, e: number): void {\r\n        this._velocity = dir;\r\n        this._velocitySquaredLength = this._velocity.lengthSquared();\r\n        const len = Math.sqrt(this._velocitySquaredLength);\r\n        if (len === 0 || len === 1.0) {\r\n            this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\r\n        } else {\r\n            dir.scaleToRef(1.0 / len, this._normalizedVelocity);\r\n        }\r\n        this._basePoint = source;\r\n\r\n        source.multiplyToRef(this._radius, this._basePointWorld);\r\n        dir.multiplyToRef(this._radius, this._velocityWorld);\r\n\r\n        this._velocityWorldLength = this._velocityWorld.length();\r\n\r\n        this._epsilon = e;\r\n        this.collisionFound = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean {\r\n        pa.subtractToRef(point, this._tempVector);\r\n        pb.subtractToRef(point, this._tempVector2);\r\n\r\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\r\n        let d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        pc.subtractToRef(point, this._tempVector3);\r\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        return d >= 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean {\r\n        const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\r\n\r\n        const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\r\n\r\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\r\n            return false;\r\n        }\r\n\r\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        let t0;\r\n        let embeddedInPlane = false;\r\n\r\n        //defensive programming, actually not needed.\r\n        if (!trianglePlaneArray) {\r\n            trianglePlaneArray = [];\r\n        }\r\n\r\n        if (!trianglePlaneArray[faceIndex]) {\r\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\r\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\r\n        }\r\n\r\n        const trianglePlane = trianglePlaneArray[faceIndex];\r\n\r\n        if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\r\n            return;\r\n        }\r\n\r\n        const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\r\n        const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\r\n\r\n        // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\r\n        // if true, it discard the faces having normal not facing velocity\r\n        if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\r\n            return;\r\n        }\r\n\r\n        if (normalDotVelocity == 0) {\r\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\r\n                return;\r\n            }\r\n            embeddedInPlane = true;\r\n            t0 = 0;\r\n        } else {\r\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n            let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n\r\n            if (t0 > t1) {\r\n                const temp = t1;\r\n                t1 = t0;\r\n                t0 = temp;\r\n            }\r\n\r\n            if (t0 > 1.0 || t1 < 0.0) {\r\n                return;\r\n            }\r\n\r\n            if (t0 < 0) {\r\n                t0 = 0;\r\n            }\r\n            if (t0 > 1.0) {\r\n                t0 = 1.0;\r\n            }\r\n        }\r\n\r\n        this._collisionPoint.copyFromFloats(0, 0, 0);\r\n\r\n        let found = false;\r\n        let t = 1.0;\r\n\r\n        if (!embeddedInPlane) {\r\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\r\n            this._velocity.scaleToRef(t0, this._tempVector);\r\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\r\n\r\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\r\n                found = true;\r\n                t = t0;\r\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            let a = this._velocitySquaredLength;\r\n\r\n            this._basePoint.subtractToRef(p1, this._tempVector);\r\n            let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            let c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            let lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p1);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p2, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p2);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p3, this._tempVector);\r\n            b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p3);\r\n            }\r\n\r\n            p2.subtractToRef(p1, this._edge);\r\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\r\n            let edgeSquaredLength = this._edge.lengthSquared();\r\n            let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p1.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p3.subtractToRef(p2, this._edge);\r\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p2.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p1.subtractToRef(p3, this._edge);\r\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\r\n            b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p3.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            const distToCollisionSquared = t * t * this._velocitySquaredLength;\r\n\r\n            if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\r\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\r\n                // onCollide observable are triggered if collideMesh is set\r\n                // this allow trigger volumes to be created.\r\n                if (hostMesh.collisionResponse) {\r\n                    if (!this.intersectionPoint) {\r\n                        this.intersectionPoint = this._collisionPoint.clone();\r\n                    } else {\r\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\r\n                    }\r\n                    this._nearestDistanceSquared = distToCollisionSquared;\r\n                    this._nearestDistance = Math.sqrt(distToCollisionSquared);\r\n                    this.collisionFound = true;\r\n                }\r\n                this.collidedMesh = hostMesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collide(\r\n        trianglePlaneArray: Array<Plane>,\r\n        pts: Vector3[],\r\n        indices: IndicesArray,\r\n        indexStart: number,\r\n        indexEnd: number,\r\n        decal: number,\r\n        hasMaterial: boolean,\r\n        hostMesh: AbstractMesh,\r\n        invertTriangles?: boolean,\r\n        triangleStrip: boolean = false\r\n    ): void {\r\n        if (triangleStrip) {\r\n            if (!indices || indices.length === 0) {\r\n                for (let i = 0; i < pts.length - 2; i += 1) {\r\n                    const p1 = pts[i];\r\n                    const p2 = pts[i + 1];\r\n                    const p3 = pts[i + 2];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = indexStart; i < indexEnd - 2; i += 1) {\r\n                    const indexA = indices[i];\r\n                    const indexB = indices[i + 1];\r\n                    const indexC = indices[i + 2];\r\n\r\n                    if (indexC === 0xffffffff) {\r\n                        i += 2;\r\n                        continue;\r\n                    }\r\n\r\n                    const p1 = pts[indexA];\r\n                    const p2 = pts[indexB];\r\n                    const p3 = pts[indexC];\r\n\r\n                    // stay defensive and don't check against undefined positions.\r\n                    if (!p1 || !p2 || !p3) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Handles strip faces one on two is reversed\r\n                    if ((invertTriangles ? 1 : 0) ^ i % 2) {\r\n                        this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                    } else {\r\n                        this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\r\n                    }\r\n                }\r\n            }\r\n        } else if (!indices || indices.length === 0) {\r\n            for (let i = 0; i < pts.length; i += 3) {\r\n                const p1 = pts[i];\r\n                const p2 = pts[i + 1];\r\n                const p3 = pts[i + 2];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = indexStart; i < indexEnd; i += 3) {\r\n                const p1 = pts[indices[i] - decal];\r\n                const p2 = pts[indices[i + 1] - decal];\r\n                const p3 = pts[indices[i + 2] - decal];\r\n\r\n                if (invertTriangles) {\r\n                    this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\r\n                } else {\r\n                    this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getResponse(pos: Vector3, vel: Vector3): void {\r\n        pos.addToRef(vel, this._destinationPoint);\r\n        vel.scaleInPlace(this._nearestDistance / vel.length());\r\n\r\n        this._basePoint.addToRef(vel, pos);\r\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\r\n        this._slidePlaneNormal.normalize();\r\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\r\n\r\n        pos.addInPlace(this._displacementVector);\r\n        this.intersectionPoint.addInPlace(this._displacementVector);\r\n\r\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\r\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\r\n\r\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\r\n    }\r\n}\r\n","import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IComputePipelineContext } from \"./IComputePipelineContext\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Options to be used when creating a compute effect.\r\n */\r\nexport interface IComputeEffectCreationOptions {\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: ComputeEffect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: ComputeEffect, errors: string) => void>;\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * Effect wrapping a compute shader and let execute (dispatch) the shader\r\n */\r\nexport class ComputeEffect {\r\n    private static _UniqueIdSeed = 0;\r\n\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public onBindObservable = new Observable<ComputeEffect>();\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    private _engine: Engine;\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    /** @internal */\r\n    public _key: string = \"\";\r\n    private _computeSourceCodeOverride: string = \"\";\r\n    /** @internal */\r\n    public _pipelineContext: Nullable<IComputePipelineContext> = null;\r\n    /** @internal */\r\n    public _computeSourceCode: string = \"\";\r\n    private _rawComputeSourceCode: string = \"\";\r\n    private _entryPoint: string;\r\n    private _shaderLanguage = ShaderLanguage.WGSL;\r\n    private _shaderStore: { [key: string]: string };\r\n    private _shaderRepository: string;\r\n    private _includeShaderStore: { [key: string]: string };\r\n\r\n    /**\r\n     * Creates a compute effect that can be used to execute a compute shader\r\n     * @param baseName Name of the effect\r\n     * @param options Set of all options to create the effect\r\n     * @param engine The engine the effect is created for\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     */\r\n    constructor(baseName: any, options: IComputeEffectCreationOptions, engine: Engine, key = \"\") {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        this._engine = engine;\r\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\r\n\r\n        this.defines = options.defines ?? \"\";\r\n        this.onError = options.onError;\r\n        this.onCompiled = options.onCompiled;\r\n        this._entryPoint = options.entryPoint ?? \"main\";\r\n\r\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\r\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\r\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\r\n\r\n        let computeSource: any;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.computeSource) {\r\n            computeSource = \"source:\" + baseName.computeSource;\r\n        } else if (baseName.computeElement) {\r\n            computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\r\n\r\n            if (!computeSource) {\r\n                computeSource = baseName.computeElement;\r\n            }\r\n        } else {\r\n            computeSource = baseName.compute || baseName;\r\n        }\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: false,\r\n            processor: null,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: this._shaderRepository,\r\n            includesShadersStore: this._includeShaderStore,\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.PreProcess(\r\n                computeCode,\r\n                processorOptions,\r\n                (migratedCommputeCode) => {\r\n                    this._rawComputeSourceCode = computeCode;\r\n                    if (options.processFinalCode) {\r\n                        migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\r\n                    }\r\n                    const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\r\n                    this._useFinalCode(finalShaders.vertexCode, baseName);\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedCommputeCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\r\n\r\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\r\n        } else {\r\n            this._computeSourceCode = migratedCommputeCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IComputePipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: ComputeEffect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IComputePipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (this._shaderStore[shader + key + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = this._shaderRepository + shader;\r\n        }\r\n\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code of this effect\r\n     */\r\n    public get computeSourceCode(): string {\r\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawComputeSourceCode(): string {\r\n        return this._rawComputeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect() {\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createComputePipelineContext();\r\n            this._pipelineContext._name = this._key;\r\n\r\n            engine._prepareComputePipelineContext(\r\n                this._pipelineContext,\r\n                this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode,\r\n                this._rawComputeSourceCode,\r\n                this._computeSourceCodeOverride ? null : defines,\r\n                this._entryPoint\r\n            );\r\n\r\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>): [Nullable<string>, Nullable<string>] {\r\n        const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IComputePipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile compute effect:\");\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getComputeShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\r\n                if (code) {\r\n                    Logger.Error(\"Compute code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseComputeEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new compute shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param computeShader compute shader content\r\n     */\r\n    public static RegisterShader(name: string, computeShader: string) {\r\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\r\n    }\r\n}\r\n","import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SerializationHelper, serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"./computeEffect\";\r\nimport type { ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\ntype ComputeBindingListInternal = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number; buffer?: Nullable<DataBuffer> } };\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: ThinEngine;\r\n    private _shaderPath: any;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingListInternal = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\r\n     *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: ThinEngine, shaderPath: any, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture: {\r\n                    const sampler = this._samplers[key];\r\n                    const texture = binding.object as BaseTexture;\r\n\r\n                    if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                        this._samplers[key] = new TextureSampler().setParameters(\r\n                            texture.wrapU,\r\n                            texture.wrapV,\r\n                            texture.wrapR,\r\n                            texture.anisotropicFilteringLevel,\r\n                            texture._texture!.samplingMode,\r\n                            texture._texture?._comparisonFunction\r\n                        );\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    const ubo = binding.object as UniformBuffer;\r\n                    if (ubo.getBuffer() !== binding.buffer) {\r\n                        binding.buffer = ubo.getBuffer();\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const check = () => {\r\n                if (!this.dispatch(x, y, z)) {\r\n                    setTimeout(check, delay);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            check();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n","import type { SmartArray } from \"../../Misc/smartArray\";\r\nimport { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { OctreeBlock } from \"./octreeBlock\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\n\r\n/**\r\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nexport class Octree<T> {\r\n    /**\r\n     * Blocks within the octree containing objects\r\n     */\r\n    public blocks: Array<OctreeBlock<T>>;\r\n    /**\r\n     * Content stored in the octree\r\n     */\r\n    public dynamicContent = new Array<T>();\r\n\r\n    private _maxBlockCapacity: number;\r\n    private _selectionContent: SmartArrayNoDuplicate<T>;\r\n    private _creationFunc: (entry: T, block: OctreeBlock<T>) => void;\r\n\r\n    /**\r\n     * Creates a octree\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n     * @param creationFunc function to be used to instantiate the octree\r\n     * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\r\n     * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\r\n     */\r\n    constructor(\r\n        creationFunc: (entry: T, block: OctreeBlock<T>) => void,\r\n        maxBlockCapacity?: number,\r\n        /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\r\n        public maxDepth = 2\r\n    ) {\r\n        this._maxBlockCapacity = maxBlockCapacity || 64;\r\n        this._selectionContent = new SmartArrayNoDuplicate<T>(1024);\r\n        this._creationFunc = creationFunc;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\r\n     * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param entries meshes to be added to the octree blocks\r\n     */\r\n    public update(worldMin: Vector3, worldMax: Vector3, entries: T[]): void {\r\n        OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh to the octree\r\n     * @param entry Mesh to add to the octree\r\n     */\r\n    public addMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.addEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an element from the octree\r\n     * @param entry defines the element to remove\r\n     */\r\n    public removeMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.removeEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Selects an array of meshes within the frustum\r\n     * @param frustumPlanes The frustum planes to use which will select all meshes within it\r\n     * @param allowDuplicate If duplicate objects are allowed in the resulting object array\r\n     * @returns array of meshes within the frustum\r\n     */\r\n    public select(frustumPlanes: Plane[], allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.select(frustumPlanes, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\r\n     * @param sphereCenter defines the bounding sphere center\r\n     * @param sphereRadius defines the bounding sphere radius\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     * @returns an array of objects that intersect the sphere\r\n     */\r\n    public intersects(sphereCenter: Vector3, sphereRadius: number, allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\r\n     * @param ray defines the ray to test with\r\n     * @returns array of intersected objects\r\n     */\r\n    public intersectsRay(ray: Ray): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersectsRay(ray, this._selectionContent);\r\n        }\r\n\r\n        this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh into the octree block if it intersects the block\r\n     * @param entry\r\n     * @param block\r\n     */\r\n    public static CreationFuncForMeshes = (entry: AbstractMesh, block: OctreeBlock<AbstractMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds a submesh into the octree block if it intersects the block\r\n     * @param entry\r\n     * @param block\r\n     */\r\n    public static CreationFuncForSubMeshes = (entry: SubMesh, block: OctreeBlock<SubMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n}\r\n","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\n\r\n/**\r\n * Contains an array of blocks representing the octree\r\n */\r\nexport interface IOctreeContainer<T> {\r\n    /**\r\n     * Blocks within the octree\r\n     */\r\n    blocks: Array<OctreeBlock<T>>;\r\n}\r\n\r\n/**\r\n * Class used to store a cell in an octree\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nexport class OctreeBlock<T> {\r\n    /**\r\n     * Gets the content of the current block\r\n     */\r\n    public entries = new Array<T>();\r\n\r\n    /**\r\n     * Gets the list of block children\r\n     */\r\n    public blocks: Array<OctreeBlock<T>>;\r\n\r\n    private _depth: number;\r\n    private _maxDepth: number;\r\n    private _capacity: number;\r\n    private _minPoint: Vector3;\r\n    private _maxPoint: Vector3;\r\n    private _boundingVectors = new Array<Vector3>();\r\n    private _creationFunc: (entry: T, block: OctreeBlock<T>) => void;\r\n\r\n    /**\r\n     * Creates a new block\r\n     * @param minPoint defines the minimum vector (in world space) of the block's bounding box\r\n     * @param maxPoint defines the maximum vector (in world space) of the block's bounding box\r\n     * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\r\n     * @param depth defines the current depth of this block in the octree\r\n     * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)\r\n     * @param creationFunc defines a callback to call when an element is added to the block\r\n     */\r\n    constructor(minPoint: Vector3, maxPoint: Vector3, capacity: number, depth: number, maxDepth: number, creationFunc: (entry: T, block: OctreeBlock<T>) => void) {\r\n        this._capacity = capacity;\r\n        this._depth = depth;\r\n        this._maxDepth = maxDepth;\r\n        this._creationFunc = creationFunc;\r\n\r\n        this._minPoint = minPoint;\r\n        this._maxPoint = maxPoint;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors.push(maxPoint.clone());\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[2].x = maxPoint.x;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[3].y = maxPoint.y;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[4].z = maxPoint.z;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[5].z = minPoint.z;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[6].x = minPoint.x;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[7].y = minPoint.y;\r\n    }\r\n\r\n    // Property\r\n\r\n    /**\r\n     * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\r\n     */\r\n    public get capacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum vector (in world space) of the block's bounding box\r\n     */\r\n    public get minPoint(): Vector3 {\r\n        return this._minPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum vector (in world space) of the block's bounding box\r\n     */\r\n    public get maxPoint(): Vector3 {\r\n        return this._maxPoint;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Add a new element to this block\r\n     * @param entry defines the element to add\r\n     */\r\n    public addEntry(entry: T): void {\r\n        if (this.blocks) {\r\n            for (let index = 0; index < this.blocks.length; index++) {\r\n                const block = this.blocks[index];\r\n                block.addEntry(entry);\r\n            }\r\n            return;\r\n        }\r\n\r\n        this._creationFunc(entry, this);\r\n\r\n        if (this.entries.length > this.capacity && this._depth < this._maxDepth) {\r\n            this.createInnerBlocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an element from this block\r\n     * @param entry defines the element to remove\r\n     */\r\n    public removeEntry(entry: T): void {\r\n        if (this.blocks) {\r\n            for (let index = 0; index < this.blocks.length; index++) {\r\n                const block = this.blocks[index];\r\n                block.removeEntry(entry);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const entryIndex = this.entries.indexOf(entry);\r\n\r\n        if (entryIndex > -1) {\r\n            this.entries.splice(entryIndex, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add an array of elements to this block\r\n     * @param entries defines the array of elements to add\r\n     */\r\n    public addEntries(entries: T[]): void {\r\n        for (let index = 0; index < entries.length; index++) {\r\n            const mesh = entries[index];\r\n            this.addEntry(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersects the frustum planes and if yes, then add its content to the selection array\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @param selection defines the array to store current content if selection is positive\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     */\r\n    public select(frustumPlanes: Plane[], selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void {\r\n        if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.select(frustumPlanes, selection, allowDuplicate);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (allowDuplicate) {\r\n                selection.concat(this.entries);\r\n            } else {\r\n                selection.concatWithNoDuplicate(this.entries);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array\r\n     * @param sphereCenter defines the bounding sphere center\r\n     * @param sphereRadius defines the bounding sphere radius\r\n     * @param selection defines the array to store current content if selection is positive\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     */\r\n    public intersects(sphereCenter: Vector3, sphereRadius: number, selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void {\r\n        if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (allowDuplicate) {\r\n                selection.concat(this.entries);\r\n            } else {\r\n                selection.concatWithNoDuplicate(this.entries);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersect with the given ray and if yes, then add its content to the selection array\r\n     * @param ray defines the ray to test with\r\n     * @param selection defines the array to store current content if selection is positive\r\n     */\r\n    public intersectsRay(ray: Ray, selection: SmartArrayNoDuplicate<T>): void {\r\n        if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.intersectsRay(ray, selection);\r\n                }\r\n                return;\r\n            }\r\n            selection.concatWithNoDuplicate(this.entries);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subdivide the content into child blocks (this block will then be empty)\r\n     */\r\n    public createInnerBlocks(): void {\r\n        OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);\r\n        this.entries.splice(0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateBlocks<T>(\r\n        worldMin: Vector3,\r\n        worldMax: Vector3,\r\n        entries: T[],\r\n        maxBlockCapacity: number,\r\n        currentDepth: number,\r\n        maxDepth: number,\r\n        target: IOctreeContainer<T>,\r\n        creationFunc: (entry: T, block: OctreeBlock<T>) => void\r\n    ): void {\r\n        target.blocks = new Array<OctreeBlock<T>>();\r\n        const blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n\r\n        // Segmenting space\r\n        for (let x = 0; x < 2; x++) {\r\n            for (let y = 0; y < 2; y++) {\r\n                for (let z = 0; z < 2; z++) {\r\n                    const localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));\r\n                    const localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));\r\n\r\n                    const block = new OctreeBlock<T>(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);\r\n                    block.addEntries(entries);\r\n                    target.blocks.push(block);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Enum defining the type of properties that can be edited in the property pages in the node editor\r\n */\r\nexport enum PropertyTypeForEdition {\r\n    /** property is a boolean */\r\n    Boolean,\r\n    /** property is a float */\r\n    Float,\r\n    /** property is a int */\r\n    Int,\r\n    /** property is a Vector2 */\r\n    Vector2,\r\n    /** property is a list of values */\r\n    List,\r\n}\r\n\r\n/**\r\n * Interface that defines an option in a variable of type list\r\n */\r\nexport interface IEditablePropertyListOption {\r\n    /** label of the option */\r\n    label: string;\r\n    /** value of the option */\r\n    value: number;\r\n}\r\n\r\n/**\r\n * Interface that defines the options available for an editable property\r\n */\r\nexport interface IEditablePropertyOption {\r\n    /** min value */\r\n    min?: number;\r\n    /** max value */\r\n    max?: number;\r\n    /** notifiers: indicates which actions to take when the property is changed */\r\n    notifiers?: {\r\n        /** the entity should be rebuilt */\r\n        rebuild?: boolean;\r\n        /** the preview should be updated */\r\n        update?: boolean;\r\n        /** the onPreviewCommandActivated observer of the preview manager should be triggered */\r\n        activatePreviewCommand?: boolean;\r\n        /** a callback to trigger */\r\n        callback?: (scene: Nullable<Scene>, block: any) => boolean | undefined | void;\r\n        /** a callback to validate the property. Returns true if the property is ok, else false. If false, the rebuild/update/callback events won't be called */\r\n        onValidation?: (block: any, propertyName: string) => boolean;\r\n    };\r\n    /** list of the options for a variable of type list */\r\n    options?: IEditablePropertyListOption[];\r\n}\r\n\r\n/**\r\n * Interface that describes an editable property\r\n */\r\nexport interface IPropertyDescriptionForEdition {\r\n    /** name of the property */\r\n    propertyName: string;\r\n    /** display name of the property */\r\n    displayName: string;\r\n    /** type of the property */\r\n    type: PropertyTypeForEdition;\r\n    /** group of the property - all properties with the same group value will be displayed in a specific section */\r\n    groupName: string;\r\n    /** options for the property */\r\n    options: IEditablePropertyOption;\r\n}\r\n\r\n/**\r\n * Decorator that flags a property in a node block as being editable\r\n * @param displayName\r\n * @param propertyType\r\n * @param groupName\r\n * @param options\r\n */\r\nexport function editableInPropertyPage(\r\n    displayName: string,\r\n    propertyType: PropertyTypeForEdition = PropertyTypeForEdition.Boolean,\r\n    groupName: string = \"PROPERTIES\",\r\n    options?: IEditablePropertyOption\r\n) {\r\n    return (target: any, propertyKey: string) => {\r\n        let propStore: IPropertyDescriptionForEdition[] = target._propStore;\r\n        if (!propStore) {\r\n            propStore = [];\r\n            target._propStore = propStore;\r\n        }\r\n        propStore.push({\r\n            propertyName: propertyKey,\r\n            displayName: displayName,\r\n            type: propertyType,\r\n            groupName: groupName,\r\n            options: options ?? {},\r\n        });\r\n    };\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Type used to locate a resource in a compute shader.\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingLocation = { group: number; binding: number };\r\n\r\n/**\r\n * Type used to lookup a resource and retrieve its binding location\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingMapping = { [key: string]: ComputeBindingLocation };\r\n\r\n/** @internal */\r\nexport enum ComputeBindingType {\r\n    Texture = 0,\r\n    StorageTexture = 1,\r\n    UniformBuffer = 2,\r\n    StorageBuffer = 3,\r\n    TextureWithoutSampler = 4,\r\n    Sampler = 5,\r\n}\r\n\r\n/** @internal */\r\nexport type ComputeBindingList = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number } };\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new compute effect\r\n         * @param baseName Name of the effect\r\n         * @param options Options used to create the effect\r\n         * @returns The new compute effect\r\n         */\r\n        createComputeEffect(baseName: any, options: IComputeEffectCreationOptions): ComputeEffect;\r\n\r\n        /**\r\n         * Creates a new compute pipeline context\r\n         * @returns the new pipeline\r\n         */\r\n        createComputePipelineContext(): IComputePipelineContext;\r\n\r\n        /**\r\n         * Creates a new compute context\r\n         * @returns the new context\r\n         */\r\n        createComputeContext(): IComputeContext | undefined;\r\n\r\n        /**\r\n         * Dispatches a compute shader\r\n         * @param effect The compute effect\r\n         * @param context The compute context\r\n         * @param bindings The list of resources to bind to the shader\r\n         * @param x The number of workgroups to execute on the X dimension\r\n         * @param y The number of workgroups to execute on the Y dimension\r\n         * @param z The number of workgroups to execute on the Z dimension\r\n         * @param bindingsMapping list of bindings mapping (key is property name, value is binding location)\r\n         */\r\n        computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x: number,\r\n            y?: number,\r\n            z?: number,\r\n            bindingsMapping?: ComputeBindingMapping\r\n        ): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if all created compute effects are ready\r\n         * @returns true if all effects are ready\r\n         */\r\n        areAllComputeEffectsReady(): boolean;\r\n\r\n        /**\r\n         * Forces the engine to release all cached compute effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n         */\r\n        releaseComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _prepareComputePipelineContext(\r\n            pipelineContext: IComputePipelineContext,\r\n            computeSourceCode: string,\r\n            rawComputeSourceCode: string,\r\n            defines: Nullable<string>,\r\n            entryPoint: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _rebuildComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _executeWhenComputeStateIsCompiled(pipelineContext: IComputePipelineContext, action: () => void): void;\r\n\r\n        /** @internal */\r\n        _releaseComputeEffect(effect: ComputeEffect): void;\r\n\r\n        /** @internal */\r\n        _deleteComputePipelineContext(pipelineContext: IComputePipelineContext): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return undefined;\r\n};\r\n\r\nThinEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    return true;\r\n};\r\n\r\nThinEngine.prototype.releaseComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {};\r\n\r\nThinEngine.prototype._rebuildComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext: IComputePipelineContext, action: () => void): void {\r\n    action();\r\n};\r\n\r\nThinEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {};\r\n\r\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {};\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /** @internal */\r\n        _debugPushGroup(groupName: string, targetObject?: number): void;\r\n\r\n        /** @internal */\r\n        _debugPopGroup(targetObject?: number): void;\r\n\r\n        /** @internal */\r\n        _debugInsertMarker(text: string, targetObject?: number): void;\r\n\r\n        /** @internal */\r\n        _debugFlushPendingCommands(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._debugPushGroup = function (groupName: string, targetObject?: number): void {};\r\n\r\nThinEngine.prototype._debugPopGroup = function (targetObject?: number): void {};\r\n\r\nThinEngine.prototype._debugInsertMarker = function (text: string, targetObject?: number): void {};\r\n\r\nThinEngine.prototype._debugFlushPendingCommands = function (): void {};\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates an external texture\r\n         * @param video video element\r\n         * @returns the external texture, or null if external textures are not supported by the engine\r\n         */\r\n        createExternalTexture(video: HTMLVideoElement): Nullable<ExternalTexture>;\r\n\r\n        /**\r\n         * Sets an internal texture to the according uniform.\r\n         * @param name The name of the uniform in the effect\r\n         * @param texture The texture to apply\r\n         */\r\n        setExternalTexture(name: string, texture: Nullable<ExternalTexture>): void;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.createExternalTexture = function (video: HTMLVideoElement): Nullable<ExternalTexture> {\r\n    return null;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.setExternalTexture = function (name: string, texture: Nullable<ExternalTexture>): void {\r\n    throw new Error(\"setExternalTexture: This engine does not support external textures!\");\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.restoreSingleAttachment = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.BACK]);\r\n};\r\n\r\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\r\n};\r\n\r\nThinEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const gl = this._gl;\r\n\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push((<any>gl)[\"COLOR_ATTACHMENT\" + i]);\r\n        } else {\r\n            result.push(gl.NONE);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    const gl = this._gl;\r\n\r\n    gl.drawBuffers(attachments);\r\n};\r\n\r\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: WebGLRenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    this._currentRenderTarget = null;\r\n\r\n    // If MSAA, we need to bitblt back to main texture\r\n    const gl = this._gl;\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n\r\n            for (let j = 0; j < count; j++) {\r\n                attachments[j] = gl.NONE;\r\n            }\r\n\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n            gl.readBuffer(attachments[i]);\r\n            gl.drawBuffers(attachments);\r\n            gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n        }\r\n\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n        }\r\n    }\r\n\r\n    if (onBeforeUnbind) {\r\n        if (rtWrapper._MSAAFramebuffer) {\r\n            // Bind the correct framebuffer\r\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n        }\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n};\r\n\r\nThinEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers: boolean = true): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n    let formats = new Array<number>();\r\n    let targets = new Array<number>();\r\n    let faceIndex = new Array<number>();\r\n    let layerIndex = new Array<number>();\r\n    let layers = new Array<number>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (options.formats) {\r\n            formats = options.formats;\r\n        }\r\n        if (options.targetTypes) {\r\n            targets = options.targetTypes;\r\n        }\r\n        if (options.faceIndex) {\r\n            faceIndex = options.faceIndex;\r\n        }\r\n        if (options.layerIndex) {\r\n            layerIndex = options.layerIndex;\r\n        }\r\n        if (options.layerCounts) {\r\n            layers = options.layerCounts;\r\n        }\r\n        if (\r\n            this.webGLVersion > 1 &&\r\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)\r\n        ) {\r\n            depthTextureFormat = options.depthTextureFormat;\r\n        }\r\n    }\r\n    const gl = this._gl;\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n\r\n    const useStencilTexture =\r\n        this.webGLVersion > 1 &&\r\n        generateDepthTexture &&\r\n        (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n    const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\r\n\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._depthStencilBuffer = depthStencilBuffer;\r\n    rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n        const format = formats[i] || defaultFormat;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        const isWebGL2 = this.webGLVersion > 1;\r\n        const attachment = (<any>gl)[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n        attachments.push(attachment);\r\n\r\n        if (target === -1) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        gl.activeTexture((<any>gl)[\"TEXTURE\" + i]);\r\n        gl.bindTexture(target, texture._hardwareTexture!.underlyingResource);\r\n\r\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const webGLTextureType = this._getWebGLTextureType(type);\r\n\r\n        if (isWebGL2 && (target === Constants.TEXTURE_2D_ARRAY || target === Constants.TEXTURE_3D)) {\r\n            if (target === Constants.TEXTURE_2D_ARRAY) {\r\n                texture.is2DArray = true;\r\n            } else {\r\n                texture.is3D = true;\r\n            }\r\n\r\n            texture.baseDepth = texture.depth = layerCount;\r\n\r\n            gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\r\n        } else if (target === Constants.TEXTURE_CUBE_MAP) {\r\n            // We have to generate all faces to complete the framebuffer\r\n            for (let i = 0; i < 6; i++) {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n            }\r\n            texture.isCube = true;\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n        }\r\n\r\n        if (generateMipMaps) {\r\n            gl.generateMipmap(target);\r\n        }\r\n\r\n        // Unbind\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n    }\r\n\r\n    if (generateDepthTexture && this._caps.depthTextureExtension) {\r\n        // Depth texture\r\n        const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n\r\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n        let glDepthTextureInternalFormat: GLenum = gl.DEPTH_COMPONENT16;\r\n        let glDepthTextureFormat: GLenum = gl.DEPTH_COMPONENT;\r\n        let glDepthTextureType: GLenum = gl.UNSIGNED_SHORT;\r\n        let glDepthTextureAttachment: GLenum = gl.DEPTH_ATTACHMENT;\r\n        if (this.webGLVersion < 2) {\r\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\r\n        } else {\r\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\r\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\r\n                glDepthTextureType = gl.FLOAT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.UNSIGNED_INT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\r\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\r\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            }\r\n        }\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        depthTexture.baseWidth = width;\r\n        depthTexture.baseHeight = height;\r\n        depthTexture.width = width;\r\n        depthTexture.height = height;\r\n        depthTexture.isReady = true;\r\n        depthTexture.samples = 1;\r\n        depthTexture.generateMipMaps = generateMipMaps;\r\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        depthTexture.format = depthTextureFormat;\r\n        depthTexture.type = depthTextureType;\r\n\r\n        textures[textureCount] = depthTexture;\r\n        this._internalTexturesCache.push(depthTexture);\r\n    }\r\n    rtWrapper.setTextures(textures);\r\n    if (initializeBuffers) {\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    this.resetTextureCache();\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (\r\n    rtWrapper: Nullable<WebGLRenderTargetWrapper>,\r\n    samples: number,\r\n    initializeBuffers: boolean = true\r\n): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper._attachments!.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    const useDepthStencil = !!rtWrapper._depthStencilBuffer;\r\n    if (useDepthStencil) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(framebuffer);\r\n\r\n        const attachments = [];\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n\r\n            hardwareTexture.releaseMSAARenderBuffers();\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n            const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n            const colorRenderbuffer = this._createRenderBuffer(\r\n                texture.width,\r\n                texture.height,\r\n                samples,\r\n                -1 /* not used */,\r\n                this._getRGBAMultiSampleBufferFormat(texture.type, texture.format),\r\n                attachment\r\n            );\r\n\r\n            if (!colorRenderbuffer) {\r\n                throw new Error(\"Unable to create multi sampled framebuffer\");\r\n            }\r\n\r\n            hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\r\n            texture.samples = samples;\r\n\r\n            attachments.push(attachment);\r\n        }\r\n        if (initializeBuffers) {\r\n            gl.drawBuffers(attachments);\r\n        }\r\n    } else {\r\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n    }\r\n\r\n    if (useDepthStencil) {\r\n        rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper._generateDepthBuffer,\r\n            rtWrapper.texture.width,\r\n            rtWrapper.texture.height,\r\n            samples\r\n        );\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    return samples;\r\n};\r\n","import { Camera } from \"../../Cameras/camera\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Scene } from \"../../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget\";\r\nimport { Frustum } from \"../../Maths/math.frustum\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Creates a new multiview render target\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @returns the created multiview render target wrapper\r\n         */\r\n        createMultiviewRenderTargetTexture(width: number, height: number, colorTexture?: WebGLTexture, depthStencilTexture?: WebGLTexture): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Binds a multiview render target wrapper to be drawn to\r\n         * @param multiviewTexture render target wrapper to bind\r\n         */\r\n        bindMultiviewFramebuffer(multiviewTexture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Binds a Space Warp render target wrapper to be drawn to\r\n         * @param spaceWarpTexture render target wrapper to bind\r\n         */\r\n        bindSpaceWarpFramebuffer(spaceWarpTexture: RenderTargetWrapper): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.createMultiviewRenderTargetTexture = function (width: number, height: number, colorTexture?: WebGLTexture, depthStencilTexture?: WebGLTexture) {\r\n    const gl = this._gl;\r\n\r\n    if (!this.getCaps().multiview) {\r\n        throw \"Multiview is not supported\";\r\n    }\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, { width, height }) as WebGLRenderTargetWrapper;\r\n\r\n    rtWrapper._framebuffer = gl.createFramebuffer();\r\n\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.isMultiview = true;\r\n\r\n    if (!colorTexture) {\r\n        colorTexture = gl.createTexture() as WebGLTexture;\r\n        gl.bindTexture(gl.TEXTURE_2D_ARRAY, colorTexture);\r\n        (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\r\n    }\r\n\r\n    rtWrapper._colorTextureArray = colorTexture;\r\n\r\n    if (!depthStencilTexture) {\r\n        depthStencilTexture = gl.createTexture() as WebGLTexture;\r\n        gl.bindTexture(gl.TEXTURE_2D_ARRAY, depthStencilTexture);\r\n        (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, (gl as any).DEPTH24_STENCIL8, width, height, 2);\r\n    }\r\n\r\n    rtWrapper._depthStencilTextureArray = depthStencilTexture;\r\n\r\n    internalTexture.isReady = true;\r\n\r\n    rtWrapper.setTextures(internalTexture);\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture: RenderTargetWrapper) {\r\n    const multiviewTexture = _multiviewTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\r\n    if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\r\n        if (this.getCaps().oculusMultiview) {\r\n            ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\r\n            ext.framebufferTextureMultisampleMultiviewOVR(\r\n                gl.DRAW_FRAMEBUFFER,\r\n                gl.DEPTH_STENCIL_ATTACHMENT,\r\n                multiviewTexture._depthStencilTextureArray,\r\n                0,\r\n                multiviewTexture.samples,\r\n                0,\r\n                2\r\n            );\r\n        } else {\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\r\n        }\r\n    } else {\r\n        throw \"Invalid multiview frame buffer\";\r\n    }\r\n};\r\n\r\nEngine.prototype.bindSpaceWarpFramebuffer = function (_spaceWarpTexture: RenderTargetWrapper) {\r\n    const spaceWarpTexture = _spaceWarpTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(spaceWarpTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, spaceWarpTexture._framebuffer);\r\n    if (spaceWarpTexture._colorTextureArray && spaceWarpTexture._depthStencilTextureArray) {\r\n        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, spaceWarpTexture._colorTextureArray, 0, 0, 2);\r\n        ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, spaceWarpTexture._depthStencilTextureArray, 0, 0, 2);\r\n    } else {\r\n        throw new Error(\"Invalid Space Warp framebuffer\");\r\n    }\r\n};\r\n\r\ndeclare module \"../../Cameras/camera\" {\r\n    export interface Camera {\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _useMultiviewToSingleView: boolean;\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _multiviewTexture: Nullable<RenderTargetTexture>;\r\n\r\n        /**\r\n         * @internal\r\n         * For WebXR cameras that are rendering to multiview texture arrays.\r\n         */\r\n        _renderingMultiview: boolean;\r\n\r\n        /**\r\n         * @internal\r\n         * ensures the multiview texture of the camera exists and has the specified width/height\r\n         * @param width height to set on the multiview texture\r\n         * @param height width to set on the multiview texture\r\n         */\r\n        _resizeOrCreateMultiviewTexture(width: number, height: number): void;\r\n    }\r\n}\r\n\r\nCamera.prototype._useMultiviewToSingleView = false;\r\n\r\nCamera.prototype._multiviewTexture = null;\r\n\r\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width: number, height: number) {\r\n    if (!this._multiviewTexture) {\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\r\n        this._multiviewTexture.dispose();\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    }\r\n};\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _transformMatrixR: Matrix;\r\n        /** @internal */\r\n        _multiviewSceneUbo: Nullable<UniformBuffer>;\r\n        /** @internal */\r\n        _createMultiviewUbo(): void;\r\n        /** @internal */\r\n        _updateMultiviewUbo(viewR?: Matrix, projectionR?: Matrix): void;\r\n        /** @internal */\r\n        _renderMultiviewToSingleView(camera: Camera): void;\r\n    }\r\n}\r\n\r\nfunction createMultiviewUbo(engine: Engine, name?: string) {\r\n    const ubo = new UniformBuffer(engine, undefined, true, name);\r\n    ubo.addUniform(\"viewProjection\", 16);\r\n    ubo.addUniform(\"viewProjectionR\", 16);\r\n    ubo.addUniform(\"view\", 16);\r\n    ubo.addUniform(\"projection\", 16);\r\n    ubo.addUniform(\"vEyePosition\", 4);\r\n    return ubo;\r\n}\r\n\r\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\r\n\r\nScene.prototype._transformMatrixR = Matrix.Zero();\r\nScene.prototype._multiviewSceneUbo = null;\r\nScene.prototype._createMultiviewUbo = function () {\r\n    this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\r\n};\r\nScene.prototype.createSceneUniformBuffer = function (name?: string): UniformBuffer {\r\n    if (this._multiviewSceneUbo) {\r\n        return createMultiviewUbo(this.getEngine(), name);\r\n    }\r\n    return currentCreateSceneUniformBuffer.bind(this)(name);\r\n};\r\nScene.prototype._updateMultiviewUbo = function (viewR?: Matrix, projectionR?: Matrix) {\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, this._transformMatrixR);\r\n    }\r\n\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\r\n        Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\r\n    }\r\n\r\n    if (this._multiviewSceneUbo) {\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\r\n        this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n        this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\r\n    }\r\n};\r\nScene.prototype._renderMultiviewToSingleView = function (camera: Camera) {\r\n    // Multiview is only able to be displayed directly for API's such as webXR\r\n    // This displays a multiview image by rendering to the multiview image and then\r\n    // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\r\n\r\n    // Render to a multiview texture\r\n    camera._resizeOrCreateMultiviewTexture(\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true),\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true)\r\n    );\r\n    if (!this._multiviewSceneUbo) {\r\n        this._createMultiviewUbo();\r\n    }\r\n    camera.outputRenderTarget = camera._multiviewTexture;\r\n    this._renderForCamera(camera);\r\n    camera.outputRenderTarget = null;\r\n\r\n    // Consume the multiview texture through a shader for each eye\r\n    for (let index = 0; index < camera._rigCameras.length; index++) {\r\n        const engine = this.getEngine();\r\n        this._activeCamera = camera._rigCameras[index];\r\n        engine.setViewport(this._activeCamera.viewport);\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._prepareFrame();\r\n            this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\r\n        }\r\n    }\r\n};\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../types\";\r\n\r\nimport type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a storage buffer\r\n         * @param data the data for the storage buffer or the size of the buffer\r\n         * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added\r\n         * @returns the new buffer\r\n         */\r\n        createStorageBuffer(data: DataArray | number, creationFlags: number): DataBuffer;\r\n\r\n        /**\r\n         * Updates a storage buffer\r\n         * @param buffer the storage buffer to update\r\n         * @param data the data used to update the storage buffer\r\n         * @param byteOffset the byte offset of the data\r\n         * @param byteLength the byte length of the data\r\n         */\r\n        updateStorageBuffer(buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;\r\n\r\n        /**\r\n         * Read data from a storage buffer\r\n         * @param storageBuffer The storage buffer to read from\r\n         * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n         * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n         * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n         * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n         */\r\n        readFromStorageBuffer(storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView>;\r\n\r\n        /**\r\n         * Sets a storage buffer in the shader\r\n         * @param name Defines the name of the storage buffer as defined in the shader\r\n         * @param buffer Defines the value to give to the uniform\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number): DataBuffer {\r\n    throw new Error(\"createStorageBuffer: Unsupported method in this engine!\");\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    throw new Error(\"readFromStorageBuffer: Unsupported method in this engine!\");\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    throw new Error(\"setStorageBuffer: Unsupported method in this engine!\");\r\n};\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Sets a texture sampler to the according uniform.\r\n         * @param name The name of the uniform in the effect\r\n         * @param sampler The sampler to apply\r\n         */\r\n        setTextureSampler(name: string, sampler: Nullable<TextureSampler>): void;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.setTextureSampler = function (name: string, sampler: Nullable<TextureSampler>): void {\r\n    throw new Error(\"setTextureSampler: This engine does not support separate texture sampler objects!\");\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport { Engine } from \"../engine\";\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /** @internal */\r\n        _excludedCompressedTextures: string[];\r\n\r\n        /** @internal */\r\n        _textureFormatInUse: string;\r\n\r\n        /**\r\n         * Gets the list of texture formats supported\r\n         */\r\n        readonly texturesSupported: Array<string>;\r\n\r\n        /**\r\n         * Gets the texture format in use\r\n         */\r\n        readonly textureFormatInUse: Nullable<string>;\r\n\r\n        /**\r\n         * Set the compressed texture extensions or file names to skip.\r\n         *\r\n         * @param skippedFiles defines the list of those texture files you want to skip\r\n         * Example: [\".dds\", \".env\", \"myfile.png\"]\r\n         */\r\n        setCompressedTextureExclusions(skippedFiles: Array<string>): void;\r\n\r\n        /**\r\n         * Set the compressed texture format to use, based on the formats you have, and the formats\r\n         * supported by the hardware / browser.\r\n         *\r\n         * Khronos Texture Container (.ktx) files are used to support this.  This format has the\r\n         * advantage of being specifically designed for OpenGL.  Header elements directly correspond\r\n         * to API arguments needed to compressed textures.  This puts the burden on the container\r\n         * generator to house the arcane code for determining these for current & future formats.\r\n         *\r\n         * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n         * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n         *\r\n         * Note: The result of this call is not taken into account when a texture is base64.\r\n         *\r\n         * @param formatsAvailable defines the list of those format families you have created\r\n         * on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)\r\n         *\r\n         * Current families are astc, dxt, pvrtc, etc2, & etc1.\r\n         * @returns The extension selected.\r\n         */\r\n        setTextureFormatToUse(formatsAvailable: Array<string>): Nullable<string>;\r\n    }\r\n}\r\n\r\nfunction transformTextureUrl(this: Engine, url: string): string {\r\n    const excludeFn = (entry: string) => {\r\n        const strRegExPattern: string = \"\\\\b\" + entry + \"\\\\b\";\r\n        return url && (url === entry || url.match(new RegExp(strRegExPattern, \"g\")));\r\n    };\r\n\r\n    if (this._excludedCompressedTextures && this._excludedCompressedTextures.some(excludeFn)) {\r\n        return url;\r\n    }\r\n\r\n    const lastDot = url.lastIndexOf(\".\");\r\n    const lastQuestionMark = url.lastIndexOf(\"?\");\r\n    const querystring = lastQuestionMark > -1 ? url.substring(lastQuestionMark, url.length) : \"\";\r\n    return (lastDot > -1 ? url.substring(0, lastDot) : url) + this._textureFormatInUse + querystring;\r\n}\r\n\r\nObject.defineProperty(Engine.prototype, \"texturesSupported\", {\r\n    get: function (this: Engine) {\r\n        // Intelligently add supported compressed formats in order to check for.\r\n        // Check for ASTC support first as it is most powerful and to be very cross platform.\r\n        // Next PVRTC & DXT, which are probably superior to ETC1/2.\r\n        // Likely no hardware which supports both PVR & DXT, so order matters little.\r\n        // ETC2 is newer and handles ETC1 (no alpha capability), so check for first.\r\n        const texturesSupported = new Array<string>();\r\n        if (this._caps.astc) {\r\n            texturesSupported.push(\"-astc.ktx\");\r\n        }\r\n        if (this._caps.s3tc) {\r\n            texturesSupported.push(\"-dxt.ktx\");\r\n        }\r\n        if (this._caps.pvrtc) {\r\n            texturesSupported.push(\"-pvrtc.ktx\");\r\n        }\r\n        if (this._caps.etc2) {\r\n            texturesSupported.push(\"-etc2.ktx\");\r\n        }\r\n        if (this._caps.etc1) {\r\n            texturesSupported.push(\"-etc1.ktx\");\r\n        }\r\n        return texturesSupported;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Engine.prototype, \"textureFormatInUse\", {\r\n    get: function (this: Engine) {\r\n        return this._textureFormatInUse || null;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nEngine.prototype.setCompressedTextureExclusions = function (skippedFiles: Array<string>): void {\r\n    this._excludedCompressedTextures = skippedFiles;\r\n};\r\n\r\nEngine.prototype.setTextureFormatToUse = function (formatsAvailable: Array<string>): Nullable<string> {\r\n    const texturesSupported = this.texturesSupported;\r\n    for (let i = 0, len1 = texturesSupported.length; i < len1; i++) {\r\n        for (let j = 0, len2 = formatsAvailable.length; j < len2; j++) {\r\n            if (texturesSupported[i] === formatsAvailable[j].toLowerCase()) {\r\n                this._transformTextureUrl = transformTextureUrl.bind(this);\r\n                return (this._textureFormatInUse = texturesSupported[i]);\r\n            }\r\n        }\r\n    }\r\n    // actively set format to nothing, to allow this to be called more than once\r\n    // and possibly fail the 2nd time\r\n    this._textureFormatInUse = \"\";\r\n    this._transformTextureUrl = null;\r\n    return null;\r\n};\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    const glformat = this._getInternalFormat(texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(Constants.TEXTURETYPE_UNSIGNED_BYTE, texture.format);\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(!invertY); // Video are upside down by default\r\n\r\n    try {\r\n        // Testing video texture support\r\n        if (this._videoTextureSupported === undefined) {\r\n            // clear old errors just in case.\r\n            this._gl.getError();\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\r\n\r\n            if (this._gl.getError() !== 0) {\r\n                this._videoTextureSupported = false;\r\n            } else {\r\n                this._videoTextureSupported = true;\r\n            }\r\n        }\r\n\r\n        // Copy video through the current working canvas if video texture is not supported\r\n        if (!this._videoTextureSupported) {\r\n            if (!texture._workingCanvas) {\r\n                texture._workingCanvas = this.createCanvas(texture.width, texture.height);\r\n                const context = texture._workingCanvas.getContext(\"2d\");\r\n\r\n                if (!context) {\r\n                    throw new Error(\"Unable to get 2d context\");\r\n                }\r\n\r\n                texture._workingContext = context;\r\n                texture._workingCanvas.width = texture.width;\r\n                texture._workingCanvas.height = texture.height;\r\n            }\r\n\r\n            texture._workingContext!.clearRect(0, 0, texture.width, texture.height);\r\n            texture._workingContext!.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, texture._workingCanvas as TexImageSource);\r\n        } else {\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n        }\r\n\r\n        if (!wasPreviouslyBound) {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n        }\r\n        //    this.resetTextureCache();\r\n        texture.isReady = true;\r\n    } catch (ex) {\r\n        // Something unexpected\r\n        // Let's disable the texture\r\n        texture._isDisabled = true;\r\n    }\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Size } from \"../../Maths/math.size\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { IsWindowObjectExist } from \"../../Misc/domManagement\";\r\nimport type { WebVROptions } from \"../../Cameras/VR/webVRCamera\";\r\n\r\n/**\r\n * Interface used to define additional presentation attributes\r\n */\r\nexport interface IVRPresentationAttributes {\r\n    /**\r\n     * Defines a boolean indicating that we want to get 72hz mode on Oculus Browser (default is off eg. 60hz)\r\n     */\r\n    highRefreshRate: boolean;\r\n    /**\r\n     * Enables foveation in VR to improve perf. 0 none, 1 low, 2 medium, 3 high (Default is 1)\r\n     */\r\n    foveationLevel: number;\r\n}\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /** @internal */\r\n        _vrDisplay: any;\r\n        /** @internal */\r\n        _vrSupported: boolean;\r\n        /** @internal */\r\n        _oldSize: Size;\r\n        /** @internal */\r\n        _oldHardwareScaleFactor: number;\r\n        /** @internal */\r\n        _vrExclusivePointerMode: boolean;\r\n        /** @internal */\r\n        _webVRInitPromise: Promise<IDisplayChangedEventArgs>;\r\n\r\n        /** @internal */\r\n        _onVRDisplayPointerRestricted: () => void;\r\n        /** @internal */\r\n        _onVRDisplayPointerUnrestricted: () => void;\r\n\r\n        /** @internal */\r\n        _onVrDisplayConnect: Nullable<(display: any) => void>;\r\n        /** @internal */\r\n        _onVrDisplayDisconnect: Nullable<() => void>;\r\n        /** @internal */\r\n        _onVrDisplayPresentChange: Nullable<() => void>;\r\n\r\n        /**\r\n         * Observable signaled when VR display mode changes\r\n         */\r\n        onVRDisplayChangedObservable: Observable<IDisplayChangedEventArgs>;\r\n        /**\r\n         * Observable signaled when VR request present is complete\r\n         */\r\n        onVRRequestPresentComplete: Observable<boolean>;\r\n        /**\r\n         * Observable signaled when VR request present starts\r\n         */\r\n        onVRRequestPresentStart: Observable<Engine>;\r\n\r\n        /**\r\n         * Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers\r\n         * @see https://docs.microsoft.com/en-us/microsoft-edge/webvr/essentials#mouse-input\r\n         */\r\n        isInVRExclusivePointerMode: boolean;\r\n\r\n        /**\r\n         * Gets a boolean indicating if a webVR device was detected\r\n         * @returns true if a webVR device was detected\r\n         */\r\n        isVRDevicePresent(): boolean;\r\n\r\n        /**\r\n         * Gets the current webVR device\r\n         * @returns the current webVR device (or null)\r\n         */\r\n        getVRDevice(): any;\r\n\r\n        /**\r\n         * Initializes a webVR display and starts listening to display change events\r\n         * The onVRDisplayChangedObservable will be notified upon these changes\r\n         * @returns A promise containing a VRDisplay and if vr is supported\r\n         */\r\n        initWebVRAsync(): Promise<IDisplayChangedEventArgs>;\r\n\r\n        /** @internal */\r\n        _getVRDisplaysAsync(): Promise<IDisplayChangedEventArgs>;\r\n\r\n        /**\r\n         * Gets or sets the presentation attributes used to configure VR rendering\r\n         */\r\n        vrPresentationAttributes?: IVRPresentationAttributes;\r\n\r\n        /**\r\n         * Call this function to switch to webVR mode\r\n         * Will do nothing if webVR is not supported or if there is no webVR device\r\n         * @param options the webvr options provided to the camera. mainly used for multiview\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRCamera\r\n         */\r\n        enableVR(options: WebVROptions): void;\r\n\r\n        /** @internal */\r\n        _onVRFullScreenTriggered(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Engine.prototype, \"isInVRExclusivePointerMode\", {\r\n    get: function (this: Engine) {\r\n        return this._vrExclusivePointerMode;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nEngine.prototype._prepareVRComponent = function () {\r\n    this._vrSupported = false;\r\n    this._vrExclusivePointerMode = false;\r\n    this.onVRDisplayChangedObservable = new Observable<IDisplayChangedEventArgs>();\r\n    this.onVRRequestPresentComplete = new Observable<boolean>();\r\n    this.onVRRequestPresentStart = new Observable<Engine>();\r\n};\r\n\r\nEngine.prototype.isVRDevicePresent = function () {\r\n    return !!this._vrDisplay;\r\n};\r\n\r\nEngine.prototype.getVRDevice = function (): any {\r\n    return this._vrDisplay;\r\n};\r\n\r\nEngine.prototype.initWebVR = function (): Observable<IDisplayChangedEventArgs> {\r\n    this.initWebVRAsync();\r\n    return this.onVRDisplayChangedObservable;\r\n};\r\n\r\nEngine.prototype.initWebVRAsync = function (): Promise<IDisplayChangedEventArgs> {\r\n    const notifyObservers = () => {\r\n        const eventArgs = {\r\n            vrDisplay: this._vrDisplay,\r\n            vrSupported: this._vrSupported,\r\n        };\r\n        this.onVRDisplayChangedObservable.notifyObservers(eventArgs);\r\n        this._webVRInitPromise = new Promise((res) => {\r\n            res(eventArgs);\r\n        });\r\n    };\r\n\r\n    if (!this._onVrDisplayConnect) {\r\n        this._onVrDisplayConnect = (event) => {\r\n            this._vrDisplay = event.display;\r\n            notifyObservers();\r\n        };\r\n        this._onVrDisplayDisconnect = () => {\r\n            this._vrDisplay.cancelAnimationFrame(this._frameHandler);\r\n            this._vrDisplay = undefined;\r\n            this._frameHandler = Engine.QueueNewFrame(this._boundRenderFunction);\r\n            notifyObservers();\r\n        };\r\n        this._onVrDisplayPresentChange = () => {\r\n            this._vrExclusivePointerMode = this._vrDisplay && this._vrDisplay.isPresenting;\r\n        };\r\n        const hostWindow = this.getHostWindow();\r\n        if (hostWindow) {\r\n            hostWindow.addEventListener(\"vrdisplayconnect\", this._onVrDisplayConnect);\r\n            hostWindow.addEventListener(\"vrdisplaydisconnect\", this._onVrDisplayDisconnect);\r\n            hostWindow.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange);\r\n        }\r\n    }\r\n    this._webVRInitPromise = this._webVRInitPromise || this._getVRDisplaysAsync();\r\n    this._webVRInitPromise.then(notifyObservers);\r\n    return this._webVRInitPromise;\r\n};\r\n\r\nEngine.prototype._getVRDisplaysAsync = function (): Promise<IDisplayChangedEventArgs> {\r\n    return new Promise((res) => {\r\n        if (navigator.getVRDisplays) {\r\n            navigator.getVRDisplays().then((devices: Array<any>) => {\r\n                this._vrSupported = true;\r\n                // note that devices may actually be an empty array. This is fine;\r\n                // we expect this._vrDisplay to be undefined in this case.\r\n                this._vrDisplay = devices[0];\r\n                res({\r\n                    vrDisplay: this._vrDisplay,\r\n                    vrSupported: this._vrSupported,\r\n                });\r\n            });\r\n        } else {\r\n            this._vrDisplay = undefined;\r\n            this._vrSupported = false;\r\n            res({\r\n                vrDisplay: this._vrDisplay,\r\n                vrSupported: this._vrSupported,\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\nEngine.prototype.enableVR = function (options: WebVROptions) {\r\n    if (this._vrDisplay && !this._vrDisplay.isPresenting) {\r\n        const onResolved = () => {\r\n            this.onVRRequestPresentComplete.notifyObservers(true);\r\n            this._onVRFullScreenTriggered();\r\n        };\r\n        const onRejected = () => {\r\n            this.onVRRequestPresentComplete.notifyObservers(false);\r\n        };\r\n\r\n        this.onVRRequestPresentStart.notifyObservers(this);\r\n\r\n        const presentationAttributes = {\r\n            highRefreshRate: this.vrPresentationAttributes ? this.vrPresentationAttributes.highRefreshRate : false,\r\n            foveationLevel: this.vrPresentationAttributes ? this.vrPresentationAttributes.foveationLevel : 1,\r\n            multiview: (this.getCaps().multiview || this.getCaps().oculusMultiview) && options.useMultiview,\r\n        };\r\n\r\n        this._vrDisplay\r\n            .requestPresent([\r\n                {\r\n                    source: this.getRenderingCanvas(),\r\n                    attributes: presentationAttributes,\r\n                    ...presentationAttributes,\r\n                },\r\n            ])\r\n            .then(onResolved)\r\n            .catch(onRejected);\r\n    }\r\n};\r\n\r\nEngine.prototype._onVRFullScreenTriggered = function () {\r\n    if (this._vrDisplay && this._vrDisplay.isPresenting) {\r\n        //get the old size before we change\r\n        this._oldSize = new Size(this.getRenderWidth(), this.getRenderHeight());\r\n        this._oldHardwareScaleFactor = this.getHardwareScalingLevel();\r\n\r\n        //get the width and height, change the render size\r\n        const leftEye = this._vrDisplay.getEyeParameters(\"left\");\r\n        this.setHardwareScalingLevel(1);\r\n        this.setSize(leftEye.renderWidth * 2, leftEye.renderHeight);\r\n    } else {\r\n        this.setHardwareScalingLevel(this._oldHardwareScaleFactor);\r\n        this.setSize(this._oldSize.width, this._oldSize.height);\r\n    }\r\n};\r\n\r\nEngine.prototype.disableVR = function () {\r\n    if (this._vrDisplay && this._vrDisplay.isPresenting) {\r\n        this._vrDisplay\r\n            .exitPresent()\r\n            .then(() => this._onVRFullScreenTriggered())\r\n            .catch(() => this._onVRFullScreenTriggered());\r\n    }\r\n\r\n    if (IsWindowObjectExist()) {\r\n        window.removeEventListener(\"vrdisplaypointerrestricted\", this._onVRDisplayPointerRestricted);\r\n        window.removeEventListener(\"vrdisplaypointerunrestricted\", this._onVRDisplayPointerUnrestricted);\r\n\r\n        if (this._onVrDisplayConnect) {\r\n            window.removeEventListener(\"vrdisplayconnect\", this._onVrDisplayConnect);\r\n            if (this._onVrDisplayDisconnect) {\r\n                window.removeEventListener(\"vrdisplaydisconnect\", this._onVrDisplayDisconnect);\r\n            }\r\n\r\n            if (this._onVrDisplayPresentChange) {\r\n                window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange);\r\n            }\r\n            this._onVrDisplayConnect = null;\r\n            this._onVrDisplayDisconnect = null;\r\n        }\r\n    }\r\n};\r\n\r\nEngine.prototype._connectVREvents = function (canvas?: HTMLCanvasElement, document?: any) {\r\n    this._onVRDisplayPointerRestricted = () => {\r\n        if (canvas) {\r\n            canvas.requestPointerLock();\r\n        }\r\n    };\r\n\r\n    this._onVRDisplayPointerUnrestricted = () => {\r\n        // Edge fix - for some reason document is not present and this is window\r\n        if (!document) {\r\n            const hostWindow = this.getHostWindow()!;\r\n            if (hostWindow.document && hostWindow.document.exitPointerLock) {\r\n                hostWindow.document.exitPointerLock();\r\n            }\r\n            return;\r\n        }\r\n        if (!document.exitPointerLock) {\r\n            return;\r\n        }\r\n        document.exitPointerLock();\r\n    };\r\n\r\n    if (IsWindowObjectExist()) {\r\n        const hostWindow = this.getHostWindow()!;\r\n        hostWindow.addEventListener(\"vrdisplaypointerrestricted\", this._onVRDisplayPointerRestricted, false);\r\n        hostWindow.addEventListener(\"vrdisplaypointerunrestricted\", this._onVRDisplayPointerUnrestricted, false);\r\n    }\r\n};\r\n\r\nEngine.prototype._submitVRFrame = function () {\r\n    // Submit frame to the vr device, if enabled\r\n    if (this._vrDisplay && this._vrDisplay.isPresenting) {\r\n        // TODO: We should only submit the frame if we read frameData successfully.\r\n        try {\r\n            this._vrDisplay.submitFrame();\r\n        } catch (e) {\r\n            Tools.Warn(\"webVR submitFrame has had an unexpected failure: \" + e);\r\n        }\r\n    }\r\n};\r\n\r\nEngine.prototype.isVRPresenting = function () {\r\n    return this._vrDisplay && this._vrDisplay.isPresenting;\r\n};\r\n\r\nEngine.prototype._requestVRFrame = function () {\r\n    this._frameHandler = Engine.QueueNewFrame(this._boundRenderFunction, this._vrDisplay);\r\n};\r\n","import type { INative, INativeDataStream } from \"./nativeInterfaces\";\r\n\r\ndeclare const _native: INative;\r\n\r\n/** @internal */\r\nexport type NativeData = Uint32Array;\r\n\r\n/** @internal */\r\nexport class NativeDataStream {\r\n    private readonly _uint32s: Uint32Array;\r\n    private readonly _int32s: Int32Array;\r\n    private readonly _float32s: Float32Array;\r\n    private readonly _length: number;\r\n    private _position: number;\r\n    private readonly _nativeDataStream: INativeDataStream;\r\n\r\n    // Must be multiple of 4!\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private static readonly DEFAULT_BUFFER_SIZE = 65536;\r\n\r\n    constructor() {\r\n        const buffer = new ArrayBuffer(NativeDataStream.DEFAULT_BUFFER_SIZE);\r\n        this._uint32s = new Uint32Array(buffer);\r\n        this._int32s = new Int32Array(buffer);\r\n        this._float32s = new Float32Array(buffer);\r\n\r\n        this._length = NativeDataStream.DEFAULT_BUFFER_SIZE / 4;\r\n        this._position = 0;\r\n\r\n        this._nativeDataStream = new _native.NativeDataStream(() => {\r\n            this._flush();\r\n        });\r\n    }\r\n\r\n    public writeUint32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._uint32s[this._position++] = value;\r\n    }\r\n\r\n    public writeInt32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._int32s[this._position++] = value;\r\n    }\r\n\r\n    public writeFloat32(value: number): void {\r\n        this._flushIfNecessary(1);\r\n        this._float32s[this._position++] = value;\r\n    }\r\n\r\n    public writeUint32Array(values: Uint32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._uint32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    public writeInt32Array(values: Int32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._int32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    public writeFloat32Array(values: Float32Array): void {\r\n        this._flushIfNecessary(1 + values.length);\r\n        this._uint32s[this._position++] = values.length;\r\n        this._float32s.set(values, this._position);\r\n        this._position += values.length;\r\n    }\r\n\r\n    public writeNativeData(handle: NativeData) {\r\n        this._flushIfNecessary(handle.length);\r\n        this._uint32s.set(handle, this._position);\r\n        this._position += handle.length;\r\n    }\r\n\r\n    public writeBoolean(value: boolean) {\r\n        this.writeUint32(value ? 1 : 0);\r\n    }\r\n\r\n    private _flushIfNecessary(required: number): void {\r\n        if (this._position + required > this._length) {\r\n            this._flush();\r\n        }\r\n    }\r\n\r\n    private _flush(): void {\r\n        this._nativeDataStream.writeBuffer(this._uint32s.buffer, this._position);\r\n        this._position = 0;\r\n    }\r\n}\r\n","import type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { INativeEngine, NativeTexture } from \"./nativeInterfaces\";\r\n\r\n/** @internal */\r\nexport class NativeHardwareTexture implements HardwareTextureWrapper {\r\n    private readonly _engine: INativeEngine;\r\n    private _nativeTexture: Nullable<NativeTexture>;\r\n\r\n    public get underlyingResource(): Nullable<NativeTexture> {\r\n        return this._nativeTexture;\r\n    }\r\n\r\n    constructor(existingTexture: NativeTexture, engine: INativeEngine) {\r\n        this._engine = engine;\r\n        this.set(existingTexture);\r\n    }\r\n\r\n    public setUsage(): void {}\r\n\r\n    public set(hardwareTexture: NativeTexture) {\r\n        this._nativeTexture = hardwareTexture;\r\n    }\r\n\r\n    public reset() {\r\n        this._nativeTexture = null;\r\n    }\r\n\r\n    public release() {\r\n        if (this._nativeTexture) {\r\n            this._engine.deleteTexture(this._nativeTexture);\r\n        }\r\n\r\n        this.reset();\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { NativeEngine } from \"../nativeEngine\";\r\n\r\nexport class NativePipelineContext implements IPipelineContext {\r\n    public isParallelCompiled: boolean = true;\r\n    public isCompiled: boolean = false;\r\n    public compilationError?: Error;\r\n\r\n    public get isAsync(): boolean {\r\n        return this.isParallelCompiled;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.compilationError) {\r\n            const message = this.compilationError.message;\r\n            throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\r\n        }\r\n        return this.isCompiled;\r\n    }\r\n\r\n    public onCompiled?: () => void;\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return null;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return null;\r\n    }\r\n\r\n    // TODO: what should this do?\r\n    public _handlesSpectorRebuildCallback(onCompiled: (compiledObject: any) => void): void {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n\r\n    public nativeProgram: any;\r\n\r\n    private _engine: NativeEngine;\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> };\r\n\r\n    constructor(engine: NativeEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this._engine;\r\n        if (engine.supportsUniformBuffers) {\r\n            for (const name in uniformBuffersNames) {\r\n                effect.bindUniformBlock(name, uniformBuffersNames[name]);\r\n            }\r\n        }\r\n\r\n        const effectAvailableUniforms = this._engine.getUniforms(this, uniformsNames);\r\n        effectAvailableUniforms.forEach((uniform, index) => {\r\n            uniforms[uniformsNames[index]] = uniform;\r\n        });\r\n        this._uniforms = uniforms;\r\n\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const sampler = effect.getUniform(samplerList[index]);\r\n            if (sampler == null) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n\r\n        samplerList.forEach((name, index) => {\r\n            samplers[name] = index;\r\n        });\r\n\r\n        attributes.push(...engine.getAttributes(this, attributesNames));\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        this._uniforms = {};\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        const cache = this._valueCache[uniformName];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setUInt(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setUInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setUInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a unsigned int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setUIntArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setFloatArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray2(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray3(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray4(this._uniforms[uniformName]!, array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!matrices) {\r\n            return;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrices(this._uniforms[uniformName]!, matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this._engine.setMatrices(this._uniforms[uniformName]!, matrix.toArray() as Float32Array)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix3x3(this._uniforms[uniformName]!, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix2x2(this._uniforms[uniformName]!, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setFloat(this._uniforms[uniformName]!, value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === bool) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName]!, bool ? 1 : 0)) {\r\n            this._valueCache[uniformName] = bool ? 1 : 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName]!, vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName]!, x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName]!, color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName]!, color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { NativeEngine } from \"../nativeEngine\";\r\nimport type { NativeFramebuffer } from \"./nativeInterfaces\";\r\n\r\nexport class NativeRenderTargetWrapper extends RenderTargetWrapper {\r\n    public override readonly _engine: NativeEngine;\r\n\r\n    private __framebuffer: Nullable<NativeFramebuffer> = null;\r\n    private __framebufferDepthStencil: Nullable<NativeFramebuffer> = null;\r\n\r\n    public get _framebuffer(): Nullable<NativeFramebuffer> {\r\n        return this.__framebuffer;\r\n    }\r\n\r\n    public set _framebuffer(framebuffer: Nullable<NativeFramebuffer>) {\r\n        if (this.__framebuffer) {\r\n            this._engine._releaseFramebufferObjects(this.__framebuffer);\r\n        }\r\n        this.__framebuffer = framebuffer;\r\n    }\r\n\r\n    public get _framebufferDepthStencil(): Nullable<NativeFramebuffer> {\r\n        return this.__framebufferDepthStencil;\r\n    }\r\n\r\n    public set _framebufferDepthStencil(framebufferDepthStencil: Nullable<NativeFramebuffer>) {\r\n        if (this.__framebufferDepthStencil) {\r\n            this._engine._releaseFramebufferObjects(this.__framebufferDepthStencil);\r\n        }\r\n        this.__framebufferDepthStencil = framebufferDepthStencil;\r\n    }\r\n\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: NativeEngine) {\r\n        super(isMulti, isCube, size, engine);\r\n        this._engine = engine;\r\n    }\r\n\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        this._framebuffer = null;\r\n        this._framebufferDepthStencil = null;\r\n\r\n        super.dispose(disposeOnlyFramebuffers);\r\n    }\r\n}\r\n","import { Constants } from \"../../constants\";\r\nimport { Engine } from \"../../engine\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype.setAlphaMode = function (mode: number, noDepthWriteChange: boolean = false): void {\r\n    if (this._alphaMode === mode && ((mode === Constants.ALPHA_DISABLE && !this._alphaState.alphaBlend) || (mode !== Constants.ALPHA_DISABLE && this._alphaState.alphaBlend))) {\r\n        if (!noDepthWriteChange) {\r\n            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)\r\n            const depthMask = mode === Constants.ALPHA_DISABLE;\r\n            if (this.depthCullingState.depthMask !== depthMask) {\r\n                this.setDepthWrite(depthMask);\r\n                this._cacheRenderPipeline.setDepthWriteEnabled(depthMask);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    switch (mode) {\r\n        case Constants.ALPHA_DISABLE:\r\n            this._alphaState.alphaBlend = false;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED_PORTERDUFF:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_COMBINE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ADD:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, 1, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SUBTRACT:\r\n            this._alphaState.setAlphaBlendFunctionParameters(0, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MULTIPLY:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_DST_COLOR, 0, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MAXIMIZED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_SRC_ALPHA, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_INTERPOLATE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SCREENMODE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ALPHATOCOLOR:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_DST_ALPHA, 1, 0, 0);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_REVERSEONEMINUS:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA, 1, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEZERO:\r\n            this._alphaState.setAlphaBlendFunctionParameters(1, 1, 1, 0);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_EXCLUSION:\r\n            this._alphaState.setAlphaBlendFunctionParameters(Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR, Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR, 0, 1);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_LAYER_ACCUMULATE:\r\n            // Same as ALPHA_COMBINE but accumulates (1 - alpha) values in the alpha channel for a later readout in order independant transparency\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                Constants.GL_ALPHA_FUNCTION_SRC_ALPHA,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA,\r\n                1,\r\n                Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n    }\r\n    if (!noDepthWriteChange) {\r\n        this.setDepthWrite(mode === Engine.ALPHA_DISABLE);\r\n        this._cacheRenderPipeline.setDepthWriteEnabled(mode === Engine.ALPHA_DISABLE);\r\n    }\r\n    this._alphaMode = mode;\r\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n\r\nWebGPUEngine.prototype.setAlphaEquation = function (equation: number): void {\r\n    Engine.prototype.setAlphaEquation.call(this, equation);\r\n\r\n    this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\r\n};\r\n","import type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer: {\r\n                        const buffer = type === ComputeBindingType.UniformBuffer ? (object as UniformBuffer) : (object as StorageBuffer);\r\n                        const dataBuffer = buffer.getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n","import type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputePipelineContext implements IComputePipelineContext {\r\n    public engine: WebGPUEngine;\r\n\r\n    public sources: {\r\n        compute: string;\r\n        rawCompute: string;\r\n    };\r\n\r\n    public stage: Nullable<GPUProgrammableStage>;\r\n\r\n    public computePipeline: GPUComputePipeline;\r\n\r\n    public get isAsync() {\r\n        return false;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.stage) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _name: string;\r\n\r\n    constructor(engine: WebGPUEngine) {\r\n        this._name = \"unnamed\";\r\n        this.engine = engine;\r\n    }\r\n\r\n    public _getComputeShaderCode(): string | null {\r\n        return this.sources?.compute;\r\n    }\r\n\r\n    public dispose(): void {}\r\n}\r\n","import type { IComputeEffectCreationOptions } from \"../../../Compute/computeEffect\";\r\nimport { ComputeEffect } from \"../../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../../Extensions/engine.computeShader\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPUComputeContext } from \"../webgpuComputeContext\";\r\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\n\r\ndeclare module \"../../webgpuEngine\" {\r\n    export interface WebGPUEngine {\r\n        /** @internal */\r\n        _createComputePipelineStageDescriptor(computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return new WebGPUComputeContext(this._device, this._cacheSampler);\r\n};\r\n\r\nWebGPUEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\r\n\r\n    const name = compute + \"@\" + options.defines;\r\n    if (this._compiledComputeEffects[name]) {\r\n        const compiledEffect = <ComputeEffect>this._compiledComputeEffects[name];\r\n        if (options.onCompiled && compiledEffect.isReady()) {\r\n            options.onCompiled(compiledEffect);\r\n        }\r\n\r\n        return compiledEffect;\r\n    }\r\n    const effect = new ComputeEffect(baseName, options, this, name);\r\n    this._compiledComputeEffects[name] = effect;\r\n\r\n    return effect;\r\n};\r\n\r\nWebGPUEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    return new WebGPUComputePipelineContext(this);\r\n};\r\n\r\nWebGPUEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    if (this._currentRenderTarget) {\r\n        // A render target pass is currently in effect (meaning beingRenderPass has been called on the command encoder this._renderTargetEncoder): we are not allowed to open\r\n        // another pass on this command encoder (even if it's a compute pass) until endPass has been called, so we need to defer the compute pass for after the current render target pass is closed\r\n        this._onAfterUnbindFrameBufferObservable.addOnce(() => {\r\n            this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);\r\n        });\r\n        return;\r\n    }\r\n\r\n    const contextPipeline = effect._pipelineContext as WebGPUComputePipelineContext;\r\n    const computeContext = context as WebGPUComputeContext;\r\n\r\n    if (!contextPipeline.computePipeline) {\r\n        contextPipeline.computePipeline = this._device.createComputePipeline({\r\n            layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n            compute: contextPipeline.stage!,\r\n        });\r\n    }\r\n\r\n    const commandEncoder = this._renderTargetEncoder;\r\n    const computePass = commandEncoder.beginComputePass();\r\n\r\n    computePass.setPipeline(contextPipeline.computePipeline);\r\n\r\n    const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\r\n    for (let i = 0; i < bindGroups.length; ++i) {\r\n        const bindGroup = bindGroups[i];\r\n        if (!bindGroup) {\r\n            continue;\r\n        }\r\n        computePass.setBindGroup(i, bindGroup);\r\n    }\r\n\r\n    computePass.dispatchWorkgroups(x, y, z);\r\n    computePass.end();\r\n};\r\n\r\nWebGPUEngine.prototype.releaseComputeEffects = function () {\r\n    for (const name in this._compiledComputeEffects) {\r\n        const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext() as WebGPUComputePipelineContext;\r\n        this._deleteComputePipelineContext(webGPUPipelineContextCompute);\r\n    }\r\n\r\n    this._compiledComputeEffects = {};\r\n};\r\n\r\nWebGPUEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {\r\n    const webGpuContext = pipelineContext as WebGPUComputePipelineContext;\r\n\r\n    if (this.dbgShowShaderCode) {\r\n        console.log(defines);\r\n        console.log(computeSourceCode);\r\n    }\r\n\r\n    webGpuContext.sources = {\r\n        compute: computeSourceCode,\r\n        rawCompute: rawComputeSourceCode,\r\n    };\r\n\r\n    webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\r\n};\r\n\r\nWebGPUEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {\r\n    if (this._compiledComputeEffects[effect._key]) {\r\n        delete this._compiledComputeEffects[effect._key];\r\n\r\n        this._deleteComputePipelineContext(effect.getPipelineContext() as WebGPUComputePipelineContext);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._rebuildComputeEffects = function (): void {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        effect._pipelineContext = null;\r\n        effect._wasPreviouslyReady = false;\r\n        effect._prepareEffect();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {\r\n    const webgpuPipelineContext = pipelineContext as WebGPUComputePipelineContext;\r\n    if (webgpuPipelineContext) {\r\n        pipelineContext.dispose();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage {\r\n    if (defines) {\r\n        defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n    } else {\r\n        defines = \"\";\r\n    }\r\n    return {\r\n        module: this._device.createShaderModule({\r\n            code: defines + computeShader,\r\n        }),\r\n        entryPoint,\r\n    };\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\n\r\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n    internalTexture.isCube = true;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n\r\n    // TODO WEBGPU allow to choose the format?\r\n    internalTexture.format = internalOptions.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n\r\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype._debugPushGroup = function (groupName: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;\r\n        encoder.pushDebugGroup(groupName);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.pushDebugGroup(groupName);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"push\", groupName]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugPopGroup = function (targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;\r\n        encoder.popDebugGroup();\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.popDebugGroup();\r\n    } else {\r\n        this._pendingDebugCommands.push([\"pop\", null]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugInsertMarker = function (text: string, targetObject?: number): void {\r\n    if (!this._options.enableGPUDebugMarkers) {\r\n        return;\r\n    }\r\n\r\n    if (targetObject === 0 || targetObject === 1) {\r\n        const encoder = targetObject === 0 ? this._renderEncoder : this._renderTargetEncoder;\r\n        encoder.insertDebugMarker(text);\r\n    } else if (this._currentRenderPass) {\r\n        this._currentRenderPass.insertDebugMarker(text);\r\n    } else {\r\n        this._pendingDebugCommands.push([\"insert\", text]);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._debugFlushPendingCommands = function (): void {\r\n    for (let i = 0; i < this._pendingDebugCommands.length; ++i) {\r\n        const [name, param] = this._pendingDebugCommands[i];\r\n\r\n        switch (name) {\r\n            case \"push\":\r\n                this._debugPushGroup(param!);\r\n                break;\r\n            case \"pop\":\r\n                this._debugPopGroup();\r\n                break;\r\n            case \"insert\":\r\n                this._debugInsertMarker(param!);\r\n                break;\r\n        }\r\n    }\r\n    this._pendingDebugCommands.length = 0;\r\n};\r\n","import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, IndicesArray } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n    const gpuBuffer = indexBuffer as WebGPUDataBuffer;\r\n\r\n    let view: ArrayBufferView;\r\n    if (indexBuffer.is32Bits) {\r\n        view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);\r\n    } else {\r\n        view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);\r\n    }\r\n\r\n    this._bufferManager.setSubData(gpuBuffer, offset, view);\r\n};\r\n\r\nWebGPUEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = vertexBuffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\nWebGPUEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    canvas: HTMLCanvasElement | OffscreenCanvas,\r\n    invertY: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture?: boolean,\r\n    allowGPUOptimization?: boolean\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const width = canvas.width,\r\n        height = canvas.height;\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n    }\r\n\r\n    this._textureHelper.updateTexture(canvas, texture, width, height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, premulAlpha, 0, 0, allowGPUOptimization);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n","import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\n/**\r\n * Nothing specific to WebGPU in this class, but the spec is not final yet so let's remove it later on\r\n * if it is not needed\r\n * @internal\r\n **/\r\nexport class WebGPUExternalTexture extends ExternalTexture {\r\n    public constructor(video: HTMLVideoElement) {\r\n        super(video);\r\n    }\r\n}\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { ExternalTexture } from \"../../../Materials/Textures/externalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUExternalTexture } from \"../webgpuExternalTexture\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets an external texture on the engine to be used in the shader.\r\n         * @param name Name of the external texture variable.\r\n         * @param texture Texture to set.\r\n         */\r\n        setExternalTexture(name: string, texture: Nullable<ExternalTexture>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setExternalTexture = function (name: string, texture: Nullable<ExternalTexture>): void {\r\n    this._engine.setExternalTexture(name, texture);\r\n};\r\n\r\nWebGPUEngine.prototype.createExternalTexture = function (video: HTMLVideoElement): Nullable<ExternalTexture> {\r\n    const texture = new WebGPUExternalTexture(video);\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.setExternalTexture = function (name: string, texture: Nullable<ExternalTexture>): void {\r\n    if (!texture) {\r\n        this._currentMaterialContext.setTexture(name, null);\r\n        return;\r\n    }\r\n    this._setInternalTexture(name, texture);\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n        this._endRenderTargetRenderPass();\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n    this._setColorFormat(this._mainRenderPassWrapper);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n    let formats = new Array<number>();\r\n    let targets = new Array<number>();\r\n    let faceIndex = new Array<number>();\r\n    let layerIndex = new Array<number>();\r\n    let layers = new Array<number>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (options.formats) {\r\n            formats = options.formats;\r\n        }\r\n        if (options.targetTypes) {\r\n            targets = options.targetTypes;\r\n        }\r\n        if (options.faceIndex) {\r\n            faceIndex = options.faceIndex;\r\n        }\r\n        if (options.layerIndex) {\r\n            layerIndex = options.layerIndex;\r\n        }\r\n        if (options.layerCounts) {\r\n            layers = options.layerCounts;\r\n        }\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    let depthStencilTexture = null;\r\n    if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\r\n        if (!generateDepthTexture) {\r\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\r\n            // So, we will align with what the WebGL engine does\r\n            if (generateDepthBuffer && generateStencilBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\r\n            } else if (generateDepthBuffer) {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n            } else {\r\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\r\n            }\r\n        }\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\r\n    }\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n\r\n        const format = formats[i] || defaultFormat;\r\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        if (target === -1) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        switch (target) {\r\n            case Constants.TEXTURE_CUBE_MAP:\r\n                texture.isCube = true;\r\n                break;\r\n            case Constants.TEXTURE_3D:\r\n                texture.is3D = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n            case Constants.TEXTURE_2D_ARRAY:\r\n                texture.is2DArray = true;\r\n                texture.baseDepth = texture.depth = layerCount;\r\n                break;\r\n        }\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures[textureCount] = depthStencilTexture;\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        gpuTextureWrapper?.releaseMSAATexture();\r\n    }\r\n\r\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\r\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples, false, i === count - 1 && lastTextureIsDepthTexture ? 0 : i);\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\nimport type { Scene } from \"../../../scene\";\r\n\r\nWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0,\r\n    useSRGBBuffer: boolean = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[i];\r\n        if (needConversion) {\r\n            faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            const allFaces = [];\r\n            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                allFaces.push(faceDataArrays[faces[faceIndex]]);\r\n            }\r\n            this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?.removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n","import type { OcclusionQuery } from \"../../Extensions/engine.query\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPURenderItemBeginOcclusionQuery, WebGPURenderItemEndOcclusionQuery } from \"../webgpuBundleList\";\r\n\r\nimport type { PerfCounter } from \"../../../Misc/perfCounter\";\r\n\r\nWebGPUEngine.prototype.getGPUFrameTimeCounter = function (): PerfCounter {\r\n    return this._timestampQuery.gpuFrameTimeCounter;\r\n};\r\n\r\nWebGPUEngine.prototype.captureGPUFrameTime = function (value: boolean) {\r\n    this._timestampQuery.enable = value && !!this._caps.timerQuery;\r\n};\r\n\r\nWebGPUEngine.prototype.createQuery = function (): OcclusionQuery {\r\n    return this._occlusionQuery.createQuery();\r\n};\r\n\r\nWebGPUEngine.prototype.deleteQuery = function (query: OcclusionQuery): WebGPUEngine {\r\n    this._occlusionQuery.deleteQuery(query as number);\r\n\r\n    return this;\r\n};\r\n\r\nWebGPUEngine.prototype.isQueryResultAvailable = function (query: OcclusionQuery): boolean {\r\n    return this._occlusionQuery.isQueryResultAvailable(query as number);\r\n};\r\n\r\nWebGPUEngine.prototype.getQueryResult = function (query: OcclusionQuery): number {\r\n    return this._occlusionQuery.getQueryResult(query as number);\r\n};\r\n\r\nWebGPUEngine.prototype.beginOcclusionQuery = function (algorithmType: number, query: OcclusionQuery): boolean {\r\n    if (this.compatibilityMode) {\r\n        if (this._occlusionQuery.canBeginQuery) {\r\n            this._currentRenderPass?.beginOcclusionQuery(query as number);\r\n            return true;\r\n        }\r\n    } else {\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n        bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query as number));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nWebGPUEngine.prototype.endOcclusionQuery = function (): WebGPUEngine {\r\n    if (this.compatibilityMode) {\r\n        this._currentRenderPass?.endOcclusionQuery();\r\n    } else {\r\n        const renderPassIndex = this._getCurrentRenderPassIndex();\r\n        const bundleList = renderPassIndex === 0 ? this._bundleList : this._bundleListRenderTarget;\r\n        bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());\r\n    }\r\n    return this;\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\n\r\nWebGPUEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    return this._textureHelper.readPixels(gpuTextureWrapper.underlyingResource!, x, y, width, height, gpuTextureWrapper.format, faceIndex, level, buffer, noDataConversion);\r\n};\r\n\r\nWebGPUEngine.prototype._readTexturePixelsSync = function (): ArrayBufferView {\r\n    throw \"_readTexturePixelsSync is unsupported in WebGPU!\";\r\n};\r\n","import { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\n/** @internal */\r\nexport class WebGPURenderTargetWrapper extends RenderTargetWrapper {\r\n    /** @internal */\r\n    public _defaultAttachments: number[];\r\n}\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, DepthTextureCreationOptions, TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\n\r\nWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti: boolean, isCube: boolean, size: TextureSize): WebGPURenderTargetWrapper {\r\n    const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);\r\n    this._renderTargetWrapperCache.push(rtWrapper);\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.createRenderTargetTexture = function (size: TextureSize, options: boolean | RenderTargetCreationOptions): WebGPURenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    const fullOptions: RenderTargetCreationOptions = {};\r\n\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        fullOptions.generateMipMaps = options.generateMipMaps;\r\n        fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n        fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n        fullOptions.creationFlags = options.creationFlags ?? 0;\r\n        fullOptions.noColorAttachment = !!options.noColorAttachment;\r\n        fullOptions.samples = options.samples;\r\n        fullOptions.label = options.label;\r\n    } else {\r\n        fullOptions.generateMipMaps = <boolean>options;\r\n        fullOptions.generateDepthBuffer = true;\r\n        fullOptions.generateStencilBuffer = false;\r\n        fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        fullOptions.creationFlags = 0;\r\n        fullOptions.noColorAttachment = false;\r\n    }\r\n\r\n    const texture = fullOptions.noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);\r\n\r\n    rtWrapper._samples = fullOptions.samples ?? 1;\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            this._caps.textureFloatLinearFiltering &&\r\n                (fullOptions.samplingMode === undefined ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR ||\r\n                    fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST),\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples,\r\n            fullOptions.generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n            fullOptions.label ? fullOptions.label + \"-DepthStencil\" : undefined\r\n        );\r\n    }\r\n\r\n    if (texture) {\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n        }\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);\r\n\r\n        if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n            texture.generateMipMaps = false;\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype._createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n    internalTexture.label = options.label;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        depthTextureFormat: options.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        ...options,\r\n    };\r\n\r\n    internalTexture.format = internalOptions.depthTextureFormat;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype._setupDepthStencilTexture = function (\r\n    internalTexture: InternalTexture,\r\n    size: TextureSize,\r\n    generateStencil: boolean,\r\n    bilinearFiltering: boolean,\r\n    comparisonFunction: number,\r\n    samples = 1\r\n): void {\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n    const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n\r\n    internalTexture.baseWidth = width;\r\n    internalTexture.baseHeight = height;\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.is2DArray = layers > 0;\r\n    internalTexture.depth = layers;\r\n    internalTexture.isReady = true;\r\n    internalTexture.samples = samples;\r\n    internalTexture.generateMipMaps = false;\r\n    internalTexture.samplingMode = bilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n    internalTexture._comparisonFunction = comparisonFunction;\r\n    internalTexture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    internalTexture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    this._textureHelper.createMSAATexture(rtWrapper.texture, samples);\r\n\r\n    if (rtWrapper._depthStencilTexture) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n    rtWrapper.texture.samples = samples;\r\n\r\n    return samples;\r\n};\r\n","import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\nWebGPUEngine.prototype.createRenderTargetCubeTexture = function (size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\r\n\r\n    const fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.depth = 0;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = fullOptions.samples;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\r\n        rtWrapper.createDepthStencilTexture(\r\n            0,\r\n            fullOptions.samplingMode === undefined ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_NEAREST_LINEAR ||\r\n                fullOptions.samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST,\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper.samples\r\n        );\r\n    }\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = true;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (options && options.createMipMaps && !fullOptions.generateMipMaps) {\r\n        texture.generateMipMaps = false;\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n","import { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\nimport type { TextureSampler } from \"../../../Materials/Textures/textureSampler\";\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a sampler on the engine to be used in the shader.\r\n         * @param name Name of the sampler variable.\r\n         * @param sampler Sampler to set.\r\n         */\r\n        setTextureSampler(name: string, sampler: Nullable<TextureSampler>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setTextureSampler = function (name: string, sampler: Nullable<TextureSampler>): void {\r\n    this._engine.setTextureSampler(name, sampler);\r\n};\r\n\r\nWebGPUEngine.prototype.setTextureSampler = function (name: string, sampler: Nullable<TextureSampler>): void {\r\n    this._currentMaterialContext?.setSampler(name, sampler);\r\n};\r\n","import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\nimport type { StorageBuffer } from \"../../../Buffers/storageBuffer\";\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a storage buffer on the engine to be used in the shader.\r\n         * @param name Name of the storage buffer variable.\r\n         * @param buffer Storage buffer to set.\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._engine.setStorageBuffer(name, buffer);\r\n};\r\n\r\nWebGPUEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number): DataBuffer {\r\n    return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE);\r\n};\r\n\r\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = buffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n\r\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    size = size || storageBuffer.capacity;\r\n\r\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n    this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n        // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n        this.onEndFrameObservable.addOnce(() => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                    let data: ArrayBufferView | undefined = buffer;\r\n                    if (data === undefined) {\r\n                        data = new Uint8Array(size!);\r\n                        (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                    } else {\r\n                        const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                        data = new ctor(data.buffer);\r\n                        (data as any).set(new ctor(copyArrayBuffer));\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    this._bufferManager.releaseBuffer(gpuBuffer);\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n};\r\n","import type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport type { ExternalTexture } from \"../../../Materials/Textures/externalTexture\";\r\n\r\nfunction IsExternalTexture(texture: Nullable<ExternalTexture> | HTMLVideoElement): texture is ExternalTexture {\r\n    return texture && (texture as ExternalTexture).underlyingResource !== undefined ? true : false;\r\n}\r\n\r\nWebGPUEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    if (this._videoTextureSupported === undefined) {\r\n        this._videoTextureSupported = true;\r\n    }\r\n\r\n    let gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n    if (!texture._hardwareTexture?.underlyingResource) {\r\n        gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (IsExternalTexture(video)) {\r\n        this._textureHelper.copyVideoToTexture(video, texture, gpuTextureWrapper.format, !invertY);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n        texture.isReady = true;\r\n    } else if (video) {\r\n        this.createImageBitmap(video)\r\n            .then((bitmap) => {\r\n                this._textureHelper.updateTexture(bitmap, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, !invertY, false, 0, 0);\r\n                if (texture.generateMipMaps) {\r\n                    this._generateMipmaps(texture, this._uploadEncoder);\r\n                }\r\n\r\n                texture.isReady = true;\r\n            })\r\n            .catch(() => {\r\n                // Sometimes createImageBitmap(video) fails with \"Failed to execute 'createImageBitmap' on 'Window': The provided element's player has no current data.\"\r\n                // Just keep going on\r\n                texture.isReady = true;\r\n            });\r\n    }\r\n};\r\n","import type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\n\r\nimport { WebVRController } from \"./webVRController\";\r\nimport type { ExtendedGamepadButton } from \"./poseEnabledController\";\r\nimport { PoseEnabledControllerHelper } from \"./poseEnabledController\";\r\n\r\n/**\r\n * Generic Controller\r\n */\r\nexport class GenericController extends WebVRController {\r\n    /**\r\n     * Base Url for the controller model.\r\n     */\r\n    public static readonly MODEL_BASE_URL: string = \"https://controllers.babylonjs.com/generic/\";\r\n    /**\r\n     * File name for the controller model.\r\n     */\r\n    public static readonly MODEL_FILENAME: string = \"generic.babylon\";\r\n\r\n    /**\r\n     * Creates a new GenericController from a gamepad\r\n     * @param vrGamepad the gamepad that the controller should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n    }\r\n\r\n    /**\r\n     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n     * @param scene scene in which to add meshes\r\n     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n     */\r\n    public initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void) {\r\n        SceneLoader.ImportMesh(\"\", GenericController.MODEL_BASE_URL, GenericController.MODEL_FILENAME, scene, (newMeshes) => {\r\n            this._defaultModel = newMeshes[1];\r\n            this.attachToMesh(this._defaultModel);\r\n            if (meshLoaded) {\r\n                meshLoaded(this._defaultModel);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called once for each button that changed state since the last frame\r\n     * @param buttonIdx Which button index changed\r\n     * @param state New state of the button\r\n     */\r\n    protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton) {\r\n        console.log(\"Button id: \" + buttonIdx + \"state: \");\r\n        console.dir(state);\r\n    }\r\n}\r\n\r\nPoseEnabledControllerHelper._DefaultControllerFactory = (gamepadInfo: any) => new GenericController(gamepadInfo);\r\n","import { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Node } from \"../../node\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\n\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport type { WebVRFreeCamera, PoseControlled, DevicePose } from \"../../Cameras/VR/webVRCamera\";\r\nimport type { TargetCamera } from \"../../Cameras/targetCamera\";\r\n\r\n/**\r\n * Defines the types of pose enabled controllers that are supported\r\n */\r\nexport enum PoseEnabledControllerType {\r\n    /**\r\n     * HTC Vive\r\n     */\r\n    VIVE,\r\n    /**\r\n     * Oculus Rift\r\n     */\r\n    OCULUS,\r\n    /**\r\n     * Windows mixed reality\r\n     */\r\n    WINDOWS,\r\n    /**\r\n     * Samsung gear VR\r\n     */\r\n    GEAR_VR,\r\n    /**\r\n     * Google Daydream\r\n     */\r\n    DAYDREAM,\r\n    /**\r\n     * Generic\r\n     */\r\n    GENERIC,\r\n}\r\n\r\n/**\r\n * Defines the MutableGamepadButton interface for the state of a gamepad button\r\n */\r\nexport interface MutableGamepadButton {\r\n    /**\r\n     * Value of the button/trigger\r\n     */\r\n    value: number;\r\n    /**\r\n     * If the button/trigger is currently touched\r\n     */\r\n    touched: boolean;\r\n    /**\r\n     * If the button/trigger is currently pressed\r\n     */\r\n    pressed: boolean;\r\n}\r\n\r\n/**\r\n * Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller\r\n * @internal\r\n */\r\nexport interface ExtendedGamepadButton extends GamepadButton {\r\n    /**\r\n     * If the button/trigger is currently pressed\r\n     */\r\n    readonly pressed: boolean;\r\n    /**\r\n     * If the button/trigger is currently touched\r\n     */\r\n    readonly touched: boolean;\r\n    /**\r\n     * Value of the button/trigger\r\n     */\r\n    readonly value: number;\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _GamePadFactory {\r\n    /**\r\n     * Returns whether or not the current gamepad can be created for this type of controller.\r\n     * @param gamepadInfo Defines the gamepad info as received from the controller APIs.\r\n     * @returns true if it can be created, otherwise false\r\n     */\r\n    canCreate(gamepadInfo: any): boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the Gamepad.\r\n     * @param gamepadInfo Defines the gamepad info as received from the controller APIs.\r\n     * @returns the new gamepad instance\r\n     */\r\n    create(gamepadInfo: any): Gamepad;\r\n}\r\n\r\n/**\r\n * Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)\r\n */\r\nexport class PoseEnabledControllerHelper {\r\n    /** @internal */\r\n    public static _ControllerFactories: _GamePadFactory[] = [];\r\n\r\n    /** @internal */\r\n    public static _DefaultControllerFactory: Nullable<(gamepadInfo: any) => Gamepad> = null;\r\n\r\n    /**\r\n     * Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)\r\n     * @param vrGamepad the gamepad to initialized\r\n     * @returns a vr controller of the type the gamepad identified as\r\n     */\r\n    public static InitiateController(vrGamepad: any) {\r\n        for (const factory of this._ControllerFactories) {\r\n            if (factory.canCreate(vrGamepad)) {\r\n                return factory.create(vrGamepad);\r\n            }\r\n        }\r\n\r\n        if (this._DefaultControllerFactory) {\r\n            return this._DefaultControllerFactory(vrGamepad);\r\n        }\r\n\r\n        throw \"The type of gamepad you are trying to load needs to be imported first or is not supported.\";\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the PoseEnabledController object that contains state of a vr capable controller\r\n */\r\nexport class PoseEnabledController extends Gamepad implements PoseControlled {\r\n    /**\r\n     * If the controller is used in a webXR session\r\n     */\r\n    public isXR = false;\r\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\r\n    private _deviceRoomPosition = Vector3.Zero();\r\n    private _deviceRoomRotationQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * The device position in babylon space\r\n     */\r\n    public devicePosition = Vector3.Zero();\r\n    /**\r\n     * The device rotation in babylon space\r\n     */\r\n    public deviceRotationQuaternion = new Quaternion();\r\n    /**\r\n     * The scale factor of the device in babylon space\r\n     */\r\n    public deviceScaleFactor: number = 1;\r\n\r\n    /**\r\n     * (Likely devicePosition should be used instead) The device position in its room space\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n    /**\r\n     * The type of controller (Eg. Windows mixed reality)\r\n     */\r\n    public controllerType: PoseEnabledControllerType;\r\n\r\n    protected _calculatedPosition: Vector3;\r\n    private _calculatedRotation: Quaternion;\r\n\r\n    /**\r\n     * The raw pose from the device\r\n     */\r\n    public rawPose: DevicePose; //GamepadPose;\r\n\r\n    // Used to convert 6dof controllers to 3dof\r\n    private _trackPosition = true;\r\n    private _maxRotationDistFromHeadset = Math.PI / 5;\r\n    private _draggedRoomRotation = 0;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disableTrackPosition(fixedPosition: Vector3) {\r\n        if (this._trackPosition) {\r\n            this._calculatedPosition.copyFrom(fixedPosition);\r\n            this._trackPosition = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal, the mesh attached to the controller\r\n     * @internal\r\n     */\r\n    public _mesh: Nullable<AbstractMesh>; // a node that will be attached to this Gamepad\r\n    private _poseControlledCamera: TargetCamera;\r\n\r\n    private _leftHandSystemQuaternion: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Internal, matrix used to convert room space to babylon space\r\n     * @internal\r\n     */\r\n    public _deviceToWorld = Matrix.Identity();\r\n\r\n    /**\r\n     * Node to be used when casting a ray from the controller\r\n     * @internal\r\n     */\r\n    public _pointingPoseNode: Nullable<TransformNode> = null;\r\n    /**\r\n     * Name of the child mesh that can be used to cast a ray from the controller\r\n     */\r\n    public static readonly POINTING_POSE = \"POINTING_POSE\";\r\n    /**\r\n     * Creates a new PoseEnabledController from a gamepad\r\n     * @param browserGamepad the gamepad that the PoseEnabledController should be created from\r\n     */\r\n    constructor(browserGamepad: any) {\r\n        super(browserGamepad.id, browserGamepad.index, browserGamepad);\r\n        this.type = Gamepad.POSE_ENABLED;\r\n        this.controllerType = PoseEnabledControllerType.GENERIC;\r\n        this.position = Vector3.Zero();\r\n        this.rotationQuaternion = new Quaternion();\r\n\r\n        this._calculatedPosition = Vector3.Zero();\r\n        this._calculatedRotation = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, this._leftHandSystemQuaternion);\r\n    }\r\n\r\n    private _workingMatrix = Matrix.Identity();\r\n    /**\r\n     * Updates the state of the pose enabled controller and mesh based on the current position and rotation of the controller\r\n     */\r\n    public update() {\r\n        super.update();\r\n        this._updatePoseAndMesh();\r\n    }\r\n\r\n    /**\r\n     * Updates only the pose device and mesh without doing any button event checking\r\n     */\r\n    protected _updatePoseAndMesh() {\r\n        if (this.isXR) {\r\n            return;\r\n        }\r\n        const pose: DevicePose = this.browserGamepad.pose;\r\n        this.updateFromDevice(pose);\r\n\r\n        if (\r\n            !this._trackPosition &&\r\n            EngineStore.LastCreatedScene &&\r\n            EngineStore.LastCreatedScene.activeCamera &&\r\n            (<WebVRFreeCamera>EngineStore.LastCreatedScene.activeCamera).devicePosition\r\n        ) {\r\n            const camera = <WebVRFreeCamera>EngineStore.LastCreatedScene.activeCamera;\r\n            camera._computeDevicePosition();\r\n\r\n            this._deviceToWorld.setTranslation(camera.devicePosition);\r\n            if (camera.deviceRotationQuaternion) {\r\n                camera._deviceRoomRotationQuaternion.toEulerAnglesToRef(TmpVectors.Vector3[0]);\r\n\r\n                // Find the radian distance away that the headset is from the controllers rotation\r\n                const distanceAway = Math.atan2(Math.sin(TmpVectors.Vector3[0].y - this._draggedRoomRotation), Math.cos(TmpVectors.Vector3[0].y - this._draggedRoomRotation));\r\n                if (Math.abs(distanceAway) > this._maxRotationDistFromHeadset) {\r\n                    // Only rotate enouph to be within the _maxRotationDistFromHeadset\r\n                    const rotationAmount = distanceAway - (distanceAway < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);\r\n                    this._draggedRoomRotation += rotationAmount;\r\n\r\n                    // Rotate controller around headset\r\n                    const sin = Math.sin(-rotationAmount);\r\n                    const cos = Math.cos(-rotationAmount);\r\n                    this._calculatedPosition.x = this._calculatedPosition.x * cos - this._calculatedPosition.z * sin;\r\n                    this._calculatedPosition.z = this._calculatedPosition.x * sin + this._calculatedPosition.z * cos;\r\n                }\r\n            }\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition);\r\n        this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix);\r\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\r\n        this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation);\r\n\r\n        if (this._mesh) {\r\n            this._mesh.position.copyFrom(this.devicePosition);\r\n\r\n            if (this._mesh.rotationQuaternion) {\r\n                this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the pose enbaled controller based on the raw pose data from the device\r\n     * @param poseData raw pose fromthe device\r\n     */\r\n    updateFromDevice(poseData: DevicePose) {\r\n        if (this.isXR) {\r\n            return;\r\n        }\r\n        if (poseData) {\r\n            this.rawPose = poseData;\r\n            if (poseData.position) {\r\n                this._deviceRoomPosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);\r\n                if (this._mesh && this._mesh.getScene().useRightHandedSystem) {\r\n                    this._deviceRoomPosition.z *= -1;\r\n                }\r\n                if (this._trackPosition) {\r\n                    this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);\r\n                }\r\n                this._calculatedPosition.addInPlace(this.position);\r\n            }\r\n            const pose = this.rawPose;\r\n            if (poseData.orientation && pose.orientation && pose.orientation.length === 4) {\r\n                this._deviceRoomRotationQuaternion.copyFromFloats(pose.orientation[0], pose.orientation[1], -pose.orientation[2], -pose.orientation[3]);\r\n                if (this._mesh) {\r\n                    if (this._mesh.getScene().useRightHandedSystem) {\r\n                        this._deviceRoomRotationQuaternion.z *= -1;\r\n                        this._deviceRoomRotationQuaternion.w *= -1;\r\n                    } else {\r\n                        this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion);\r\n                    }\r\n                }\r\n\r\n                // if the camera is set, rotate to the camera's rotation\r\n                this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _meshAttachedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * Attaches a mesh to the controller\r\n     * @param mesh the mesh to be attached\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh) {\r\n        if (this._mesh) {\r\n            this._mesh.parent = null;\r\n        }\r\n        this._mesh = mesh;\r\n        if (this._poseControlledCamera) {\r\n            this._mesh.parent = this._poseControlledCamera;\r\n        }\r\n        if (!this._mesh.rotationQuaternion) {\r\n            this._mesh.rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        // Sync controller mesh and pointing pose node's state with controller, this is done to avoid a frame where position is 0,0,0 when attaching mesh\r\n        if (!this.isXR) {\r\n            this._updatePoseAndMesh();\r\n            if (this._pointingPoseNode) {\r\n                const parents = [];\r\n                let obj: Node = this._pointingPoseNode;\r\n                while (obj.parent) {\r\n                    parents.push(obj.parent);\r\n                    obj = obj.parent;\r\n                }\r\n                parents.reverse().forEach((p) => {\r\n                    p.computeWorldMatrix(true);\r\n                });\r\n            }\r\n        }\r\n\r\n        this._meshAttachedObservable.notifyObservers(mesh);\r\n    }\r\n\r\n    /**\r\n     * Attaches the controllers mesh to a camera\r\n     * @param camera the camera the mesh should be attached to\r\n     */\r\n    public attachToPoseControlledCamera(camera: TargetCamera) {\r\n        this._poseControlledCamera = camera;\r\n        if (this._mesh) {\r\n            this._mesh.parent = this._poseControlledCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the controller\r\n     */\r\n    public dispose() {\r\n        if (this._mesh) {\r\n            this._mesh.dispose();\r\n        }\r\n        this._mesh = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * The mesh that is attached to the controller\r\n     */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray of the controller in the direction the controller is pointing\r\n     * @param length the length the resulting ray should be\r\n     * @returns a ray in the direction the controller is pointing\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (!this.mesh) {\r\n            return new Ray(Vector3.Zero(), new Vector3(0, 0, 1), length);\r\n        }\r\n\r\n        const m = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix();\r\n        const origin = m.getTranslation();\r\n\r\n        const forward = new Vector3(0, 0, -1);\r\n        const forwardWorld = Vector3.TransformNormal(forward, m);\r\n\r\n        const direction = Vector3.Normalize(forwardWorld);\r\n\r\n        return new Ray(origin, direction, length);\r\n    }\r\n}\r\n","import { Observable } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { ExtendedGamepadButton, MutableGamepadButton } from \"./poseEnabledController\";\r\nimport { PoseEnabledController } from \"./poseEnabledController\";\r\nimport type { StickValues, GamepadButtonChanges } from \"../../Gamepads/gamepad\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines the WebVRController object that represents controllers tracked in 3D space\r\n * @deprecated Use WebXR instead\r\n */\r\nexport abstract class WebVRController extends PoseEnabledController {\r\n    /**\r\n     * Internal, the default controller model for the controller\r\n     */\r\n    protected _defaultModel: Nullable<AbstractMesh>;\r\n\r\n    // Observables\r\n    /**\r\n     * Fired when the trigger state has changed\r\n     */\r\n    public onTriggerStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the main button state has changed\r\n     */\r\n    public onMainButtonStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the secondary button state has changed\r\n     */\r\n    public onSecondaryButtonStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the pad state has changed\r\n     */\r\n    public onPadStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when controllers stick values have changed\r\n     */\r\n    public onPadValuesChangedObservable = new Observable<StickValues>();\r\n\r\n    /**\r\n     * Array of button available on the controller\r\n     */\r\n    protected _buttons: Array<MutableGamepadButton>;\r\n\r\n    private _onButtonStateChange: (controlledIndex: number, buttonIndex: number, state: ExtendedGamepadButton) => void;\r\n\r\n    /**\r\n     * Fired when a controller button's state has changed\r\n     * @param callback the callback containing the button that was modified\r\n     */\r\n    public onButtonStateChange(callback: (controlledIndex: number, buttonIndex: number, state: ExtendedGamepadButton) => void) {\r\n        this._onButtonStateChange = callback;\r\n    }\r\n\r\n    /**\r\n     * X and Y axis corresponding to the controllers joystick\r\n     */\r\n    public pad: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum\r\n     */\r\n    public hand: string;\r\n\r\n    /**\r\n     * The default controller model for the controller\r\n     */\r\n    public get defaultModel(): Nullable<AbstractMesh> {\r\n        return this._defaultModel;\r\n    }\r\n\r\n    /**\r\n     * Creates a new WebVRController from a gamepad\r\n     * @param vrGamepad the gamepad that the WebVRController should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n        this._buttons = new Array<ExtendedGamepadButton>(vrGamepad.buttons.length);\r\n        this.hand = vrGamepad.hand;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the controller and mesh based on the current position and rotation of the controller\r\n     */\r\n    public update() {\r\n        super.update();\r\n        for (let index = 0; index < this._buttons.length; index++) {\r\n            this._setButtonValue(this.browserGamepad.buttons[index], this._buttons[index], index);\r\n        }\r\n        if (this.leftStick.x !== this.pad.x || this.leftStick.y !== this.pad.y) {\r\n            this.pad.x = this.leftStick.x;\r\n            this.pad.y = this.leftStick.y;\r\n            this.onPadValuesChangedObservable.notifyObservers(this.pad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to be called when a button is modified\r\n     */\r\n    protected abstract _handleButtonChange(buttonIdx: number, value: ExtendedGamepadButton, changes: GamepadButtonChanges): void;\r\n\r\n    /**\r\n     * Loads a mesh and attaches it to the controller\r\n     * @param scene the scene the mesh should be added to\r\n     * @param meshLoaded callback for when the mesh has been loaded\r\n     */\r\n    public abstract initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;\r\n\r\n    private _setButtonValue(newState: ExtendedGamepadButton, currentState: ExtendedGamepadButton, buttonIndex: number) {\r\n        if (!newState) {\r\n            newState = {\r\n                pressed: false,\r\n                touched: false,\r\n                value: 0,\r\n            };\r\n        }\r\n        if (!currentState) {\r\n            this._buttons[buttonIndex] = {\r\n                pressed: newState.pressed,\r\n                touched: newState.touched,\r\n                value: newState.value,\r\n            };\r\n            return;\r\n        }\r\n        this._checkChanges(newState, currentState);\r\n        if (this._changes.changed) {\r\n            this._onButtonStateChange && this._onButtonStateChange(this.index, buttonIndex, newState);\r\n\r\n            this._handleButtonChange(buttonIndex, newState, this._changes);\r\n        }\r\n        this._buttons[buttonIndex].pressed = newState.pressed;\r\n        this._buttons[buttonIndex].touched = newState.touched;\r\n        // oculus triggers are never 0, thou not touched.\r\n        this._buttons[buttonIndex].value = newState.value < 0.00000001 ? 0 : newState.value;\r\n    }\r\n\r\n    // avoid GC, store state in a tmp object\r\n    private _changes: GamepadButtonChanges = {\r\n        pressChanged: false,\r\n        touchChanged: false,\r\n        valueChanged: false,\r\n        changed: false,\r\n    };\r\n\r\n    private _checkChanges(newState: ExtendedGamepadButton, currentState: ExtendedGamepadButton) {\r\n        this._changes.pressChanged = newState.pressed !== currentState.pressed;\r\n        this._changes.touchChanged = newState.touched !== currentState.touched;\r\n        this._changes.valueChanged = newState.value !== currentState.value;\r\n        this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged;\r\n        return this._changes;\r\n    }\r\n\r\n    /**\r\n     * Disposes of th webVRController\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._defaultModel = null;\r\n\r\n        this.onTriggerStateChangedObservable.clear();\r\n        this.onMainButtonStateChangedObservable.clear();\r\n        this.onSecondaryButtonStateChangedObservable.clear();\r\n        this.onPadStateChangedObservable.clear();\r\n        this.onPadValuesChangedObservable.clear();\r\n    }\r\n}\r\n","import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        // if pose is supported, use the (WebVR) pose enabled controller\r\n        else if (gamepad.pose) {\r\n            newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            this._checkGamepadsStatus();\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Scene } from \"../scene\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Axis } from \"../Maths/math\";\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\r\n    /**\r\n     * Define the source as a Monoscopic panoramic 360/180.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = 0;\r\n    /**\r\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = 1;\r\n    /**\r\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = 2;\r\n\r\n    private _halfDome: boolean = false;\r\n    private _crossEye: boolean = false;\r\n\r\n    protected _useDirectMapping = false;\r\n\r\n    /**\r\n     * The texture being displayed on the sphere\r\n     */\r\n    protected _texture: T;\r\n\r\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\r\n    public get texture(): T {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\r\n    public set texture(newTexture: T) {\r\n        if (this._texture === newTexture) {\r\n            return;\r\n        }\r\n        this._texture = newTexture;\r\n        if (this._useDirectMapping) {\r\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.diffuseTexture = this._texture;\r\n        } else {\r\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.reflectionTexture = this._texture;\r\n        }\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * The skybox material\r\n     */\r\n    protected _material: BackgroundMaterial;\r\n\r\n    /**\r\n     * The surface used for the dome\r\n     */\r\n    protected _mesh: Mesh;\r\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\r\n    public get mesh(): Mesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\r\n     */\r\n    private _halfDomeMask: Mesh;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._material.fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        this._material.fovMultiplier = value;\r\n    }\r\n\r\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public get textureMode(): number {\r\n        return this._textureMode;\r\n    }\r\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public set textureMode(value: number) {\r\n        if (this._textureMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._changeTextureMode(value);\r\n    }\r\n\r\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\r\n    public get halfDome(): boolean {\r\n        return this._halfDome;\r\n    }\r\n\r\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\r\n    public set halfDome(enabled: boolean) {\r\n        this._halfDome = enabled;\r\n        this._halfDomeMask.setEnabled(enabled);\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\r\n    public set crossEye(enabled: boolean) {\r\n        this._crossEye = enabled;\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\r\n    public get crossEye(): boolean {\r\n        return this._crossEye;\r\n    }\r\n\r\n    /**\r\n     * The background material of this dome.\r\n     */\r\n    public get material(): BackgroundMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /**\r\n     * Observable raised when an error occurred while loading the texture\r\n     */\r\n    public onLoadErrorObservable = new Observable<string>();\r\n    /**\r\n     * Observable raised when the texture finished loading\r\n     */\r\n    public onLoadObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n     * @param name Element's name, child elements will append suffixes for their own names.\r\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n     * @param options An object containing optional or exposed sub element properties\r\n     * @param options.resolution\r\n     * @param options.clickToPlay\r\n     * @param options.autoPlay\r\n     * @param options.loop\r\n     * @param options.size\r\n     * @param options.poster\r\n     * @param options.faceForward\r\n     * @param options.useDirectMapping\r\n     * @param options.halfDomeMode\r\n     * @param options.crossEyeMode\r\n     * @param options.generateMipMaps\r\n     * @param options.mesh\r\n     * @param scene\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        name: string,\r\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\r\n        options: {\r\n            resolution?: number;\r\n            clickToPlay?: boolean;\r\n            autoPlay?: boolean;\r\n            loop?: boolean;\r\n            size?: number;\r\n            poster?: string;\r\n            faceForward?: boolean;\r\n            useDirectMapping?: boolean;\r\n            halfDomeMode?: boolean;\r\n            crossEyeMode?: boolean;\r\n            generateMipMaps?: boolean;\r\n            mesh?: Mesh;\r\n        },\r\n        scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(name, scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        // set defaults and manage values\r\n        name = name || \"textureDome\";\r\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\r\n        options.clickToPlay = Boolean(options.clickToPlay);\r\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\r\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\r\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\r\n\r\n        if (options.useDirectMapping === undefined) {\r\n            this._useDirectMapping = true;\r\n        } else {\r\n            this._useDirectMapping = options.useDirectMapping;\r\n        }\r\n\r\n        if (options.faceForward === undefined) {\r\n            options.faceForward = true;\r\n        }\r\n\r\n        this._setReady(false);\r\n        if (!options.mesh) {\r\n            this._mesh = CreateSphere(name + \"_mesh\", { segments: options.resolution, diameter: options.size, updatable: false, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        } else {\r\n            this._mesh = options.mesh;\r\n        }\r\n        // configure material\r\n        const material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\r\n        material.useEquirectangularFOV = true;\r\n        material.fovMultiplier = 1.0;\r\n        material.opacityFresnel = false;\r\n\r\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\r\n        this.texture = texture;\r\n\r\n        // configure mesh\r\n        this._mesh.material = material;\r\n        this._mesh.parent = this;\r\n\r\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\r\n        this._halfDomeMask = CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\r\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\r\n        this._halfDomeMask.parent = this._mesh;\r\n        this._halfDome = !!options.halfDomeMode;\r\n        // enable or disable according to the settings\r\n        this._halfDomeMask.setEnabled(this._halfDome);\r\n        this._crossEye = !!options.crossEyeMode;\r\n\r\n        // create\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n        this._texture.onLoadObservable.addOnce(() => {\r\n            this._setReady(true);\r\n        });\r\n\r\n        // Initial rotation\r\n        if (options.faceForward && scene.activeCamera) {\r\n            const camera = scene.activeCamera;\r\n\r\n            const forward = Vector3.Forward();\r\n            const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\r\n            direction.normalize();\r\n\r\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\r\n        }\r\n\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\r\n\r\n    protected _changeTextureMode(value: number): void {\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this._textureMode = value;\r\n\r\n        // Default Setup and Reset.\r\n        this._texture.uScale = 1;\r\n        this._texture.vScale = 1;\r\n        this._texture.uOffset = 0;\r\n        this._texture.vOffset = 0;\r\n        this._texture.vAng = 0;\r\n\r\n        switch (value) {\r\n            case TextureDome.MODE_MONOSCOPIC:\r\n                if (this._halfDome) {\r\n                    this._texture.uScale = 2;\r\n                    this._texture.uOffset = -1;\r\n                }\r\n                break;\r\n            case TextureDome.MODE_SIDEBYSIDE: {\r\n                // in half-dome mode the uScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\r\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\r\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    if (isRightCamera) {\r\n                        this._texture.uOffset = rightOffset;\r\n                    } else {\r\n                        this._texture.uOffset = leftOffset;\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case TextureDome.MODE_TOPBOTTOM:\r\n                // in half-dome mode the vScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    // allow \"cross-eye\" if left and right were switched in this mode\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\r\n                });\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.dispose();\r\n        this._mesh.dispose();\r\n        this._material.dispose();\r\n\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this.onLoadErrorObservable.clear();\r\n        this.onLoadObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\n/**\r\n * @internal\r\n **/\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _TimeToken {\r\n    public _startTimeQuery: Nullable<WebGLQuery>;\r\n    public _endTimeQuery: Nullable<WebGLQuery>;\r\n    public _timeElapsedQuery: Nullable<WebGLQuery>;\r\n    public _timeElapsedQueryEnded = false;\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"glowMapGenerationPixelShader\";\nconst shader = `#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)\n#include<helperFunctions>\n#endif\n#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;uniform sampler2D diffuseSampler;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;uniform sampler2D opacitySampler;uniform float opacityIntensity;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;uniform sampler2D emissiveSampler;\n#endif\n#ifdef VERTEXALPHA\nvarying vec4 vColor;\n#endif\nuniform vec4 glowColor;uniform float glowIntensity;\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\nvec4 finalColor=glowColor;\n#ifdef DIFFUSE\nvec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);\n#ifdef DIFFUSE_ISLINEAR\nalbedoTexture=toGammaSpace(albedoTexture);\n#endif\n#ifdef GLOW\nfinalColor.a*=albedoTexture.a;\n#endif\n#ifdef HIGHLIGHT\nfinalColor.a=albedoTexture.a;\n#endif\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vUVOpacity);\n#ifdef OPACITYRGB\nfinalColor.a*=getLuminance(opacityMap.rgb);\n#else\nfinalColor.a*=opacityMap.a;\n#endif\nfinalColor.a*=opacityIntensity;\n#endif\n#ifdef VERTEXALPHA\nfinalColor.a*=vColor.a;\n#endif\n#ifdef ALPHATEST\nif (finalColor.a<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifdef EMISSIVE\nvec4 emissive=texture2D(emissiveSampler,vUVEmissive);\n#ifdef EMISSIVE_ISLINEAR\nemissive=toGammaSpace(emissive);\n#endif\ngl_FragColor=emissive*finalColor*glowIntensity;\n#else\ngl_FragColor=finalColor*glowIntensity;\n#endif\n#ifdef HIGHLIGHT\ngl_FragColor.a=glowColor.a;\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapGenerationPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"glowMapGenerationVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;varying vec4 vPosition;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vUVDiffuse;uniform mat4 diffuseMatrix;\n#endif\n#ifdef OPACITY\nvarying vec2 vUVOpacity;uniform mat4 opacityMatrix;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;uniform mat4 emissiveMatrix;\n#endif\n#ifdef VERTEXALPHA\nattribute vec4 color;varying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef CUBEMAP\nvPosition=worldPos;gl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#else\nvPosition=viewProjection*worldPos;gl_Position=vPosition;\n#endif\n#ifdef DIFFUSE\n#ifdef DIFFUSEUV1\nvUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef DIFFUSEUV2\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef OPACITY\n#ifdef OPACITYUV1\nvUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef OPACITYUV2\nvUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef EMISSIVEUV2\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef VERTEXALPHA\nvColor=color;\n#endif\n#include<clipPlaneVertex>\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapGenerationVertexShader = { name, shader };\n","import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n    protected _effectIntensity: { [meshUniqueId: number]: number } = {};\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._mainTexture.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._effectIntensity[mesh.uniqueId] ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._effectIntensity[mesh.uniqueId] = intensity;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene\r\n    ) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._effectLayerOptions.mainTextureType,\r\n            false,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            true,\r\n            this._effectLayerOptions.generateStencilBuffer\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        for (const id in this._materialForRendering) {\r\n            const [mesh, material] = this._materialForRendering[id];\r\n            this._mainTexture.setMaterialForRendering(mesh, material);\r\n        }\r\n\r\n        this._mainTexture.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        if (this._scene.getBoundingBoxRenderer) {\r\n            const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n            this._mainTexture.onBeforeBindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._mainTexture.onAfterUnbindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"glowIntensity\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: morphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        // Check\r\n        let isReady = true;\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = isReady && currentEffect.effect!.isReady();\r\n        }\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalRender(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     * @param subMesh\r\n     * @param enableAlphaMode\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n        } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTesting();\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Intensity of effect\r\n                effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { PBRMaterial } from \"../Materials/PBR/pbrMaterial\";\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return the first glow layer of the scene with a given name.\r\n         * @param name The name of the glow layer to look for.\r\n         * @returns The glow layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getGlowLayerByName = function (name: string): Nullable<GlowLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * How big is the kernel of the blur texture. Default: 32\r\n     */\r\n    blurKernelSize: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Enable MSAA by choosing the number of samples. Default: 1\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Forces the merge step to be done in ldr (clamp values > 1). Default: false\r\n     */\r\n    ldrMerge?: boolean;\r\n\r\n    /**\r\n     * Defines the blend mode used by the merge. Default: ALPHA_ADD\r\n     */\r\n    alphaBlendingMode?: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        if (value === this._options.blurKernelSize) {\r\n            return;\r\n        }\r\n\r\n        this._options.blurKernelSize = value;\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._horizontalBlurPostprocess2.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess2.kernel = effectiveKernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._options.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    private _options: IGlowLayerOptions;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n\r\n    private _includedOnlyMeshes: number[] = [];\r\n    private _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId,\r\n            mainTextureType: this._options.mainTextureType,\r\n            generateStencilBuffer: this._options.generateStencilBuffer,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        let defines = \"#define EMISSIVE \\n\";\r\n        if (this._options.ldrMerge) {\r\n            defines += \"#define LDR \\n\";\r\n        }\r\n\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerHBP1\",\r\n            new Vector2(1.0, 0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerVBP1\",\r\n            new Vector2(0, 1.0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerHBP2\",\r\n            new Vector2(1.0, 0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerVBP2\",\r\n            new Vector2(0, 1.0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            const internalTexture = this._blurTexture1.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\r\n\r\n                const internalTexture2 = this._blurTexture2.renderTarget;\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @returns The blur kernel size used by the glow.\r\n     * Note: The value passed in the options is divided by 2 for back compatibility.\r\n     */\r\n    private _getEffectiveBlurKernelSize() {\r\n        return this._options.blurKernelSize / 2;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        const emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        const previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        let textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            } else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                const emissiveIntensity = (<PBRMaterial>material).emissiveIntensity ?? 1;\r\n                textureLevel *= emissiveIntensity;\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha\r\n                );\r\n            } else {\r\n                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n\r\n        mesh.onDisposeObservable.add(() => {\r\n            this._disposeMesh(mesh as Mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        let index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        if (this._includedOnlyMeshes.length) {\r\n            for (index = 0; index < this._includedOnlyMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes.length) {\r\n            for (index = 0; index < this._excludedMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\r\n","import type { Nullable } from \"../types\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { LensFlareSystem } from \"./lensFlareSystem\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\n/**\r\n * This represents one of the lens effect in a `lensFlareSystem`.\r\n * It controls one of the individual texture used in the effect.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n */\r\nexport class LensFlare {\r\n    /**\r\n     * Define the lens color.\r\n     */\r\n    public color: Color3;\r\n\r\n    /**\r\n     * Define the lens texture.\r\n     */\r\n    public texture: Nullable<Texture>;\r\n\r\n    /**\r\n     * Define the alpha mode to render this particular lens.\r\n     */\r\n    public alphaMode: number = Constants.ALPHA_ONEONE;\r\n\r\n    /** @internal */\r\n    public _drawWrapper: DrawWrapper;\r\n\r\n    private _system: LensFlareSystem;\r\n\r\n    /**\r\n     * Creates a new Lens Flare.\r\n     * This represents one of the lens effect in a `lensFlareSystem`.\r\n     * It controls one of the individual texture used in the effect.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     * @param size Define the size of the lens flare (a floating value between 0 and 1)\r\n     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\r\n     * @param color Define the lens color\r\n     * @param imgUrl Define the lens texture url\r\n     * @param system Define the `lensFlareSystem` this flare is part of\r\n     * @returns The newly created Lens Flare\r\n     */\r\n    public static AddFlare(size: number, position: number, color: Color3, imgUrl: string, system: LensFlareSystem): LensFlare {\r\n        return new LensFlare(size, position, color, imgUrl, system);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Lens Flare.\r\n     * This represents one of the lens effect in a `lensFlareSystem`.\r\n     * It controls one of the individual texture used in the effect.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     * @param size Define the size of the lens flare in the system (a floating value between 0 and 1)\r\n     * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\r\n     * @param color Define the lens color\r\n     * @param imgUrl Define the lens texture url\r\n     * @param system Define the `lensFlareSystem` this flare is part of\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the size of the lens flare in the system (a floating value between 0 and 1)\r\n         */\r\n        public size: number,\r\n        /**\r\n         * Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.\r\n         */\r\n        public position: number,\r\n        color: Color3,\r\n        imgUrl: string,\r\n        system: LensFlareSystem\r\n    ) {\r\n        this.color = color || new Color3(1, 1, 1);\r\n        this.texture = imgUrl ? new Texture(imgUrl, system.getScene(), true) : null;\r\n        this._system = system;\r\n\r\n        const engine = system.scene.getEngine();\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        this._drawWrapper.effect = engine.createEffect(\"lensFlare\", [VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\r\n\r\n        system.lensFlares.push(this);\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        const index = this._system.lensFlares.indexOf(this);\r\n        this._system.lensFlares.splice(index, 1);\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lensFlarePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);gl_FragColor=baseColor*color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lensFlarePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lensFlareVertexShader\";\nconst shader = `attribute vec2 position;uniform mat4 viewportMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=position*madd+madd;gl_Position=viewportMatrix*vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lensFlareVertexShader = { name, shader };\n","import { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { LensFlare } from \"./lensFlare\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/lensFlare.fragment\";\r\nimport \"../Shaders/lensFlare.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\n\r\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n */\r\nexport class LensFlareSystem {\r\n    /**\r\n     * List of lens flares used in this system.\r\n     */\r\n    public lensFlares = new Array<LensFlare>();\r\n\r\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\r\n    public borderLimit = 300;\r\n\r\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\r\n    public viewportBorder = 0;\r\n\r\n    /**\r\n     * Define a predicate which could limit the list of meshes able to occlude the effect.\r\n     */\r\n    public meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /** Gets the scene */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Define the id of the lens flare system in the scene.\r\n     * (equal to name by default)\r\n     */\r\n    public id: string;\r\n\r\n    private _scene: Scene;\r\n    private _emitter: any;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _positionX: number;\r\n    private _positionY: number;\r\n    private _isEnabled = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"LensFlareSystemSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Instantiates a lens flare system.\r\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n     * It is usually composed of several `lensFlare`.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     * @param name Define the name of the lens flare system in the scene\r\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param scene Define the scene the lens flare system belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the lens flare system\r\n         */\r\n        public name: string,\r\n        emitter: any,\r\n        scene: Scene\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        LensFlareSystem._SceneComponentInitialization(this._scene);\r\n\r\n        this._emitter = emitter;\r\n        this.id = name;\r\n        scene.lensFlareSystems.push(this);\r\n\r\n        this.meshesSelectionPredicate = (m) =>\r\n            <boolean>(scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        // Indices\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the effects belongs to.\r\n     * @returns the scene holding the lens flare system\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the emitter of the lens flare system\r\n     */\r\n    public getEmitter(): any {\r\n        return this._emitter;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param newEmitter Define the new emitter of the system\r\n     */\r\n    public setEmitter(newEmitter: any): void {\r\n        this._emitter = newEmitter;\r\n    }\r\n\r\n    /**\r\n     * Get the lens flare system emitter position.\r\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the position\r\n     */\r\n    public getEmitterPosition(): Vector3 {\r\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public computeEffectivePosition(globalViewport: Viewport): boolean {\r\n        let position = this.getEmitterPosition();\r\n\r\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._positionX = position.x;\r\n        this._positionY = position.y;\r\n\r\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x -= this.viewportBorder;\r\n            globalViewport.y -= this.viewportBorder;\r\n            globalViewport.width += this.viewportBorder * 2;\r\n            globalViewport.height += this.viewportBorder * 2;\r\n            position.x += this.viewportBorder;\r\n            position.y += this.viewportBorder;\r\n            this._positionX += this.viewportBorder;\r\n            this._positionY += this.viewportBorder;\r\n        }\r\n\r\n        const rhs = this._scene.useRightHandedSystem;\r\n        const okZ = (position.z > 0 && !rhs) || (position.z < 0 && rhs);\r\n\r\n        if (okZ) {\r\n            if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\r\n                if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\r\n                    return true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isVisible(): boolean {\r\n        if (!this._isEnabled || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const emitterPosition = this.getEmitterPosition();\r\n        const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\r\n        const distance = direction.length();\r\n        direction.normalize();\r\n\r\n        const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\r\n        const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\r\n\r\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public render(): boolean {\r\n        if (!this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const viewport = this._scene.activeCamera.viewport;\r\n        const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\r\n\r\n        // Position\r\n        if (!this.computeEffectivePosition(globalViewport)) {\r\n            return false;\r\n        }\r\n\r\n        // Visibility\r\n        if (!this._isVisible()) {\r\n            return false;\r\n        }\r\n\r\n        // Intensity\r\n        let awayX;\r\n        let awayY;\r\n\r\n        if (this._positionX < this.borderLimit + globalViewport.x) {\r\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\r\n        } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\r\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\r\n        } else {\r\n            awayX = 0;\r\n        }\r\n\r\n        if (this._positionY < this.borderLimit + globalViewport.y) {\r\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\r\n        } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\r\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\r\n        } else {\r\n            awayY = 0;\r\n        }\r\n\r\n        let away = awayX > awayY ? awayX : awayY;\r\n\r\n        away -= this.viewportBorder;\r\n\r\n        if (away > this.borderLimit) {\r\n            away = this.borderLimit;\r\n        }\r\n\r\n        let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\r\n        if (intensity < 0) {\r\n            return false;\r\n        }\r\n\r\n        if (intensity > 1.0) {\r\n            intensity = 1.0;\r\n        }\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x += this.viewportBorder;\r\n            globalViewport.y += this.viewportBorder;\r\n            globalViewport.width -= this.viewportBorder * 2;\r\n            globalViewport.height -= this.viewportBorder * 2;\r\n            this._positionX -= this.viewportBorder;\r\n            this._positionY -= this.viewportBorder;\r\n        }\r\n\r\n        // Position\r\n        const centerX = globalViewport.x + globalViewport.width / 2;\r\n        const centerY = globalViewport.y + globalViewport.height / 2;\r\n        const distX = centerX - this._positionX;\r\n        const distY = centerY - this._positionY;\r\n\r\n        // Effects\r\n        engine.setState(false);\r\n        engine.setDepthBuffer(false);\r\n\r\n        // Flares\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            if (!flare._drawWrapper.effect!.isReady() || (flare.texture && !flare.texture.isReady())) {\r\n                continue;\r\n            }\r\n\r\n            engine.enableEffect(flare._drawWrapper);\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect!);\r\n\r\n            engine.setAlphaMode(flare.alphaMode);\r\n\r\n            const x = centerX - distX * flare.position;\r\n            const y = centerY - distY * flare.position;\r\n\r\n            const cw = flare.size;\r\n            const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\r\n            const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\r\n            const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\r\n\r\n            const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\r\n\r\n            flare._drawWrapper.effect!.setMatrix(\"viewportMatrix\", viewportMatrix);\r\n\r\n            // Texture\r\n            flare._drawWrapper.effect!.setTexture(\"textureSampler\", flare.texture);\r\n\r\n            // Color\r\n            flare._drawWrapper.effect!.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        engine.setDepthBuffer(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the lens flare system\r\n     */\r\n    public rebuild(): void {\r\n        this._createIndexBuffer();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]?._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        while (this.lensFlares.length) {\r\n            this.lensFlares[0].dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        const index = this._scene.lensFlareSystems.indexOf(this);\r\n        this._scene.lensFlareSystems.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Parse a lens flare system from a JSON representation\r\n     * @param parsedLensFlareSystem Define the JSON to parse\r\n     * @param scene Define the scene the parsed system should be instantiated in\r\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n     * @returns the parsed system\r\n     */\r\n    public static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem {\r\n        const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\r\n\r\n        const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\r\n\r\n        const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\r\n\r\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\r\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\r\n\r\n        for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\r\n            const parsedFlare = parsedLensFlareSystem.flares[index];\r\n            LensFlare.AddFlare(\r\n                parsedFlare.size,\r\n                parsedFlare.position,\r\n                Color3.FromArray(parsedFlare.color),\r\n                parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\",\r\n                lensFlareSystem\r\n            );\r\n        }\r\n\r\n        return lensFlareSystem;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current Lens Flare System into a JSON representation.\r\n     * @returns the serialized JSON\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.emitterId = this.getEmitter().id;\r\n        serializationObject.borderLimit = this.borderLimit;\r\n\r\n        serializationObject.flares = [];\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            serializationObject.flares.push({\r\n                size: flare.size,\r\n                position: flare.position,\r\n                color: flare.color.asArray(),\r\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\"),\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\n\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n\r\n/**\r\n * Base block used as input for post process\r\n */\r\nexport class CurrentScreenBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"textureSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new CurrentScreenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"CurrentScreenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\");\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\r\n            state.sharedData.blockingBlocks.push(this);\r\n        }\r\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\r\n            state.sharedData.textureBlocks.push(this);\r\n        }\r\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\n/**\r\n * Block used to provide an image for a TextureBlock\r\n */\r\nexport class ImageSourceBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageSourceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setTexture(this._samplerName, this.texture);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ImageSourceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _defineCubicName: string;\r\n    /** @internal */\r\n    public _defineExplicitName: string;\r\n    /** @internal */\r\n    public _defineProjectionName: string;\r\n    /** @internal */\r\n    public _defineLocalCubicName: string;\r\n    /** @internal */\r\n    public _defineSphericalName: string;\r\n    /** @internal */\r\n    public _definePlanarName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularName: string;\r\n    /** @internal */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineSkyboxName: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _reflectionPositionName: string;\r\n    /** @internal */\r\n    public _reflectionSizeName: string;\r\n\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @internal */\r\n    public _reflectionCoordsName: string;\r\n    /** @internal */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n    protected _worldPositionNameInFragmentOnlyMode: string;\r\n\r\n    protected _texture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<BaseTexture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    protected static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as ReflectionTextureBaseBlock;\r\n        return that._onGenerateOnlyFragmentCodeChanged();\r\n    }\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        this._setTarget();\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === Constants.TEXTURE_EXPLICIT_MODE, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === Constants.TEXTURE_SKYBOX_MODE, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === Constants.TEXTURE_CUBIC_MODE || texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === Constants.TEXTURE_SPHERICAL_MODE, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === Constants.TEXTURE_PLANAR_MODE, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === Constants.TEXTURE_PROJECTION_MODE, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === Constants.TEXTURE_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n\r\n        if ((<any>texture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>texture;\r\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return \"\";\r\n        }\r\n\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\r\n\r\n        const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\n`;\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        if (\r\n            this.generateOnlyFragmentCode ||\r\n            state._emitVaryingFromString(\r\n                this._directionWName,\r\n                \"vec3\",\r\n                `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`\r\n            )\r\n        ) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${\r\n                this.position.associatedVariableName\r\n            }.xyz, 0.0)));\\n`;\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\r\n        state._samplerDeclaration += `#else\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\r\n        state._samplerDeclaration += `#endif\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }],\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n\r\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\r\n\r\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false, doNotEmitInvertZ = false): string {\r\n        if (!worldPos) {\r\n            worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        const reflectionMatrix = this._reflectionMatrixName;\r\n        const direction = `normalize(${this._directionWName})`;\r\n        const positionUVW = `${this._positionUVWName}`;\r\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        const view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\\n`;\r\n\r\n        if (!doNotEmitInvertZ) {\r\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\n`;\r\n        }\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `#endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (const output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        if (this.texture.isCube) {\r\n            const forcedExtension = (this.texture as CubeTexture).forcedExtension;\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${\r\n                this.texture.noMipmap\r\n            }, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\n`;\r\n        } else {\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\n\r\n/**\r\n * Block used to implement TBN matrix\r\n */\r\nexport class TBNBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new TBNBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.normal.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\r\n\r\n        this.registerOutput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Output, TBNBlock, \"TBNBlock\")\r\n        );\r\n\r\n        this.registerOutput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TBNBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"tbnNormal\");\r\n        state._excludeVariableName(\"tbnTangent\");\r\n        state._excludeVariableName(\"tbnBitangent\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN output component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the row0 of the output matrix\r\n     */\r\n    public get row0(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the row1 of the output matrix\r\n     */\r\n    public get row1(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the row2 of the output matrix\r\n     */\r\n    public get row2(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public get target() {\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {}\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate(\r\n                (b) => b.isAttribute && b.name === \"tangent\" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4 && additionalFilteringInfo(b)\r\n            );\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n\r\n        let normalAvailable = normal.isConnected;\r\n        if (normal.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(normal.connectInputBlock?.name)) {\r\n            normalAvailable = false;\r\n        }\r\n\r\n        let tangentAvailable = tangent.isConnected;\r\n        if (tangent.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(tangent.connectInputBlock?.name)) {\r\n            tangentAvailable = false;\r\n        }\r\n\r\n        const useTBNBlock = normalAvailable && tangentAvailable;\r\n\r\n        defines.setValue(\"TBNBLOCK\", useTBNBlock, true);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const world = this.world;\r\n        const TBN = this.TBN;\r\n        const row0 = this.row0;\r\n        const row1 = this.row1;\r\n        const row2 = this.row2;\r\n\r\n        // Fragment\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `\r\n                // ${this.name}\r\n                vec3 tbnNormal = normalize(${normal.associatedVariableName}).xyz;\r\n                vec3 tbnTangent = normalize(${tangent.associatedVariableName}.xyz);\r\n                vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;\r\n                mat3 ${TBN.associatedVariableName} = mat3(${world.associatedVariableName}) * mat3(tbnTangent, tbnBitangent, tbnNormal);\r\n            `;\r\n\r\n            if (row0.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(row0, state) + ` = vec3(${TBN.associatedVariableName}[0][0], ${TBN.associatedVariableName}[0][1], ${TBN.associatedVariableName}[0][2]);\\n`;\r\n            }\r\n            if (row1.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(row1, state) + ` = vec3(${TBN.associatedVariableName}[1[0], ${TBN.associatedVariableName}[1][1], ${TBN.associatedVariableName}[1][2]);\\n`;\r\n            }\r\n            if (row2.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(row2, state) + ` = vec3(${TBN.associatedVariableName}[2][0], ${TBN.associatedVariableName}[2][1], ${TBN.associatedVariableName}[2][2]);\\n`;\r\n            }\r\n\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TBNBlock\", TBNBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.rgb.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float\r\n        );\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    @editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    @editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (this.useLogarithmicDepth && mesh) {\r\n            MaterialHelper.BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        if (this.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\n`;\r\n        }\r\n\r\n        state.compilationString += `#if defined(PREPASS)\\r\\n`;\r\n        state.compilationString += `gl_FragData[0] = gl_FragColor;\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n","/**\r\n * Enum defining the type of animations supported by InputBlock\r\n */\r\nexport enum AnimatedInputBlockTypes {\r\n    /** No animation */\r\n    None,\r\n    /** Time based animation (is incremented by 0.6 each second). Will only work for floats */\r\n    Time,\r\n    /** Time elapsed (in seconds) since the engine was initialized. Will only work for floats */\r\n    RealTime,\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Effect } from \"../../../../Materials/effect\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Color3, Color4, TmpColors } from \"../../../../Maths/math\";\r\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes\";\r\nimport { Observable } from \"../../../../Misc/observable\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\r\n\r\nconst remapAttributeName: { [name: string]: string } = {\r\n    position2d: \"position\",\r\n    particle_uv: \"vUV\",\r\n    particle_color: \"vColor\",\r\n    particle_texturemask: \"textureMask\",\r\n    particle_positionw: \"vPositionW\",\r\n};\r\n\r\nconst attributeInFragmentOnly: { [name: string]: boolean } = {\r\n    particle_uv: true,\r\n    particle_color: true,\r\n    particle_texturemask: true,\r\n    particle_positionw: true,\r\n};\r\n\r\nconst attributeAsUniform: { [name: string]: boolean } = {\r\n    particle_texturemask: true,\r\n};\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class InputBlock extends NodeMaterialBlock {\r\n    private _mode = NodeMaterialBlockConnectionPointMode.Undefined;\r\n    private _associatedVariableName: string;\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeMaterialBlockConnectionPointTypes;\r\n    private _animationType = AnimatedInputBlockTypes.None;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\r\n    public isBoolean: boolean = false;\r\n\r\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\r\n    public matrixMode: number = 0;\r\n\r\n    /** @internal */\r\n    public _systemValue: Nullable<NodeMaterialSystemValues> = null;\r\n\r\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\r\n    public isConstant = false;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<InputBlock>();\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.isUniform && this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Color3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case \"Color4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isAttribute) {\r\n                switch (this.name) {\r\n                    case \"position\":\r\n                    case \"normal\":\r\n                    case \"particle_positionw\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"uv\":\r\n                    case \"uv2\":\r\n                    case \"uv3\":\r\n                    case \"uv4\":\r\n                    case \"uv5\":\r\n                    case \"uv6\":\r\n                    case \"position2d\":\r\n                    case \"particle_uv\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"matricesIndices\":\r\n                    case \"matricesWeights\":\r\n                    case \"matricesIndicesExtra\":\r\n                    case \"matricesWeightsExtra\":\r\n                    case \"world0\":\r\n                    case \"world1\":\r\n                    case \"world2\":\r\n                    case \"world3\":\r\n                    case \"tangent\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"color\":\r\n                    case \"instanceColor\":\r\n                    case \"particle_color\":\r\n                    case \"particle_texturemask\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isSystemValue) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.World:\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                    case NodeMaterialSystemValues.View:\r\n                    case NodeMaterialSystemValues.ViewProjection:\r\n                    case NodeMaterialSystemValues.Projection:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraPosition:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.FogColor:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.DeltaTime:\r\n                    case NodeMaterialSystemValues.MaterialAlpha:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraParameters:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, type: NodeMaterialBlockConnectionPointTypes = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n        super(name, target, false);\r\n\r\n        this._type = type;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Validates if a name is a reserve word.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        if (!this.isAttribute) {\r\n            return super.validateBlockName(newName);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a vertex attribute\r\n     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\r\n     * @returns the current connection point\r\n     */\r\n    public setAsAttribute(attributeName?: string): InputBlock {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\r\n        if (attributeName) {\r\n            this.name = attributeName;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a system value\r\n     * @param value define the system value to use (world, view, etc...) or null to switch to manual value\r\n     * @returns the current connection point\r\n     */\r\n    public setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock {\r\n        this.systemValue = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n            if (this.isBoolean) {\r\n                value = value ? 1 : 0;\r\n            } else if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Gets or sets the type of animation applied to the input */\r\n    public get animationType() {\r\n        return this._animationType;\r\n    }\r\n\r\n    public set animationType(value: AnimatedInputBlockTypes) {\r\n        this._animationType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this connection point not defined yet\r\n     */\r\n    public get isUndefined(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\r\n     * In this case the connection point name must be the name of the uniform to use.\r\n     * Can only be set on inputs\r\n     */\r\n    public get isUniform(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    public set isUniform(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\r\n     * In this case the connection point name must be the name of the attribute to use\r\n     * Can only be set on inputs\r\n     */\r\n    public get isAttribute(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\r\n    }\r\n\r\n    public set isAttribute(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\r\n     * Can only be set on exit points\r\n     */\r\n    public get isVarying(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\r\n    }\r\n\r\n    public set isVarying(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a system value\r\n     */\r\n    public get isSystemValue(): boolean {\r\n        return this._systemValue != null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current well known value or null if not defined as a system value\r\n     */\r\n    public get systemValue(): Nullable<NodeMaterialSystemValues> {\r\n        return this._systemValue;\r\n    }\r\n\r\n    public set systemValue(value: Nullable<NodeMaterialSystemValues>) {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n        this.associatedVariableName = \"\";\r\n        this._systemValue = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"InputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Animate the input if animationType !== None\r\n     * @param scene defines the rendering scene\r\n     */\r\n    public animate(scene: Scene) {\r\n        switch (this._animationType) {\r\n            case AnimatedInputBlockTypes.Time: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value += scene.getAnimationRatio() * 0.01;\r\n                }\r\n                break;\r\n            }\r\n            case AnimatedInputBlockTypes.RealTime: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1000;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _emitDefine(define: string): string {\r\n        if (define[0] === \"!\") {\r\n            return `#ifndef ${define.substring(1)}\\n`;\r\n        }\r\n\r\n        return `#ifdef ${define}\\n`;\r\n    }\r\n\r\n    public initialize() {\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                this.value = Color3.White();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                this.value = new Color4(1, 1, 1, 1);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _emitConstant(state: NodeMaterialBuildState) {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return `${state._emitFloat(this.value)}`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return `vec2(${this.value.x}, ${this.value.y})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _noContextSwitch(): boolean {\r\n        return attributeInFragmentOnly[this.name];\r\n    }\r\n\r\n    private _emit(state: NodeMaterialBuildState, define?: string) {\r\n        // Uniforms\r\n        if (this.isUniform) {\r\n            if (!this.associatedVariableName) {\r\n                this.associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\r\n            }\r\n\r\n            if (this.isConstant) {\r\n                if (state.constants.indexOf(this.associatedVariableName) !== -1) {\r\n                    return;\r\n                }\r\n                state.constants.push(this.associatedVariableName);\r\n                state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};\\n`;\r\n                return;\r\n            }\r\n\r\n            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state.uniforms.push(this.associatedVariableName);\r\n            if (define) {\r\n                state._uniformDeclaration += this._emitDefine(define);\r\n            }\r\n            state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};\\n`;\r\n            if (define) {\r\n                state._uniformDeclaration += `#endif\\n`;\r\n            }\r\n\r\n            // well known\r\n            const hints = state.sharedData.hints;\r\n            if (this._systemValue !== null && this._systemValue !== undefined) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                        hints.needWorldViewMatrix = true;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                        hints.needWorldViewProjectionMatrix = true;\r\n                        break;\r\n                }\r\n            } else {\r\n                if (this._animationType !== AnimatedInputBlockTypes.None) {\r\n                    state.sharedData.animatedInputs.push(this);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Attribute\r\n        if (this.isAttribute) {\r\n            this.associatedVariableName = remapAttributeName[this.name] ?? this.name;\r\n\r\n            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\r\n                // Attribute for fragment need to be carried over by varyings\r\n                if (attributeInFragmentOnly[this.name]) {\r\n                    if (attributeAsUniform[this.name]) {\r\n                        state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                    } else {\r\n                        state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                    }\r\n                } else {\r\n                    this._emit(state._vertexState, define);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (state.attributes.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state.attributes.push(this.associatedVariableName);\r\n\r\n            if (attributeInFragmentOnly[this.name]) {\r\n                if (attributeAsUniform[this.name]) {\r\n                    state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                } else {\r\n                    state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\r\n                }\r\n            } else {\r\n                if (define) {\r\n                    state._attributeDeclaration += this._emitDefine(define);\r\n                }\r\n                state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};\\n`;\r\n                if (define) {\r\n                    state._attributeDeclaration += `#endif\\n`;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix) {\r\n        if (!this._systemValue) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this.associatedVariableName;\r\n        switch (this._systemValue) {\r\n            case NodeMaterialSystemValues.World:\r\n                effect.setMatrix(variableName, world);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldView:\r\n                effect.setMatrix(variableName, worldView);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldViewProjection:\r\n                effect.setMatrix(variableName, worldViewProjection);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmit(effect: Effect, scene: Scene, material: NodeMaterial) {\r\n        if (this.isAttribute) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this.associatedVariableName;\r\n        if (this._systemValue) {\r\n            switch (this._systemValue) {\r\n                case NodeMaterialSystemValues.World:\r\n                case NodeMaterialSystemValues.WorldView:\r\n                case NodeMaterialSystemValues.WorldViewProjection:\r\n                    return;\r\n                case NodeMaterialSystemValues.View:\r\n                    effect.setMatrix(variableName, scene.getViewMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.Projection:\r\n                    effect.setMatrix(variableName, scene.getProjectionMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.ViewProjection:\r\n                    effect.setMatrix(variableName, scene.getTransformMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraPosition:\r\n                    scene.bindEyePosition(effect, variableName, true);\r\n                    break;\r\n                case NodeMaterialSystemValues.FogColor:\r\n                    effect.setColor3(variableName, scene.fogColor);\r\n                    break;\r\n                case NodeMaterialSystemValues.DeltaTime:\r\n                    effect.setFloat(variableName, scene.deltaTime / 1000.0);\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraParameters:\r\n                    if (scene.activeCamera) {\r\n                        effect.setFloat4(\r\n                            variableName,\r\n                            scene.getEngine().hasOriginBottomLeft ? -1 : 1,\r\n                            scene.activeCamera.minZ,\r\n                            scene.activeCamera.maxZ,\r\n                            1 / scene.activeCamera.maxZ\r\n                        );\r\n                    }\r\n                    break;\r\n                case NodeMaterialSystemValues.MaterialAlpha:\r\n                    effect.setFloat(variableName, material.alpha);\r\n                    break;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const value = this._valueCallback ? this._valueCallback() : this._storedValue;\r\n\r\n        if (value === null) {\r\n            return;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                effect.setFloat(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                effect.setInt(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setColor3(variableName, TmpColors.Color3[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setDirectColor4(variableName, TmpColors.Color4[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                effect.setVector2(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                effect.setVector3(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                effect.setVector4(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                effect.setMatrix(variableName, value);\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isUniform || this.isSystemValue) {\r\n            state.sharedData.inputBlocks.push(this);\r\n        }\r\n\r\n        this._emit(state);\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isAttribute) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\n`;\r\n        }\r\n        if (this.isSystemValue) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue!]});\\n`;\r\n        }\r\n        if (this.isUniform) {\r\n            const codes: string[] = [];\r\n\r\n            let valueString = \"\";\r\n\r\n            switch (this.type) {\r\n                case NodeMaterialBlockConnectionPointTypes.Float:\r\n                    valueString = `${this.value}`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                    valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                    valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                    valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                    valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                    valueString = `BABYLON.Matrix.FromArray([${(this.value as Matrix).m}])`;\r\n                    break;\r\n            }\r\n\r\n            // Common Property \"Value\"\r\n            codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n            // Float-Value-Specific Properties\r\n            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                codes.push(\r\n                    `${variableName}.min = ${this.min}`,\r\n                    `${variableName}.max = ${this.max}`,\r\n                    `${variableName}.isBoolean = ${this.isBoolean}`,\r\n                    `${variableName}.matrixMode = ${this.matrixMode}`,\r\n                    `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`\r\n                );\r\n            }\r\n\r\n            // Common Property \"Type\"\r\n            codes.push(`${variableName}.isConstant = ${this.isConstant}`);\r\n\r\n            codes.push(\"\");\r\n\r\n            return super._dumpPropertiesCode() + codes.join(\";\\n\");\r\n        }\r\n        return super._dumpPropertiesCode();\r\n    }\r\n\r\n    public dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.mode = this._mode;\r\n        serializationObject.systemValue = this._systemValue;\r\n        serializationObject.animationType = this._animationType;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.isBoolean = this.isBoolean;\r\n        serializationObject.matrixMode = this.matrixMode;\r\n        serializationObject.isConstant = this.isConstant;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n\r\n        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this._mode = serializationObject.mode;\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\r\n        this._animationType = serializationObject.animationType;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.isBoolean = !!serializationObject.isBoolean;\r\n        this.matrixMode = serializationObject.matrixMode || 0;\r\n        this.isConstant = !!serializationObject.isConstant;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        // Tangents back compat\r\n        if (\r\n            serializationObject.name === \"tangent\" &&\r\n            serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute &&\r\n            serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3\r\n        ) {\r\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n        }\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\r\n","import type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPositionConnectionPoint;\r\n        const worldNormal = this.worldNormalConnectionPoint;\r\n        const worldTangent = this.worldTangent;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const TBN = this.TBN;\r\n        if (TBN.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${\r\n            uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"\r\n        }, vec2(1., 1.));\r\n            #endif\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n        const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\r\n\r\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n                ${roughness},\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n        defines.setValue(\"ANISOTROPIC_LEGACY\", !this.roughness.isConnected);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { PBRMetallicRoughnessBlock } from \"./pbrMetallicRoughnessBlock\";\r\nimport type { PerturbNormalBlock } from \"../Fragment/perturbNormalBlock\";\r\nimport { PBRClearCoatConfiguration } from \"../../../PBR/pbrClearCoatConfiguration\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\n\r\n/**\r\n * Block used to implement the clear coat module of the PBR material\r\n */\r\nexport class ClearCoatBlock extends NodeMaterialBlock {\r\n    private _scene: Scene;\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * Create a new ClearCoatBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintThickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.worldNormal.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n\r\n        this.registerOutput(\r\n            \"clearcoat\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock, \"ClearCoatBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\r\n     */\r\n    @editableInPropertyPage(\"Remap F0 on interface change\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\r\n    public remapF0OnInterfaceChange: boolean = true;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"clearcoatOut\");\r\n        state._excludeVariableName(\"vClearCoatParams\");\r\n        state._excludeVariableName(\"vClearCoatTintParams\");\r\n        state._excludeVariableName(\"vClearCoatRefractionParams\");\r\n        state._excludeVariableName(\"vClearCoatTangentSpaceParams\");\r\n        state._excludeVariableName(\"vGeometricNormaClearCoatW\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ClearCoatBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the ior input component\r\n     */\r\n    public get indexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the bump texture input component\r\n     */\r\n    public get normalMapColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint color input component\r\n     */\r\n    public get tintColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint \"at distance\" input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint thickness input component\r\n     */\r\n    public get tintThickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the world tangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[10];\r\n    }\r\n\r\n    /**\r\n     * Gets the clear coat object output component\r\n     */\r\n    public get clearcoat(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"ClearCoat intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"CLEARCOAT\", true);\r\n        defines.setValue(\"CLEARCOAT_TEXTURE\", false, true);\r\n        defines.setValue(\"CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\r\n        defines.setValue(\"CLEARCOAT_TINT\", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);\r\n        defines.setValue(\"CLEARCOAT_BUMP\", this.normalMapColor.isConnected, true);\r\n        defines.setValue(\r\n            \"CLEARCOAT_DEFAULTIOR\",\r\n            this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock!.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true,\r\n            true\r\n        );\r\n        defines.setValue(\"CLEARCOAT_REMAP_F0\", this.remapF0OnInterfaceChange, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        // Clear Coat Refraction params\r\n        const indexOfRefraction = this.indexOfRefraction.connectInputBlock?.value ?? PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n        const a = 1 - indexOfRefraction;\r\n        const b = 1 + indexOfRefraction;\r\n        const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\r\n        const eta = 1 / indexOfRefraction;\r\n\r\n        effect.setFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\r\n\r\n        // Clear Coat tangent space params\r\n        const mainPBRBlock = this.clearcoat.hasEndpoints ? (this.clearcoat.endpoints[0].ownerBlock as PBRMetallicRoughnessBlock) : null;\r\n        const perturbedNormalBlock = mainPBRBlock?.perturbedNormal.isConnected ? (mainPBRBlock.perturbedNormal.connectedPoint!.ownerBlock as PerturbNormalBlock) : null;\r\n\r\n        if (this._scene._mirroredCameraPosition) {\r\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? 1.0 : -1.0, perturbedNormalBlock?.invertY ? 1.0 : -1.0);\r\n        } else {\r\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? -1.0 : 1.0, perturbedNormalBlock?.invertY ? -1.0 : 1.0);\r\n        }\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState, worldPositionVarName: string, worldNormalVarName: string) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const worldTangent = this.worldTangent;\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const TBN = this.TBN;\r\n        if (TBN.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormalVarName}.xyz);\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @param worldPosVarName name of the variable holding the world position\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)\r\n     * @param worldNormalVarName name of the variable holding the world normal\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(\r\n        state: NodeMaterialBuildState,\r\n        ccBlock: Nullable<ClearCoatBlock>,\r\n        reflectionBlock: Nullable<ReflectionBlock>,\r\n        worldPosVarName: string,\r\n        generateTBNSpace: boolean,\r\n        vTBNAvailable: boolean,\r\n        worldNormalVarName: string\r\n    ): string {\r\n        let code = \"\";\r\n\r\n        const intensity = ccBlock?.intensity.isConnected ? ccBlock.intensity.associatedVariableName : \"1.\";\r\n        const roughness = ccBlock?.roughness.isConnected ? ccBlock.roughness.associatedVariableName : \"0.\";\r\n        const normalMapColor = ccBlock?.normalMapColor.isConnected ? ccBlock.normalMapColor.associatedVariableName : \"vec3(0.)\";\r\n        const uv = ccBlock?.uv.isConnected ? ccBlock.uv.associatedVariableName : \"vec2(0.)\";\r\n\r\n        const tintColor = ccBlock?.tintColor.isConnected ? ccBlock.tintColor.associatedVariableName : \"vec3(1.)\";\r\n        const tintThickness = ccBlock?.tintThickness.isConnected ? ccBlock.tintThickness.associatedVariableName : \"1.\";\r\n        const tintAtDistance = ccBlock?.tintAtDistance.isConnected ? ccBlock.tintAtDistance.associatedVariableName : \"1.\";\r\n        const tintTexture = \"vec4(0.)\";\r\n\r\n        if (ccBlock) {\r\n            state._emitUniformFromString(\"vClearCoatRefractionParams\", \"vec4\");\r\n            state._emitUniformFromString(\"vClearCoatTangentSpaceParams\", \"vec2\");\r\n\r\n            const normalShading = ccBlock.worldNormal;\r\n            code += `vec3 vGeometricNormaClearCoatW = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\n`;\r\n        } else {\r\n            code += `vec3 vGeometricNormaClearCoatW = geometricNormalW;\\n`;\r\n        }\r\n\r\n        if (generateTBNSpace && ccBlock) {\r\n            code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);\r\n            vTBNAvailable = ccBlock.worldTangent.isConnected;\r\n        }\r\n\r\n        code += `clearcoatOutParams clearcoatOut;\r\n\r\n        #ifdef CLEARCOAT\r\n            vec2 vClearCoatParams = vec2(${intensity}, ${roughness});\r\n            vec4 vClearCoatTintParams = vec4(${tintColor}, ${tintThickness});\r\n\r\n            clearcoatBlock(\r\n                ${worldPosVarName}.xyz,\r\n                vGeometricNormaClearCoatW,\r\n                viewDirectionW,\r\n                vClearCoatParams,\r\n                specularEnvironmentR0,\r\n            #ifdef CLEARCOAT_TEXTURE\r\n                vec2(0.),\r\n            #endif\r\n            #ifdef CLEARCOAT_TINT\r\n                vClearCoatTintParams,\r\n                ${tintAtDistance},\r\n                vClearCoatRefractionParams,\r\n                #ifdef CLEARCOAT_TINT_TEXTURE\r\n                    ${tintTexture},\r\n                #endif\r\n            #endif\r\n            #ifdef CLEARCOAT_BUMP\r\n                vec2(0., 1.),\r\n                vec4(${normalMapColor}, 0.),\r\n                ${uv},\r\n                #if defined(${vTBNAvailable ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                    vTBN,\r\n                #else\r\n                    vClearCoatTangentSpaceParams,\r\n                #endif\r\n                #ifdef OBJECTSPACE_NORMALMAP\r\n                    normalMatrix,\r\n                #endif\r\n            #endif\r\n            #if defined(FORCENORMALFORWARD) && defined(NORMAL)\r\n                faceNormal,\r\n            #endif\r\n            #ifdef REFLECTION\r\n                ${reflectionBlock?._vReflectionMicrosurfaceInfosName},\r\n                ${reflectionBlock?._vReflectionInfosName},\r\n                ${reflectionBlock?.reflectionColor},\r\n                vLightingIntensity,\r\n                #ifdef ${reflectionBlock?._define3DName}\r\n                    ${reflectionBlock?._cubeSamplerName},\r\n                #else\r\n                    ${reflectionBlock?._2DSamplerName},\r\n                #endif\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${reflectionBlock?._define3DName}\r\n                        ${reflectionBlock?._cubeSamplerName},\r\n                        ${reflectionBlock?._cubeSamplerName},\r\n                    #else\r\n                        ${reflectionBlock?._2DSamplerName},\r\n                        ${reflectionBlock?._2DSamplerName},\r\n                    #endif\r\n                #endif\r\n            #endif\r\n            #if defined(ENVIRONMENTBRDF) && !defined(${reflectionBlock?._defineSkyboxName})\r\n                #ifdef RADIANCEOCCLUSION\r\n                    ambientMonochrome,\r\n                #endif\r\n            #endif\r\n            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\r\n                (gl_FrontFacing ? 1. : -1.),\r\n            #endif\r\n                clearcoatOut\r\n            );\r\n        #else\r\n            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.remapF0OnInterfaceChange = serializationObject.remapF0OnInterfaceChange ?? true;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ClearCoatBlock\", ClearCoatBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { PBRIridescenceConfiguration } from \"../../../../Materials/PBR/pbrIridescenceConfiguration\";\r\n\r\n/**\r\n * Block used to implement the iridescence module of the PBR material\r\n */\r\nexport class IridescenceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new IridescenceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"iridescence\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"iridescence\", this, NodeMaterialConnectionPointDirection.Output, IridescenceBlock, \"IridescenceBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"iridescenceOut\");\r\n        state._excludeVariableName(\"vIridescenceParams\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"IridescenceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the indexOfRefraction input component\r\n     */\r\n    public get indexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the thickness input component\r\n     */\r\n    public get thickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the iridescence object output component\r\n     */\r\n    public get iridescence(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Iridescence intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n\r\n            const indexOfRefractionInput = new InputBlock(\"Iridescence ior\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            indexOfRefractionInput.value = 1.3;\r\n            indexOfRefractionInput.output.connectTo(this.indexOfRefraction);\r\n\r\n            const thicknessInput = new InputBlock(\"Iridescence thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            thicknessInput.value = 400;\r\n            thicknessInput.output.connectTo(this.thickness);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"IRIDESCENCE\", true, true);\r\n        defines.setValue(\"IRIDESCENCE_TEXTURE\", false, true);\r\n        defines.setValue(\"IRIDESCENCE_THICKNESS_TEXTURE\", false, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param iridescenceBlock instance of a IridescenceBlock or null if the code must be generated without an active iridescence module\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(iridescenceBlock: Nullable<IridescenceBlock>): string {\r\n        let code = \"\";\r\n\r\n        const intensityName = iridescenceBlock?.intensity.isConnected ? iridescenceBlock.intensity.associatedVariableName : \"1.\";\r\n        const indexOfRefraction = iridescenceBlock?.indexOfRefraction.isConnected\r\n            ? iridescenceBlock.indexOfRefraction.associatedVariableName\r\n            : PBRIridescenceConfiguration._DefaultIndexOfRefraction;\r\n        const thickness = iridescenceBlock?.thickness.isConnected ? iridescenceBlock.thickness.associatedVariableName : PBRIridescenceConfiguration._DefaultMaximumThickness;\r\n\r\n        code += `iridescenceOutParams iridescenceOut;\r\n\r\n        #ifdef IRIDESCENCE\r\n            iridescenceBlock(\r\n                vec4(${intensityName}, ${indexOfRefraction}, 1., ${thickness}),\r\n                NdotV,\r\n                specularEnvironmentR0,\r\n                #ifdef CLEARCOAT\r\n                    NdotVUnclamped,\r\n                #endif\r\n                iridescenceOut\r\n            );\r\n\r\n            float iridescenceIntensity = iridescenceOut.iridescenceIntensity;\r\n            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.IridescenceBlock\", IridescenceBlock);\r\n","import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { ReflectionTextureBaseBlock } from \"../Dual/reflectionTextureBaseBlock\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../../../Meshes/subMesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the reflection module of the PBR material\r\n */\r\nexport class ReflectionBlock extends ReflectionTextureBaseBlock {\r\n    /** @internal */\r\n    public _defineLODReflectionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularReflection: string;\r\n    private _vEnvironmentIrradianceName: string;\r\n    /** @internal */\r\n    public _vReflectionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionFilteringInfoName: string;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public cameraPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     */\r\n    @editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useSphericalHarmonics: boolean = true;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public forceIrradianceInFragment: boolean = false;\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        if (this.position.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            console.error(\"The position input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        this._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        super._setTarget();\r\n        this.getInputByName(\"position\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        if (this.generateOnlyFragmentCode) {\r\n            this.forceIrradianceInFragment = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"reflection\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\")\r\n        );\r\n\r\n        this.position.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this.worldPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this.worldNormalConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this.cameraPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection object output component\r\n     */\r\n    public get reflection(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\r\n     */\r\n    public get reflectionColor(): string {\r\n        return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n        const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"REFLECTION\", reflection, true);\r\n\r\n        if (!reflection) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._defineLODReflectionAlpha, reflectionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularReflection, reflectionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture!.invertZ : reflectionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\r\n        defines.setValue(\"GAMMAREFLECTION\", reflectionTexture!.gammaSpace, true);\r\n        defines.setValue(\"RGBDREFLECTION\", reflectionTexture!.isRGBD, true);\r\n\r\n        if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n            if (reflectionTexture.isCube) {\r\n                defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\r\n                defines.setValue(\"USEIRRADIANCEMAP\", false);\r\n                if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", false);\r\n                } else {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n\r\n        if (!reflectionTexture || !subMesh) {\r\n            return;\r\n        }\r\n\r\n        if (reflectionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, reflectionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, reflectionTexture);\r\n        }\r\n\r\n        const width = reflectionTexture.getSize().width;\r\n\r\n        effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\r\n        effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        const defines = subMesh.materialDefines as NodeMaterialDefines;\r\n\r\n        const polynomials = reflectionTexture.sphericalPolynomial;\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n            if (defines.SPHERICAL_HARMONICS) {\r\n                const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n            } else {\r\n                effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        let code = super.handleVertexSide(state);\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        const reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\r\n\r\n        this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\r\n\r\n        state._emitVaryingFromString(this._vEnvironmentIrradianceName, \"vec3\", \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\");\r\n\r\n        state._emitUniformFromString(\"vSphericalL00\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL1_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL10\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL11\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_2\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL20\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL21\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL22\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n\r\n        state._emitUniformFromString(\"vSphericalX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXX_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYY_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n\r\n        code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\r\n                vec3 ${reflectionVectorName} = vec3(${this._reflectionMatrixName} * vec4(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;\r\n                #ifdef ${this._defineOppositeZ}\r\n                    ${reflectionVectorName}.z *= -1.0;\r\n                #endif\r\n                ${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});\r\n            #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param normalVarName name of the existing variable corresponding to the normal\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, normalVarName: string): string {\r\n        let code = \"\";\r\n\r\n        this.handleFragmentSideInits(state);\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        state._emitFunction(\r\n            \"sampleReflection\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleReflection(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleReflection(s, c) texture2D(s, c)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleReflectionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        const computeReflectionCoordsFunc = `\r\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\r\n                ${this.handleFragmentSideCodeReflectionCoords(\"worldNormal\", \"worldPos\", true, true)}\r\n                return ${this._reflectionVectorName};\r\n            }\\n`;\r\n\r\n        state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, `//${this.name}`);\r\n\r\n        this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, \"vec3\");\r\n\r\n        this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\r\n\r\n        this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vReflectionFilteringInfoName, \"vec2\");\r\n\r\n        code += `#ifdef REFLECTION\r\n            vec2 ${this._vReflectionInfosName} = vec2(1., 0.);\r\n\r\n            reflectionOutParams reflectionOut;\r\n\r\n            reflectionBlock(\r\n                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName}.xyz,\r\n                ${normalVarName},\r\n                alphaG,\r\n                ${this._vReflectionMicrosurfaceInfosName},\r\n                ${this._vReflectionInfosName},\r\n                ${this.reflectionColor},\r\n            #ifdef ANISOTROPIC\r\n                anisotropicOut,\r\n            #endif\r\n            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})\r\n                NdotVUnclamped,\r\n            #endif\r\n            #ifdef ${this._defineLinearSpecularReflection}\r\n                roughness,\r\n            #endif\r\n            #ifdef ${this._define3DName}\r\n                ${this._cubeSamplerName},\r\n            #else\r\n                ${this._2DSamplerName},\r\n            #endif\r\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\r\n                ${this._vEnvironmentIrradianceName},\r\n            #endif\r\n            #ifdef USESPHERICALFROMREFLECTIONMAP\r\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\r\n                    ${this._reflectionMatrixName},\r\n                #endif\r\n            #endif\r\n            #ifdef USEIRRADIANCEMAP\r\n                irradianceSampler, // ** not handled **\r\n            #endif\r\n            #ifndef LODBASEDMICROSFURACE\r\n                #ifdef ${this._define3DName}\r\n                    ${this._cubeSamplerName},\r\n                    ${this._cubeSamplerName},\r\n                #else\r\n                    ${this._2DSamplerName},\r\n                    ${this._2DSamplerName},\r\n                #endif\r\n            #endif\r\n            #ifdef REALTIME_FILTERING\r\n                ${this._vReflectionFilteringInfoName},\r\n            #endif\r\n                reflectionOut\r\n            );\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\r\n            this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\\n`;\r\n        codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\r\n        serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\r\n        serializationObject.gammaSpace = this.texture?.gammaSpace ?? true;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\r\n        this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\r\n        if (this.texture) {\r\n            this.texture.gammaSpace = serializationObject.gammaSpace;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionBlock\", ReflectionBlock);\r\n","import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _refractionMatrixName: string;\r\n    /** @internal */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @internal */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useThicknessAsDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vRefractionPosition\");\r\n        state._excludeVariableName(\"vRefractionSize\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the volume index of refraction input component\r\n     */\r\n    public get volumeIndexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture!.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture!.invertZ : refractionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture!.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture!.isRGBD, true);\r\n        defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", (<any>refractionTexture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat4(\r\n            this._vRefractionMicrosurfaceInfosName,\r\n            refractionTexture.getSize().width,\r\n            refractionTexture.lodGenerationScale,\r\n            refractionTexture.lodGenerationOffset,\r\n            1 / indexOfRefraction\r\n        );\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        if ((<any>refractionTexture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>refractionTexture;\r\n            effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        const code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\r\n        state._samplerDeclaration += `#else\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\r\n        state._samplerDeclaration += `#endif\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\r\n\r\n        state._emitFunction(\r\n            \"sampleRefraction\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefraction(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleRefraction(s, c) texture2D(s, c)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleRefractionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\r\n\r\n        state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\r\n        state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\n`;\r\n        codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n        serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n        this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\n\r\n/**\r\n * Block used to implement the sheen module of the PBR material\r\n */\r\nexport class SheenBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new SheenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"sheen\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sheen\", this, NodeMaterialConnectionPointDirection.Output, SheenBlock, \"SheenBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @editableInPropertyPage(\"Albedo scaling\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public albedoScaling: boolean = false;\r\n\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @editableInPropertyPage(\"Link sheen with albedo\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public linkSheenWithAlbedo: boolean = false;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sheenOut\");\r\n        state._excludeVariableName(\"sheenMapData\");\r\n        state._excludeVariableName(\"vSheenColor\");\r\n        state._excludeVariableName(\"vSheenRoughness\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SheenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the sheen object output component\r\n     */\r\n    public get sheen(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"SHEEN\", true);\r\n        defines.setValue(\"SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\r\n        defines.setValue(\"SHEEN_LINKWITHALBEDO\", this.linkSheenWithAlbedo, true);\r\n        defines.setValue(\"SHEEN_ROUGHNESS\", this.roughness.isConnected, true);\r\n        defines.setValue(\"SHEEN_ALBEDOSCALING\", this.albedoScaling, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @returns the shader code\r\n     */\r\n    public getCode(reflectionBlock: Nullable<ReflectionBlock>): string {\r\n        let code = \"\";\r\n\r\n        const color = this.color.isConnected ? this.color.associatedVariableName : \"vec3(1.)\";\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.\";\r\n        const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\r\n        const texture = \"vec4(0.)\";\r\n\r\n        code = `#ifdef SHEEN\r\n            sheenOutParams sheenOut;\r\n\r\n            vec4 vSheenColor = vec4(${color}, ${intensity});\r\n\r\n            sheenBlock(\r\n                vSheenColor,\r\n            #ifdef SHEEN_ROUGHNESS\r\n                ${roughness},\r\n            #endif\r\n                roughness,\r\n            #ifdef SHEEN_TEXTURE\r\n                ${texture},\r\n                1.0,\r\n            #endif\r\n                reflectance,\r\n            #ifdef SHEEN_LINKWITHALBEDO\r\n                baseColor,\r\n                surfaceAlbedo,\r\n            #endif\r\n            #ifdef ENVIRONMENTBRDF\r\n                NdotV,\r\n                environmentBrdf,\r\n            #endif\r\n            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\r\n                AARoughnessFactors,\r\n                ${reflectionBlock?._vReflectionMicrosurfaceInfosName},\r\n                ${reflectionBlock?._vReflectionInfosName},\r\n                ${reflectionBlock?.reflectionColor},\r\n                vLightingIntensity,\r\n                #ifdef ${reflectionBlock?._define3DName}\r\n                    ${reflectionBlock?._cubeSamplerName},\r\n                #else\r\n                    ${reflectionBlock?._2DSamplerName},\r\n                #endif\r\n                reflectionOut.reflectionCoords,\r\n                NdotVUnclamped,\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${reflectionBlock?._define3DName}\r\n                        ${reflectionBlock?._cubeSamplerName},\r\n                        ${reflectionBlock?._cubeSamplerName},\r\n                    #else\r\n                        ${reflectionBlock?._2DSamplerName},\r\n                        ${reflectionBlock?._2DSamplerName},\r\n                    #endif\r\n                #endif\r\n                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(RADIANCEOCCLUSION)\r\n                    seo,\r\n                #endif\r\n                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(${reflectionBlock?._define3DName})\r\n                    eho,\r\n                #endif\r\n            #endif\r\n                sheenOut\r\n            );\r\n\r\n            #ifdef SHEEN_LINKWITHALBEDO\r\n                surfaceAlbedo = sheenOut.surfaceAlbedo;\r\n            #endif\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.albedoScaling = ${this.albedoScaling};\\n`;\r\n        codeString += `${this._codeVariableName}.linkSheenWithAlbedo = ${this.linkSheenWithAlbedo};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.albedoScaling = this.albedoScaling;\r\n        serializationObject.linkSheenWithAlbedo = this.linkSheenWithAlbedo;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.albedoScaling = serializationObject.albedoScaling;\r\n        this.linkSheenWithAlbedo = serializationObject.linkSheenWithAlbedo;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SheenBlock\", SheenBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RefractionBlock } from \"./refractionBlock\";\r\n\r\n/**\r\n * Block used to implement the sub surface module of the PBR material\r\n */\r\nexport class SubSurfaceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new SubSurfaceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"translucencyIntensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"translucencyDiffusionDist\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Input, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n\r\n        this.registerOutput(\r\n            \"subsurface\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"subsurface\", this, NodeMaterialConnectionPointDirection.Output, SubSurfaceBlock, \"SubSurfaceBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"subSurfaceOut\");\r\n        state._excludeVariableName(\"vThicknessParam\");\r\n        state._excludeVariableName(\"vTintColor\");\r\n        state._excludeVariableName(\"vSubSurfaceIntensity\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"SubSurfaceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the thickness component\r\n     */\r\n    public get thickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint color input component\r\n     */\r\n    public get tintColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the translucency intensity input component\r\n     */\r\n    public get translucencyIntensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the translucency diffusion distance input component\r\n     */\r\n    public get translucencyDiffusionDist(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object parameters\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the sub surface object output component\r\n     */\r\n    public get subsurface(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (!this.thickness.isConnected) {\r\n            const thicknessInput = new InputBlock(\"SubSurface thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            thicknessInput.value = 0;\r\n            thicknessInput.output.connectTo(this.thickness);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;\r\n\r\n        defines.setValue(\"SUBSURFACE\", translucencyEnabled || this.refraction.isConnected, true);\r\n        defines.setValue(\"SS_TRANSLUCENCY\", translucencyEnabled, true);\r\n        defines.setValue(\"SS_THICKNESSANDMASK_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_REFRACTIONINTENSITY_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_TRANSLUCENCYINTENSITY_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_MASK_FROM_THICKNESS_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_USE_GLTF_TEXTURES\", false, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @param worldPosVarName name of the variable holding the world position\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(state: NodeMaterialBuildState, ssBlock: Nullable<SubSurfaceBlock>, reflectionBlock: Nullable<ReflectionBlock>, worldPosVarName: string): string {\r\n        let code = \"\";\r\n\r\n        const thickness = ssBlock?.thickness.isConnected ? ssBlock.thickness.associatedVariableName : \"0.\";\r\n        const tintColor = ssBlock?.tintColor.isConnected ? ssBlock.tintColor.associatedVariableName : \"vec3(1.)\";\r\n        const translucencyIntensity = ssBlock?.translucencyIntensity.isConnected ? ssBlock?.translucencyIntensity.associatedVariableName : \"1.\";\r\n        const translucencyDiffusionDistance = ssBlock?.translucencyDiffusionDist.isConnected ? ssBlock?.translucencyDiffusionDist.associatedVariableName : \"vec3(1.)\";\r\n\r\n        const refractionBlock: Nullable<RefractionBlock> = (ssBlock?.refraction.isConnected ? ssBlock?.refraction.connectedPoint?.ownerBlock : null) as Nullable<RefractionBlock>;\r\n\r\n        const refractionTintAtDistance = refractionBlock?.tintAtDistance.isConnected ? refractionBlock.tintAtDistance.associatedVariableName : \"1.\";\r\n        const refractionIntensity = refractionBlock?.intensity.isConnected ? refractionBlock.intensity.associatedVariableName : \"1.\";\r\n        const refractionView = refractionBlock?.view.isConnected ? refractionBlock.view.associatedVariableName : \"\";\r\n\r\n        code += refractionBlock?.getCode(state) ?? \"\";\r\n\r\n        code += `subSurfaceOutParams subSurfaceOut;\r\n\r\n        #ifdef SUBSURFACE\r\n            vec2 vThicknessParam = vec2(0., ${thickness});\r\n            vec4 vTintColor = vec4(${tintColor}, ${refractionTintAtDistance});\r\n            vec3 vSubSurfaceIntensity = vec3(${refractionIntensity}, ${translucencyIntensity}, 0.);\r\n\r\n            subSurfaceBlock(\r\n                vSubSurfaceIntensity,\r\n                vThicknessParam,\r\n                vTintColor,\r\n                normalW,\r\n                specularEnvironmentReflectance,\r\n            #ifdef SS_THICKNESSANDMASK_TEXTURE\r\n                vec4(0.),\r\n            #endif\r\n            #ifdef REFLECTION\r\n                #ifdef SS_TRANSLUCENCY\r\n                    ${reflectionBlock?._reflectionMatrixName},\r\n                    #ifdef USESPHERICALFROMREFLECTIONMAP\r\n                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\r\n                            reflectionOut.irradianceVector,\r\n                        #endif\r\n                        #if defined(REALTIME_FILTERING)\r\n                            ${reflectionBlock?._cubeSamplerName},\r\n                            ${reflectionBlock?._vReflectionFilteringInfoName},\r\n                        #endif\r\n                        #endif\r\n                    #ifdef USEIRRADIANCEMAP\r\n                        irradianceSampler,\r\n                    #endif\r\n                #endif\r\n            #endif\r\n            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\r\n                surfaceAlbedo,\r\n            #endif\r\n            #ifdef SS_REFRACTION\r\n                ${worldPosVarName}.xyz,\r\n                viewDirectionW,\r\n                ${refractionView},\r\n                ${refractionBlock?._vRefractionInfosName ?? \"\"},\r\n                ${refractionBlock?._refractionMatrixName ?? \"\"},\r\n                ${refractionBlock?._vRefractionMicrosurfaceInfosName ?? \"\"},\r\n                vLightingIntensity,\r\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\r\n                    alpha,\r\n                #endif\r\n                #ifdef ${refractionBlock?._defineLODRefractionAlpha ?? \"IGNORE\"}\r\n                    NdotVUnclamped,\r\n                #endif\r\n                #ifdef ${refractionBlock?._defineLinearSpecularRefraction ?? \"IGNORE\"}\r\n                    roughness,\r\n                #endif\r\n                alphaG,\r\n                #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\r\n                    ${refractionBlock?._cubeSamplerName ?? \"\"},\r\n                #else\r\n                    ${refractionBlock?._2DSamplerName ?? \"\"},\r\n                #endif\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\r\n                        ${refractionBlock?._cubeSamplerName ?? \"\"},\r\n                        ${refractionBlock?._cubeSamplerName ?? \"\"},\r\n                    #else\r\n                        ${refractionBlock?._2DSamplerName ?? \"\"},\r\n                        ${refractionBlock?._2DSamplerName ?? \"\"},\r\n                    #endif\r\n                #endif\r\n                #ifdef ANISOTROPIC\r\n                    anisotropicOut,\r\n                #endif\r\n                #ifdef REALTIME_FILTERING\r\n                    ${refractionBlock?._vRefractionFilteringInfoName ?? \"\"},\r\n                #endif\r\n                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\r\n                    vRefractionPosition,\r\n                    vRefractionSize,\r\n                #endif\r\n            #endif\r\n            #ifdef SS_TRANSLUCENCY\r\n                ${translucencyDiffusionDistance},\r\n            #endif\r\n                subSurfaceOut\r\n            );\r\n\r\n            #ifdef SS_REFRACTION\r\n                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;\r\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\r\n                    alpha = subSurfaceOut.alpha;\r\n                #endif\r\n            #endif\r\n        #else\r\n            subSurfaceOut.specularEnvironmentReflectance = specularEnvironmentReflectance;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SubSurfaceBlock\", SubSurfaceBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle blend multiply section\r\n */\r\nexport class ParticleBlendMultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleBlendMultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaTexture\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaColor\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"blendColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleBlendMultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaTexture input component\r\n     */\r\n    public get alphaTexture(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaColor input component\r\n     */\r\n    public get alphaColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the blendColor output component\r\n     */\r\n    public get blendColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sourceAlpha\");\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `\r\n            #ifdef BLENDMULTIPLYMODE\r\n                ${this._declareOutput(this.blendColor, state)};\r\n                float sourceAlpha = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};\r\n                ${this.blendColor.associatedVariableName}.rgb = ${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha);\r\n                ${this.blendColor.associatedVariableName}.a = ${this.color.associatedVariableName}.a;\r\n            #else\r\n                ${this._declareOutput(this.blendColor, state)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleBlendMultiplyBlock\", ParticleBlendMultiplyBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle ramp gradient section\r\n */\r\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleRampGradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleRampGradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rampColor output component\r\n     */\r\n    public get rampColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"remapRanges\");\r\n        state._excludeVariableName(\"rampSampler\");\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"alpha\");\r\n        state._excludeVariableName(\"remappedColorIndex\");\r\n        state._excludeVariableName(\"rampColor\");\r\n        state._excludeVariableName(\"finalAlpha\");\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(\"rampSampler\");\r\n        state._emitVaryingFromString(\"remapRanges\", \"vec4\", \"RAMPGRADIENT\");\r\n\r\n        state.compilationString += `\r\n            #ifdef RAMPGRADIENT\r\n                vec4 baseColor = ${this.color.associatedVariableName};\r\n                float alpha = ${this.color.associatedVariableName}.a;\r\n\r\n                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\r\n\r\n                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));\r\n                baseColor.rgb *= rampColor.rgb;\r\n\r\n                // Remapped alpha\r\n                float finalAlpha = baseColor.a;\r\n                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);\r\n\r\n                ${this._declareOutput(this.rampColor, state)} = baseColor;\r\n            #else\r\n                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\n\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\\n`;\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport { VertexBuffer } from \"../../../../Buffers/buffer\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\n\r\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\r\nexport class MorphTargetsBlock extends NodeMaterialBlock {\r\n    private _repeatableContentAnchor: string;\r\n\r\n    /**\r\n     * Create a new MorphTargetsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.tangent.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MorphTargetsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the position output component\r\n     */\r\n    public get positionOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal output component\r\n     */\r\n    public get normalOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get tangentOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get uvOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"morphTargetInfluences\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\" && additionalFilteringInfo(b));\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if ((<Mesh>mesh).morphTargetManager) {\r\n            const morphTargetManager = (<Mesh>mesh).morphTargetManager;\r\n\r\n            if (morphTargetManager?.isUsingTextureForTargets && morphTargetManager.numInfluencers !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n                defines.markAsAttributesDirty();\r\n            }\r\n        }\r\n\r\n        if (!defines._areAttributesDirty) {\r\n            return;\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\r\n            MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n\r\n            if (mesh.morphTargetManager.isUsingTextureForTargets) {\r\n                mesh.morphTargetManager._bind(effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const state = vertexShaderState;\r\n        const repeatCount = defines.NUM_MORPH_INFLUENCERS as number;\r\n\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        const hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\r\n\r\n        let injectionCode = \"\";\r\n\r\n        if (manager?.isUsingTextureForTargets && repeatCount > 0) {\r\n            injectionCode += `float vertexID;\\n`;\r\n        }\r\n\r\n        for (let index = 0; index < repeatCount; index++) {\r\n            injectionCode += `#ifdef MORPHTARGETS\\n`;\r\n            if (manager?.isUsingTextureForTargets) {\r\n                injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\n`;\r\n                injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\r\n                injectionCode += `vertexID += 1.0;\\n`;\r\n            } else {\r\n                injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\r\n            }\r\n\r\n            if (hasNormals) {\r\n                injectionCode += `#ifdef MORPHTARGETS_NORMAL\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\n`;\r\n                } else {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\r\n                }\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n\r\n            if (hasUVs) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\n`;\r\n                } else {\r\n                    injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\n`;\r\n                }\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n\r\n            if (hasTangents) {\r\n                injectionCode += `#ifdef MORPHTARGETS_TANGENT\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(${index}, vertexID) - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\n`;\r\n                }\r\n\r\n                if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\n`;\r\n                }\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n\r\n            injectionCode += `#endif\\n`;\r\n        }\r\n\r\n        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\r\n\r\n        if (repeatCount > 0) {\r\n            for (let index = 0; index < repeatCount; index++) {\r\n                state.attributes.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (hasNormals) {\r\n                    state.attributes.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (hasTangents) {\r\n                    state.attributes.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (hasUVs) {\r\n                    state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Register for repeatable content generation\r\n        state.sharedData.repeatableContentBlocks.push(this);\r\n\r\n        // Emit code\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const comments = `//${this.name}`;\r\n\r\n        state.uniforms.push(\"morphTargetInfluences\");\r\n        state.uniforms.push(\"morphTargetTextureInfo\");\r\n        state.uniforms.push(\"morphTargetTextureIndices\");\r\n        state.samplers.push(\"morphTargets\");\r\n\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\r\n            repeatKey: \"maxSimultaneousMorphTargets\",\r\n        });\r\n\r\n        state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\n`;\r\n        state.compilationString += `#ifdef NORMAL\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef TANGENT\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec4(0., 0., 0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef UV1\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        // Repeatable content\r\n        this._repeatableContentAnchor = state._repeatableContentAnchor;\r\n        state.compilationString += this._repeatableContentAnchor;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);\r\n","import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Immutable } from \"../../../../types\";\r\n\r\nimport type { FragmentOutputBlock } from \"../Fragment/fragmentOutputBlock\";\r\n\r\n/**\r\n * Block used to output the vertex position\r\n */\r\nexport class VertexOutputBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VertexOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex, true);\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VertexOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input component\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    private _isLogarithmicDepthEnabled(nodeList: Immutable<NodeMaterialBlock[]>): boolean {\r\n        for (const node of nodeList) {\r\n            if ((node as FragmentOutputBlock).useLogarithmicDepth) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.vector;\r\n\r\n        state.compilationString += `gl_Position = ${input.associatedVariableName};\\n`;\r\n\r\n        if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes)) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\r\n            state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\r\n\r\n            state.compilationString += `vFragmentDepth = 1.0 + gl_Position.w;\\n`;\r\n            state.compilationString += `gl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VertexOutputBlock\", VertexOutputBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to expand a Color3/4 into 4 outputs (one for each component)\r\n */\r\nexport class ColorSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ColorSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputsAreExclusive = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ColorSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component (input)\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component (output)\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component (output)\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n    /**\r\n     * Gets the b component (output)\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n    /**\r\n     * Gets the a component (output)\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.rgba.isConnected ? this.rgba : this.rgbIn;\r\n\r\n        if (!input.isConnected) {\r\n            return;\r\n        }\r\n\r\n        const rgbOutput = this._outputs[0];\r\n        const rOutput = this._outputs[1];\r\n        const gOutput = this._outputs[2];\r\n        const bOutput = this._outputs[3];\r\n        const aOutput = this._outputs[4];\r\n\r\n        if (rgbOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(rgbOutput, state) + ` = ${input.associatedVariableName}.rgb;\\n`;\r\n        }\r\n        if (rOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(rOutput, state) + ` = ${input.associatedVariableName}.r;\\n`;\r\n        }\r\n        if (gOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(gOutput, state) + ` = ${input.associatedVariableName}.g;\\n`;\r\n        }\r\n        if (bOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(bOutput, state) + ` = ${input.associatedVariableName}.b;\\n`;\r\n        }\r\n        if (aOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(aOutput, state) + ` = ${input.associatedVariableName}.a;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorSplitterBlock\", ColorSplitterBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to multiply 2 values\r\n */\r\nexport class MultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiplyBlock\", MultiplyBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\n/**\r\n * Block used to remap a float from a range to a new one\r\n */\r\nexport class RemapBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the source range\r\n     */\r\n    @editableInPropertyPage(\"From\", PropertyTypeForEdition.Vector2)\r\n    public sourceRange = new Vector2(-1, 1);\r\n\r\n    /**\r\n     * Gets or sets the target range\r\n     */\r\n    @editableInPropertyPage(\"To\", PropertyTypeForEdition.Vector2)\r\n    public targetRange = new Vector2(0, 1);\r\n\r\n    /**\r\n     * Creates a new RemapBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"sourceMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"sourceMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RemapBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source min input component\r\n     */\r\n    public get sourceMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the source max input component\r\n     */\r\n    public get sourceMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the target min input component\r\n     */\r\n    public get targetMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the target max input component\r\n     */\r\n    public get targetMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);\r\n        const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);\r\n\r\n        const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);\r\n        const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);\r\n\r\n        state.compilationString +=\r\n            this._declareOutput(output, state) +\r\n            ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.sourceRange = this.sourceRange.asArray();\r\n        serializationObject.targetRange = this.targetRange.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);\r\n        this.targetRange = Vector2.FromArray(serializationObject.targetRange);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RemapBlock\", RemapBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { InputBlock } from \"./Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\r\n\r\n/**\r\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\r\n */\r\nexport class TransformBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Defines the value to use to complement W value to transform it to a Vector4\r\n     */\r\n    public complementW = 1;\r\n\r\n    /**\r\n     * Defines the value to use to complement z value to transform it to a Vector4\r\n     */\r\n    public complementZ = 0;\r\n\r\n    /**\r\n     * Creates a new TransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.target = NodeMaterialBlockTargets.Vertex;\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (other.ownerBlock.isInput) {\r\n                const otherAsInput = other.ownerBlock as InputBlock;\r\n\r\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\r\n                    this.complementW = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz output component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix transform input\r\n     */\r\n    public get transform(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const transform = this.transform;\r\n\r\n        if (vector.connectedPoint) {\r\n            // None uniform scaling case.\r\n            if (this.complementW === 0) {\r\n                const comments = `//${this.name}`;\r\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n                state.sharedData.blocksWithDefines.push(this);\r\n\r\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\r\n                state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\r\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\r\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\r\n                state.compilationString += `#endif\\n`;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                const transformName = transform.associatedVariableName;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) +\r\n                            ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (this.xyz.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     */\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n        if (mesh.nonUniformScaling) {\r\n            defines.setValue(\"NONUNIFORMSCALING\", true);\r\n        }\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.complementZ = this.complementZ;\r\n        serializationObject.complementW = this.complementW;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\r\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { NodeMaterial } from \"../nodeMaterial\";\r\nimport type { Effect } from \"../../effect\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Texture } from \"../../Textures/texture\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport \"../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\r\n */\r\nexport class TriPlanarBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    protected _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _textureInfoName: string;\r\n    private _imageSource: Nullable<ImageSourceBlock>;\r\n\r\n    /**\r\n     * Project the texture(s) for a better fit to a cube\r\n     */\r\n    @editableInPropertyPage(\"Project as cube\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public projectAsCube: boolean = false;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the textureY associated with the node\r\n     */\r\n    public get textureY(): Nullable<Texture> {\r\n        if (this.sourceY.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the textureZ associated with the node\r\n     */\r\n    public get textureZ(): Nullable<Texture> {\r\n        if (this.sourceZ?.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _getImageSourceBlock(connectionPoint: Nullable<NodeMaterialConnectionPoint>): Nullable<ImageSourceBlock> {\r\n        return connectionPoint?.isConnected ? (connectionPoint.connectedPoint!.ownerBlock as ImageSourceBlock) : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        const imageSourceBlock = this._getImageSourceBlock(this.source);\r\n        if (imageSourceBlock) {\r\n            return imageSourceBlock.samplerName;\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerY name associated with this texture\r\n     */\r\n    public get samplerYName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerZ name associated with this texture\r\n     */\r\n    public get samplerZName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return this.source.isConnected;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TriPlanarBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string, hideSourceZ = false) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"sourceY\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        if (!hideSourceZ) {\r\n            this.registerInput(\r\n                \"sourceZ\",\r\n                NodeMaterialBlockConnectionPointTypes.Object,\r\n                true,\r\n                NodeMaterialBlockTargets.VertexAndFragment,\r\n                new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n            );\r\n        }\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TriPlanarBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the sharpness input component\r\n     */\r\n    public get sharpness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceY input component\r\n     */\r\n    public get sourceY(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceZ input component\r\n     */\r\n    public get sourceZ(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloat(this._textureInfoName, this.texture.level);\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    protected _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n        const samplerYName = this.samplerYName ?? samplerName;\r\n        const samplerZName = this.samplerZName ?? samplerName;\r\n\r\n        const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\r\n\r\n        const x = state._getFreeVariableName(\"x\");\r\n        const y = state._getFreeVariableName(\"y\");\r\n        const z = state._getFreeVariableName(\"z\");\r\n        const w = state._getFreeVariableName(\"w\");\r\n        const n = state._getFreeVariableName(\"n\");\r\n        const uvx = state._getFreeVariableName(\"uvx\");\r\n        const uvy = state._getFreeVariableName(\"uvy\");\r\n        const uvz = state._getFreeVariableName(\"uvz\");\r\n\r\n        state.compilationString += `\r\n            vec3 ${n} = ${this.normal.associatedVariableName}.xyz;\r\n\r\n            vec2 ${uvx} = ${this.position.associatedVariableName}.yz;\r\n            vec2 ${uvy} = ${this.position.associatedVariableName}.zx;\r\n            vec2 ${uvz} = ${this.position.associatedVariableName}.xy;\r\n        `;\r\n\r\n        if (this.projectAsCube) {\r\n            state.compilationString += `\r\n                ${uvx}.xy = ${uvx}.yx;\r\n\r\n                if (${n}.x >= 0.0) {\r\n                    ${uvx}.x = -${uvx}.x;\r\n                }\r\n                if (${n}.y < 0.0) {\r\n                    ${uvy}.y = -${uvy}.y;\r\n                }\r\n                if (${n}.z < 0.0) {\r\n                    ${uvz}.x = -${uvz}.x;\r\n                }\r\n            `;\r\n        }\r\n\r\n        state.compilationString += `\r\n            vec4 ${x} = texture2D(${samplerName}, ${uvx});\r\n            vec4 ${y} = texture2D(${samplerYName}, ${uvy});\r\n            vec4 ${z} = texture2D(${samplerZName}, ${uvz});\r\n           \r\n            // blend weights\r\n            vec3 ${w} = pow(abs(${n}), vec3(${sharpness}));\r\n\r\n            // blend and return\r\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \r\n        `;\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = this._textureInfoName;\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        if (!this._imageSource) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        // Declarations\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitUniformFromString(this._textureInfoName, \"float\");\r\n\r\n        this._generateTextureLookup(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\r\n        codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        serializationObject.projectAsCube = this.projectAsCube;\r\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n        this.projectAsCube = !!serializationObject.projectAsCube;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Operations supported by the Trigonometry block\r\n */\r\nexport enum TrigonometryBlockOperations {\r\n    /** Cos */\r\n    Cos,\r\n    /** Sin */\r\n    Sin,\r\n    /** Abs */\r\n    Abs,\r\n    /** Exp */\r\n    Exp,\r\n    /** Exp2 */\r\n    Exp2,\r\n    /** Round */\r\n    Round,\r\n    /** Floor */\r\n    Floor,\r\n    /** Ceiling */\r\n    Ceiling,\r\n    /** Square root */\r\n    Sqrt,\r\n    /** Log */\r\n    Log,\r\n    /** Tangent */\r\n    Tan,\r\n    /** Arc tangent */\r\n    ArcTan,\r\n    /** Arc cosinus */\r\n    ArcCos,\r\n    /** Arc sinus */\r\n    ArcSin,\r\n    /** Fraction */\r\n    Fract,\r\n    /** Sign */\r\n    Sign,\r\n    /** To radians (from degrees) */\r\n    Radians,\r\n    /** To degrees (from radians) */\r\n    Degrees,\r\n}\r\n\r\n/**\r\n * Block used to apply trigonometry operation to floats\r\n */\r\nexport class TrigonometryBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    public operation = TrigonometryBlockOperations.Cos;\r\n\r\n    /**\r\n     * Creates a new TrigonometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TrigonometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        let operation = \"\";\r\n\r\n        switch (this.operation) {\r\n            case TrigonometryBlockOperations.Cos: {\r\n                operation = \"cos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sin: {\r\n                operation = \"sin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Abs: {\r\n                operation = \"abs\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp: {\r\n                operation = \"exp\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp2: {\r\n                operation = \"exp2\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Round: {\r\n                operation = \"round\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Floor: {\r\n                operation = \"floor\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Ceiling: {\r\n                operation = \"ceil\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sqrt: {\r\n                operation = \"sqrt\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Log: {\r\n                operation = \"log\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Tan: {\r\n                operation = \"tan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcTan: {\r\n                operation = \"atan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcCos: {\r\n                operation = \"acos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcSin: {\r\n                operation = \"asin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Fract: {\r\n                operation = \"fract\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sign: {\r\n                operation = \"sign\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Radians: {\r\n                operation = \"radians\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Degrees: {\r\n                operation = \"degrees\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.compilationString += this._declareOutput(output, state) + ` = ${operation}(${this.input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TrigonometryBlock\", TrigonometryBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Block used to create a Vector2/3/4 out of individual inputs (one for each component)\r\n */\r\nexport class VectorMergerBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the swizzle for x (meaning which component to affect to the output.x)\r\n     */\r\n    public xSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"x\";\r\n    /**\r\n     * Gets or sets the swizzle for y (meaning which component to affect to the output.y)\r\n     */\r\n    public ySwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"y\";\r\n    /**\r\n     * Gets or sets the swizzle for z (meaning which component to affect to the output.z)\r\n     */\r\n    public zSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"z\";\r\n    /**\r\n     * Gets or sets the swizzle for w (meaning which component to affect to the output.w)\r\n     */\r\n    public wSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"w\";\r\n\r\n    /**\r\n     * Create a new VectorMergerBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"xyzw \", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"zw \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VectorMergerBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (input)\r\n     */\r\n    public get zwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (input)\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (input)\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (input)\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (input)\r\n     */\r\n    public get w(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (output)\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zwOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     * @deprecated Please use xyOut instead.\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this.xyOut;\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     * @deprecated Please use xyzOut instead.\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this.xyzOut;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        if (name === \"xyzw \") {\r\n            return \"xyzwIn\";\r\n        }\r\n        if (name === \"xyz \") {\r\n            return \"xyzIn\";\r\n        }\r\n        if (name === \"xy \") {\r\n            return \"xyIn\";\r\n        }\r\n        if (name === \"zw \") {\r\n            return \"zwIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private _buildSwizzle(len: number) {\r\n        const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;\r\n\r\n        return \".\" + swizzle.substr(0, len);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const xInput = this.x;\r\n        const yInput = this.y;\r\n        const zInput = this.z;\r\n        const wInput = this.w;\r\n        const xyInput = this.xyIn;\r\n        const zwInput = this.zwIn;\r\n        const xyzInput = this.xyzIn;\r\n        const xyzwInput = this.xyzwIn;\r\n\r\n        const v4Output = this._outputs[0];\r\n        const v3Output = this._outputs[1];\r\n        const v2Output = this._outputs[2];\r\n        const v2CompOutput = this._outputs[3];\r\n\r\n        if (xyzwInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v4Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyzInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v4Output, state) +\r\n                    ` = vec4(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${\r\n                            wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v3Output, state) +\r\n                    ` = vec3(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"})${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v2CompOutput, state) +\r\n                        ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        } else {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zwInput.associatedVariableName\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v4Output, state) +\r\n                        ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                        }, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v3Output, state) +\r\n                    ` = vec3(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                        zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                    })${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    this._declareOutput(v2Output, state) +\r\n                    ` = vec2(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"})${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        this._declareOutput(v2CompOutput, state) +\r\n                        ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.xSwizzle = this.xSwizzle;\r\n        serializationObject.ySwizzle = this.ySwizzle;\r\n        serializationObject.zSwizzle = this.zSwizzle;\r\n        serializationObject.wSwizzle = this.wSwizzle;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.xSwizzle = serializationObject.xSwizzle ?? \"x\";\r\n        this.ySwizzle = serializationObject.ySwizzle ?? \"y\";\r\n        this.zSwizzle = serializationObject.zSwizzle ?? \"z\";\r\n        this.wSwizzle = serializationObject.wSwizzle ?? \"w\";\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.xSwizzle = \"${this.xSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.ySwizzle = \"${this.ySwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.zSwizzle = \"${this.zSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.wSwizzle = \"${this.wSwizzle}\";\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorMergerBlock\", VectorMergerBlock);\r\n","import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\n/**\r\n * Block used to get the view direction\r\n */\r\nexport class ViewDirectionBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ViewDirectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ViewDirectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            this._declareOutput(output, state) + ` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ViewDirectionBlock\", ViewDirectionBlock);\r\n","/**\r\n * Enum defining the mode of a NodeMaterialBlockConnectionPoint\r\n */\r\nexport enum NodeMaterialBlockConnectionPointMode {\r\n    /** Value is an uniform */\r\n    Uniform,\r\n    /** Value is a mesh attribute */\r\n    Attribute,\r\n    /** Value is a varying between vertex and fragment shaders */\r\n    Varying,\r\n    /** Mode is undefined */\r\n    Undefined,\r\n}\r\n","/**\r\n * Defines the kind of connection point for node based material\r\n */\r\nexport enum NodeMaterialBlockConnectionPointTypes {\r\n    /** Float */\r\n    Float = 0x0001,\r\n    /** Int */\r\n    Int = 0x0002,\r\n    /** Vector2 */\r\n    Vector2 = 0x0004,\r\n    /** Vector3 */\r\n    Vector3 = 0x0008,\r\n    /** Vector4 */\r\n    Vector4 = 0x0010,\r\n    /** Color3 */\r\n    Color3 = 0x0020,\r\n    /** Color4 */\r\n    Color4 = 0x0040,\r\n    /** Matrix */\r\n    Matrix = 0x0080,\r\n    /** Custom object */\r\n    Object = 0x0100,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x0400,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x0800,\r\n    /** Bitmask of all types */\r\n    All = 0x0fff,\r\n}\r\n","/**\r\n * Enum used to define the target of a block\r\n */\r\nexport enum NodeMaterialBlockTargets {\r\n    /** Vertex shader */\r\n    Vertex = 1,\r\n    /** Fragment shader */\r\n    Fragment = 2,\r\n    /** Neutral */\r\n    Neutral = 4,\r\n    /** Vertex and Fragment */\r\n    VertexAndFragment = Vertex | Fragment,\r\n}\r\n","/**\r\n * Enum used to define the material modes\r\n */\r\nexport enum NodeMaterialModes {\r\n    /** Regular material */\r\n    Material = 0,\r\n    /** For post process */\r\n    PostProcess = 1,\r\n    /** For particle system */\r\n    Particle = 2,\r\n    /** For procedural texture */\r\n    ProceduralTexture = 3,\r\n}\r\n","/**\r\n * Enum used to define system values e.g. values automatically provided by the system\r\n */\r\nexport enum NodeMaterialSystemValues {\r\n    /** World */\r\n    World = 1,\r\n    /** View */\r\n    View = 2,\r\n    /** Projection */\r\n    Projection = 3,\r\n    /** ViewProjection */\r\n    ViewProjection = 4,\r\n    /** WorldView */\r\n    WorldView = 5,\r\n    /** WorldViewProjection */\r\n    WorldViewProjection = 6,\r\n    /** CameraPosition */\r\n    CameraPosition = 7,\r\n    /** Fog Color */\r\n    FogColor = 8,\r\n    /** Delta time */\r\n    DeltaTime = 9,\r\n    /** Camera parameters */\r\n    CameraParameters = 10,\r\n    /** Material alpha */\r\n    MaterialAlpha = 11,\r\n}\r\n","import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _isTeleportOut = false;\r\n    private _isTeleportIn = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = this.getClassName() === \"InputBlock\";\r\n        this._isTeleportOut = this.getClassName() === \"NodeMaterialTeleportOutBlock\";\r\n        this._isTeleportIn = this.getClassName() === \"NodeMaterialTeleportInBlock\";\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setInitialTarget(target: NodeMaterialBlockTargets): void {\r\n        this._target = target;\r\n        (this._originalTargetIsNeutral as boolean) = target === NodeMaterialBlockTargets.Neutral;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public isConnectedInFragmentShader() {\r\n        return this.outputs.some((o) => o.isConnectedInFragmentShader);\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {}\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state, activeBlocks);\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\n//${this.name}\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n","import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @internal */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @internal */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @internal */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.isConnectedInFragmentShader()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}\r\n","import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport { Effect } from \"../effect\";\r\n\r\n/**\r\n * Class used to store node based material build state\r\n */\r\nexport class NodeMaterialBuildState {\r\n    /** Gets or sets a boolean indicating if the current state can emit uniform buffers */\r\n    public supportUniformBuffers = false;\r\n    /**\r\n     * Gets the list of emitted attributes\r\n     */\r\n    public attributes = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted uniforms\r\n     */\r\n    public uniforms = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted constants\r\n     */\r\n    public constants = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted samplers\r\n     */\r\n    public samplers = new Array<string>();\r\n    /**\r\n     * Gets the list of emitted functions\r\n     */\r\n    public functions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted extensions\r\n     */\r\n    public extensions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted prePass outputs - if using the prepass\r\n     */\r\n    public prePassOutput: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Gets the target of the compilation state\r\n     */\r\n    public target: NodeMaterialBlockTargets;\r\n    /**\r\n     * Gets the list of emitted counters\r\n     */\r\n    public counters: { [key: string]: number } = {};\r\n\r\n    /**\r\n     * Shared data between multiple NodeMaterialBuildState instances\r\n     */\r\n    public sharedData: NodeMaterialBuildStateSharedData;\r\n\r\n    /** @internal */\r\n    public _vertexState: NodeMaterialBuildState;\r\n\r\n    /** @internal */\r\n    public _attributeDeclaration = \"\";\r\n    /** @internal */\r\n    public _uniformDeclaration = \"\";\r\n    /** @internal */\r\n    public _constantDeclaration = \"\";\r\n    /** @internal */\r\n    public _samplerDeclaration = \"\";\r\n    /** @internal */\r\n    public _varyingTransfer = \"\";\r\n    /** @internal */\r\n    public _injectAtEnd = \"\";\r\n\r\n    private _repeatableContentAnchorIndex = 0;\r\n    /** @internal */\r\n    public _builtCompilationString = \"\";\r\n\r\n    /**\r\n     * Gets the emitted compilation strings\r\n     */\r\n    public compilationString = \"\";\r\n\r\n    /**\r\n     * Finalize the compilation strings\r\n     * @param state defines the current compilation state\r\n     */\r\n    public finalize(state: NodeMaterialBuildState) {\r\n        const emitComments = state.sharedData.emitComments;\r\n        const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;\r\n\r\n        this.compilationString = `\\n${emitComments ? \"//Entry point\\n\" : \"\"}void main(void) {\\n${this.compilationString}`;\r\n\r\n        if (this._constantDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Constants\\n\" : \"\"}${this._constantDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        let functionCode = \"\";\r\n        for (const functionName in this.functions) {\r\n            functionCode += this.functions[functionName] + `\\n`;\r\n        }\r\n        this.compilationString = `\\n${functionCode}\\n${this.compilationString}`;\r\n\r\n        if (!isFragmentMode && this._varyingTransfer) {\r\n            this.compilationString = `${this.compilationString}\\n${this._varyingTransfer}`;\r\n        }\r\n\r\n        if (this._injectAtEnd) {\r\n            this.compilationString = `${this.compilationString}\\n${this._injectAtEnd}`;\r\n        }\r\n\r\n        this.compilationString = `${this.compilationString}\\n}`;\r\n\r\n        if (this.sharedData.varyingDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Varyings\\n\" : \"\"}${this.sharedData.varyingDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._samplerDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Samplers\\n\" : \"\"}${this._samplerDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._uniformDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Uniforms\\n\" : \"\"}${this._uniformDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._attributeDeclaration && !isFragmentMode) {\r\n            this.compilationString = `\\n${emitComments ? \"//Attributes\\n\" : \"\"}${this._attributeDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        this.compilationString = \"precision highp float;\\n\" + this.compilationString;\r\n        this.compilationString = \"#if defined(WEBGL2) || defines(WEBGPU)\\nprecision highp sampler2DArray;\\n#endif\\n\" + this.compilationString;\r\n\r\n        if (isFragmentMode) {\r\n            this.compilationString =\r\n                \"#if defined(PREPASS)\\r\\n#extension GL_EXT_draw_buffers : require\\r\\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\\r\\nhighp vec4 gl_FragColor;\\r\\n#endif\\r\\n\" +\r\n                this.compilationString;\r\n        }\r\n\r\n        for (const extensionName in this.extensions) {\r\n            const extension = this.extensions[extensionName];\r\n            this.compilationString = `\\n${extension}\\n${this.compilationString}`;\r\n        }\r\n\r\n        this._builtCompilationString = this.compilationString;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _repeatableContentAnchor(): string {\r\n        return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeVariableName(prefix: string): string {\r\n        prefix = prefix.replace(/[^a-zA-Z_]+/g, \"\");\r\n\r\n        if (this.sharedData.variableNames[prefix] === undefined) {\r\n            this.sharedData.variableNames[prefix] = 0;\r\n\r\n            // Check reserved words\r\n            if (prefix === \"output\" || prefix === \"texture\") {\r\n                return prefix + this.sharedData.variableNames[prefix];\r\n            }\r\n\r\n            return prefix;\r\n        } else {\r\n            this.sharedData.variableNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.variableNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeDefineName(prefix: string): string {\r\n        if (this.sharedData.defineNames[prefix] === undefined) {\r\n            this.sharedData.defineNames[prefix] = 0;\r\n        } else {\r\n            this.sharedData.defineNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.defineNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _excludeVariableName(name: string) {\r\n        this.sharedData.variableNames[name] = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DSampler(name: string) {\r\n        if (this.samplers.indexOf(name) < 0) {\r\n            this._samplerDeclaration += `uniform sampler2D ${name};\\n`;\r\n            this.samplers.push(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DArraySampler(name: string) {\r\n        if (this.samplers.indexOf(name) < 0) {\r\n            this._samplerDeclaration += `uniform sampler2DArray ${name};\\n`;\r\n            this.samplers.push(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getGLType(type: NodeMaterialBlockConnectionPointTypes): string {\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitExtension(name: string, extension: string, define: string = \"\") {\r\n        if (this.extensions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (define) {\r\n            extension = `#if ${define}\\n${extension}\\n#endif`;\r\n        }\r\n        this.extensions[name] = extension;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunction(name: string, code: string, comments: string) {\r\n        if (this.functions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        this.functions[name] = code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCodeFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n        }\r\n    ) {\r\n        if (options && options.repeatKey) {\r\n            return `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n        }\r\n\r\n        let code = Effect.IncludesShadersStore[includeName] + \"\\n\";\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        if (!options) {\r\n            return code;\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                code = code.replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunctionFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n            removeAttributes?: boolean;\r\n            removeUniforms?: boolean;\r\n            removeVaryings?: boolean;\r\n            removeIfDef?: boolean;\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n        },\r\n        storeKey: string = \"\"\r\n    ) {\r\n        const key = includeName + storeKey;\r\n        if (this.functions[key]) {\r\n            return;\r\n        }\r\n\r\n        if (!options || (!options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings)) {\r\n            if (options && options.repeatKey) {\r\n                this.functions[key] = `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n            } else {\r\n                this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? \"(\" + options?.substitutionVars + \")\" : \"\"}\\n`;\r\n            }\r\n\r\n            if (this.sharedData.emitComments) {\r\n                this.functions[key] = comments + `\\n` + this.functions[key];\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.functions[key] = Effect.IncludesShadersStore[includeName];\r\n\r\n        if (this.sharedData.emitComments) {\r\n            this.functions[key] = comments + `\\n` + this.functions[key];\r\n        }\r\n\r\n        if (options.removeIfDef) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#ifdef.+$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#endif.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#else.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#elif.*$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeAttributes) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?attribute .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeUniforms) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?uniform .*?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeVaryings) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?(varying|in) .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerTempVariable(name: string) {\r\n        if (this.sharedData.temps.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.temps.push(name);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitVaryingFromString(name: string, type: string, define: string = \"\", notDefine = false) {\r\n        if (this.sharedData.varyings.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.varyings.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this.sharedData.varyingDeclaration += `#if ${define}\\n`;\r\n            } else {\r\n                this.sharedData.varyingDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n            }\r\n        }\r\n        this.sharedData.varyingDeclaration += `varying ${type} ${name};\\n`;\r\n        if (define) {\r\n            this.sharedData.varyingDeclaration += `#endif\\n`;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitUniformFromString(name: string, type: string, define: string = \"\", notDefine = false) {\r\n        if (this.uniforms.indexOf(name) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.uniforms.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this._uniformDeclaration += `#if ${define}\\n`;\r\n            } else {\r\n                this._uniformDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n            }\r\n        }\r\n        this._uniformDeclaration += `uniform ${type} ${name};\\n`;\r\n        if (define) {\r\n            this._uniformDeclaration += `#endif\\n`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFloat(value: number) {\r\n        if (value.toString() === value.toFixed(0)) {\r\n            return `${value}.0`;\r\n        }\r\n\r\n        return value.toString();\r\n    }\r\n}\r\n","import type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Immutable } from \"../../types\";\r\nimport type { NodeMaterialTextureBlocks } from \"./nodeMaterial\";\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public temps = new Array<string>();\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings = new Array<string>();\r\n\r\n    /**\r\n     * Gets the varying declaration string\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * List of the fragment output nodes\r\n     */\r\n    public fragmentOutputNodes: Immutable<Array<NodeMaterialBlock>>;\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks = new Array<NodeMaterialTextureBlocks>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\r\n     */\r\n    public forcedBindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a repeatable content\r\n     */\r\n    public repeatableContentBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a dynamic list of uniforms\r\n     */\r\n    public dynamicUniformBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false,\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>(),\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\n\";\r\n        }\r\n        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeMaterial failed:\\n\" + errorMessage;\r\n        }\r\n    }\r\n}\r\n","import type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointCompatibilityStates } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines a connection point to be used for points with a custom object type\r\n */\r\nexport class NodeMaterialConnectionPointCustomObject<T extends NodeMaterialBlock> extends NodeMaterialConnectionPoint {\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     * @param _blockType\r\n     * @param _blockName\r\n     */\r\n    public constructor(\r\n        name: string,\r\n        ownerBlock: NodeMaterialBlock,\r\n        direction: NodeMaterialConnectionPointDirection,\r\n        // @internal\r\n        public _blockType: new (...args: any[]) => T,\r\n        private _blockName: string\r\n    ) {\r\n        super(name, ownerBlock, direction);\r\n\r\n        this.needDualDirectionValidation = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        return connectionPoint instanceof NodeMaterialConnectionPointCustomObject && connectionPoint._blockName === this._blockName\r\n            ? NodeMaterialConnectionPointCompatibilityStates.Compatible\r\n            : NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return [new this._blockType(this._blockName), this.name];\r\n    }\r\n}\r\n","import { serialize, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * The Physically based simple base material of BJS.\r\n *\r\n * This enables better naming and convention enforcements on top of the pbrMaterial.\r\n * It is used as the base class for both the specGloss and metalRough conventions.\r\n */\r\nexport abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Environment Texture used in the material (this is use for both reflection and environment lighting).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")\r\n    public environmentTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * Normal map used in the model.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")\r\n    public normalTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Emissivie color used to self-illuminate the model.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * Emissivie texture used to self-illuminate the model.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Occlusion Channel Strength.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")\r\n    public occlusionStrength: number = 1.0;\r\n\r\n    /**\r\n     * Occlusion Texture of the material (adding extra occlusion effects).\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")\r\n    public occlusionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")\r\n    public alphaCutOff: number;\r\n\r\n    /**\r\n     * Gets the current double sided mode.\r\n     */\r\n    @serialize()\r\n    public get doubleSided(): boolean {\r\n        return this._twoSidedLighting;\r\n    }\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    public set doubleSided(value: boolean) {\r\n        if (this._twoSidedLighting === value) {\r\n            return;\r\n        }\r\n        this._twoSidedLighting = value;\r\n        this.backFaceCulling = !value;\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this._useAlphaFromAlbedoTexture = true;\r\n        this._useAmbientInGrayScale = true;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRBaseSimpleMaterial\";\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"hdrFilteringVertexShader\";\nconst shader = `attribute vec2 position;varying vec3 direction;uniform vec3 up;uniform vec3 right;uniform vec3 front;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nmat3 view=mat3(up,right,front);direction=view*vec3(position,1.0);gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"hdrFilteringPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nuniform float alphaG;uniform samplerCube inputTexture;uniform vec2 vFilteringInfo;uniform float hdrScale;varying vec3 direction;void main() {vec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);gl_FragColor=vec4(color*hdrScale,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringPixelShader = { name, shader };\n","import { Vector3 } from \"../../../Maths/math\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { BaseTexture } from \"../baseTexture\";\r\nimport type { ThinEngine } from \"../../../Engines/thinEngine\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\nimport \"../../../Shaders/hdrFiltering.vertex\";\r\nimport \"../../../Shaders/hdrFiltering.fragment\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\n/**\r\n * Options for texture filtering\r\n */\r\ninterface IHDRFilteringOptions {\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    hdrScale?: number;\r\n\r\n    /**\r\n     * Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering\r\n     */\r\n    quality?: number;\r\n}\r\n\r\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\r\nexport class HDRFiltering {\r\n    private _engine: ThinEngine;\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    private _lodGenerationOffset: number = 0;\r\n    private _lodGenerationScale: number = 0.8;\r\n\r\n    /**\r\n     * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\r\n     * you care about baking speed.\r\n     */\r\n    public quality: number = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\r\n\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    public hdrScale: number = 1;\r\n\r\n    /**\r\n     * Instantiates HDR filter for reflection maps\r\n     *\r\n     * @param engine Thin engine\r\n     * @param options Options\r\n     */\r\n    constructor(engine: ThinEngine, options: IHDRFilteringOptions = {}) {\r\n        // pass\r\n        this._engine = engine;\r\n        this.hdrScale = options.hdrScale || this.hdrScale;\r\n        this.quality = options.quality || this.quality;\r\n    }\r\n\r\n    private _createRenderTarget(size: number): RenderTargetWrapper {\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (this._engine.getCaps().textureFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            type: textureType,\r\n            createMipMaps: true,\r\n            generateMipMaps: false,\r\n            generateDepthBuffer: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        });\r\n        this._engine.updateTextureWrappingMode(rtWrapper.texture!, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\r\n\r\n        this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, rtWrapper.texture!, true);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    private _prefilterInternal(texture: BaseTexture): BaseTexture {\r\n        const width = texture.getSize().width;\r\n        const mipmapsCount = Scalar.ILog2(width) + 1;\r\n\r\n        const effect = this._effectWrapper.effect;\r\n        const outputTexture = this._createRenderTarget(width);\r\n        this._effectRenderer.saveStates();\r\n        this._effectRenderer.setViewport();\r\n\r\n        const intTexture = texture.getInternalTexture();\r\n        if (intTexture) {\r\n            // Just in case generate fresh clean mips.\r\n            this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, intTexture, true);\r\n        }\r\n\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        const directions = [\r\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\r\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\r\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\r\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\r\n        ];\r\n\r\n        effect.setFloat(\"hdrScale\", this.hdrScale);\r\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\r\n        effect.setTexture(\"inputTexture\", texture);\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            effect.setVector3(\"up\", directions[face][0]);\r\n            effect.setVector3(\"right\", directions[face][1]);\r\n            effect.setVector3(\"front\", directions[face][2]);\r\n\r\n            for (let lod = 0; lod < mipmapsCount; lod++) {\r\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\r\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\r\n                if (lod === 0) {\r\n                    alpha = 0;\r\n                }\r\n\r\n                effect.setFloat(\"alphaG\", alpha);\r\n\r\n                this._effectRenderer.draw();\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.restoreDefaultFramebuffer();\r\n        this._engine._releaseTexture(texture._texture!);\r\n\r\n        // Internal Swap\r\n        const type = outputTexture.texture!.type;\r\n        const format = outputTexture.texture!.format;\r\n\r\n        outputTexture._swapAndDie(texture._texture!);\r\n\r\n        texture._texture!.type = type;\r\n        texture._texture!.format = format;\r\n\r\n        // New settings\r\n        texture.gammaSpace = false;\r\n        texture.lodGenerationOffset = this._lodGenerationOffset;\r\n        texture.lodGenerationScale = this._lodGenerationScale;\r\n        texture._prefiltered = true;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _createEffect(texture: BaseTexture, onCompiled?: Nullable<(effect: Effect) => void>): EffectWrapper {\r\n        const defines = [];\r\n        if (texture.gammaSpace) {\r\n            defines.push(\"#define GAMMA_INPUT\");\r\n        }\r\n\r\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            name: \"hdrFiltering\",\r\n            vertexShader: \"hdrFiltering\",\r\n            fragmentShader: \"hdrFiltering\",\r\n            samplerNames: [\"inputTexture\"],\r\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\r\n            useShaderStore: true,\r\n            defines,\r\n            onCompiled: onCompiled,\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the filter is ready to be used\r\n     * @param texture Texture to filter\r\n     * @returns true if the filter is ready\r\n     */\r\n    public isReady(texture: BaseTexture) {\r\n        return texture.isReady() && this._effectWrapper.effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n     * Prefiltering will be invoked at the end of next rendering pass.\r\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n     * @param texture Texture to filter\r\n     * @param onFinished Callback when filtering is done\r\n     * @returns Promise called when prefiltering is done\r\n     */\r\n    public prefilter(texture: BaseTexture, onFinished: Nullable<() => void> = null): Promise<void> {\r\n        if (!this._engine._features.allowTexturePrefiltering) {\r\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n            return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            this._effectRenderer = new EffectRenderer(this._engine);\r\n            this._effectWrapper = this._createEffect(texture);\r\n            this._effectWrapper.effect.executeWhenCompiled(() => {\r\n                this._prefilterInternal(texture);\r\n                this._effectRenderer.dispose();\r\n                this._effectWrapper.dispose();\r\n                resolve();\r\n                if (onFinished) {\r\n                    onFinished();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Renders to multiple views with a single draw call\r\n * @see https://www.khronos.org/registry/webgl/extensions/OVR_multiview2/\r\n */\r\nexport class MultiviewRenderTarget extends RenderTargetTexture {\r\n    public set samples(value: number) {\r\n        // We override this setter because multisampling is handled by framebufferTextureMultisampleMultiviewOVR\r\n        this._samples = value;\r\n    }\r\n\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Creates a multiview render target\r\n     * @param scene scene used with the render target\r\n     * @param size the size of the render target (used for each view)\r\n     */\r\n    constructor(scene?: Scene, size: number | { width: number; height: number } | { ratio: number } = 512) {\r\n        super(\"multiview rtt\", size, scene, false, true, Constants.TEXTURETYPE_UNSIGNED_INT, false, undefined, false, false, true, undefined, true);\r\n        this._renderTarget = this.getScene()!.getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight());\r\n        this._texture = this._renderTarget.texture!;\r\n        this._texture.isMultiview = true;\r\n        this._texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n        this.samples = this._getEngine()!.getCaps().maxSamples || this.samples;\r\n        this._texture.samples = this._samples;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindFrameBuffer() {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        this.getScene()!.getEngine().bindMultiviewFramebuffer(this._renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 2;\r\n    }\r\n}\r\n","import type { Vector2 } from \"../../../Maths/math.vector\";\r\n\r\n/**\r\n * Defines the basic options interface of a TexturePacker Frame\r\n */\r\nexport interface ITexturePackerFrame {\r\n    /**\r\n     * The frame ID\r\n     */\r\n    id: number;\r\n\r\n    /**\r\n     * The frames Scale\r\n     */\r\n    scale: Vector2;\r\n\r\n    /**\r\n     * The Frames offset\r\n     */\r\n    offset: Vector2;\r\n}\r\n\r\n/**\r\n * This is a support class for frame Data on texture packer sets.\r\n */\r\nexport class TexturePackerFrame implements ITexturePackerFrame {\r\n    /**\r\n     * The frame ID\r\n     */\r\n    public id: number;\r\n\r\n    /**\r\n     * The frames Scale\r\n     */\r\n    public scale: Vector2;\r\n\r\n    /**\r\n     * The Frames offset\r\n     */\r\n    public offset: Vector2;\r\n\r\n    /**\r\n     * Initializes a texture package frame.\r\n     * @param id The numerical frame identifier\r\n     * @param scale Scalar Vector2 for UV frame\r\n     * @param offset Vector2 for the frame position in UV units.\r\n     * @returns TexturePackerFrame\r\n     */\r\n    constructor(id: number, scale: Vector2, offset: Vector2) {\r\n        this.id = id;\r\n        this.scale = scale;\r\n        this.offset = offset;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"proceduralVertexShader\";\nconst shader = `attribute vec2 position;varying vec2 vPosition;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvPosition=position;vUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const proceduralVertexShader = { name, shader };\n","import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n            });\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal*\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n        let shaders;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        } else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\r\n                this._rtWrapper?.dispose();\r\n                this._rtWrapper = this._texture = null;\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind and restore viewport\r\n        engine.unBindFramebuffer(this._rtWrapper, this.isCube);\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n","import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport type { ProceduralTexture } from \"./proceduralTexture\";\r\n\r\ndeclare module \"../../../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of procedural textures added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n         */\r\n        proceduralTextures: Array<ProceduralTexture>;\r\n    }\r\n}\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.proceduralTextures = new Array<ProceduralTexture>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n","import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        const size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        clearColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { HDRTools } from \"../../Misc/HighDynamicRange/hdr\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { ToGammaSpace } from \"../../Maths/math.constants\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering\";\r\nimport { ToHalfFloat } from \"../../Misc/textureTools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport \"../../Materials/Textures/baseTexture.polynomial\";\r\n\r\n/**\r\n * This represents a texture coming from an HDR input.\r\n *\r\n * The only supported format is currently panorama picture stored in RGBE format.\r\n * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris\r\n */\r\nexport class HDRCubeTexture extends BaseTexture {\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _generateHarmonics = true;\r\n    private _noMipmap: boolean;\r\n    private _prefilterOnLoad: boolean;\r\n    private _textureMatrix: Matrix;\r\n    private _size: number;\r\n    private _supersample: boolean;\r\n    private _onLoad: () => void;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Sets whether or not the texture is blocking during loading.\r\n     */\r\n    public set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    /**\r\n     * Gets whether or not the texture is blocking during loading.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture\r\n     * It must define where the camera used to render the texture was set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<HDRCubeTexture> = new Observable<HDRCubeTexture>();\r\n\r\n    /**\r\n     * Instantiates an HDRTexture from the following parameters.\r\n     *\r\n     * @param url The location of the HDR raw data (Panorama stored in RGBE format)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process\r\n     * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\r\n     * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.\r\n     * @param onLoad\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        url: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        size: number,\r\n        noMipmap = false,\r\n        generateHarmonics = true,\r\n        gammaSpace = false,\r\n        prefilterOnLoad = false,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        supersample = false\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._prefilterOnLoad = prefilterOnLoad;\r\n        this._onLoad = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        this._onError = onError;\r\n        this.gammaSpace = gammaSpace;\r\n\r\n        this._noMipmap = noMipmap;\r\n        this._size = size;\r\n        this._supersample = supersample;\r\n        this._generateHarmonics = generateHarmonics;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!this.getScene()?.useDelayedTextureLoading) {\r\n                this._loadTexture();\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => this._onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(this._onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"HDRCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"HDRCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file is raw .hdr file.\r\n     */\r\n    private _loadTexture() {\r\n        const engine = this._getEngine()!;\r\n        const caps = engine.getCaps();\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (caps.textureFloat && caps.textureFloatLinearFiltering) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        } else if (caps.textureHalfFloat && caps.textureHalfFloatLinearFiltering) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n\r\n        const callback = (buffer: ArrayBuffer): Nullable<ArrayBufferView[]> => {\r\n            this.lodGenerationOffset = 0.0;\r\n            this.lodGenerationScale = 0.8;\r\n\r\n            // Extract the raw linear data.\r\n            const data = HDRTools.GetCubeMapTextureData(buffer, this._size, this._supersample);\r\n\r\n            // Generate harmonics if needed.\r\n            if (this._generateHarmonics) {\r\n                const sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\r\n                this.sphericalPolynomial = sphericalPolynomial;\r\n            }\r\n\r\n            const results = [];\r\n\r\n            let byteArray: Nullable<Uint8Array> = null;\r\n            let shortArray: Nullable<Uint16Array> = null;\r\n\r\n            // Push each faces.\r\n            for (let j = 0; j < 6; j++) {\r\n                // Create fallback array\r\n                if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n                    shortArray = new Uint16Array(this._size * this._size * 3);\r\n                } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                    // 3 channels of 1 bytes per pixel in bytes.\r\n                    byteArray = new Uint8Array(this._size * this._size * 3);\r\n                }\r\n\r\n                const dataFace = <Float32Array>(<any>data)[HDRCubeTexture._FacesMapping[j]];\r\n\r\n                // If special cases.\r\n                if (this.gammaSpace || shortArray || byteArray) {\r\n                    for (let i = 0; i < this._size * this._size; i++) {\r\n                        // Put in gamma space if requested.\r\n                        if (this.gammaSpace) {\r\n                            dataFace[i * 3 + 0] = Math.pow(dataFace[i * 3 + 0], ToGammaSpace);\r\n                            dataFace[i * 3 + 1] = Math.pow(dataFace[i * 3 + 1], ToGammaSpace);\r\n                            dataFace[i * 3 + 2] = Math.pow(dataFace[i * 3 + 2], ToGammaSpace);\r\n                        }\r\n\r\n                        // Convert to half float texture for fallback.\r\n                        if (shortArray) {\r\n                            shortArray[i * 3 + 0] = ToHalfFloat(dataFace[i * 3 + 0]);\r\n                            shortArray[i * 3 + 1] = ToHalfFloat(dataFace[i * 3 + 1]);\r\n                            shortArray[i * 3 + 2] = ToHalfFloat(dataFace[i * 3 + 2]);\r\n                        }\r\n\r\n                        // Convert to int texture for fallback.\r\n                        if (byteArray) {\r\n                            let r = Math.max(dataFace[i * 3 + 0] * 255, 0);\r\n                            let g = Math.max(dataFace[i * 3 + 1] * 255, 0);\r\n                            let b = Math.max(dataFace[i * 3 + 2] * 255, 0);\r\n\r\n                            // May use luminance instead if the result is not accurate.\r\n                            const max = Math.max(Math.max(r, g), b);\r\n                            if (max > 255) {\r\n                                const scale = 255 / max;\r\n                                r *= scale;\r\n                                g *= scale;\r\n                                b *= scale;\r\n                            }\r\n\r\n                            byteArray[i * 3 + 0] = r;\r\n                            byteArray[i * 3 + 1] = g;\r\n                            byteArray[i * 3 + 2] = b;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (shortArray) {\r\n                    results.push(shortArray);\r\n                } else if (byteArray) {\r\n                    results.push(byteArray);\r\n                } else {\r\n                    results.push(dataFace);\r\n                }\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (engine._features.allowTexturePrefiltering && this._prefilterOnLoad) {\r\n            const previousOnLoad = this._onLoad;\r\n            const hdrFiltering = new HDRFiltering(engine);\r\n            this._onLoad = () => {\r\n                hdrFiltering.prefilter(this, previousOnLoad);\r\n            };\r\n        }\r\n\r\n        this._texture = engine.createRawCubeTextureFromUrl(\r\n            this.url,\r\n            this.getScene(),\r\n            this._size,\r\n            Constants.TEXTUREFORMAT_RGB,\r\n            textureType,\r\n            this._noMipmap,\r\n            callback,\r\n            null,\r\n            this._onLoad,\r\n            this._onError\r\n        );\r\n    }\r\n\r\n    public clone(): HDRCubeTexture {\r\n        const newTexture = new HDRCubeTexture(this.url, this.getScene() || this._getEngine()!, this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    // Methods\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            this._loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Set the texture reflection matrix used to rotate/transform the reflection.\r\n     * @param value Define the reflection matrix to set\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        this._textureMatrix = value;\r\n\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.onLoadObservable.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON representation of an HDR Texture in order to create the texture\r\n     * @param parsedTexture Define the JSON representation\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param rootUrl Define the root url in case we need to load relative dependencies\r\n     * @returns the newly created texture after parsing\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<HDRCubeTexture> {\r\n        let texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new HDRCubeTexture(\r\n                rootUrl + parsedTexture.name,\r\n                scene,\r\n                parsedTexture.size,\r\n                parsedTexture.noMipmap,\r\n                parsedTexture.generateHarmonics,\r\n                parsedTexture.useInGammaSpace\r\n            );\r\n            texture.name = parsedTexture.name;\r\n            texture.hasAlpha = parsedTexture.hasAlpha;\r\n            texture.level = parsedTexture.level;\r\n            texture.coordinatesMode = parsedTexture.coordinatesMode;\r\n            texture.isBlocking = parsedTexture.isBlocking;\r\n        }\r\n        if (texture) {\r\n            if (parsedTexture.boundingBoxPosition) {\r\n                (<any>texture).boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n            }\r\n            if (parsedTexture.boundingBoxSize) {\r\n                (<any>texture).boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n            }\r\n            if (parsedTexture.rotationY) {\r\n                (<any>texture).rotationY = parsedTexture.rotationY;\r\n            }\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.hasAlpha = this.hasAlpha;\r\n        serializationObject.isCube = true;\r\n        serializationObject.level = this.level;\r\n        serializationObject.size = this._size;\r\n        serializationObject.coordinatesMode = this.coordinatesMode;\r\n        serializationObject.useInGammaSpace = this.gammaSpace;\r\n        serializationObject.generateHarmonics = this._generateHarmonics;\r\n        serializationObject.customType = \"BABYLON.HDRCubeTexture\";\r\n        serializationObject.noMipmap = this._noMipmap;\r\n        serializationObject.isBlocking = this._isBlocking;\r\n        serializationObject.rotationY = this._rotationY;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HDRCubeTexture\", HDRCubeTexture);\r\n","import type { Scene } from \"../../scene\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if sRGB format should be used for each of the draw buffers we want to create\r\n     */\r\n    useSRGBBuffers?: boolean[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define the internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...) of all the draw buffers we want to create\r\n     */\r\n    formats?: number[];\r\n    /**\r\n     * Define depth texture format to use\r\n     */\r\n    depthTextureFormat?: number;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    drawOnlyOnFirstAttachmentByDefault?: boolean;\r\n    /**\r\n     * Define the type of texture at each attahment index (of Constants.TEXTURE_2D, .TEXTURE_2D_ARRAY, .TEXTURE_CUBE_MAP, .TEXTURE_CUBE_MAP_ARRAY, .TEXTURE_3D).\r\n     * You can also use the -1 value to indicate that no texture should be created but that you will assign a texture to that attachment index later.\r\n     * Can be useful when you want to attach several layers of the same 2DArrayTexture / 3DTexture or several faces of the same CubeMapTexture: Use the setInternalTexture\r\n     * method for that purpose, after the MultiRenderTarget has been created.\r\n     */\r\n    targetTypes?: number[];\r\n    /**\r\n     * Define the face index of each texture in the textures array (if applicable, given the corresponding targetType) at creation time (for Constants.TEXTURE_CUBE_MAP and .TEXTURE_CUBE_MAP_ARRAY).\r\n     * Can be changed at any time by calling setLayerAndFaceIndices or setLayerAndFaceIndex\r\n     */\r\n    faceIndex?: number[];\r\n    /**\r\n     * Define the layer index of each texture in the textures array (if applicable, given the corresponding targetType) at creation time (for Constants.TEXTURE_3D, .TEXTURE_2D_ARRAY, and .TEXTURE_CUBE_MAP_ARRAY).\r\n     * Can be changed at any time by calling setLayerAndFaceIndices or setLayerAndFaceIndex\r\n     */\r\n    layerIndex?: number[];\r\n    /**\r\n     * Define the number of layer of each texture in the textures array (if applicable, given the corresponding targetType) (for Constants.TEXTURE_3D, .TEXTURE_2D_ARRAY, and .TEXTURE_CUBE_MAP_ARRAY)\r\n     */\r\n    layerCounts?: number[];\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n    private _drawOnlyOnFirstAttachmentByDefault: boolean;\r\n    private _textureNames?: string[];\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\r\n     */\r\n    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\r\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        this._textureNames = textureNames;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n        const formats: number[] = [];\r\n        const targetTypes: number[] = [];\r\n        const faceIndex: number[] = [];\r\n        const layerIndex: number[] = [];\r\n        const layerCounts: number[] = [];\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\r\n\r\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            depthTextureFormat: depthTextureFormat,\r\n            types: types,\r\n            textureCount: count,\r\n            useSRGBBuffers: useSRGBBuffers,\r\n            formats: formats,\r\n            targetTypes: targetTypes,\r\n            faceIndex: faceIndex,\r\n            layerIndex: layerIndex,\r\n            layerCounts: layerCounts,\r\n        };\r\n\r\n        this._count = count;\r\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\r\n\r\n        if (count > 0) {\r\n            this._createInternalTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n    }\r\n\r\n    private _initTypes(\r\n        count: number,\r\n        types: number[],\r\n        samplingModes: number[],\r\n        useSRGBBuffers: boolean[],\r\n        formats: number[],\r\n        targets: number[],\r\n        faceIndex: number[],\r\n        layerIndex: number[],\r\n        layerCounts: number[],\r\n        options?: IMultiRenderTargetOptions\r\n    ) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n\r\n            if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\r\n                useSRGBBuffers.push(options.useSRGBBuffers[i]);\r\n            } else {\r\n                useSRGBBuffers.push(false);\r\n            }\r\n\r\n            if (options && options.formats && options.formats[i] !== undefined) {\r\n                formats.push(options.formats[i]);\r\n            } else {\r\n                formats.push(Constants.TEXTUREFORMAT_RGBA);\r\n            }\r\n\r\n            if (options && options.targetTypes && options.targetTypes[i] !== undefined) {\r\n                targets.push(options.targetTypes[i]);\r\n            } else {\r\n                targets.push(Constants.TEXTURE_2D);\r\n            }\r\n\r\n            if (options && options.faceIndex && options.faceIndex[i] !== undefined) {\r\n                faceIndex.push(options.faceIndex[i]);\r\n            } else {\r\n                faceIndex.push(0);\r\n            }\r\n\r\n            if (options && options.layerIndex && options.layerIndex[i] !== undefined) {\r\n                layerIndex.push(options.layerIndex[i]);\r\n            } else {\r\n                layerIndex.push(0);\r\n            }\r\n\r\n            if (options && options.layerCounts && options.layerCounts[i] !== undefined) {\r\n                layerCounts.push(options.layerCounts[i]);\r\n            } else {\r\n                layerCounts.push(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createInternaTextureIndexMapping() {\r\n        const mapMainInternalTexture2Index: { [key: number]: number } = {};\r\n        const mapInternalTexture2MainIndex: number[] = [];\r\n\r\n        if (!this._renderTarget) {\r\n            return mapInternalTexture2MainIndex;\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = internalTextures[i];\r\n            if (!texture) {\r\n                continue;\r\n            }\r\n            const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];\r\n            if (mainIndex !== undefined) {\r\n                mapInternalTexture2MainIndex[i] = mainIndex;\r\n            } else {\r\n                mapMainInternalTexture2Index[texture.uniqueId] = i;\r\n            }\r\n        }\r\n\r\n        return mapInternalTexture2MainIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rebuild(forceFullRebuild: boolean = false, textureNames?: string[]): void {\r\n        if (this._count < 1) {\r\n            return;\r\n        }\r\n\r\n        const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();\r\n\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._releaseTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = this._textures[i];\r\n            if (mapInternalTexture2MainIndex[i] !== undefined) {\r\n                this._renderTarget!.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            if (texture._texture) {\r\n                texture._noMipmap = !texture._texture.useMipMaps;\r\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\r\n            }\r\n        }\r\n\r\n        if (this.samples !== 1) {\r\n            this._renderTarget!.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._renderTarget = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\r\n        this._texture = this._renderTarget.texture;\r\n    }\r\n\r\n    private _releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createTextures(textureNames?: string[]): void {\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        this._textures = [];\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = new Texture(null, this.getScene());\r\n            if (textureNames?.[i]) {\r\n                texture.name = textureNames[i];\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            if (texture._texture) {\r\n                texture._noMipmap = !texture._texture.useMipMaps;\r\n                texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\r\n            }\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\r\n     * @param texture The new texture to set in the MRT\r\n     * @param index The index of the texture to replace\r\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\r\n     */\r\n    public setInternalTexture(texture: InternalTexture, index: number, disposePrevious: boolean = true) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (index === 0) {\r\n            this._texture = texture;\r\n        }\r\n\r\n        this.renderTarget.setTexture(texture, index, disposePrevious);\r\n\r\n        if (!this.textures[index]) {\r\n            this.textures[index] = new Texture(null, this.getScene());\r\n            this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;\r\n        }\r\n        this.textures[index]._texture = texture;\r\n        this.textures[index]._noMipmap = !texture.useMipMaps;\r\n        this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;\r\n\r\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\r\n\r\n        if (this._multiRenderTargetOptions.types) {\r\n            this._multiRenderTargetOptions.types[index] = texture.type;\r\n        }\r\n        if (this._multiRenderTargetOptions.samplingModes) {\r\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\r\n        }\r\n        if (this._multiRenderTargetOptions.useSRGBBuffers) {\r\n            this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\r\n        }\r\n        if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {\r\n            let target: number = 0;\r\n            if (texture.is2DArray) {\r\n                target = Constants.TEXTURE_2D_ARRAY;\r\n            } else if (texture.isCube) {\r\n                target = Constants.TEXTURE_CUBE_MAP;\r\n            } /*else if (texture.isCubeArray) {\r\n                target = Constants.TEXTURE_CUBE_MAP_ARRAY;\r\n            }*/ else if (texture.is3D) {\r\n                target = Constants.TEXTURE_3D;\r\n            } else {\r\n                target = Constants.TEXTURE_2D;\r\n            }\r\n            this._multiRenderTargetOptions.targetTypes[index] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes an attached texture's face index or layer.\r\n     * @param index The index of the texture to modify the attachment of\r\n     * @param layerIndex The layer index of the texture to be attached to the framebuffer\r\n     * @param faceIndex The face index of the texture to be attached to the framebuffer\r\n     */\r\n    public setLayerAndFaceIndex(index: number, layerIndex: number = -1, faceIndex: number = -1) {\r\n        if (!this.textures[index] || !this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (this._multiRenderTargetOptions.layerIndex) {\r\n            this._multiRenderTargetOptions.layerIndex[index] = layerIndex;\r\n        }\r\n        if (this._multiRenderTargetOptions.faceIndex) {\r\n            this._multiRenderTargetOptions.faceIndex[index] = faceIndex;\r\n        }\r\n\r\n        this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);\r\n    }\r\n\r\n    /**\r\n     * Changes every attached texture's face index or layer.\r\n     * @param layerIndices The layer indices of the texture to be attached to the framebuffer\r\n     * @param faceIndices The face indices of the texture to be attached to the framebuffer\r\n     */\r\n    public setLayerAndFaceIndices(layerIndices: number[], faceIndices: number[]) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        this._multiRenderTargetOptions.layerIndex = layerIndices;\r\n        this._multiRenderTargetOptions.faceIndex = faceIndices;\r\n\r\n        this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        } else {\r\n            // In case samples are set with 0 textures created, we must save the desired samples value\r\n            this._samples = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._processSizeParameter(size, false);\r\n        this._rebuild(undefined, this._textureNames);\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n        const formats: number[] = [];\r\n        const targetTypes: number[] = [];\r\n        const faceIndex: number[] = [];\r\n        const layerIndex: number[] = [];\r\n        const layerCounts: number[] = [];\r\n\r\n        this._textureNames = textureNames;\r\n\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\r\n        this._multiRenderTargetOptions.formats = formats;\r\n        this._multiRenderTargetOptions.targetTypes = targetTypes;\r\n        this._multiRenderTargetOptions.faceIndex = faceIndex;\r\n        this._multiRenderTargetOptions.layerIndex = layerIndex;\r\n        this._multiRenderTargetOptions.layerCounts = layerCounts;\r\n\r\n        this._rebuild(true, textureNames);\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (this._renderTarget) {\r\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\r\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     * @param doNotDisposeInternalTextures\r\n     */\r\n    public dispose(doNotDisposeInternalTextures = false): void {\r\n        this._releaseTextures();\r\n        if (!doNotDisposeInternalTextures) {\r\n            this.releaseInternalTextures();\r\n        } else {\r\n            // Prevent internal texture dispose in super.dispose\r\n            this._texture = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        const internalTextures = this._renderTarget?.textures;\r\n\r\n        if (!internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\r\n            this._textures[i]._texture = null;\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n    }\r\n}\r\n","import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ExternalTexture } from \"./externalTexture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\nfunction removeSource(video: HTMLVideoElement): void {\r\n    // Remove any <source> elements, etc.\r\n    while (video.firstChild) {\r\n        video.removeChild(video.firstChild);\r\n    }\r\n\r\n    // detach srcObject\r\n    video.srcObject = null;\r\n\r\n    // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\r\n    video.src = \"\";\r\n\r\n    // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\r\n    video.removeAttribute(\"src\");\r\n}\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `muted` to video, if specified\r\n     */\r\n    muted?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n\r\n    /**\r\n     * Defines the associated texture format.\r\n     */\r\n    format?: number;\r\n\r\n    /**\r\n     * Notify babylon to not modify any video settings and not control the video's playback.\r\n     * Set this to true if you are controlling the way the video is being played, stopped and paused.\r\n     */\r\n    independentVideoSource?: boolean;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _externalTexture: Nullable<ExternalTexture>;\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggered when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n    private _onError?: Nullable<(message?: string, exception?: any) => void>;\r\n    private _errorFound = false;\r\n\r\n    private _processError(reason: any) {\r\n        this._errorFound = true;\r\n        if (this._onError) {\r\n            this._onError(reason?.message);\r\n        } else {\r\n            Logger.Error(reason?.message);\r\n        }\r\n    }\r\n\r\n    private _handlePlay() {\r\n        this._errorFound = false;\r\n        this.video.play().catch((reason) => {\r\n            if (reason?.name === \"NotAllowedError\") {\r\n                if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                    this._onUserActionRequestedObservable.notifyObservers(this);\r\n                    return;\r\n                } else if (!this.video.muted) {\r\n                    Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\r\n                    this.video.muted = true;\r\n                    this._errorFound = false;\r\n                    this.video.play().catch((otherReason) => {\r\n                        this._processError(otherReason);\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._processError(reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param format defines the texture format to use (Engine.TEXTUREFORMAT_RGBA by default)\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._settings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n            ...settings,\r\n        };\r\n\r\n        this._onError = onError;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = this._settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n        this._externalTexture = this._engine?.createExternalTexture(this.video) ?? null;\r\n        if (!this._settings.independentVideoSource) {\r\n            if (this._settings.poster) {\r\n                this.video.poster = this._settings.poster;\r\n            }\r\n            if (this._settings.autoPlay !== undefined) {\r\n                this.video.autoplay = this._settings.autoPlay;\r\n            }\r\n            if (this._settings.loop !== undefined) {\r\n                this.video.loop = this._settings.loop;\r\n            }\r\n            if (this._settings.muted !== undefined) {\r\n                this.video.muted = this._settings.muted;\r\n            }\r\n\r\n            this.video.setAttribute(\"playsinline\", \"\");\r\n            this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"emptied\", this._reset);\r\n\r\n            if (this._settings.autoPlay) {\r\n                this._handlePlay();\r\n            }\r\n        }\r\n\r\n        this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this._format = format;\r\n\r\n        const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\r\n        if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._getEngine()!.createTexture(this._settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        } else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the video texture useful for serialization or dynamic coding.\r\n     * @returns \"VideoTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VideoTexture\";\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if ((<any>src).isNative) {\r\n            return <HTMLVideoElement>src;\r\n        }\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n\r\n        this.onDisposeObservable.addOnce(() => {\r\n            removeSource(video);\r\n        });\r\n\r\n        return video;\r\n    }\r\n\r\n    private _resizeInternalTexture = (): void => {\r\n        // Cleanup the old texture before replacing it\r\n        if (this._texture != null) {\r\n            this._texture.dispose();\r\n        }\r\n\r\n        if (!this._getEngine()!.needPOTTextures || (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\r\n        this._texture.format = this._format ?? Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        // Reset the frame ID and update the new texture to ensure it pulls in the current video frame\r\n        this._frameId = -1;\r\n        this._updateInternalTexture();\r\n    };\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._displayingPosterTexture = false;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.video.addEventListener(\"resize\", this._resizeInternalTexture);\r\n        this._resizeInternalTexture();\r\n\r\n        if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {\r\n            const oldHandler = this.video.onplaying;\r\n            const oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._updateInternalTexture();\r\n                if (!this._errorFound) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            this._handlePlay();\r\n        } else {\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    };\r\n\r\n    private _reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @internal Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        const frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._getEngine()!.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);\r\n    };\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name, this._currentSrc!, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        if (!this._settings.independentVideoSource) {\r\n            this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"emptied\", this._reset);\r\n            this.video.removeEventListener(\"resize\", this._resizeInternalTexture);\r\n            this.video.pause();\r\n        }\r\n\r\n        this._externalTexture?.dispose();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @param constraints video constraints\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream, constraints: any, invertY = true): Promise<VideoTexture> {\r\n        const video = scene.getEngine().createVideoElement(constraints);\r\n\r\n        if (scene.getEngine()._badOS) {\r\n            // Yes... I know and I hope to remove it soon...\r\n            document.body.appendChild(video);\r\n            video.style.transform = \"scale(0.0001, 0.0001)\";\r\n            video.style.opacity = \"0\";\r\n            video.style.position = \"fixed\";\r\n            video.style.bottom = \"0px\";\r\n            video.style.right = \"0px\";\r\n        }\r\n\r\n        video.setAttribute(\"autoplay\", \"\");\r\n        video.setAttribute(\"muted\", \"true\");\r\n        video.setAttribute(\"playsinline\", \"\");\r\n        video.muted = true;\r\n\r\n        if (video.isNative) {\r\n            // No additional configuration needed for native\r\n        } else if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\r\n                video.src = window.URL && window.URL.createObjectURL(stream as any);\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            const onPlaying = () => {\r\n                const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY, undefined, undefined, undefined, Constants.TEXTUREFORMAT_RGB);\r\n                if (scene.getEngine()._badOS) {\r\n                    videoTexture.onDisposeObservable.addOnce(() => {\r\n                        video.remove();\r\n                    });\r\n                }\r\n                videoTexture.onDisposeObservable.addOnce(() => {\r\n                    removeSource(video);\r\n                });\r\n\r\n                resolve(videoTexture);\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static async CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): Promise<VideoTexture> {\r\n        if (navigator.mediaDevices) {\r\n            const stream = await navigator.mediaDevices.getUserMedia({\r\n                video: constraints,\r\n                audio: audioConstaints,\r\n            });\r\n\r\n            const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);\r\n            videoTexture.onDisposeObservable.addOnce(() => {\r\n                stream.getTracks().forEach((track) => {\r\n                    track.stop();\r\n                });\r\n            });\r\n\r\n            return videoTexture;\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Defines the scene the texture should be created in\r\n     * @param onReady Defines a callback to triggered once the texture will be ready\r\n     * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY)\r\n            .then(function (videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function (err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"greasedLinePixelShader\";\nconst shader = `precision highp float;uniform sampler2D grlColors;uniform float grlUseColors;uniform float grlUseDash;uniform float grlDashArray;uniform float grlDashOffset;uniform float grlDashRatio;uniform float grlVisibility;uniform float grlColorsWidth;uniform vec2 grl_colorModeAndColorDistributionType;uniform vec3 grlColor;varying float grlCounters;varying float grlColorPointer;void main() {float grlColorMode=grl_colorModeAndColorDistributionType.x;float grlColorDistributionType=grl_colorModeAndColorDistributionType.y;gl_FragColor=vec4(grlColor,1.);gl_FragColor.a=step(grlCounters,grlVisibility);if (gl_FragColor.a==0.) discard;if( grlUseDash==1. ){gl_FragColor.a=ceil(mod(grlCounters+grlDashOffset,grlDashArray)-(grlDashArray*grlDashRatio));if (gl_FragColor.a==0.) discard;}\nif (grlUseColors==1.) {vec4 textureColor;if (grlColorDistributionType==1.) { \ntextureColor=texture2D(grlColors,vec2(grlCounters,0.),0.);} else {textureColor=texture2D(grlColors,vec2(grlColorPointer/grlColorsWidth,0.),0.);}\nif (grlColorMode==0.) { \ngl_FragColor=textureColor;} else if (grlColorMode==1.) { \ngl_FragColor+=textureColor;} else if (grlColorMode==2.) { \ngl_FragColor*=textureColor;}}}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const greasedLinePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"greasedLineVertexShader\";\nconst shader = `precision highp float;attribute vec4 grl_previousAndSide;attribute vec4 grl_nextAndCounters;attribute float grl_widths;attribute vec3 grl_offsets;attribute float grl_colorPointers;attribute vec3 position;uniform vec2 grlResolution;uniform float grlAspect;uniform float grlWidth;uniform float grlSizeAttenuation;uniform mat4 worldViewProjection;uniform mat4 projection;varying float grlCounters;varying float grlColorPointer;vec2 grlFix( vec4 i,float aspect ) {vec2 res=i.xy/i.w;res.x*=aspect;return res;}\nvoid main() {grlColorPointer=grl_colorPointers;float grlBaseWidth=grlWidth;vec3 grlPrevious=grl_previousAndSide.xyz;float grlSide=grl_previousAndSide.w;vec3 grlNext=grl_nextAndCounters.xyz;grlCounters=grl_nextAndCounters.w;mat4 grlMatrix=worldViewProjection;vec3 grlPositionOffset=grl_offsets;vec4 grlFinalPosition=grlMatrix*vec4( position+grlPositionOffset ,1.0 );vec4 grlPrevPos=grlMatrix*vec4( grlPrevious+grlPositionOffset,1.0 );vec4 grlNextPos=grlMatrix*vec4( grlNext+grlPositionOffset,1.0 );vec2 grlCurrentP=grlFix( grlFinalPosition,grlAspect );vec2 grlPrevP=grlFix( grlPrevPos,grlAspect );vec2 grlNextP=grlFix( grlNextPos,grlAspect );float grlWidth=grlBaseWidth*grl_widths;vec2 grlDir;if( grlNextP==grlCurrentP ) grlDir=normalize( grlCurrentP-grlPrevP );else if( grlPrevP==grlCurrentP ) grlDir=normalize( grlNextP-grlCurrentP );else {vec2 grlDir1=normalize( grlCurrentP-grlPrevP );vec2 grlDir2=normalize( grlNextP-grlCurrentP );grlDir=normalize( grlDir1+grlDir2 );}\nvec4 grlNormal=vec4( -grlDir.y,grlDir.x,0.,1. );\n#ifdef GREASED_LNE_RIGHT_HANDED_COORDINATE_SYSTEM\ngrlNormal.xy*=-.5*grlWidth;\n#else\ngrlNormal.xy*=.5*grlWidth;\n#endif\ngrlNormal*=projection;if (grlSizeAttenuation==1.) {grlNormal.xy*=grlFinalPosition.w;grlNormal.xy/=( vec4( grlResolution,0.,1. )*projection ).xy;}\ngrlFinalPosition.xy+=grlNormal.xy*grlSide;gl_Position=grlFinalPosition;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const greasedLineVertexShader = { name, shader };\n","import type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { RawTexture } from \"./Textures/rawTexture\";\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLinePluginMaterial\";\r\nimport { GreasedLineMeshColorMode, GreasedLineMeshColorDistributionType } from \"./greasedLinePluginMaterial\";\r\n\r\nimport { ShaderMaterial } from \"./shaderMaterial\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\n\r\nimport \"../Shaders/greasedLine.fragment\";\r\nimport \"../Shaders/greasedLine.vertex\";\r\n\r\n/**\r\n * GreasedLineSimpleMaterial\r\n */\r\nexport class GreasedLineSimpleMaterial extends ShaderMaterial implements IGreasedLineMaterial {\r\n    /**\r\n     * Default line color for newly created lines\r\n     */\r\n    public static DEFAULT_COLOR = Color3.White();\r\n    /**\r\n     * Default line width when sizeAttenuation is true\r\n     */\r\n    public static DEFAULT_WIDTH_ATTENUATED = 1;\r\n    /**\r\n     * Defaule line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n\r\n    private static _EmptyColorsTexture: BaseTexture;\r\n\r\n    private _visibility: number;\r\n    private _width: number;\r\n    private _useDash: boolean;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _dashRatio: number;\r\n    private _dashOffset: number;\r\n    private _useColors: boolean;\r\n    private _color: Color3 = Color3.White();\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType = GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n    private _colorMode: GreasedLineMeshColorMode;\r\n    private _colorsSampling: number;\r\n    private _resolution: Vector2;\r\n    private _sizeAttenuation: boolean;\r\n    private _colorsTexture?: RawTexture;\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * GreasedLineSimple material constructor\r\n     * @param name material name\r\n     * @param scene the scene\r\n     * @param options material options\r\n     */\r\n    constructor(name: string, scene: Scene, options: GreasedLineMaterialOptions) {\r\n        super(\r\n            name,\r\n            scene,\r\n            {\r\n                vertex: \"greasedLine\",\r\n                fragment: \"greasedLine\",\r\n            },\r\n            {\r\n                attributes: [\"position\", \"normal\", \"grl_previousAndSide\", \"grl_nextAndCounters\", \"grl_widths\", \"grl_offsets\", \"grl_colorPointers\"],\r\n                uniforms: [\r\n                    \"worldViewProjection\",\r\n                    \"projection\",\r\n                    \"grlColorsWidth\",\r\n                    \"grlUseColors\",\r\n                    \"grlWidth\",\r\n                    \"grlColor\",\r\n                    \"grl_colorModeAndColorDistributionType\",\r\n                    \"grlResolution\",\r\n                    \"grlAspect\",\r\n                    \"grlAizeAttenuation\",\r\n                    \"grlDashArray\",\r\n                    \"grlDashOffset\",\r\n                    \"grlDashRatio\",\r\n                    \"grlUseDash\",\r\n                    \"grlVisibility\",\r\n                ],\r\n                samplers: [\"grlColors\"],\r\n                defines: scene.useRightHandedSystem ? [\"GREASED_LNE_RIGHT_HANDED_COORDINATE_SYSTEM\"] : [],\r\n            }\r\n        );\r\n        options = options || {\r\n            color: GreasedLineSimpleMaterial.DEFAULT_COLOR,\r\n        };\r\n\r\n        this._engine = scene.getEngine();\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineSimpleMaterial.DEFAULT_WIDTH_ATTENUATED : GreasedLineSimpleMaterial.DEFAULT_WIDTH;\r\n        this.sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.color = options.color ?? Color3.White();\r\n        this.useColors = options.useColors ?? false;\r\n        this.colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._colors = options.colors ?? null;\r\n\r\n        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (this._colors) {\r\n            this.setColors(this._colors);\r\n        }\r\n\r\n        this._engine.onDisposeObservable.add(() => {\r\n            GreasedLineSimpleMaterial._EmptyColorsTexture?.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    private static _BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    private static _Color3toRGBAUint8(colors: Color3[]) {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     */\r\n    private _createColorsTexture(name: string, colors: Color3[]) {\r\n        const colorsArray = GreasedLineSimpleMaterial._Color3toRGBAUint8(colors);\r\n        this._colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, this.getScene(), false, true, this._colorsSampling);\r\n        this._colorsTexture.name = name;\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public dispose(): void {\r\n        this._colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    private _setColorModeAndColorDistributionType() {\r\n        this.setVector2(\"grl_colorModeAndColorDistributionType\", new Vector2(this._colorMode, this._colorsDistributionType));\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     * @returns\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this._colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineSimpleMaterial._Color3toRGBAUint8(colors);\r\n            this._colorsTexture.update(colorArray);\r\n        } else {\r\n            this._colorsTexture?.dispose();\r\n            this._createColorsTexture(`${this.name}-colors-texture`, colors);\r\n        }\r\n\r\n        if (this._colorsTexture) {\r\n            this.setFloat(\"grlColorsWidth\", this._colorsTexture.getSize().width);\r\n            this.setTexture(\"grlColors\", this._colorsTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this.setFloat(\"grlWidth\", value);\r\n    }\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    get useColors() {\r\n        return this._useColors;\r\n    }\r\n\r\n    set useColors(value: boolean) {\r\n        this._useColors = value;\r\n        this.setFloat(\"grlUseColors\", GreasedLineSimpleMaterial._BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    get colorsSampling() {\r\n        return this._colorsSampling;\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    set colorsSampling(value: number) {\r\n        this._colorsSampling = value;\r\n    }\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    get visibility() {\r\n        return this._visibility;\r\n    }\r\n\r\n    set visibility(value: number) {\r\n        this._visibility = value;\r\n        this.setFloat(\"grlVisibility\", value);\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    get useDash() {\r\n        return this._useDash;\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    set useDash(value: boolean) {\r\n        this._useDash = value;\r\n        this.setFloat(\"grlUseDash\", GreasedLineSimpleMaterial._BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the dash offset\r\n     */\r\n    get dashOffset() {\r\n        return this._dashOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the dash offset\r\n     */\r\n    set dashOffset(value: number) {\r\n        this._dashOffset = value;\r\n        this.setFloat(\"grlDashOffset\", value);\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    get dashRatio() {\r\n        return this._dashRatio;\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    set dashRatio(value: number) {\r\n        this._dashRatio = value;\r\n        this.setFloat(\"grlDashRatio\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n        this.setFloat(\"grlDashArray\", this._dashArray);\r\n    }\r\n\r\n    /**\r\n     * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off attenuation of the width option and widths array.\r\n     * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.setFloat(\"grlSizeAttenuation\", GreasedLineSimpleMaterial._BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this.color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3\r\n     */\r\n    set color(value: Color3) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>) {\r\n        value = value ?? GreasedLineSimpleMaterial.DEFAULT_COLOR;\r\n        this._color = value;\r\n        this.setColor3(\"grlColor\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    get colorMode() {\r\n        return this._colorMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    set colorMode(value: GreasedLineMeshColorMode) {\r\n        this._colorMode = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._resolution = value;\r\n        this.setVector2(\"grlResolution\", value);\r\n        this.setFloat(\"grlAspect\", value.x / value.y);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this._colorsSampling,\r\n            colorMode: this._colorMode,\r\n            color: this._color,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this._dashOffset,\r\n            dashRatio: this._dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this._useColors,\r\n            useDash: this._useDash,\r\n            visibility: this._visibility,\r\n            width: this._width,\r\n        };\r\n\r\n        this._colors && (greasedLineMaterialOptions.colors = this._colors);\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param _rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, _rootUrl: string): void {\r\n        // TODO: super.parse?\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this._colorsTexture?.dispose();\r\n\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this._createColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors);\r\n        } else {\r\n            GreasedLineSimpleMaterial._PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        greasedLineMaterialOptions.color && (this.color = greasedLineMaterialOptions.color);\r\n        greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\r\n        greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\r\n        greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\r\n        greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\r\n        greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\r\n        greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\r\n        greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\r\n        greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\r\n        greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\r\n        greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\r\n        greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\r\n        greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     */\r\n    private static _PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!this._EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineSimpleMaterial._EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineSimpleMaterial._EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"core/types\";\r\nimport { DecalMapConfiguration } from \"./material.decalMapConfiguration\";\r\nimport { StandardMaterial } from \"./standardMaterial\";\r\n\r\ndeclare module \"./standardMaterial\" {\r\n    export interface StandardMaterial {\r\n        /** @internal */\r\n        _decalMap: Nullable<DecalMapConfiguration>;\r\n\r\n        /**\r\n         * Defines the decal map parameters for the material.\r\n         */\r\n        decalMap: Nullable<DecalMapConfiguration>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(StandardMaterial.prototype, \"decalMap\", {\r\n    get: function (this: StandardMaterial) {\r\n        if (!this._decalMap) {\r\n            if (this._uniformBufferLayoutBuilt) {\r\n                // Material already used to display a mesh, so it's invalid to add the decal map plugin at that point\r\n                // Returns null instead of having new DecalMapConfiguration throws an exception\r\n                return null;\r\n            }\r\n\r\n            this._decalMap = new DecalMapConfiguration(this);\r\n        }\r\n        return this._decalMap;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n","import type { Nullable } from \"core/types\";\r\nimport { DecalMapConfiguration } from \"../material.decalMapConfiguration\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\ndeclare module \"./pbrBaseMaterial\" {\r\n    export interface PBRBaseMaterial {\r\n        /** @internal */\r\n        _decalMap: Nullable<DecalMapConfiguration>;\r\n\r\n        /**\r\n         * Defines the decal map parameters for the material.\r\n         */\r\n        decalMap: Nullable<DecalMapConfiguration>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(PBRBaseMaterial.prototype, \"decalMap\", {\r\n    get: function (this: PBRBaseMaterial) {\r\n        if (!this._decalMap) {\r\n            if (this._uniformBufferLayoutBuilt) {\r\n                // Material already used to display a mesh, so it's invalid to add the decal map plugin at that point\r\n                // Returns null instead of having new DecalMapConfiguration throws an exception\r\n                return null;\r\n            }\r\n\r\n            this._decalMap = new DecalMapConfiguration(this);\r\n        }\r\n        return this._decalMap;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n","import type { IColor3Like, IColor4Like, IMatrixLike, IVector3Like, IVector4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\n\r\n/** @internal */\r\nexport class UniformBufferEffectCommonAccessor {\r\n    public setMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    public setMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    public setFloat: (name: string, x: number) => void;\r\n\r\n    public setFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    public setFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    public setFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    public setFloatArray: (name: string, array: Float32Array) => void;\r\n\r\n    public setArray: (name: string, array: number[]) => void;\r\n\r\n    public setIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    public setMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    public setMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    public setVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    public setVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    public setColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    public setColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    public setDirectColor4: (name: string, color: IColor4Like) => void;\r\n\r\n    public setInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    public setInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    public setInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    public setInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    private _isUbo(uboOrEffect: UniformBuffer | Effect): uboOrEffect is UniformBuffer {\r\n        return (uboOrEffect as UniformBuffer).addUniform !== undefined;\r\n    }\r\n\r\n    constructor(uboOrEffect: UniformBuffer | Effect) {\r\n        if (this._isUbo(uboOrEffect)) {\r\n            this.setMatrix3x3 = uboOrEffect.updateMatrix3x3.bind(uboOrEffect);\r\n            this.setMatrix2x2 = uboOrEffect.updateMatrix2x2.bind(uboOrEffect);\r\n            this.setFloat = uboOrEffect.updateFloat.bind(uboOrEffect);\r\n            this.setFloat2 = uboOrEffect.updateFloat2.bind(uboOrEffect);\r\n            this.setFloat3 = uboOrEffect.updateFloat3.bind(uboOrEffect);\r\n            this.setFloat4 = uboOrEffect.updateFloat4.bind(uboOrEffect);\r\n            this.setFloatArray = uboOrEffect.updateFloatArray.bind(uboOrEffect);\r\n            this.setArray = uboOrEffect.updateArray.bind(uboOrEffect);\r\n            this.setIntArray = uboOrEffect.updateIntArray.bind(uboOrEffect);\r\n            this.setMatrix = uboOrEffect.updateMatrix.bind(uboOrEffect);\r\n            this.setMatrices = uboOrEffect.updateMatrices.bind(uboOrEffect);\r\n            this.setVector3 = uboOrEffect.updateVector3.bind(uboOrEffect);\r\n            this.setVector4 = uboOrEffect.updateVector4.bind(uboOrEffect);\r\n            this.setColor3 = uboOrEffect.updateColor3.bind(uboOrEffect);\r\n            this.setColor4 = uboOrEffect.updateColor4.bind(uboOrEffect);\r\n            this.setDirectColor4 = uboOrEffect.updateDirectColor4.bind(uboOrEffect);\r\n            this.setInt = uboOrEffect.updateInt.bind(uboOrEffect);\r\n            this.setInt2 = uboOrEffect.updateInt2.bind(uboOrEffect);\r\n            this.setInt3 = uboOrEffect.updateInt3.bind(uboOrEffect);\r\n            this.setInt4 = uboOrEffect.updateInt4.bind(uboOrEffect);\r\n        } else {\r\n            this.setMatrix3x3 = uboOrEffect.setMatrix3x3.bind(uboOrEffect);\r\n            this.setMatrix2x2 = uboOrEffect.setMatrix2x2.bind(uboOrEffect);\r\n            this.setFloat = uboOrEffect.setFloat.bind(uboOrEffect);\r\n            this.setFloat2 = uboOrEffect.setFloat2.bind(uboOrEffect);\r\n            this.setFloat3 = uboOrEffect.setFloat3.bind(uboOrEffect);\r\n            this.setFloat4 = uboOrEffect.setFloat4.bind(uboOrEffect);\r\n            this.setFloatArray = uboOrEffect.setFloatArray.bind(uboOrEffect);\r\n            this.setArray = uboOrEffect.setArray.bind(uboOrEffect);\r\n            this.setIntArray = uboOrEffect.setIntArray.bind(uboOrEffect);\r\n            this.setMatrix = uboOrEffect.setMatrix.bind(uboOrEffect);\r\n            this.setMatrices = uboOrEffect.setMatrices.bind(uboOrEffect);\r\n            this.setVector3 = uboOrEffect.setVector3.bind(uboOrEffect);\r\n            this.setVector4 = uboOrEffect.setVector4.bind(uboOrEffect);\r\n            this.setColor3 = uboOrEffect.setColor3.bind(uboOrEffect);\r\n            this.setColor4 = uboOrEffect.setColor4.bind(uboOrEffect);\r\n            this.setDirectColor4 = uboOrEffect.setDirectColor4.bind(uboOrEffect);\r\n            this.setInt = uboOrEffect.setInt.bind(uboOrEffect);\r\n            this.setInt2 = uboOrEffect.setInt2.bind(uboOrEffect);\r\n            this.setInt3 = uboOrEffect.setInt3.bind(uboOrEffect);\r\n            this.setInt4 = uboOrEffect.setInt4.bind(uboOrEffect);\r\n        }\r\n    }\r\n}\r\n","import { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../../nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"../../nodeGeometryBuildState\";\r\nimport { GeometryInputBlock } from \"../geometryInputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { CreateSegmentedBoxVertexData } from \"core/Meshes/Builders/boxBuilder\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Defines a block used to generate box geometry data\r\n */\r\nexport class BoxBlock extends NodeGeometryBlock {\r\n    /**\r\n     * Gets or sets a boolean indicating that this block can evaluate context\r\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\r\n     */\r\n    @editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { rebuild: true } })\r\n    public evaluateContext = false;\r\n\r\n    /**\r\n     * Create a new BoxBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"size\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\r\n        this.registerInput(\"width\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"height\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"depth\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\r\n        this.registerInput(\"subdivisions\", NodeGeometryBlockConnectionPointTypes.Int, true, 1);\r\n        this.registerInput(\"subdivisionsX\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n        this.registerInput(\"subdivisionsY\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n        this.registerInput(\"subdivisionsZ\", NodeGeometryBlockConnectionPointTypes.Int, true, 0);\r\n\r\n        this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"BoxBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the size input component\r\n     */\r\n    public get size(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the width input component\r\n     */\r\n    public get width(): NodeGeometryConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the height input component\r\n     */\r\n    public get height(): NodeGeometryConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth input component\r\n     */\r\n    public get depth(): NodeGeometryConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisions input component\r\n     */\r\n    public get subdivisions(): NodeGeometryConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsX input component\r\n     */\r\n    public get subdivisionsX(): NodeGeometryConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsY input component\r\n     */\r\n    public get subdivisionsY(): NodeGeometryConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the subdivisionsZ input component\r\n     */\r\n    public get subdivisionsZ(): NodeGeometryConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public autoConfigure() {\r\n        if (this.size.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected && !this.height.isConnected && !this.depth.isConnected) {\r\n            const sizeInput = new GeometryInputBlock(\"Size\");\r\n            sizeInput.value = 1;\r\n            sizeInput.output.connectTo(this.size);\r\n            return;\r\n        }\r\n\r\n        if (!this.width.isConnected) {\r\n            const widthInput = new GeometryInputBlock(\"Width\");\r\n            widthInput.value = 1;\r\n            widthInput.output.connectTo(this.width);\r\n        }\r\n\r\n        if (!this.height.isConnected) {\r\n            const heightInput = new GeometryInputBlock(\"Height\");\r\n            heightInput.value = 1;\r\n            heightInput.output.connectTo(this.height);\r\n        }\r\n\r\n        if (!this.depth.isConnected) {\r\n            const depthInput = new GeometryInputBlock(\"Depth\");\r\n            depthInput.value = 1;\r\n            depthInput.output.connectTo(this.depth);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        const options: {\r\n            size?: number;\r\n            width?: number;\r\n            height?: number;\r\n            depth?: number;\r\n            segments?: number;\r\n            widthSegments?: number;\r\n            heightSegments?: number;\r\n            depthSegments?: number;\r\n        } = {};\r\n        const func = (state: NodeGeometryBuildState) => {\r\n            options.size = this.size.getConnectedValue(state);\r\n            options.width = this.width.getConnectedValue(state);\r\n            options.height = this.height.getConnectedValue(state);\r\n            options.depth = this.depth.getConnectedValue(state);\r\n\r\n            const subdivisions = this.subdivisions.getConnectedValue(state);\r\n            const subdivisionsX = this.subdivisionsX.getConnectedValue(state);\r\n            const subdivisionsY = this.subdivisionsY.getConnectedValue(state);\r\n            const subdivisionsZ = this.subdivisionsZ.getConnectedValue(state);\r\n\r\n            if (subdivisions) {\r\n                options.segments = subdivisions;\r\n            }\r\n\r\n            if (subdivisionsX) {\r\n                options.widthSegments = subdivisionsX;\r\n            }\r\n\r\n            if (subdivisionsY) {\r\n                options.heightSegments = subdivisionsY;\r\n            }\r\n\r\n            if (subdivisionsZ) {\r\n                options.depthSegments = subdivisionsZ;\r\n            }\r\n\r\n            // Append vertex data from the plane builder\r\n            return CreateSegmentedBoxVertexData(options);\r\n        };\r\n\r\n        if (this.evaluateContext) {\r\n            this.geometry._storedFunction = func;\r\n        } else {\r\n            this.geometry._storedValue = func(state);\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.evaluateContext = this.evaluateContext;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this.evaluateContext = serializationObject.evaluateContext;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BoxBlock\", BoxBlock);\r\n","import { Observable } from \"../../../Misc/observable\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { GetClass, RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources\";\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class GeometryInputBlock extends NodeGeometryBlock {\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeGeometryBlockConnectionPointTypes = NodeGeometryBlockConnectionPointTypes.Undefined;\r\n    private _contextualSource = NodeGeometryContextualSources.None;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<GeometryInputBlock>();\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeGeometryBlockConnectionPointTypes {\r\n        if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeGeometryBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeGeometryBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a contextual value\r\n     */\r\n    public get isContextual(): boolean {\r\n        return this._contextualSource !== NodeGeometryContextualSources.None;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current contextual value\r\n     */\r\n    public get contextualValue(): NodeGeometryContextualSources {\r\n        return this._contextualSource;\r\n    }\r\n\r\n    public set contextualValue(value: NodeGeometryContextualSources) {\r\n        this._contextualSource = value;\r\n\r\n        switch (value) {\r\n            case NodeGeometryContextualSources.Positions:\r\n            case NodeGeometryContextualSources.Normals:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\r\n                break;\r\n            case NodeGeometryContextualSources.Colors:\r\n            case NodeGeometryContextualSources.Tangents:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\r\n                break;\r\n            case NodeGeometryContextualSources.UV:\r\n            case NodeGeometryContextualSources.UV2:\r\n            case NodeGeometryContextualSources.UV3:\r\n            case NodeGeometryContextualSources.UV4:\r\n            case NodeGeometryContextualSources.UV5:\r\n            case NodeGeometryContextualSources.UV6:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\r\n                break;\r\n            case NodeGeometryContextualSources.VertexID:\r\n            case NodeGeometryContextualSources.GeometryID:\r\n            case NodeGeometryContextualSources.CollectionID:\r\n            case NodeGeometryContextualSources.FaceID:\r\n            case NodeGeometryContextualSources.LoopID:\r\n                this._type = NodeGeometryBlockConnectionPointTypes.Int;\r\n                break;\r\n        }\r\n\r\n        if (this.output) {\r\n            this.output.type = this._type;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param type defines the type of the input (can be set to NodeGeometryBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, type: NodeGeometryBlockConnectionPointTypes = NodeGeometryBlockConnectionPointTypes.AutoDetect) {\r\n        super(name);\r\n\r\n        this._type = type;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeGeometryBlockConnectionPointTypes.Float) {\r\n            if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryInputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry output component\r\n     */\r\n    public get output(): NodeGeometryConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        this.contextualValue = NodeGeometryContextualSources.None;\r\n        switch (this.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n            case NodeGeometryBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isContextual) {\r\n            this.output._storedValue = null;\r\n            this.output._storedFunction = (state) => {\r\n                return state.getContextualValue(this._contextualSource);\r\n            };\r\n        } else {\r\n            this.output._storedFunction = null;\r\n            this.output._storedValue = this.value;\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isContextual) {\r\n            return (\r\n                super._dumpPropertiesCode() + `${variableName}.contextualValue = BABYLON.NodeGeometryContextualSources.${NodeGeometryContextualSources[this._contextualSource]};\\n`\r\n            );\r\n        }\r\n        const codes: string[] = [];\r\n\r\n        let valueString = \"\";\r\n\r\n        switch (this.type) {\r\n            case NodeGeometryBlockConnectionPointTypes.Float:\r\n            case NodeGeometryBlockConnectionPointTypes.Int:\r\n                valueString = `${this.value}`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                break;\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                break;\r\n        }\r\n\r\n        // Common Property \"Value\"\r\n        codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n        // Float-Value-Specific Properties\r\n        if (this.type === NodeGeometryBlockConnectionPointTypes.Float || this.type === NodeGeometryBlockConnectionPointTypes.Int) {\r\n            codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`);\r\n        }\r\n\r\n        codes.push(\"\");\r\n\r\n        return super._dumpPropertiesCode() + codes.join(\";\\n\");\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.contextualValue = this.contextualValue;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n\r\n        if (this._storedValue !== null && !this.isContextual) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any) {\r\n        super._deserialize(serializationObject);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this.contextualValue = serializationObject.contextualValue;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryInputBlock\", GeometryInputBlock);\r\n","import { NodeGeometryBlock } from \"../nodeGeometryBlock\";\r\nimport type { NodeGeometryConnectionPoint } from \"../nodeGeometryBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes\";\r\nimport type { NodeGeometryBuildState } from \"../nodeGeometryBuildState\";\r\nimport type { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../types\";\r\n\r\n/**\r\n * Block used to generate the final geometry\r\n */\r\nexport class GeometryOutputBlock extends NodeGeometryBlock {\r\n    private _vertexData: Nullable<VertexData> = null;\r\n\r\n    /**\r\n     * Gets the current vertex data if the graph was successfully built\r\n     */\r\n    public get currentVertexData() {\r\n        return this._vertexData;\r\n    }\r\n\r\n    /**\r\n     * Create a new GeometryOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"GeometryOutputBlock\";\r\n    }\r\n    /**\r\n     * Gets the geometry input component\r\n     */\r\n    public get geometry(): NodeGeometryConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        state.vertexData = this.geometry.getConnectedValue(state);\r\n        this._vertexData = state.vertexData;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GeometryOutputBlock\", GeometryOutputBlock);\r\n","/**\r\n * Defines the kind of connection point for node geometry\r\n */\r\nexport enum NodeGeometryBlockConnectionPointTypes {\r\n    /** Int */\r\n    Int = 0x0001,\r\n    /** Float */\r\n    Float = 0x0002,\r\n    /** Vector2 */\r\n    Vector2 = 0x0004,\r\n    /** Vector3 */\r\n    Vector3 = 0x0008,\r\n    /** Vector4 */\r\n    Vector4 = 0x0010,\r\n    /** Matrix */\r\n    Matrix = 0x0020,\r\n    /** Geometry */\r\n    Geometry = 0x0040,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x0400,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x0800,\r\n    /** Undefined */\r\n    Undefined = 0x1000,\r\n    /** Bitmask of all types */\r\n    All = 0x0fff,\r\n}\r\n","/**\r\n * Defines the kind of contextual sources for node geometry\r\n */\r\nexport enum NodeGeometryContextualSources {\r\n    /** None */\r\n    None = 0x0000,\r\n    /** Positions */\r\n    Positions = 0x0001,\r\n    /** Normals */\r\n    Normals = 0x0002,\r\n    /** Tangents */\r\n    Tangents = 0x0003,\r\n    /** UV */\r\n    UV = 0x0004,\r\n    /** UV2 */\r\n    UV2 = 0x0005,\r\n    /** UV3 */\r\n    UV3 = 0x0006,\r\n    /** UV4 */\r\n    UV4 = 0x0007,\r\n    /** UV5 */\r\n    UV5 = 0x0008,\r\n    /** UV6 */\r\n    UV6 = 0x0009,\r\n    /** Colors */\r\n    Colors = 0x000a,\r\n    /** VertexID */\r\n    VertexID = 0x000b,\r\n    /** FaceID */\r\n    FaceID = 0x000c,\r\n    /** GeometryID */\r\n    GeometryID = 0x000d,\r\n    /** CollectionID */\r\n    CollectionID = 0x000e,\r\n    /** LoopID */\r\n    LoopID = 0x000f,\r\n}\r\n","import { GetClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\nimport { NodeGeometryConnectionPoint, NodeGeometryConnectionPointDirection } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport type { NodeGeometryBuildState } from \"./nodeGeometryBuildState\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based geometry\r\n */\r\nexport class NodeGeometryBlock {\r\n    private _name = \"\";\r\n    private _buildId: number;\r\n    private _isInput = false;\r\n    private _isTeleportOut = false;\r\n    private _isTeleportIn = false;\r\n    protected _isUnique = false;\r\n    private _buildExecutionTime: number = 0;\r\n\r\n    /**\r\n     * Gets an observable raised when the block is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeGeometryBlock>();\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeGeometryConnectionPoint>();\r\n    /** @internal */\r\n    public _preparationId: number;\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /**\r\n     * Gets the time spent to build this block (in ms)\r\n     */\r\n    public get buildExecutionTime() {\r\n        return this._buildExecutionTime;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeGeometryConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeGeometryConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or set the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is an input\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeGeometry\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the block\r\n     */\r\n    @serialize(\"comment\")\r\n    public comments: string;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeGeometryBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeGeometryBlock\";\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeGeometryBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeGeometryBlock) => boolean): Nullable<NodeGeometryBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\r\n\r\n                if (descendant) {\r\n                    return descendant;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeGeometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n        this._isInput = this.getClassName() === \"GeometryInputBlock\";\r\n        this._isTeleportOut = this.getClassName() === \"TeleportOutBlock\";\r\n        this._isTeleportIn = this.getClassName() === \"TeleportInBlock\";\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param value value to return if there is no connection\r\n     * @param valueMin min value accepted for value\r\n     * @param valueMax max value accepted for value\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeGeometryBlockConnectionPointTypes, isOptional: boolean = false, value?: any, valueMin?: any, valueMax?: any) {\r\n        const point = new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        point.defaultValue = value;\r\n        point.value = value;\r\n        point.valueMin = valueMin;\r\n        point.valueMax = valueMax;\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeGeometryBlockConnectionPointTypes, point?: NodeGeometryConnectionPoint) {\r\n        point = point ?? new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Output);\r\n        point.type = type;\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeGeometryBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeGeometryBuildState): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Build the current node and generate the vertex data\r\n     * @param state defines the current generation state\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeGeometryBuildState): boolean {\r\n        if (this._buildId === state.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (this._outputs.length > 0) {\r\n            if (!this._outputs.some((o) => o.hasEndpoints)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._buildId = state.buildId;\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                block.build(state);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state);\r\n\r\n        // Logs\r\n        if (state.verbose) {\r\n            console.log(`Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        const now = PrecisionDate.Now;\r\n        this._buildBlock(state);\r\n        this._buildExecutionTime = PrecisionDate.Now - now;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block) {\r\n                    block.build(state);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     */\r\n    public initialize() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     */\r\n    public autoConfigure() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @param _saveMeshData defines a boolean indicating that mesh data must be saved as well\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(_saveMeshData?: boolean): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _deserialize(serializationObject: any) {\r\n        this._name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n                if (port.value !== undefined && port.value !== null) {\r\n                    if (port.valueType === \"number\") {\r\n                        this.inputs[i].value = port.value;\r\n                    } else {\r\n                        const valueType = GetClass(port.valueType);\r\n\r\n                        if (valueType) {\r\n                            this.inputs[i].value = valueType.FromArray(port.value);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeGeometryBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeGeometryBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeGeometryBlock = new blockType();\r\n            block._deserialize(serializationObject);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n\r\n        this.onBuildObservable.clear();\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { VertexData } from \"../mesh.vertexData\";\r\nimport type { NodeGeometryConnectionPoint } from \"./nodeGeometryBlockConnectionPoint\";\r\nimport { NodeGeometryContextualSources } from \"./Enums/nodeGeometryContextualSources\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport type { INodeGeometryExecutionContext } from \"./Interfaces/nodeGeometryExecutionContext\";\r\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes\";\r\n\r\n/**\r\n * Class used to store node based geometry build state\r\n */\r\nexport class NodeGeometryBuildState {\r\n    private _rotationMatrix = new Matrix();\r\n    private _scalingMatrix = new Matrix();\r\n    private _positionMatrix = new Matrix();\r\n    private _scalingRotationMatrix = new Matrix();\r\n    private _transformMatrix = new Matrix();\r\n    private _tempVector3 = new Vector3();\r\n\r\n    /** Gets or sets the list of non connected mandatory inputs */\r\n    public notConnectedNonOptionalInputs: NodeGeometryConnectionPoint[] = [];\r\n    /** Gets or sets the list of non contextual inputs having no contextudal data */\r\n    public noContextualData: NodeGeometryContextualSources[] = [];\r\n    /** Gets or sets the build identifier */\r\n    public buildId: number;\r\n    /** Gets or sets a boolean indicating that verbose mode is on */\r\n    public verbose: boolean;\r\n    /** Gets or sets the vertex data */\r\n    public vertexData: Nullable<VertexData> = null;\r\n    /** Gets or sets the geometry context */\r\n    public geometryContext: Nullable<VertexData> = null;\r\n    /** Gets or sets the execution context */\r\n    public executionContext: Nullable<INodeGeometryExecutionContext> = null;\r\n\r\n    /**\r\n     * Gets the value associated with a contextual source\r\n     * @param source Source of the contextual value\r\n     * @returns the value associated with the source\r\n     */\r\n    public getContextualValue(source: NodeGeometryContextualSources) {\r\n        if (!this.executionContext) {\r\n            this.noContextualData.push(source);\r\n            return null;\r\n        }\r\n\r\n        const index = this.executionContext.getExecutionIndex();\r\n\r\n        switch (source) {\r\n            case NodeGeometryContextualSources.Positions:\r\n                if (this.executionContext.getOverridePositionsContextualValue) {\r\n                    return this.executionContext.getOverridePositionsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.positions) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.positions as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Normals:\r\n                if (this.executionContext.getOverrideNormalsContextualValue) {\r\n                    return this.executionContext.getOverrideNormalsContextualValue();\r\n                }\r\n                if (!this.geometryContext || !this.geometryContext.normals) {\r\n                    return Vector3.Zero();\r\n                }\r\n                return Vector3.FromArray(this.geometryContext.normals as ArrayLike<number>, index * 3);\r\n            case NodeGeometryContextualSources.Colors:\r\n                if (!this.geometryContext || !this.geometryContext.colors) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.colors as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.Tangents:\r\n                if (!this.geometryContext || !this.geometryContext.tangents) {\r\n                    return Vector4.Zero();\r\n                }\r\n                return Vector4.FromArray(this.geometryContext.tangents as ArrayLike<number>, index * 4);\r\n            case NodeGeometryContextualSources.UV:\r\n                if (!this.geometryContext || !this.geometryContext.uvs) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV2:\r\n                if (!this.geometryContext || !this.geometryContext.uvs2) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs2 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV3:\r\n                if (!this.geometryContext || !this.geometryContext.uvs3) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs3 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV4:\r\n                if (!this.geometryContext || !this.geometryContext.uvs4) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs4 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV5:\r\n                if (!this.geometryContext || !this.geometryContext.uvs5) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs5 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.UV6:\r\n                if (!this.geometryContext || !this.geometryContext.uvs6) {\r\n                    return Vector2.Zero();\r\n                }\r\n                return Vector2.FromArray(this.geometryContext.uvs6 as ArrayLike<number>, index * 2);\r\n            case NodeGeometryContextualSources.VertexID:\r\n                return index;\r\n            case NodeGeometryContextualSources.FaceID:\r\n                return this.executionContext.getExecutionFaceIndex();\r\n            case NodeGeometryContextualSources.LoopID:\r\n                return this.executionContext.getExecutionLoopIndex();\r\n            case NodeGeometryContextualSources.GeometryID:\r\n                return !this.geometryContext ? 0 : this.geometryContext.uniqueId;\r\n            case NodeGeometryContextualSources.CollectionID: {\r\n                if (!this.geometryContext || !this.geometryContext.metadata) {\r\n                    return 0;\r\n                }\r\n                return this.geometryContext.metadata.collectionId || 0;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt a value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @returns the adapted value\r\n     */\r\n    adapt(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes) {\r\n        const value = source.getConnectedValue(this);\r\n\r\n        if (source.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adapt an input value to a target type\r\n     * @param source defines the value to adapt\r\n     * @param targetType defines the target type\r\n     * @param defaultValue defines the default value to use if not connected\r\n     * @returns the adapted value\r\n     */\r\n    adaptInput(source: NodeGeometryConnectionPoint, targetType: NodeGeometryBlockConnectionPointTypes, defaultValue: any) {\r\n        if (!source.isConnected) {\r\n            return source.value || defaultValue;\r\n        }\r\n\r\n        const value = source.getConnectedValue(this);\r\n\r\n        if (source._connectedPoint?.type === targetType) {\r\n            return value;\r\n        }\r\n\r\n        switch (targetType) {\r\n            case NodeGeometryBlockConnectionPointTypes.Vector2:\r\n                return new Vector2(value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector3:\r\n                return new Vector3(value, value, value);\r\n            case NodeGeometryBlockConnectionPointTypes.Vector4:\r\n                return new Vector4(value, value, value, value);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        for (const notConnectedInput of this.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n\r\n        for (const source of this.noContextualData) {\r\n            errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeGeometry failed:\\n\" + errorMessage;\r\n        }\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiate(clone: VertexData, currentPosition: Vector3, rotation: Vector3, scaling: Vector3, additionalVertexData: VertexData[]) {\r\n        // Transform\r\n        Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\r\n        Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\r\n        Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\r\n\r\n        this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\r\n        this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n\r\n    /** @internal  */\r\n    public _instantiateWithMatrix(clone: VertexData, transform: Matrix, additionalVertexData: VertexData[]) {\r\n        for (let clonePositionIndex = 0; clonePositionIndex < clone.positions!.length; clonePositionIndex += 3) {\r\n            this._tempVector3.fromArray(clone.positions!, clonePositionIndex);\r\n            Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);\r\n            this._tempVector3.toArray(clone.positions!, clonePositionIndex);\r\n\r\n            if (clone.normals) {\r\n                this._tempVector3.fromArray(clone.normals, clonePositionIndex);\r\n                Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);\r\n                this._tempVector3.toArray(clone.normals, clonePositionIndex);\r\n            }\r\n        }\r\n\r\n        additionalVertexData.push(clone);\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { MeshUVSpaceRenderer } from \"./meshUVSpaceRenderer\";\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _decalMap: Nullable<MeshUVSpaceRenderer>;\r\n\r\n        /**\r\n         * Gets or sets the decal map for this mesh\r\n         */\r\n        decalMap: Nullable<MeshUVSpaceRenderer>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"decalMap\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._decalMap;\r\n    },\r\n    set: function (this: AbstractMesh, decalMap: Nullable<MeshUVSpaceRenderer>) {\r\n        this._decalMap = decalMap;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n","import { Constants } from \"../Engines/constants\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IndicesArray } from \"../types\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\ndeclare module \"./subMesh\" {\r\n    export interface SubMesh {\r\n        /** @internal */\r\n        _projectOnTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number;\r\n        /** @internal */\r\n        _projectOnUnIndexedTrianglesToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n        /**\r\n         * Projects a point on this submesh and stores the result in \"ref\"\r\n         *\r\n         * @param vector point to project\r\n         * @param positions defines mesh's positions array\r\n         * @param indices defines mesh's indices array\r\n         * @param ref vector that will store the result\r\n         * @returns distance from the point and the submesh, or -1 if the mesh rendering mode doesn't support projections\r\n         */\r\n        projectToRef(vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, step: number, checkStopper: boolean, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n        const indexA = indices[index];\r\n        const indexB = indices[index + 1];\r\n        const indexC = indices[index + 2];\r\n\r\n        if (checkStopper && indexC === 0xffffffff) {\r\n            index += 2;\r\n            continue;\r\n        }\r\n\r\n        const p0 = positions[indexA];\r\n        const p1 = positions[indexB];\r\n        const p2 = positions[indexC];\r\n\r\n        // stay defensive and don't check against undefined positions.\r\n        if (!p0 || !p1 || !p2) {\r\n            continue;\r\n        }\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    // Triangles test\r\n    const proj = TmpVectors.Vector3[0];\r\n    const tmp = TmpVectors.Vector3[1];\r\n    let distance = +Infinity;\r\n\r\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n        const p0 = positions[index];\r\n        const p1 = positions[index + 1];\r\n        const p2 = positions[index + 2];\r\n\r\n        const tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\r\n        if (tmpDist < distance) {\r\n            proj.copyFrom(tmp);\r\n            distance = tmpDist;\r\n        }\r\n    }\r\n\r\n    ref.copyFrom(proj);\r\n\r\n    return distance;\r\n};\r\n\r\nSubMesh.prototype.projectToRef = function (vector: Vector3, positions: Vector3[], indices: IndicesArray, ref: Vector3): number {\r\n    const material = this.getMaterial();\r\n    if (!material) {\r\n        return -1;\r\n    }\r\n    let step = 3;\r\n    let checkStopper = false;\r\n\r\n    switch (material.fillMode) {\r\n        case Constants.MATERIAL_PointListDrawMode:\r\n        case Constants.MATERIAL_LineLoopDrawMode:\r\n        case Constants.MATERIAL_LineStripDrawMode:\r\n        case Constants.MATERIAL_TriangleFanDrawMode:\r\n            return -1;\r\n        case Constants.MATERIAL_TriangleStripDrawMode:\r\n            step = 1;\r\n            checkStopper = true;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // LineMesh first as it's also a Mesh...\r\n    if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n        return -1;\r\n    } else {\r\n        // Check if mesh is unindexed\r\n        if (!indices.length && (this as any)._mesh._unIndexed) {\r\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\r\n        }\r\n\r\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\r\n    }\r\n};\r\n","import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n    private static _Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static _Rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n        if (exponent > 0) {\r\n            /*nonzero pixel*/\r\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        } else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static _ReadStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        let line = \"\";\r\n        let character = \"\";\r\n\r\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @returns The header information.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        let height: number = 0;\r\n        let width: number = 0;\r\n\r\n        let line = this._ReadStringLine(uint8array, 0);\r\n        if (line[0] != \"#\" || line[1] != \"?\") {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        let endOfHeader = false;\r\n        let findFormat = false;\r\n        let lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += line.length + 1;\r\n            line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            } else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n        line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n        const match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @returns The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number, supersample = false): CubeMapInfo {\r\n        const uint8array = new Uint8Array(buffer);\r\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @returns The pixels data in RGB right to left up to down order.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static _RGBEReadPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, count: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n        let index = 0,\r\n            endIndex = 0,\r\n            i = 0;\r\n\r\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    } else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (let j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static _RGBEReadPixelsNOTRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, i: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @returns The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number, supersample = false): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number, supersample = false) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\r\n        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\r\n        const sampleFactor = 1 / samples;\r\n        const sampleFactorSqr = sampleFactor * sampleFactor;\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            for (let sy = 0; sy < samples; sy++) {\r\n                let xv1 = faceData[0];\r\n                let xv2 = faceData[2];\r\n\r\n                for (let x = 0; x < texSize; x++) {\r\n                    for (let sx = 0; sx < samples; sx++) {\r\n                        const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                        v.normalize();\r\n\r\n                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                        // 3 channels per pixels\r\n                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\r\n\r\n                        xv1 = xv1.add(rotDX1);\r\n                        xv2 = xv2.add(rotDX2);\r\n                    }\r\n                }\r\n\r\n                fy += dy * sampleFactor;\r\n            }\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n","const growthFactor = 1.5;\r\n\r\n/**\r\n * A class acting as a dynamic float32array used in the performance viewer\r\n */\r\nexport class DynamicFloat32Array {\r\n    private _view: Float32Array;\r\n    private _itemLength: number;\r\n\r\n    /**\r\n     * Creates a new DynamicFloat32Array with the desired item capacity.\r\n     * @param itemCapacity The initial item capacity you would like to set for the array.\r\n     */\r\n    constructor(itemCapacity: number) {\r\n        this._view = new Float32Array(itemCapacity);\r\n        this._itemLength = 0;\r\n    }\r\n\r\n    /**\r\n     * The number of items currently in the array.\r\n     */\r\n    public get itemLength(): number {\r\n        return this._itemLength;\r\n    }\r\n\r\n    /**\r\n     * Gets value at index, NaN if no such index exists.\r\n     * @param index the index to get the value at.\r\n     * @returns the value at the index provided.\r\n     */\r\n    public at(index: number): number {\r\n        if (index < 0 || index >= this._itemLength) {\r\n            return NaN;\r\n        }\r\n\r\n        return this._view[index];\r\n    }\r\n\r\n    /**\r\n     * Gets a view of the original array from start to end (exclusive of end).\r\n     * @param start starting index.\r\n     * @param end ending index.\r\n     * @returns a subarray of the original array.\r\n     */\r\n    public subarray(start: number, end: number): Float32Array {\r\n        if (start >= end || start < 0) {\r\n            return new Float32Array(0);\r\n        }\r\n\r\n        if (end > this._itemLength) {\r\n            end = this._itemLength;\r\n        }\r\n\r\n        return this._view.subarray(start, end);\r\n    }\r\n\r\n    /**\r\n     * Pushes items to the end of the array.\r\n     * @param item The item to push into the array.\r\n     */\r\n    public push(item: number) {\r\n        this._view[this._itemLength] = item;\r\n        this._itemLength++;\r\n        if (this._itemLength >= this._view.length) {\r\n            this._growArray();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Grows the array by the growth factor when necessary.\r\n     */\r\n    private _growArray() {\r\n        const newCapacity = Math.floor(this._view.length * growthFactor);\r\n        const view = new Float32Array(newCapacity);\r\n        view.set(this._view);\r\n        this._view = view;\r\n    }\r\n}\r\n","import type { Scene } from \"../../scene\";\r\nimport type { IPerfCustomEvent, IPerfDatasets, IPerfMetadata } from \"../interfaces/iPerfViewer\";\r\nimport { EventState, Observable } from \"../observable\";\r\nimport { PrecisionDate } from \"../precisionDate\";\r\nimport { Tools } from \"../tools\";\r\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array\";\r\nimport type { IPerfViewerCollectionStrategy, PerfStrategyInitialization } from \"./performanceViewerCollectionStrategies\";\r\n\r\n// the initial size of our array, should be a multiple of two!\r\nconst InitialArraySize = 1800;\r\n\r\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\r\nconst NumberOfBitsInHexcode = 24;\r\n\r\n// Allows single numeral hex numbers to be appended by a 0.\r\nconst HexPadding = \"0\";\r\n\r\n// header for the timestamp column\r\nconst TimestampColHeader = \"timestamp\";\r\n\r\n// header for the numPoints column\r\nconst NumPointsColHeader = \"numPoints\";\r\n\r\n// regex to capture all carriage returns in the string.\r\nconst CarriageReturnRegex = /\\r/g;\r\n\r\n// string to use as separator when exporting extra information along with the dataset id\r\nconst ExportedDataSeparator = \"@\";\r\n\r\n/**\r\n * Callback strategy and optional category for data collection\r\n */\r\ninterface IPerformanceViewerStrategyParameter {\r\n    /**\r\n     * The strategy for collecting data. Available strategies are located on the PerfCollectionStrategy class\r\n     */\r\n    strategyCallback: PerfStrategyInitialization;\r\n    /**\r\n     * Category for displaying this strategy on the viewer. Can be undefined or an empty string, in which case the strategy will be displayed on top\r\n     */\r\n    category?: string;\r\n    /**\r\n     * Starts hidden\r\n     */\r\n    hidden?: boolean;\r\n}\r\n\r\n/**\r\n * The collector class handles the collection and storage of data into the appropriate array.\r\n * The collector also handles notifying any observers of any updates.\r\n */\r\nexport class PerformanceViewerCollector {\r\n    private _datasetMeta: Map<string, IPerfMetadata>;\r\n    private _strategies: Map<string, IPerfViewerCollectionStrategy>;\r\n    private _startingTimestamp: number;\r\n    private _hasLoadedData: boolean;\r\n    private _isStarted: boolean;\r\n    private readonly _customEventObservable: Observable<IPerfCustomEvent>;\r\n    private readonly _eventRestoreSet: Set<string>;\r\n\r\n    /**\r\n     * Datastructure containing the collected datasets. Warning: you should not modify the values in here, data will be of the form [timestamp, numberOfPoints, value1, value2..., timestamp, etc...]\r\n     */\r\n    public readonly datasets: IPerfDatasets;\r\n    /**\r\n     * An observable you can attach to get deltas in the dataset. Subscribing to this will increase memory consumption slightly, and may hurt performance due to increased garbage collection needed.\r\n     * Updates of slices will be of the form [timestamp, numberOfPoints, value1, value2...].\r\n     */\r\n    public readonly datasetObservable: Observable<number[]>;\r\n    /**\r\n     * An observable you can attach to get the most updated map of metadatas.\r\n     */\r\n    public readonly metadataObservable: Observable<Map<string, IPerfMetadata>>;\r\n\r\n    /**\r\n     * The offset for when actual data values start appearing inside a slice.\r\n     */\r\n    public static get SliceDataOffset() {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * The offset for the value of the number of points inside a slice.\r\n     */\r\n    public static get NumberOfPointsOffset() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Handles the creation of a performance viewer collector.\r\n     * @param _scene the scene to collect on.\r\n     * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\r\n     */\r\n    constructor(private _scene: Scene, _enabledStrategyCallbacks?: IPerformanceViewerStrategyParameter[]) {\r\n        this.datasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n        this._strategies = new Map<string, IPerfViewerCollectionStrategy>();\r\n        this._datasetMeta = new Map<string, IPerfMetadata>();\r\n        this._eventRestoreSet = new Set();\r\n        this._customEventObservable = new Observable();\r\n        this.datasetObservable = new Observable();\r\n        this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));\r\n        if (_enabledStrategyCallbacks) {\r\n            this.addCollectionStrategies(..._enabledStrategyCallbacks);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\r\n     * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\r\n     * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\r\n     * @param name The name of the event to register\r\n     * @param forceUpdate if the code should force add an event, and replace the last one.\r\n     * @param category the category for that event\r\n     * @returns The event registered, used in sendEvent\r\n     */\r\n    public registerEvent(name: string, forceUpdate?: boolean, category?: string): IPerfCustomEvent | undefined {\r\n        if (this._strategies.has(name) && !forceUpdate) {\r\n            return;\r\n        }\r\n\r\n        if (this._strategies.has(name) && forceUpdate) {\r\n            this._strategies.get(name)?.dispose();\r\n            this._strategies.delete(name);\r\n        }\r\n\r\n        const strategy: PerfStrategyInitialization = (scene) => {\r\n            let counter: number = 0;\r\n            let value: number = 0;\r\n\r\n            const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                value = counter;\r\n                counter = 0;\r\n            });\r\n\r\n            const stringObserver = this._customEventObservable.add((eventVal) => {\r\n                if (name !== eventVal.name) {\r\n                    return;\r\n                }\r\n\r\n                if (eventVal.value !== undefined) {\r\n                    counter = eventVal.value;\r\n                } else {\r\n                    counter++;\r\n                }\r\n            });\r\n\r\n            return {\r\n                id: name,\r\n                getData: () => value,\r\n                dispose: () => {\r\n                    scene.onAfterRenderObservable.remove(afterRenderObserver);\r\n                    this._customEventObservable.remove(stringObserver);\r\n                },\r\n            };\r\n        };\r\n        const event: IPerfCustomEvent = {\r\n            name,\r\n        };\r\n\r\n        this._eventRestoreSet.add(name);\r\n        this.addCollectionStrategies({ strategyCallback: strategy, category });\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\r\n     * @param event the event to handle an occurence for\r\n     */\r\n    public sendEvent(event: IPerfCustomEvent) {\r\n        this._customEventObservable.notifyObservers(event);\r\n    }\r\n\r\n    /**\r\n     * This event restores all custom string events if necessary.\r\n     */\r\n    private _restoreStringEvents() {\r\n        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\r\n            this._eventRestoreSet.forEach((event) => {\r\n                this.registerEvent(event, true);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method adds additional collection strategies for data collection purposes.\r\n     * @param strategyCallbacks the list of data to collect with callbacks.\r\n     */\r\n    public addCollectionStrategies(...strategyCallbacks: IPerformanceViewerStrategyParameter[]) {\r\n        // eslint-disable-next-line prefer-const\r\n        for (let { strategyCallback, category, hidden } of strategyCallbacks) {\r\n            const strategy = strategyCallback(this._scene);\r\n            if (this._strategies.has(strategy.id)) {\r\n                strategy.dispose();\r\n                continue;\r\n            }\r\n\r\n            this.datasets.ids.push(strategy.id);\r\n\r\n            if (category) {\r\n                category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\r\n            }\r\n\r\n            this._datasetMeta.set(strategy.id, {\r\n                color: this._getHexColorFromId(strategy.id),\r\n                category,\r\n                hidden,\r\n            });\r\n\r\n            this._strategies.set(strategy.id, strategy);\r\n        }\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Gets a 6 character hexcode representing the colour from a passed in string.\r\n     * @param id the string to get a hex code for.\r\n     * @returns a hexcode hashed from the id.\r\n     */\r\n    private _getHexColorFromId(id: string) {\r\n        // this first bit is just a known way of hashing a string.\r\n        let hash = 0;\r\n        for (let i = 0; i < id.length; i++) {\r\n            // (hash << 5) - hash is the same as hash * 31\r\n            hash = id.charCodeAt(i) + ((hash << 5) - hash);\r\n        }\r\n\r\n        // then we build the string octet by octet.\r\n        let hex = \"#\";\r\n        for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\r\n            const octet = (hash >> i) & 0xff;\r\n            hex += (HexPadding + octet.toString(16)).substr(-2);\r\n        }\r\n\r\n        return hex;\r\n    }\r\n\r\n    /**\r\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\r\n     * This method will then notify all observers with the latest slice.\r\n     */\r\n    private _collectDataAtFrame = () => {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n\r\n        // add the starting index for the slice\r\n        const numberOfIndices = this.datasets.startingIndices.itemLength;\r\n        let startingIndex = 0;\r\n\r\n        if (numberOfIndices > 0) {\r\n            const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\r\n            startingIndex =\r\n                previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\r\n        }\r\n\r\n        this.datasets.startingIndices.push(startingIndex);\r\n\r\n        // add the first 2 items in our slice.\r\n        this.datasets.data.push(timestamp);\r\n        this.datasets.data.push(numPoints);\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            this.datasets.data.push(strategy.getData());\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            const slice: number[] = [timestamp, numPoints];\r\n\r\n            for (let i = 0; i < numPoints; i++) {\r\n                slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\r\n            }\r\n\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\r\n     * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\r\n     * This method does not add onto the collected data accessible via the datasets variable.\r\n     */\r\n    public getCurrentSlice() {\r\n        const timestamp = PrecisionDate.Now - this._startingTimestamp;\r\n        const numPoints = this.datasets.ids.length;\r\n        const slice: number[] = [timestamp, numPoints];\r\n\r\n        // add the values inside the slice.\r\n        this.datasets.ids.forEach((id: string) => {\r\n            const strategy = this._strategies.get(id);\r\n\r\n            if (!strategy) {\r\n                return;\r\n            }\r\n\r\n            if (this.datasetObservable.hasObservers()) {\r\n                slice.push(strategy.getData());\r\n            }\r\n        });\r\n\r\n        if (this.datasetObservable.hasObservers()) {\r\n            this.datasetObservable.notifyObservers(slice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates a property for a dataset's metadata with the value provided.\r\n     * @param id the id of the dataset which needs its metadata updated.\r\n     * @param prop the property to update.\r\n     * @param value the value to update the property with.\r\n     */\r\n    public updateMetadata<T extends keyof IPerfMetadata>(id: string, prop: T, value: IPerfMetadata[T]) {\r\n        const meta = this._datasetMeta.get(id);\r\n\r\n        if (!meta) {\r\n            return;\r\n        }\r\n\r\n        meta[prop] = value;\r\n\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n    }\r\n\r\n    /**\r\n     * Completely clear, data, ids, and strategies saved to this performance collector.\r\n     * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\r\n     */\r\n    public clear(preserveStringEventsRestore?: boolean) {\r\n        this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n        this.datasets.ids.length = 0;\r\n        this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        if (!preserveStringEventsRestore) {\r\n            this._eventRestoreSet.clear();\r\n        }\r\n        this._hasLoadedData = false;\r\n    }\r\n\r\n    /**\r\n     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\r\n     * Call clear() to reset this value.\r\n     * @returns true if the data is loaded from a file, false otherwise.\r\n     */\r\n    public get hasLoadedData(): boolean {\r\n        return this._hasLoadedData;\r\n    }\r\n\r\n    /**\r\n     * Given a string containing file data, this function parses the file data into the datasets object.\r\n     * It returns a boolean to indicate if this object was successfully loaded with the data.\r\n     * @param data string content representing the file data.\r\n     * @param keepDatasetMeta if it should use reuse the existing dataset metadata\r\n     * @returns true if the data was successfully loaded, false otherwise.\r\n     */\r\n    public loadFromFileData(data: string, keepDatasetMeta?: boolean): boolean {\r\n        const lines = data\r\n            .replace(CarriageReturnRegex, \"\")\r\n            .split(\"\\n\")\r\n            .map((line) => line.split(\",\").filter((s) => s.length > 0))\r\n            .filter((line) => line.length > 0);\r\n        const timestampIndex = 0;\r\n        const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\r\n        if (lines.length < 2) {\r\n            return false;\r\n        }\r\n\r\n        const parsedDatasets: IPerfDatasets = {\r\n            ids: [],\r\n            data: new DynamicFloat32Array(InitialArraySize),\r\n            startingIndices: new DynamicFloat32Array(InitialArraySize),\r\n        };\r\n\r\n        // parse first line separately to populate ids!\r\n        const [firstLine, ...dataLines] = lines;\r\n        // make sure we have the correct beginning headers\r\n        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\r\n            return false;\r\n        }\r\n\r\n        const idCategoryMap: Map<string, string> = new Map<string, string>();\r\n\r\n        // populate the ids.\r\n        for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\r\n            const [id, category] = firstLine[i].split(ExportedDataSeparator);\r\n            parsedDatasets.ids.push(id);\r\n            idCategoryMap.set(id, category);\r\n        }\r\n\r\n        let startingIndex = 0;\r\n        for (const line of dataLines) {\r\n            if (line.length < 2) {\r\n                return false;\r\n            }\r\n\r\n            const timestamp = parseFloat(line[timestampIndex]);\r\n            const numPoints = parseInt(line[numPointsIndex]);\r\n\r\n            if (isNaN(numPoints) || isNaN(timestamp)) {\r\n                return false;\r\n            }\r\n\r\n            parsedDatasets.data.push(timestamp);\r\n            parsedDatasets.data.push(numPoints);\r\n\r\n            if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\r\n                return false;\r\n            }\r\n\r\n            for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\r\n                const val = parseFloat(line[i]);\r\n                if (isNaN(val)) {\r\n                    return false;\r\n                }\r\n                parsedDatasets.data.push(val);\r\n            }\r\n\r\n            parsedDatasets.startingIndices.push(startingIndex);\r\n            startingIndex += line.length;\r\n        }\r\n\r\n        this.datasets.ids = parsedDatasets.ids;\r\n        this.datasets.data = parsedDatasets.data;\r\n        this.datasets.startingIndices = parsedDatasets.startingIndices;\r\n        if (!keepDatasetMeta) {\r\n            this._datasetMeta.clear();\r\n        }\r\n        this._strategies.forEach((strategy) => strategy.dispose());\r\n        this._strategies.clear();\r\n\r\n        // populate metadata.\r\n        if (!keepDatasetMeta) {\r\n            for (const id of this.datasets.ids) {\r\n                const category = idCategoryMap.get(id);\r\n\r\n                this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });\r\n            }\r\n        }\r\n        this.metadataObservable.notifyObservers(this._datasetMeta);\r\n        this._hasLoadedData = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Exports the datasets inside of the collector to a csv.\r\n     */\r\n    public exportDataToCsv() {\r\n        let csvContent = \"\";\r\n        // create the header line.\r\n        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\r\n        for (let i = 0; i < this.datasets.ids.length; i++) {\r\n            csvContent += `,${this.datasets.ids[i]}`;\r\n            if (this._datasetMeta) {\r\n                const meta = this._datasetMeta.get(this.datasets.ids[i]);\r\n                if (meta?.category) {\r\n                    csvContent += `${ExportedDataSeparator}${meta.category}`;\r\n                }\r\n            }\r\n        }\r\n        csvContent += \"\\n\";\r\n        // create the data lines\r\n        for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\r\n            const startingIndex = this.datasets.startingIndices.at(i);\r\n            const timestamp = this.datasets.data.at(startingIndex);\r\n            const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\r\n\r\n            csvContent += `${timestamp},${numPoints}`;\r\n\r\n            for (let offset = 0; offset < numPoints; offset++) {\r\n                csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\r\n            }\r\n\r\n            // add extra commas.\r\n            for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\r\n                csvContent += \",\";\r\n            }\r\n\r\n            csvContent += \"\\n\";\r\n        }\r\n\r\n        const fileName = `${new Date().toISOString()}-perfdata.csv`;\r\n        Tools.Download(new Blob([csvContent], { type: \"text/csv\" }), fileName);\r\n    }\r\n    /**\r\n     * Starts the realtime collection of data.\r\n     * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\r\n     */\r\n    public start(shouldPreserve?: boolean) {\r\n        if (!shouldPreserve) {\r\n            this.datasets.data = new DynamicFloat32Array(InitialArraySize);\r\n            this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        } else if (this._startingTimestamp === undefined) {\r\n            this._startingTimestamp = PrecisionDate.Now;\r\n        }\r\n        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\r\n        this._restoreStringEvents();\r\n        this._isStarted = true;\r\n    }\r\n\r\n    /**\r\n     * Stops the collection of data.\r\n     */\r\n    public stop() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._isStarted = false;\r\n    }\r\n\r\n    /**\r\n     * Returns if the perf collector has been started or not.\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\r\n        this._datasetMeta.clear();\r\n        this._strategies.forEach((strategy) => {\r\n            strategy.dispose();\r\n        });\r\n        this.datasetObservable.clear();\r\n        this.metadataObservable.clear();\r\n        this._isStarted = false;\r\n        (<any>this.datasets) = null;\r\n    }\r\n}\r\n","import { Scene } from \"../../scene\";\r\nimport { PerformanceViewerCollector } from \"./performanceViewerCollector\";\r\n\r\nScene.prototype.getPerfCollector = function (this: Scene): PerformanceViewerCollector {\r\n    if (!this._perfCollector) {\r\n        this._perfCollector = new PerformanceViewerCollector(this);\r\n    }\r\n\r\n    return this._perfCollector;\r\n};\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { Scene } from \"../scene\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\r\n\r\nimport \"../Engines/Extensions/engine.cubeTexture\";\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nconst DDS_MAGIC = 0x20534444;\r\n\r\nconst //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nconst DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nconst //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\r\n}\r\n\r\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nconst headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nconst off_magic = 0;\r\n\r\nconst off_size = 1;\r\nconst off_flags = 2;\r\nconst off_height = 3;\r\nconst off_width = 4;\r\n\r\nconst off_mipmapCount = 7;\r\n\r\nconst off_pfFlags = 20;\r\nconst off_pfFourCC = 21;\r\nconst off_RGBbpp = 22;\r\nconst off_RMask = 23;\r\nconst off_GMask = 24;\r\nconst off_BMask = 25;\r\nconst off_AMask = 26;\r\n// var off_caps1 = 27;\r\nconst off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nconst off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        let mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const fourCC = header[off_pfFourCC];\r\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = Constants.TEXTURETYPE_FLOAT;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType,\r\n        };\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        const destArray = new Float32Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Uint16Array(dataLength);\r\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            const destArray = new Float32Array(dataLength);\r\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            let index = 0;\r\n            for (let y = 0; y < height; y++) {\r\n                for (let x = 0; x < width; x++) {\r\n                    const srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        const destArray = new Uint16Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                destArray[index] = ToHalfFloat(srcData[index]);\r\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\r\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = ToHalfFloat(lod);\r\n                } else {\r\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint8Array {\r\n        const destArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number,\r\n        aOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(\r\n        width: number,\r\n        height: number,\r\n        dataOffset: number,\r\n        dataLength: number,\r\n        arrayBuffer: ArrayBuffer,\r\n        rOffset: number,\r\n        gOffset: number,\r\n        bOffset: number\r\n    ): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        const byteArray = new Uint8Array(dataLength);\r\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        let index = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcPos = x + y * width;\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @internal\r\n     */\r\n    public static UploadDDSLevels(\r\n        engine: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView,\r\n        info: DDSInfo,\r\n        loadMipmaps: boolean,\r\n        faces: number,\r\n        lodIndex = -1,\r\n        currentFace?: number,\r\n        destTypeMustBeFilterable = true\r\n    ) {\r\n        let sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = new Array<ArrayBufferView>();\r\n        }\r\n        const ext = !!engine.getCaps().s3tc;\r\n\r\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\r\n        texture.generateMipMaps = loadMipmaps;\r\n\r\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        let fourCC: number,\r\n            width: number,\r\n            height: number,\r\n            dataLength: number = 0,\r\n            dataOffset: number;\r\n        let byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        let bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    bpp = 64;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    bpp = 128;\r\n                    break;\r\n                case FOURCC_DX10: {\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 64;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            bpp = 128;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-fallthrough\r\n                default:\r\n                    console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        const caps = engine.getCaps();\r\n        for (let face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = lodIndex === -1 ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                        dataLength = width * height * 4;\r\n                        let floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\r\n                            // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            } else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(\r\n                                        DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i)\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        } else {\r\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\r\n\r\n                            const destType =\r\n                                (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\r\n                                    ? Constants.TEXTURETYPE_FLOAT\r\n                                    : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\r\n                                    ? Constants.TEXTURETYPE_HALF_FLOAT\r\n                                    : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n                            let dataGetter: (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView;\r\n                            let dataGetterPolynomial: Nullable<\r\n                                (width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number) => ArrayBufferView\r\n                            > = null;\r\n\r\n                            switch (bpp) {\r\n                                case 128: {\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    // 64 bpp\r\n                                    switch (destType) {\r\n                                        case Constants.TEXTURETYPE_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = null;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\r\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\r\n                                            break;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            texture.type = destType;\r\n\r\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n\r\n                            if (sphericalPolynomialFaces && i == 0) {\r\n                                sphericalPolynomialFaces.push(\r\n                                    dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        if (bpp === 24) {\r\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else {\r\n                            // 32\r\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        const unpackAlignment = engine._getUnpackAlignement();\r\n                        const unpaddedRowSize = width;\r\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                type: Constants.TEXTURETYPE_FLOAT,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n\r\ndeclare module \"../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number,\r\n            forcedExtension?: any,\r\n            createPolynomials?: boolean\r\n        ): InternalTexture;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\r\nThinEngine.prototype.createPrefilteredCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    lodScale: number,\r\n    lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = true\r\n): InternalTexture {\r\n    const callback = (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        } else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        const gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            const smoothness = i / (mipSlices - 1);\r\n            const roughness = 1 - smoothness;\r\n\r\n            const minLODIndex = lodOffset; // roughness = 0\r\n            const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            glTextureFromLod._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            glTextureFromLod._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                const info: DDSInfo = loadData.info;\r\n                const data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            } else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture._isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n","import type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\n\r\n/** Interface used by value gradients (color, factor, ...) */\r\nexport interface IValueGradient {\r\n    /**\r\n     * Gets or sets the gradient value (between 0 and 1)\r\n     */\r\n    gradient: number;\r\n}\r\n\r\n/** Class used to store color4 gradient */\r\nexport class ColorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color4 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color1 gets or sets first associated color\r\n     * @param color2 gets or sets first second color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated color\r\n         */\r\n        public color1: Color4,\r\n        /**\r\n         * Gets or sets second associated color\r\n         */\r\n        public color2?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a color picked randomly between color1 and color2.\r\n     * If color2 is undefined then color1 will be used\r\n     * @param result defines the target Color4 to store the result in\r\n     */\r\n    public getColorToRef(result: Color4) {\r\n        if (!this.color2) {\r\n            result.copyFrom(this.color1);\r\n            return;\r\n        }\r\n\r\n        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\r\n    }\r\n}\r\n\r\n/** Class used to store color 3 gradient */\r\nexport class Color3Gradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color3 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color gets or sets associated color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets the associated color\r\n         */\r\n        public color: Color3\r\n    ) {}\r\n}\r\n\r\n/** Class used to store factor gradient */\r\nexport class FactorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new factor gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param factor1 gets or sets first associated factor\r\n     * @param factor2 gets or sets second associated factor\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated factor\r\n         */\r\n        public factor1: number,\r\n        /**\r\n         * Gets or sets second associated factor\r\n         */\r\n        public factor2?: number\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a number picked randomly between factor1 and factor2.\r\n     * If factor2 is undefined then factor1 will be used\r\n     * @returns the picked number\r\n     */\r\n    public getFactor(): number {\r\n        if (this.factor2 === undefined || this.factor2 === this.factor1) {\r\n            return this.factor1;\r\n        }\r\n\r\n        return this.factor1 + (this.factor2 - this.factor1) * Math.random();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\r\nexport class GradientHelper {\r\n    /**\r\n     * Gets the current gradient from an array of IValueGradient\r\n     * @param ratio defines the current ratio to get\r\n     * @param gradients defines the array of IValueGradient\r\n     * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n     */\r\n    public static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void) {\r\n        // Use last index if over\r\n        if (gradients[0].gradient > ratio) {\r\n            updateFunc(gradients[0], gradients[0], 1.0);\r\n            return;\r\n        }\r\n\r\n        for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\r\n            const currentGradient = gradients[gradientIndex];\r\n            const nextGradient = gradients[gradientIndex + 1];\r\n\r\n            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\r\n                const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\r\n                updateFunc(currentGradient, nextGradient, scale);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Use last index if over\r\n        const lastIndex = gradients.length - 1;\r\n        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\r\n    }\r\n}\r\n","import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        return p1.lengthSquared() === 0 && p2.lengthSquared() === 0 && p3.lengthSquared() === 0;\r\n    }\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        meshes.forEach((m, meshIndex) => {\r\n            const vertices = m.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = m.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, i, vi1, m, meshIndex, vertices, indices);\r\n                        pointsFromPredicate && points.push(pointsFromPredicate);\r\n                    } else {\r\n                        points.push([p1, p2, p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[]) {\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < points.length; i += 3) {\r\n            array.push(new Vector3(points[i], points[i + 1], points[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data);\r\n        } else {\r\n            points = <Vector3[]>data;\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines = what[0] instanceof Vector3 ? GreasedLineTools.GetLineSegments(what as Vector3[]) : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        subLines.forEach((s) => {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                segments.forEach((seg) => {\r\n                    points.push(seg);\r\n                });\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        });\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[], segmentCount: number): Vector3[] {\r\n        const segmentLength = GreasedLineTools.GetLineLength(what) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(what, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\n\r\n/**\r\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n */\r\nexport class KhronosTextureContainer {\r\n    private static HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\r\n\r\n    // load types\r\n    private static COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n    private static COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n    private static TEX_2D = 2; // uses a gl.texImage2D()\r\n    private static TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\n    // elements of the header\r\n    /**\r\n     * Gets the openGL type\r\n     */\r\n    public glType: number;\r\n    /**\r\n     * Gets the openGL type size\r\n     */\r\n    public glTypeSize: number;\r\n    /**\r\n     * Gets the openGL format\r\n     */\r\n    public glFormat: number;\r\n    /**\r\n     * Gets the openGL internal format\r\n     */\r\n    public glInternalFormat: number;\r\n    /**\r\n     * Gets the base internal format\r\n     */\r\n    public glBaseInternalFormat: number;\r\n    /**\r\n     * Gets image width in pixel\r\n     */\r\n    public pixelWidth: number;\r\n    /**\r\n     * Gets image height in pixel\r\n     */\r\n    public pixelHeight: number;\r\n    /**\r\n     * Gets image depth in pixels\r\n     */\r\n    public pixelDepth: number;\r\n    /**\r\n     * Gets the number of array elements\r\n     */\r\n    public numberOfArrayElements: number;\r\n    /**\r\n     * Gets the number of faces\r\n     */\r\n    public numberOfFaces: number;\r\n    /**\r\n     * Gets the number of mipmap levels\r\n     */\r\n    public numberOfMipmapLevels: number;\r\n    /**\r\n     * Gets the bytes of key value data\r\n     */\r\n    public bytesOfKeyValueData: number;\r\n    /**\r\n     * Gets the load type\r\n     */\r\n    public loadType: number;\r\n    /**\r\n     * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\r\n     */\r\n    public isInvalid = false;\r\n\r\n    /**\r\n     * Creates a new KhronosTextureContainer\r\n     * @param data contents of the KTX container file\r\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\r\n     */\r\n    public constructor(\r\n        /** contents of the KTX container file */\r\n        public data: ArrayBufferView,\r\n        facesExpected: number\r\n    ) {\r\n        if (!KhronosTextureContainer.IsValid(data)) {\r\n            this.isInvalid = true;\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            return;\r\n        }\r\n\r\n        // load the reset of the header in native 32 bit uint\r\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\r\n        const endianness = headerDataView.getUint32(0, true);\r\n        const littleEndian = endianness === 0x04030201;\r\n\r\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\r\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\r\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\r\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\r\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\r\n\r\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n        if (this.glType !== 0) {\r\n            Logger.Error(\"only compressed formats currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        } else {\r\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\r\n        }\r\n\r\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\r\n            Logger.Error(\"only 2D textures currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfArrayElements !== 0) {\r\n            Logger.Error(\"texture arrays not currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfFaces !== facesExpected) {\r\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        // we now have a completely validated file, so could use existence of loadType as success\r\n        // would need to make this more elaborate & adjust checks above to support more than one load type\r\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\r\n    }\r\n\r\n    /**\r\n     * Uploads KTX content to a Babylon Texture.\r\n     * It is assumed that the texture has already been created & is currently bound\r\n     * @internal\r\n     */\r\n    public uploadLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        switch (this.loadType) {\r\n            case KhronosTextureContainer.COMPRESSED_2D:\r\n                this._upload2DCompressedLevels(texture, loadMipmaps);\r\n                break;\r\n\r\n            case KhronosTextureContainer.TEX_2D:\r\n            case KhronosTextureContainer.COMPRESSED_3D:\r\n            case KhronosTextureContainer.TEX_3D:\r\n        }\r\n    }\r\n\r\n    private _upload2DCompressedLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        // initialize width & height for level 1\r\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\r\n        let width = this.pixelWidth;\r\n        let height = this.pixelHeight;\r\n\r\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n        for (let level = 0; level < mipmapCount; level++) {\r\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\r\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\r\n            for (let face = 0; face < this.numberOfFaces; face++) {\r\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\r\n\r\n                const engine = texture.getEngine();\r\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\r\n\r\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\r\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\r\n            }\r\n            width = Math.max(1.0, width * 0.5);\r\n            height = Math.max(1.0, height * 0.5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x31 &&\r\n                identifier[6] === 0x31 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import { Observable } from \"./observable\";\r\nimport type { AsyncCoroutine, CoroutineStep, CoroutineScheduler } from \"./coroutine\";\r\nimport { runCoroutineAsync, inlineScheduler } from \"./coroutine\";\r\n\r\nfunction CreateObservableScheduler<T>(observable: Observable<any>): { scheduler: CoroutineScheduler<T>; dispose: () => void } {\r\n    const coroutines = new Array<AsyncCoroutine<T>>();\r\n    const onSteps = new Array<(stepResult: CoroutineStep<T>) => void>();\r\n    const onErrors = new Array<(stepError: any) => void>();\r\n\r\n    const observer = observable.add(() => {\r\n        const count = coroutines.length;\r\n        for (let i = 0; i < count; i++) {\r\n            inlineScheduler(coroutines.shift()!, onSteps.shift()!, onErrors.shift()!);\r\n        }\r\n    });\r\n\r\n    const scheduler = (coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => {\r\n        coroutines.push(coroutine);\r\n        onSteps.push(onStep);\r\n        onErrors.push(onError);\r\n    };\r\n\r\n    return {\r\n        scheduler: scheduler,\r\n        dispose: () => {\r\n            observable.remove(observer);\r\n        },\r\n    };\r\n}\r\n\r\ndeclare module \"./observable\" {\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    export interface Observable<T> {\r\n        /**\r\n         * Internal observable-based coroutine scheduler instance.\r\n         */\r\n        _coroutineScheduler?: CoroutineScheduler<void>;\r\n\r\n        /**\r\n         * Internal disposal method for observable-based coroutine scheduler instance.\r\n         */\r\n        _coroutineSchedulerDispose?: () => void;\r\n\r\n        /**\r\n         * Runs a coroutine asynchronously on this observable\r\n         * @param coroutine the iterator resulting from having started the coroutine\r\n         * @returns a promise which will be resolved when the coroutine finishes or rejected if the coroutine is cancelled\r\n         */\r\n        runCoroutineAsync(coroutine: AsyncCoroutine<void>): Promise<void>;\r\n\r\n        /**\r\n         * Cancels all coroutines currently running on this observable\r\n         */\r\n        cancelAllCoroutines(): void;\r\n    }\r\n}\r\n\r\nObservable.prototype.runCoroutineAsync = function (coroutine: AsyncCoroutine<void>) {\r\n    if (!this._coroutineScheduler) {\r\n        const schedulerAndDispose = CreateObservableScheduler<void>(this);\r\n        this._coroutineScheduler = schedulerAndDispose.scheduler;\r\n        this._coroutineSchedulerDispose = schedulerAndDispose.dispose;\r\n    }\r\n\r\n    return runCoroutineAsync(coroutine, this._coroutineScheduler);\r\n};\r\n\r\nObservable.prototype.cancelAllCoroutines = function () {\r\n    if (this._coroutineSchedulerDispose) {\r\n        this._coroutineSchedulerDispose();\r\n    }\r\n    this._coroutineScheduler = undefined;\r\n    this._coroutineSchedulerDispose = undefined;\r\n};\r\n","import { Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\n\r\n/**\r\n * Class containing a set of static utilities functions for managing Pivots\r\n * @internal\r\n */\r\nexport class PivotTools {\r\n    // Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)\r\n    // store/remove pivot point should only be applied during their outermost calls\r\n    private static _PivotCached = 0;\r\n    private static _OldPivotPoint = new Vector3();\r\n    private static _PivotTranslation = new Vector3();\r\n    private static _PivotTmpVector = new Vector3();\r\n    private static _PivotPostMultiplyPivotMatrix = false;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveAndStorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && PivotTools._PivotCached === 0) {\r\n            // Save old pivot and set pivot to 0,0,0\r\n            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);\r\n            PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;\r\n            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {\r\n                mesh.setPivotMatrix(Matrix.IdentityReadOnly);\r\n                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);\r\n                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n                mesh.position.addInPlace(PivotTools._PivotTmpVector);\r\n            }\r\n        }\r\n        PivotTools._PivotCached++;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RestorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {\r\n            mesh.setPivotPoint(PivotTools._OldPivotPoint);\r\n            mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;\r\n            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);\r\n        }\r\n        this._PivotCached--;\r\n    }\r\n}\r\n","import type { Geometry } from \"../Meshes/geometry\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { SerializationHelper } from \"./decorators\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport type { Node } from \"../node\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\nlet serializedGeometries: Geometry[] = [];\r\nconst SerializeGeometry = (geometry: Geometry, serializationGeometries: any): any => {\r\n    if (geometry.doNotSerialize) {\r\n        return;\r\n    }\r\n\r\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\r\n\r\n    (<any>serializedGeometries)[geometry.id] = true;\r\n};\r\n\r\nconst SerializeMesh = (mesh: Mesh, serializationScene: any): any => {\r\n    const serializationObject: any = {};\r\n\r\n    // Geometry\r\n    const geometry = mesh._geometry;\r\n    if (geometry) {\r\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\r\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\r\n            SerializeGeometry(geometry, serializationScene.geometries);\r\n        }\r\n    }\r\n\r\n    // Custom\r\n    if (mesh.serialize) {\r\n        mesh.serialize(serializationObject);\r\n    }\r\n\r\n    return serializationObject;\r\n};\r\n\r\nconst FinalizeSingleNode = (node: Node, serializationObject: any) => {\r\n    if ((node as Mesh)._isMesh) {\r\n        const mesh = node as Mesh;\r\n        //only works if the mesh is already loaded\r\n        if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n            const serializeMaterial = (material: Material) => {\r\n                serializationObject.materials = serializationObject.materials || [];\r\n                if (mesh.material && !serializationObject.materials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                    serializationObject.materials.push(material.serialize());\r\n                }\r\n            };\r\n\r\n            //serialize material\r\n            if (mesh.material && !mesh.material.doNotSerialize) {\r\n                if (mesh.material instanceof MultiMaterial) {\r\n                    serializationObject.multiMaterials = serializationObject.multiMaterials || [];\r\n                    if (!serializationObject.multiMaterials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                        serializationObject.multiMaterials.push(mesh.material.serialize());\r\n                        for (const submaterial of mesh.material.subMaterials) {\r\n                            if (submaterial) {\r\n                                serializeMaterial(submaterial);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    serializeMaterial(mesh.material);\r\n                }\r\n            } else if (!mesh.material) {\r\n                serializeMaterial(mesh.getScene().defaultMaterial);\r\n            }\r\n\r\n            //serialize geometry\r\n            const geometry = mesh._geometry;\r\n            if (geometry) {\r\n                if (!serializationObject.geometries) {\r\n                    serializationObject.geometries = {};\r\n\r\n                    serializationObject.geometries.boxes = [];\r\n                    serializationObject.geometries.spheres = [];\r\n                    serializationObject.geometries.cylinders = [];\r\n                    serializationObject.geometries.toruses = [];\r\n                    serializationObject.geometries.grounds = [];\r\n                    serializationObject.geometries.planes = [];\r\n                    serializationObject.geometries.torusKnots = [];\r\n                    serializationObject.geometries.vertexData = [];\r\n                }\r\n\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n            // Skeletons\r\n            if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\r\n                serializationObject.skeletons = serializationObject.skeletons || [];\r\n                serializationObject.skeletons.push(mesh.skeleton.serialize());\r\n            }\r\n\r\n            //serialize the actual mesh\r\n            serializationObject.meshes = serializationObject.meshes || [];\r\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n        }\r\n    } else if (node.getClassName() === \"TransformNode\") {\r\n        const transformNode = node as TransformNode;\r\n        serializationObject.transformNodes.push(transformNode.serialize());\r\n    } else if (node.getClassName().indexOf(\"Camera\") !== -1) {\r\n        const camera = node as Camera;\r\n        serializationObject.cameras.push(camera.serialize());\r\n    } else if (node.getClassName().indexOf(\"Light\") !== -1) {\r\n        const light = node as Light;\r\n        serializationObject.lights.push(light.serialize());\r\n    }\r\n};\r\n\r\n/**\r\n * Class used to serialize a scene into a string\r\n */\r\nexport class SceneSerializer {\r\n    /**\r\n     * Clear cache used by a previous serialization\r\n     */\r\n    public static ClearCache(): void {\r\n        serializedGeometries = [];\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\r\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static Serialize(scene: Scene): any {\r\n        return SceneSerializer._Serialize(scene);\r\n    }\r\n\r\n    private static _Serialize(scene: Scene, checkSyncReadSupported = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\r\n            console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\r\n        }\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        // Scene\r\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        serializationObject.autoClear = scene.autoClear;\r\n        serializationObject.clearColor = scene.clearColor.asArray();\r\n        serializationObject.ambientColor = scene.ambientColor.asArray();\r\n        serializationObject.gravity = scene.gravity.asArray();\r\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\r\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Fog\r\n        if (scene.fogMode && scene.fogMode !== 0) {\r\n            serializationObject.fogMode = scene.fogMode;\r\n            serializationObject.fogColor = scene.fogColor.asArray();\r\n            serializationObject.fogStart = scene.fogStart;\r\n            serializationObject.fogEnd = scene.fogEnd;\r\n            serializationObject.fogDensity = scene.fogDensity;\r\n        }\r\n\r\n        //Physics\r\n        if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {\r\n            const physicEngine = scene.getPhysicsEngine();\r\n\r\n            if (physicEngine) {\r\n                serializationObject.physicsEnabled = true;\r\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\r\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (scene.metadata) {\r\n            serializationObject.metadata = scene.metadata;\r\n        }\r\n\r\n        // Morph targets\r\n        serializationObject.morphTargetManagers = [];\r\n        for (const abstractMesh of scene.meshes) {\r\n            const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n\r\n            if (manager) {\r\n                serializationObject.morphTargetManagers.push(manager.serialize());\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        serializationObject.lights = [];\r\n        let index: number;\r\n        let light: Light;\r\n        for (index = 0; index < scene.lights.length; index++) {\r\n            light = scene.lights[index];\r\n\r\n            if (!light.doNotSerialize) {\r\n                serializationObject.lights.push(light.serialize());\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        serializationObject.cameras = [];\r\n        for (index = 0; index < scene.cameras.length; index++) {\r\n            const camera = scene.cameras[index];\r\n\r\n            if (!camera.doNotSerialize) {\r\n                serializationObject.cameras.push(camera.serialize());\r\n            }\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            serializationObject.activeCameraID = scene.activeCamera.id;\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\r\n\r\n        // Animation Groups\r\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\r\n            serializationObject.animationGroups = [];\r\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\r\n                const animationGroup = scene.animationGroups[animationGroupIndex];\r\n\r\n                serializationObject.animationGroups.push(animationGroup.serialize());\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\r\n            serializationObject.reflectionProbes = [];\r\n\r\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const reflectionProbe = scene.reflectionProbes[index];\r\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        serializationObject.materials = [];\r\n        serializationObject.multiMaterials = [];\r\n        let material: Material;\r\n        for (index = 0; index < scene.materials.length; index++) {\r\n            material = scene.materials[index];\r\n            if (!material.doNotSerialize) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        }\r\n\r\n        // MultiMaterials\r\n        serializationObject.multiMaterials = [];\r\n        for (index = 0; index < scene.multiMaterials.length; index++) {\r\n            const multiMaterial = scene.multiMaterials[index];\r\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\r\n        }\r\n\r\n        // Environment texture\r\n        if (scene.environmentTexture) {\r\n            if ((scene.environmentTexture as CubeTexture)._files) {\r\n                serializationObject.environmentTexture = scene.environmentTexture.serialize();\r\n            } else {\r\n                serializationObject.environmentTexture = scene.environmentTexture.name;\r\n                serializationObject.environmentTextureRotationY = (scene.environmentTexture as CubeTexture).rotationY;\r\n            }\r\n        }\r\n\r\n        // Environment Intensity\r\n        serializationObject.environmentIntensity = scene.environmentIntensity;\r\n\r\n        // Skeletons\r\n        serializationObject.skeletons = [];\r\n        for (index = 0; index < scene.skeletons.length; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (!skeleton.doNotSerialize) {\r\n                serializationObject.skeletons.push(skeleton.serialize());\r\n            }\r\n        }\r\n\r\n        // Transform nodes\r\n        serializationObject.transformNodes = [];\r\n        for (index = 0; index < scene.transformNodes.length; index++) {\r\n            if (!scene.transformNodes[index].doNotSerialize) {\r\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        serializationObject.geometries = {};\r\n\r\n        serializationObject.geometries.boxes = [];\r\n        serializationObject.geometries.spheres = [];\r\n        serializationObject.geometries.cylinders = [];\r\n        serializationObject.geometries.toruses = [];\r\n        serializationObject.geometries.grounds = [];\r\n        serializationObject.geometries.planes = [];\r\n        serializationObject.geometries.torusKnots = [];\r\n        serializationObject.geometries.vertexData = [];\r\n\r\n        serializedGeometries = [];\r\n        const geometries = scene.getGeometries();\r\n        for (index = 0; index < geometries.length; index++) {\r\n            const geometry = geometries[index];\r\n\r\n            if (geometry.isReady()) {\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        serializationObject.meshes = [];\r\n        for (index = 0; index < scene.meshes.length; index++) {\r\n            const abstractMesh = scene.meshes[index];\r\n\r\n            if (abstractMesh instanceof Mesh) {\r\n                const mesh = abstractMesh;\r\n                if (!mesh.doNotSerialize) {\r\n                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Particles Systems\r\n        serializationObject.particleSystems = [];\r\n        for (index = 0; index < scene.particleSystems.length; index++) {\r\n            serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\r\n        }\r\n\r\n        // Post processes\r\n        serializationObject.postProcesses = [];\r\n        for (index = 0; index < scene.postProcesses.length; index++) {\r\n            serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\r\n        }\r\n\r\n        // Action Manager\r\n        if (scene.actionManager) {\r\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\r\n        }\r\n\r\n        // Components\r\n        for (const component of scene._serializableComponents) {\r\n            component.serialize(serializationObject);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON promise compatible object\r\n     */\r\n    public static SerializeAsync(scene: Scene): Promise<any> {\r\n        const serializationObject = SceneSerializer._Serialize(scene, false);\r\n\r\n        const promises: Array<Promise<any>> = [];\r\n\r\n        this._CollectPromises(serializationObject, promises);\r\n\r\n        return Promise.all(promises).then(() => serializationObject);\r\n    }\r\n\r\n    private static _CollectPromises(obj: any, promises: Array<Promise<any>>): void {\r\n        if (Array.isArray(obj)) {\r\n            for (let i = 0; i < obj.length; ++i) {\r\n                const o = obj[i];\r\n                if (o instanceof Promise) {\r\n                    promises.push(o.then((res: any) => (obj[i] = res)));\r\n                } else if (o instanceof Object || Array.isArray(o)) {\r\n                    this._CollectPromises(o, promises);\r\n                }\r\n            }\r\n        } else if (obj instanceof Object) {\r\n            for (const name in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\r\n                    const o = obj[name];\r\n                    if (o instanceof Promise) {\r\n                        promises.push(o.then((res: any) => (obj[name] = res)));\r\n                    } else if (o instanceof Object || Array.isArray(o)) {\r\n                        this._CollectPromises(o, promises);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize a mesh into a JSON compatible object\r\n     * @param toSerialize defines the mesh to serialize\r\n     * @param withParents defines if parents must be serialized as well\r\n     * @param withChildren defines if children must be serialized as well\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static SerializeMesh(toSerialize: any /* Mesh || Mesh[] */, withParents: boolean = false, withChildren: boolean = false): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.meshes = [];\r\n        serializationObject.transformNodes = [];\r\n        serializationObject.cameras = [];\r\n        serializationObject.lights = [];\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\r\n\r\n        if (withParents || withChildren) {\r\n            //deliberate for loop! not for each, appended should be processed as well.\r\n            for (let i = 0; i < toSerialize.length; ++i) {\r\n                if (withChildren) {\r\n                    toSerialize[i].getDescendants().forEach((node: Node) => {\r\n                        if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\r\n                            toSerialize.push(node);\r\n                        }\r\n                    });\r\n                }\r\n                //make sure the array doesn't contain the object already\r\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\r\n                    toSerialize.push(toSerialize[i].parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        toSerialize.forEach((mesh: Node) => {\r\n            FinalizeSingleNode(mesh, serializationObject);\r\n        });\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { StringDictionary } from \"./stringDictionary\";\r\n\r\n// Mainly based on these 2 articles :\r\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\r\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\r\n\r\n/**\r\n * Defines the potential axis of a Joystick\r\n */\r\nexport enum JoystickAxis {\r\n    /** X axis */\r\n    X,\r\n    /** Y axis */\r\n    Y,\r\n    /** Z axis */\r\n    Z,\r\n}\r\n\r\n/**\r\n * Represents the different customization options available\r\n * for VirtualJoystick\r\n */\r\ninterface VirtualJoystickCustomizations {\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    puckSize: number;\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    containerSize: number;\r\n    /**\r\n     * Color of the joystick && puck\r\n     */\r\n    color: string;\r\n    /**\r\n     * Image URL for the joystick's puck\r\n     */\r\n    puckImage?: string;\r\n    /**\r\n     * Image URL for the joystick's container\r\n     */\r\n    containerImage?: string;\r\n    /**\r\n     * Defines the unmoving position of the joystick container\r\n     */\r\n    position?: { x: number; y: number };\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    alwaysVisible: boolean;\r\n    /**\r\n     * Defines whether or not to limit the movement of the puck to the joystick's container\r\n     */\r\n    limitToContainer: boolean;\r\n}\r\n\r\n/**\r\n * Class used to define virtual joystick (used in touch mode)\r\n */\r\nexport class VirtualJoystick {\r\n    /**\r\n     * Gets or sets a boolean indicating that left and right values must be inverted\r\n     */\r\n    public reverseLeftRight: boolean;\r\n    /**\r\n     * Gets or sets a boolean indicating that up and down values must be inverted\r\n     */\r\n    public reverseUpDown: boolean;\r\n    /**\r\n     * Gets the offset value for the position (ie. the change of the position value)\r\n     */\r\n    public deltaPosition: Vector3;\r\n    /**\r\n     * Gets a boolean indicating if the virtual joystick was pressed\r\n     */\r\n    public pressed: boolean;\r\n    /**\r\n     * Canvas the virtual joystick will render onto, default z-index of this is 5\r\n     */\r\n    public static Canvas: Nullable<HTMLCanvasElement>;\r\n\r\n    /**\r\n     * boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area\r\n     */\r\n    public limitToContainer: boolean;\r\n\r\n    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\r\n    private static _GlobalJoystickIndex: number = 0;\r\n    private static _AlwaysVisibleSticks: number = 0;\r\n    private static _VJCanvasContext: CanvasRenderingContext2D;\r\n    private static _VJCanvasWidth: number;\r\n    private static _VJCanvasHeight: number;\r\n    private static _HalfWidth: number;\r\n    private static _GetDefaultOptions(): VirtualJoystickCustomizations {\r\n        return {\r\n            puckSize: 40,\r\n            containerSize: 60,\r\n            color: \"cyan\",\r\n            puckImage: undefined,\r\n            containerImage: undefined,\r\n            position: undefined,\r\n            alwaysVisible: false,\r\n            limitToContainer: false,\r\n        };\r\n    }\r\n\r\n    private _action: () => any;\r\n    private _axisTargetedByLeftAndRight: JoystickAxis;\r\n    private _axisTargetedByUpAndDown: JoystickAxis;\r\n    private _joystickSensibility: number;\r\n    private _inversedSensibility: number;\r\n    private _joystickPointerId: number;\r\n    private _joystickColor: string;\r\n    private _joystickPointerPos: Vector2;\r\n    private _joystickPreviousPointerPos: Vector2;\r\n    private _joystickPointerStartPos: Vector2;\r\n    private _deltaJoystickVector: Vector2;\r\n    private _leftJoystick: boolean;\r\n    private _touches: StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>;\r\n    private _joystickPosition: Nullable<Vector2>;\r\n    private _alwaysVisible: boolean;\r\n    private _puckImage: HTMLImageElement;\r\n    private _containerImage: HTMLImageElement;\r\n    private _released = false;\r\n\r\n    // size properties\r\n    private _joystickPuckSize: number;\r\n    private _joystickContainerSize: number;\r\n    private _clearPuckSize: number;\r\n    private _clearContainerSize: number;\r\n    private _clearPuckSizeOffset: number;\r\n    private _clearContainerSizeOffset: number;\r\n\r\n    private _onPointerDownHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerMoveHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerUpHandlerRef: (e: PointerEvent) => any;\r\n    private _onResize: (e: any) => any;\r\n\r\n    /**\r\n     * Creates a new virtual joystick\r\n     * @param leftJoystick defines that the joystick is for left hand (false by default)\r\n     * @param customizations Defines the options we want to customize the VirtualJoystick\r\n     */\r\n    constructor(leftJoystick?: boolean, customizations?: Partial<VirtualJoystickCustomizations>) {\r\n        const options = {\r\n            ...VirtualJoystick._GetDefaultOptions(),\r\n            ...customizations,\r\n        };\r\n\r\n        if (leftJoystick) {\r\n            this._leftJoystick = true;\r\n        } else {\r\n            this._leftJoystick = false;\r\n        }\r\n\r\n        VirtualJoystick._GlobalJoystickIndex++;\r\n\r\n        // By default left & right arrow keys are moving the X\r\n        // and up & down keys are moving the Y\r\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n\r\n        this.reverseLeftRight = false;\r\n        this.reverseUpDown = false;\r\n\r\n        // collections of pointers\r\n        this._touches = new StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>();\r\n        this.deltaPosition = Vector3.Zero();\r\n\r\n        this._joystickSensibility = 25;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n\r\n        this._onResize = () => {\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            if (VirtualJoystick.Canvas) {\r\n                VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\r\n                VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\r\n            }\r\n            VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\r\n        };\r\n\r\n        // injecting a canvas element on top of the canvas 3D game\r\n        if (!VirtualJoystick.Canvas) {\r\n            window.addEventListener(\"resize\", this._onResize, false);\r\n            VirtualJoystick.Canvas = document.createElement(\"canvas\");\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            VirtualJoystick.Canvas.width = window.innerWidth;\r\n            VirtualJoystick.Canvas.height = window.innerHeight;\r\n            VirtualJoystick.Canvas.style.width = \"100%\";\r\n            VirtualJoystick.Canvas.style.height = \"100%\";\r\n            VirtualJoystick.Canvas.style.position = \"absolute\";\r\n            VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\r\n            VirtualJoystick.Canvas.style.top = \"0px\";\r\n            VirtualJoystick.Canvas.style.left = \"0px\";\r\n            VirtualJoystick.Canvas.style.zIndex = \"5\";\r\n            VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\r\n            // Support for jQuery PEP polyfill\r\n            VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\r\n            const context = VirtualJoystick.Canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to create canvas for virtual joystick\");\r\n            }\r\n\r\n            VirtualJoystick._VJCanvasContext = context;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            document.body.appendChild(VirtualJoystick.Canvas);\r\n        }\r\n        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\r\n        this.pressed = false;\r\n        this.limitToContainer = options.limitToContainer;\r\n\r\n        // default joystick color\r\n        this._joystickColor = options.color;\r\n\r\n        // default joystick size\r\n        this.containerSize = options.containerSize;\r\n        this.puckSize = options.puckSize;\r\n\r\n        if (options.position) {\r\n            this.setPosition(options.position.x, options.position.y);\r\n        }\r\n        if (options.puckImage) {\r\n            this.setPuckImage(options.puckImage);\r\n        }\r\n        if (options.containerImage) {\r\n            this.setContainerImage(options.containerImage);\r\n        }\r\n        if (options.alwaysVisible) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n        }\r\n\r\n        // must come after position potentially set\r\n        this.alwaysVisible = options.alwaysVisible;\r\n\r\n        this._joystickPointerId = -1;\r\n        // current joystick position\r\n        this._joystickPointerPos = new Vector2(0, 0);\r\n        this._joystickPreviousPointerPos = new Vector2(0, 0);\r\n        // origin joystick position\r\n        this._joystickPointerStartPos = new Vector2(0, 0);\r\n        this._deltaJoystickVector = new Vector2(0, 0);\r\n\r\n        this._onPointerDownHandlerRef = (evt) => {\r\n            this._onPointerDown(evt);\r\n        };\r\n        this._onPointerMoveHandlerRef = (evt) => {\r\n            this._onPointerMove(evt);\r\n        };\r\n        this._onPointerUpHandlerRef = (evt) => {\r\n            this._onPointerUp(evt);\r\n        };\r\n\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\r\n            \"contextmenu\",\r\n            (evt) => {\r\n                evt.preventDefault(); // Disables system menu\r\n            },\r\n            false\r\n        );\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\r\n     * @param newJoystickSensibility defines the new sensibility\r\n     */\r\n    public setJoystickSensibility(newJoystickSensibility: number) {\r\n        this._joystickSensibility = newJoystickSensibility;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n    }\r\n\r\n    private _onPointerDown(e: PointerEvent) {\r\n        let positionOnScreenCondition: boolean;\r\n\r\n        e.preventDefault();\r\n\r\n        if (this._leftJoystick === true) {\r\n            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\r\n        } else {\r\n            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\r\n        }\r\n\r\n        if (positionOnScreenCondition && this._joystickPointerId < 0) {\r\n            // First contact will be dedicated to the virtual joystick\r\n            this._joystickPointerId = e.pointerId;\r\n\r\n            if (this._joystickPosition) {\r\n                this._joystickPointerStartPos = this._joystickPosition.clone();\r\n                this._joystickPointerPos = this._joystickPosition.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPosition.clone();\r\n\r\n                // in case the user only clicks down && doesn't move:\r\n                // this ensures the delta is properly set\r\n                this._onPointerMove(e);\r\n            } else {\r\n                this._joystickPointerStartPos.x = e.clientX;\r\n                this._joystickPointerStartPos.y = e.clientY;\r\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\r\n            }\r\n\r\n            this._deltaJoystickVector.x = 0;\r\n            this._deltaJoystickVector.y = 0;\r\n            this.pressed = true;\r\n            this._touches.add(e.pointerId.toString(), e);\r\n        } else {\r\n            // You can only trigger the action buttons with a joystick declared\r\n            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\r\n                this._action();\r\n                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerMove(e: PointerEvent) {\r\n        // If the current pointer is the one associated to the joystick (first touch contact)\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            // limit to container if need be\r\n            if (this.limitToContainer) {\r\n                const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\r\n                const distance = vector.length();\r\n\r\n                if (distance > this.containerSize) {\r\n                    vector.scaleInPlace(this.containerSize / distance);\r\n                }\r\n\r\n                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\r\n                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\r\n            } else {\r\n                this._joystickPointerPos.x = e.clientX;\r\n                this._joystickPointerPos.y = e.clientY;\r\n            }\r\n\r\n            // create delta vector\r\n            this._deltaJoystickVector = this._joystickPointerPos.clone();\r\n            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\r\n\r\n            // if a joystick is always visible, there will be clipping issues if\r\n            // you drag the puck from one over the container of the other\r\n            if (0 < VirtualJoystick._AlwaysVisibleSticks) {\r\n                if (this._leftJoystick) {\r\n                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                } else {\r\n                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                }\r\n            }\r\n\r\n            const directionLeftRight = this.reverseLeftRight ? -1 : 1;\r\n            const deltaJoystickX = (directionLeftRight * this._deltaJoystickVector.x) / this._inversedSensibility;\r\n            switch (this._axisTargetedByLeftAndRight) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n            }\r\n            const directionUpDown = this.reverseUpDown ? 1 : -1;\r\n            const deltaJoystickY = (directionUpDown * this._deltaJoystickVector.y) / this._inversedSensibility;\r\n            switch (this._axisTargetedByUpAndDown) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n            }\r\n        } else {\r\n            const data = this._touches.get(e.pointerId.toString());\r\n            if (data) {\r\n                (data as any).x = e.clientX;\r\n                (data as any).y = e.clientY;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerUp(e: PointerEvent) {\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            this._clearPreviousDraw();\r\n\r\n            this._joystickPointerId = -1;\r\n            this.pressed = false;\r\n        } else {\r\n            const touch = <{ x: number; y: number; prevX: number; prevY: number }>this._touches.get(e.pointerId.toString());\r\n            if (touch) {\r\n                VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\r\n            }\r\n        }\r\n        this._deltaJoystickVector.x = 0;\r\n        this._deltaJoystickVector.y = 0;\r\n\r\n        this._touches.remove(e.pointerId.toString());\r\n    }\r\n\r\n    /**\r\n     * Change the color of the virtual joystick\r\n     * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\r\n     */\r\n    public setJoystickColor(newColor: string) {\r\n        this._joystickColor = newColor;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    public set containerSize(newSize: number) {\r\n        this._joystickContainerSize = newSize;\r\n        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\r\n        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\r\n    }\r\n    public get containerSize() {\r\n        return this._joystickContainerSize;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    public set puckSize(newSize: number) {\r\n        this._joystickPuckSize = newSize;\r\n        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\r\n        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\r\n    }\r\n    public get puckSize() {\r\n        return this._joystickPuckSize;\r\n    }\r\n\r\n    /**\r\n     * Clears the set position of the joystick\r\n     */\r\n    public clearPosition() {\r\n        this.alwaysVisible = false;\r\n\r\n        this._joystickPosition = null;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    public set alwaysVisible(value: boolean) {\r\n        if (this._alwaysVisible === value) {\r\n            return;\r\n        }\r\n\r\n        if (value && this._joystickPosition) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n\r\n            this._alwaysVisible = true;\r\n        } else {\r\n            VirtualJoystick._AlwaysVisibleSticks--;\r\n\r\n            this._alwaysVisible = false;\r\n        }\r\n    }\r\n    public get alwaysVisible() {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the constant position of the Joystick container\r\n     * @param x X axis coordinate\r\n     * @param y Y axis coordinate\r\n     */\r\n    public setPosition(x: number, y: number) {\r\n        // just in case position is moved while the container is visible\r\n        if (this._joystickPointerStartPos) {\r\n            this._clearPreviousDraw();\r\n        }\r\n\r\n        this._joystickPosition = new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Defines a callback to call when the joystick is touched\r\n     * @param action defines the callback\r\n     */\r\n    public setActionOnTouch(action: () => any) {\r\n        this._action = action;\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for left & right\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForLeftRight(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByLeftAndRight = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for up & down\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForUpDown(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByUpAndDown = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the canvas from the previous puck / container draw\r\n     */\r\n    private _clearPreviousDraw() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        // clear container pixels\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            jp.x - this._clearContainerSizeOffset,\r\n            jp.y - this._clearContainerSizeOffset,\r\n            this._clearContainerSize,\r\n            this._clearContainerSize\r\n        );\r\n\r\n        // clear puck pixels + 1 pixel for the change made before it moved\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1,\r\n            this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1,\r\n            this._clearPuckSize + 2,\r\n            this._clearPuckSize + 2\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the container's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setContainerImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._containerImage = image);\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the puck's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setPuckImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._puckImage = image);\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's container\r\n     */\r\n    private _drawContainer() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        this._clearPreviousDraw();\r\n\r\n        if (this._containerImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\r\n        } else {\r\n            // outer container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n\r\n            // inner container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's puck\r\n     */\r\n    private _drawPuck() {\r\n        if (this._puckImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(\r\n                this._puckImage,\r\n                this._joystickPointerPos.x - this.puckSize,\r\n                this._joystickPointerPos.y - this.puckSize,\r\n                this.puckSize * 2,\r\n                this.puckSize * 2\r\n            );\r\n        } else {\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    private _drawVirtualJoystick() {\r\n        // canvas released? don't continue iterating\r\n        if (this._released) {\r\n            return;\r\n        }\r\n        if (this.alwaysVisible) {\r\n            this._drawContainer();\r\n        }\r\n\r\n        if (this.pressed) {\r\n            this._touches.forEach((key, touch) => {\r\n                if ((<PointerEvent>touch).pointerId === this._joystickPointerId) {\r\n                    if (!this.alwaysVisible) {\r\n                        this._drawContainer();\r\n                    }\r\n\r\n                    this._drawPuck();\r\n\r\n                    // store current pointer for next clear\r\n                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\r\n                } else {\r\n                    VirtualJoystick._VJCanvasContext.clearRect((<any>touch).prevX - 44, (<any>touch).prevY - 44, 88, 88);\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\r\n                    VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n                    VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\r\n                    VirtualJoystick._VJCanvasContext.stroke();\r\n                    VirtualJoystick._VJCanvasContext.closePath();\r\n                    (<any>touch).prevX = touch.x;\r\n                    (<any>touch).prevY = touch.y;\r\n                }\r\n            });\r\n        }\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release internal HTML canvas\r\n     */\r\n    public releaseCanvas() {\r\n        if (VirtualJoystick.Canvas) {\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\r\n            window.removeEventListener(\"resize\", this._onResize);\r\n            document.body.removeChild(VirtualJoystick.Canvas);\r\n            VirtualJoystick.Canvas = null;\r\n        }\r\n        this._released = true;\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class BoxParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     */\r\n    public minEmitBox = new Vector3(-0.5, -0.5, -0.5);\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     */\r\n    public maxEmitBox = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    /**\r\n     * Creates a new instance BoxParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.x = randX;\r\n            directionToUpdate.y = randY;\r\n            directionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);\r\n        const randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);\r\n        const randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): BoxParticleEmitter {\r\n        const newOne = new BoxParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n        uboOrEffect.setVector3(\"minEmitBox\", this.minEmitBox);\r\n        uboOrEffect.setVector3(\"maxEmitBox\", this.maxEmitBox);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n        ubo.addUniform(\"minEmitBox\", 3);\r\n        ubo.addUniform(\"maxEmitBox\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define BOXEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BoxParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.minEmitBox = this.minEmitBox.asArray();\r\n        serializationObject.maxEmitBox = this.maxEmitBox.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n        Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);\r\n        Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\r\nexport class ConeParticleEmitter implements IParticleEmitterType {\r\n    private _radius: number;\r\n    private _angle: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public radiusRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public heightRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\r\n    public emitFromSpawnPointOnly = false;\r\n\r\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    private _buildHeight() {\r\n        if (this._angle !== 0) {\r\n            this._height = this._radius / Math.tan(this._angle / 2);\r\n        } else {\r\n            this._height = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConeParticleEmitter\r\n     * @param radius the radius of the emission cone (1 by default)\r\n     * @param angle the cone base angle (PI by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        angle = Math.PI,\r\n        /** defines how much to randomize the particle direction [0-1] (default is 0) */\r\n        public directionRandomizer = 0\r\n    ) {\r\n        this.angle = angle;\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition!).normalize();\r\n        } else {\r\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\r\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\r\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\r\n        directionToUpdate.normalize();\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const s = Scalar.RandomRange(0, Math.PI * 2);\r\n        let h: number;\r\n\r\n        if (!this.emitFromSpawnPointOnly) {\r\n            h = Scalar.RandomRange(0, this.heightRange);\r\n            // Better distribution in a cone at normal angles.\r\n            h = 1 - h * h;\r\n        } else {\r\n            h = 0.0001;\r\n        }\r\n        let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\r\n        radius = radius * h;\r\n\r\n        const randX = radius * Math.sin(s);\r\n        const randZ = radius * Math.cos(s);\r\n        const randY = h * this._height;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): ConeParticleEmitter {\r\n        const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\r\n        uboOrEffect.setFloat(\"coneAngle\", this._angle);\r\n        uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 2);\r\n        ubo.addUniform(\"coneAngle\", 1);\r\n        ubo.addUniform(\"height\", 2);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        let defines = \"#define CONEEMITTER\";\r\n\r\n        if (this.emitFromSpawnPointOnly) {\r\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\r\n        }\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ConeParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ConeParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this._radius;\r\n        serializationObject.angle = this._angle;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.heightRange = this.heightRange;\r\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.angle = serializationObject.angle;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n\r\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\r\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\r\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Particle } from \"../particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\r\nexport class CustomParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Gets or sets the position generator that will create the initial position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Creates a new instance CustomParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particleDestinationGenerator) {\r\n            this.particleDestinationGenerator(-1, particle, tmpVector);\r\n\r\n            // Get direction\r\n            const diffVector = TmpVectors.Vector3[1];\r\n            tmpVector.subtractToRef(particle.position, diffVector);\r\n\r\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particlePositionGenerator) {\r\n            this.particlePositionGenerator(-1, particle, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CustomParticleEmitter {\r\n        const newOne = new CustomParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {}\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public buildUniformLayout(ubo: UniformBuffer): void {}\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CUSTOMEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CustomParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public parse(serializationObject: any): void {}\r\n}\r\n","import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\r\n */\r\nexport class CylinderParticleEmitter implements IParticleEmitterType {\r\n    private _tempVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a new instance CylinderParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission cylinder.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The height of the emission cylinder.\r\n         */\r\n        public height = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean, inverseWorldMatrix: Matrix): void {\r\n        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\r\n\r\n        this._tempVector.normalize();\r\n\r\n        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\r\n\r\n        const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\r\n\r\n        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\r\n        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\r\n\r\n        this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\r\n        this._tempVector.x = Math.sin(angle);\r\n        this._tempVector.z = Math.cos(angle);\r\n        this._tempVector.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(this._tempVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\r\n        const angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n\r\n        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\r\n        const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\r\n        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\r\n        const xPos = positionRadius * Math.cos(angle);\r\n        const zPos = positionRadius * Math.sin(angle);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(xPos, yPos, zPos);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderParticleEmitter {\r\n        const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.height = this.height;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.height = serializationObject.height;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\r\n    /**\r\n     * Creates a new instance CylinderDirectedParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius, height, radiusRange);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderDirectedParticleEmitter {\r\n        const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a hemisphere.\r\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\r\n */\r\nexport class HemisphericParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance HemisphericParticleEmitter\r\n     * @param radius the radius of the emission hemisphere (1 by default)\r\n     * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission hemisphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): HemisphericParticleEmitter {\r\n        const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define HEMISPHERICEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { IndicesArray, Nullable, FloatArray } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class MeshParticleEmitter implements IParticleEmitterType {\r\n    private _indices: Nullable<IndicesArray> = null;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _storedNormal = Vector3.Zero();\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\r\n     */\r\n    public useMeshNormalsForDirection = true;\r\n\r\n    /** Defines the mesh to use as source */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<AbstractMesh>) {\r\n        if (this._mesh === value) {\r\n            return;\r\n        }\r\n\r\n        this._mesh = value;\r\n\r\n        if (value) {\r\n            this._indices = value.getIndices();\r\n            this._positions = value.getVerticesData(VertexBuffer.PositionKind);\r\n            this._normals = value.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            this._indices = null;\r\n            this._positions = null;\r\n            this._normals = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MeshParticleEmitter\r\n     * @param mesh defines the mesh to use as source\r\n     */\r\n    constructor(mesh: Nullable<AbstractMesh> = null) {\r\n        this.mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\r\n            return;\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (!this._indices || !this._positions) {\r\n            return;\r\n        }\r\n\r\n        const randomFaceIndex = (3 * Math.random() * (this._indices.length / 3)) | 0;\r\n        const bu = Math.random();\r\n        const bv = Math.random() * (1.0 - bu);\r\n        const bw = 1.0 - bu - bv;\r\n\r\n        const faceIndexA = this._indices[randomFaceIndex];\r\n        const faceIndexB = this._indices[randomFaceIndex + 1];\r\n        const faceIndexC = this._indices[randomFaceIndex + 2];\r\n        const vertexA = TmpVectors.Vector3[0];\r\n        const vertexB = TmpVectors.Vector3[1];\r\n        const vertexC = TmpVectors.Vector3[2];\r\n        const randomVertex = TmpVectors.Vector3[3];\r\n\r\n        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\r\n\r\n        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\r\n        } else {\r\n            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\r\n        }\r\n\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\r\n\r\n            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): MeshParticleEmitter {\r\n        const newOne = new MeshParticleEmitter(this.mesh);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.meshId = this.mesh?.id;\r\n        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public parse(serializationObject: any, scene: Nullable<Scene>): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n\r\n        if (serializationObject.meshId && scene) {\r\n            this.mesh = scene.getLastMeshById(serializationObject.meshId);\r\n        }\r\n\r\n        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\r\n    }\r\n}\r\n","import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a point.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class PointParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Creates a new instance PointParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(0, 0, 0);\r\n            return;\r\n        }\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): PointParticleEmitter {\r\n        const newOne = new PointParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define POINTEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"PointParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n    }\r\n}\r\n","import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\r\nexport class SphereParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance SphereParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission sphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereParticleEmitter {\r\n        const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\r\n    /**\r\n     * Creates a new instance SphereDirectedParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereDirectedParticleEmitter {\r\n        const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n","/* eslint-disable import/no-internal-modules */\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    PointParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n    ConeParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\n\r\n/**\r\n * This represents the base class for particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class BaseParticleSystem implements IClipPlanesHolder {\r\n    /**\r\n     * Source color is added to the destination color without alpha affecting the result\r\n     */\r\n    public static BLENDMODE_ONEONE = 0;\r\n    /**\r\n     * Blend current color and particle color using particles alpha\r\n     */\r\n    public static BLENDMODE_STANDARD = 1;\r\n    /**\r\n     * Add current color and particle color multiplied by particles alpha\r\n     */\r\n    public static BLENDMODE_ADD = 2;\r\n    /**\r\n     * Multiply current color with particle color\r\n     */\r\n    public static BLENDMODE_MULTIPLY = 3;\r\n\r\n    /**\r\n     * Multiply current color with particle color then add current color and particle color multiplied by particles alpha\r\n     */\r\n    public static BLENDMODE_MULTIPLYADD = 4;\r\n\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets the unique id of the particle system\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * The friendly name of the Particle system.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Snippet ID if the particle system was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    public renderingGroupId = 0;\r\n\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    public emitter: Nullable<AbstractMesh | Vector3> = Vector3.Zero();\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame\r\n     */\r\n    public emitRate = 10;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    public manualEmitCount = -1;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    public updateSpeed = 0.01;\r\n\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    public targetStopDuration = 0;\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    public disposeOnStop = false;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    public minEmitPower = 1;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    public maxEmitPower = 1;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    public minLifeTime = 1;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    public maxLifeTime = 1;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    public minSize = 1;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    public maxSize = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    public minScaleX = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    public maxScaleX = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    public minScaleY = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    public maxScaleY = 1;\r\n\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    public minInitialRotation = 0;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    public maxInitialRotation = 0;\r\n\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public minAngularSpeed = 0;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public maxAngularSpeed = 0;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    public particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * This can help using your own shader to render the particle system.\r\n     * The according effect will be created\r\n     */\r\n    public customShader: any = null;\r\n\r\n    /**\r\n     * By default particle system starts as soon as they are created. This prevents the\r\n     * automatic start to happen and let you decide when to start emitting particles.\r\n     */\r\n    public preventAutoStart: boolean = false;\r\n\r\n    /** @internal */\r\n    _wasDispatched = false;\r\n\r\n    protected _rootUrl = \"\";\r\n    private _noiseTexture: Nullable<ProceduralTexture>;\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    public get noiseTexture(): Nullable<ProceduralTexture> {\r\n        return this._noiseTexture;\r\n    }\r\n\r\n    public set noiseTexture(value: Nullable<ProceduralTexture>) {\r\n        if (this._noiseTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._noiseTexture = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    public noiseStrength = new Vector3(10, 10, 10);\r\n\r\n    /**\r\n     * Callback triggered when the particle animation is ending.\r\n     */\r\n    public onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.\r\n     */\r\n    public blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\r\n    public preWarmCycles = 0;\r\n\r\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\r\n    public preWarmStepOffset = 1;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    public spriteCellChangeSpeed = 1;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    public startSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    public endSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    public spriteCellWidth = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    public spriteCellHeight = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\r\n     */\r\n    public spriteCellLoop = true;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    public spriteRandomStartCell = false;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    public translationPivot = new Vector2(0, 0);\r\n\r\n    /** @internal */\r\n    public _isAnimationSheetEnabled: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    public beginAnimationOnStart = false;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationFrom = 0;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationTo = 60;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationLoop = false;\r\n\r\n    /**\r\n     * Gets or sets a world offset applied to all particles\r\n     */\r\n    public worldOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\r\n     */\r\n    public get isAnimationSheetEnabled(): boolean {\r\n        return this._isAnimationSheetEnabled;\r\n    }\r\n\r\n    public set isAnimationSheetEnabled(value: boolean) {\r\n        if (this._isAnimationSheetEnabled == value) {\r\n            return;\r\n        }\r\n\r\n        this._isAnimationSheetEnabled = value;\r\n\r\n        this._reset();\r\n    }\r\n\r\n    private _useLogarithmicDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene()!.getEngine().getCaps().fragmentDepthSupported;\r\n    }\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    public gravity = Vector3.Zero();\r\n\r\n    protected _colorGradients: Nullable<Array<ColorGradient>> = null;\r\n    protected _sizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _lifeTimeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _angularSpeedGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _velocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _limitVelocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _dragGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _emitRateGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _startSizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _rampGradients: Nullable<Array<Color3Gradient>> = null;\r\n    protected _colorRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _alphaRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n\r\n    protected _hasTargetStopDurationDependantGradient() {\r\n        return (\r\n            (this._startSizeGradients && this._startSizeGradients.length > 0) ||\r\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\r\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    public startDelay = 0;\r\n\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    public getDragGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._dragGradients;\r\n    }\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    public limitVelocityDamping = 0.4;\r\n\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    public getLimitVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._limitVelocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    public getColorGradients(): Nullable<Array<ColorGradient>> {\r\n        return this._colorGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    public getSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._sizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    public getColorRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._colorRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    public getAlphaRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._alphaRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    public getLifeTimeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._lifeTimeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    public getAngularSpeedGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._angularSpeedGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    public getVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._velocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    public getStartSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._startSizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    public getEmitRateGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._emitRateGradients;\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction1(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction1;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction1(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction1 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction2(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction2;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction2(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction2 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get minEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).minEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set minEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).minEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get maxEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set maxEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Color the particle will have at the end of its lifetime\r\n     */\r\n    public colorDead = new Color4(0, 0, 0, 1.0);\r\n\r\n    /**\r\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\r\n     */\r\n    public textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    public particleEmitterType: IParticleEmitterType;\r\n\r\n    /** @internal */\r\n    public _isSubEmitter = false;\r\n\r\n    /** @internal */\r\n    public _billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    public get billboardMode(): number {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._billboardMode = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isBillboardBased = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    public get isBillboardBased(): boolean {\r\n        return this._isBillboardBased;\r\n    }\r\n\r\n    public set isBillboardBased(value: boolean) {\r\n        if (this._isBillboardBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isBillboardBased = value;\r\n        this._reset();\r\n    }\r\n\r\n    /**\r\n     * The scene the particle system belongs to.\r\n     */\r\n    protected _scene: Nullable<Scene>;\r\n\r\n    /**\r\n     * The engine the particle system belongs to.\r\n     */\r\n    protected _engine: ThinEngine;\r\n\r\n    /**\r\n     * Local cache of defines for image processing.\r\n     */\r\n    protected _imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration && this._scene) {\r\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _reset() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem {\r\n        if (!gradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const valueGradient of gradients) {\r\n            if (valueGradient.gradient === gradient) {\r\n                gradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        if (texture) {\r\n            texture.dispose();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     */\r\n    public constructor(name: string) {\r\n        this.id = name;\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @returns the emitter\r\n     */\r\n    public createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        const particleEmitter = new PointParticleEmitter();\r\n        particleEmitter.direction1 = direction1;\r\n        particleEmitter.direction2 = direction2;\r\n\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        const particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     * @returns the emitter\r\n     */\r\n    public createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        const particleEmitter = new SphereParticleEmitter(radius, radiusRange);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        const particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     * @returns the emitter\r\n     */\r\n    public createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        const particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @returns the emitter\r\n     */\r\n    public createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        const particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     * @returns the emitter\r\n     */\r\n    public createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        const particleEmitter = new ConeParticleEmitter(radius, angle);\r\n        this.particleEmitterType = particleEmitter;\r\n        return particleEmitter;\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @returns the emitter\r\n     */\r\n    public createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        const particleEmitter = new BoxParticleEmitter();\r\n        this.particleEmitterType = particleEmitter;\r\n        this.direction1 = direction1;\r\n        this.direction2 = direction2;\r\n        this.minEmitBox = minEmitBox;\r\n        this.maxEmitBox = maxEmitBox;\r\n        return particleEmitter;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration2\";\nconst shader = `#ifdef CLIPPLANE\nin float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nin float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nin float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration2 = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration2\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\n\nconst name = \"gpuRenderParticlesPixelShader\";\nconst shader = `precision highp float;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform sampler2D diffuseSampler;varying vec2 vUV;varying vec4 vColor;\n#include<clipPlaneFragmentDeclaration2> \n#include<imageProcessingDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main() {\n#include<clipPlaneFragment> \nvec4 textureColor=texture2D(diffuseSampler,vUV);gl_FragColor=textureColor*vColor;\n#ifdef BLENDMULTIPLYMODE\nfloat alpha=vColor.a*textureColor.a;gl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\n#endif \n#include<logDepthFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);gl_FragColor=applyImageProcessing(gl_FragColor);\n#endif\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuRenderParticlesPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertexDeclaration2\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;out float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;out float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;out float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;out float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;out float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;out float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertexDeclaration2 = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration2\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"gpuRenderParticlesVertexShader\";\nconst shader = `precision highp float;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;uniform vec3 worldOffset;\n#ifdef LOCAL\nuniform mat4 emitterWM;\n#endif\nattribute vec3 position;attribute float age;attribute float life;attribute vec3 size;\n#ifndef BILLBOARD\nattribute vec3 initialDirection;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\nattribute float angle;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\nattribute vec2 offset;attribute vec2 uv;varying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration2>\n#include<logDepthDeclaration>\n#ifdef COLORGRADIENTS\nuniform sampler2D colorGradientSampler;\n#else\nuniform vec4 colorDead;attribute vec4 color;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 sheetInfos;\n#endif\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#endif\nvoid main() {\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/sheetInfos.z);float columnOffset=cellIndex-rowOffset*sheetInfos.z;vec2 uvScale=sheetInfos.xy;vec2 uvOffset=vec2(uv.x ,1.0-uv.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=uv;\n#endif\nfloat ratio=age/life;\n#ifdef COLORGRADIENTS\nvColor=texture2D(colorGradientSampler,vec2(ratio,0));\n#else\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\n#endif\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x;\n#ifdef BILLBOARD\nvec4 rotatedCorner;rotatedCorner.w=0.;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=(position+worldOffset)-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=(position+worldOffset)-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;\n#ifdef LOCAL\nvec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;\n#else\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\n#endif\nvPositionW=(invView*viewPosition).xyz;\n#endif\n#else\nvec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=0.;rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(initialDirection);vPositionW=rotate(yaxis,rotatedCorner);vec4 viewPosition=view*vec4(vPositionW,1.0);\n#endif\ngl_Position=projection*viewPosition;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuRenderParticlesVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Immutable, Nullable, float, DataArray } from \"../types\";\r\nimport type { Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color4, TmpColors } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { IGPUParticleSystemPlatform } from \"./IGPUParticleSystemPlatform\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\nimport \"../Engines/Extensions/engine.transformFeedback\";\r\n\r\nimport \"../Shaders/gpuRenderParticles.fragment\";\r\nimport \"../Shaders/gpuRenderParticles.vertex\";\r\n\r\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\r\nexport class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    private _capacity: number;\r\n    private _maxActiveParticleCount: number;\r\n    private _currentActiveCount: number;\r\n    private _accumulatedCount = 0;\r\n    private _updateBuffer: UniformBufferEffectCommonAccessor;\r\n\r\n    private _buffer0: Buffer;\r\n    private _buffer1: Buffer;\r\n    private _spriteBuffer: Buffer;\r\n    private _renderVertexBuffers: Array<{ [key: string]: VertexBuffer }> = [];\r\n    private _linesIndexBufferUseInstancing: Nullable<DataBuffer>;\r\n\r\n    private _targetIndex = 0;\r\n    private _sourceBuffer: Buffer;\r\n    private _targetBuffer: Buffer;\r\n\r\n    private _currentRenderId = -1;\r\n    private _currentRenderingCameraUniqueId = -1;\r\n    private _started = false;\r\n    private _stopped = false;\r\n\r\n    private _timeDelta = 0;\r\n\r\n    /** @internal */\r\n    public _randomTexture: RawTexture;\r\n    /** @internal */\r\n    public _randomTexture2: RawTexture;\r\n\r\n    /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\r\n    public updateInAnimate = false;\r\n\r\n    private _attributesStrideSize: number;\r\n    private _cachedUpdateDefines: string;\r\n\r\n    private _randomTextureSize: number;\r\n    private _actualFrame = 0;\r\n    private _drawWrappers: { [blendMode: number]: DrawWrapper };\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n\r\n    private _platform: IGPUParticleSystemPlatform;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        if (!EngineStore.LastCreatedEngine) {\r\n            return false;\r\n        }\r\n        const caps = EngineStore.LastCreatedEngine.getCaps();\r\n\r\n        return caps.supportTransformFeedbacks || caps.supportComputeShaders;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the system is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _createIndexBuffer() {\r\n        this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * The value cannot be greater than \"capacity\" (if it is, it will be limited to \"capacity\").\r\n     */\r\n    public get maxActiveParticleCount(): number {\r\n        return this._maxActiveParticleCount;\r\n    }\r\n\r\n    public set maxActiveParticleCount(value: number) {\r\n        this._maxActiveParticleCount = Math.min(value, this._capacity);\r\n    }\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     * @deprecated Please use maxActiveParticleCount instead.\r\n     */\r\n    public get activeParticleCount(): number {\r\n        return this.maxActiveParticleCount;\r\n    }\r\n\r\n    public set activeParticleCount(value: number) {\r\n        this.maxActiveParticleCount = value;\r\n    }\r\n\r\n    private _preWarmDone = false;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is GPU based */\r\n    public readonly isGPU = true;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (!this._platform.isUpdateBufferCreated()) {\r\n            this._recreateUpdateEffect();\r\n            return false;\r\n        }\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n     * @returns True if it has been stopped, otherwise false.\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return false; // Stop is immediate on GPU\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._preWarmDone = false;\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    public stop(): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n        this._stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n        this._currentActiveCount = 0;\r\n        this._targetIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"GPUParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GPUParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"gpuRenderParticles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\r\n     * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\r\n        // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\r\n        // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\r\n        // (and that will be the source buffers in the next frame)\r\n        return this._renderVertexBuffers[this._targetIndex ^ 1];\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (null for GPU particle systems)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _colorGradientsTexture: RawTexture;\r\n\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem {\r\n        super._removeGradientAndTexture(gradient, gradients, texture);\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4): GPUParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._refreshColorGradient(true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshColorGradient(reorder = false) {\r\n        if (this._colorGradients) {\r\n            if (reorder) {\r\n                this._colorGradients.sort((a, b) => {\r\n                    if (a.gradient < b.gradient) {\r\n                        return -1;\r\n                    } else if (a.gradient > b.gradient) {\r\n                        return 1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            if (this._colorGradientsTexture) {\r\n                this._colorGradientsTexture.dispose();\r\n                (<any>this._colorGradientsTexture) = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._refreshColorGradient();\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\r\n        (<any>this._colorGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.drawContext?.reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _angularSpeedGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _sizeGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _velocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _limitVelocityGradientsTexture: RawTexture;\r\n    /** @internal */\r\n    public _dragGradientsTexture: RawTexture;\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number) {\r\n        const valueGradient = new FactorGradient(gradient, factor);\r\n        factorGradients.push(valueGradient);\r\n\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\r\n\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\r\n        (<any>this._sizeGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshFactorGradient(factorGradients: Nullable<FactorGradient[]>, textureName: string, reorder = false) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        if (reorder) {\r\n            factorGradients.sort((a, b) => {\r\n                if (a.gradient < b.gradient) {\r\n                    return -1;\r\n                } else if (a.gradient > b.gradient) {\r\n                    return 1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        const that = this as any;\r\n        if (that[textureName]) {\r\n            that[textureName].dispose();\r\n            that[textureName] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\r\n        (<any>this._angularSpeedGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\r\n        (<any>this._velocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\r\n        (<any>this._limitVelocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\r\n        (<any>this._dragGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        //Not supported by GPUParticleSystem\r\n        return false;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        //Not supported by GPUParticleSystem\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a GPU particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param options The options used to create the system\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: Partial<{\r\n            capacity: number;\r\n            randomTextureSize: number;\r\n        }>,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false\r\n    ) {\r\n        super(name);\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().supportComputeShaders) {\r\n            if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\r\n                throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\") as any)(this, this._engine);\r\n        } else {\r\n            if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\r\n                throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\r\n            }\r\n            this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\") as any)(this, this._engine);\r\n        }\r\n\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = { 0: new DrawWrapper(this._engine) };\r\n        if (this._drawWrappers[0].drawContext) {\r\n            this._drawWrappers[0].drawContext.useInstancing = true;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        options = options ?? {};\r\n\r\n        if (!options.randomTextureSize) {\r\n            delete options.randomTextureSize;\r\n        }\r\n\r\n        const fullOptions = {\r\n            capacity: 50000,\r\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\r\n            ...options,\r\n        };\r\n\r\n        const optionsAsNumber = <number>options;\r\n        if (isFinite(optionsAsNumber)) {\r\n            fullOptions.capacity = optionsAsNumber;\r\n        }\r\n\r\n        this._capacity = fullOptions.capacity;\r\n        this._maxActiveParticleCount = fullOptions.capacity;\r\n        this._currentActiveCount = 0;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n\r\n        // Random data\r\n        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\r\n        let d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture.name = \"GPUParticleSystem_random1\";\r\n        this._randomTexture.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        d = [];\r\n        for (let i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture2 = new RawTexture(\r\n            new Float32Array(d),\r\n            maxTextureSize,\r\n            1,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            false,\r\n            false,\r\n            Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        this._randomTexture2.name = \"GPUParticleSystem_random2\";\r\n        this._randomTexture2.wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n        this._randomTexture2.wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n        this._randomTextureSize = maxTextureSize;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers(updateBuffer: Buffer, renderBuffer: Buffer, spriteSource: Buffer): void {\r\n        const renderVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\r\n        let offset = 3;\r\n        renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\r\n        offset += 3;\r\n        renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        offset += 4; // seed\r\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\r\n        }\r\n        offset += 3; // direction\r\n        if (this._platform.alignDataInBuffer) {\r\n            offset += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\r\n            offset += 4;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n            renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\r\n        if (this._angularSpeedGradientsTexture) {\r\n            offset++;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\r\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\r\n\r\n        this._renderVertexBuffers.push(renderVertexBuffers);\r\n\r\n        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _initialize(force = false): void {\r\n        if (this._buffer0 && !force) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const data = new Array<float>();\r\n\r\n        this._attributesStrideSize = 21;\r\n        this._targetIndex = 0;\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 1;\r\n        }\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (!this.isBillboardBased) {\r\n            this._attributesStrideSize += 3;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._attributesStrideSize -= 4;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._attributesStrideSize -= 1;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._attributesStrideSize += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._attributesStrideSize += 6;\r\n            if (this._platform.alignDataInBuffer) {\r\n                this._attributesStrideSize += 2;\r\n            }\r\n        }\r\n\r\n        if (this._platform.alignDataInBuffer) {\r\n            this._attributesStrideSize += 3 - ((this._attributesStrideSize + 3) & 3); // round to multiple of 4\r\n        }\r\n\r\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        let offset = 0;\r\n        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\r\n            // position\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // Age\r\n            data.push(0.0); // create the particle as a dead one to create a new one at start\r\n\r\n            // Size\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            // life\r\n            data.push(0.0);\r\n\r\n            // Seed\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n\r\n            // direction\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particleDestinationGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            } else {\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                data.push(0.0); // dummy0\r\n            }\r\n\r\n            offset += 16; // position, age, size, life, seed, direction, dummy0\r\n\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particlePositionGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy1\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this._colorGradientsTexture) {\r\n                // color\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                offset += 4;\r\n            }\r\n\r\n            if (!this.isBillboardBased) {\r\n                // initialDirection\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy2\r\n                }\r\n                offset += 4;\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                // Random coordinates for reading into noise texture\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy3\r\n                }\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                if (this._platform.alignDataInBuffer) {\r\n                    data.push(0.0); // dummy4\r\n                }\r\n                offset += 8;\r\n            }\r\n\r\n            // angle\r\n            data.push(0.0);\r\n            offset += 1;\r\n\r\n            if (!this._angularSpeedGradientsTexture) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled) {\r\n                data.push(0.0);\r\n                offset += 1;\r\n                if (this.spriteRandomStartCell) {\r\n                    data.push(0.0);\r\n                    offset += 1;\r\n                }\r\n            }\r\n\r\n            if (this._platform.alignDataInBuffer) {\r\n                let numDummies = 3 - ((offset + 3) & 3);\r\n                offset += numDummies;\r\n                while (numDummies-- > 0) {\r\n                    data.push(0.0);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sprite data\r\n        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\r\n\r\n        const bufferData1: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n        const bufferData2: DataArray | DataBuffer = this._platform.createParticleBuffer(data);\r\n\r\n        // Buffers\r\n        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\r\n        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\r\n\r\n        // Update & Render vertex buffers\r\n        this._renderVertexBuffers = [];\r\n        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\r\n        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\r\n\r\n        // Links\r\n        this._sourceBuffer = this._buffer0;\r\n        this._targetBuffer = this._buffer1;\r\n    }\r\n\r\n    /** @internal */\r\n    public _recreateUpdateEffect() {\r\n        this._createColorGradientTexture();\r\n        this._createSizeGradientTexture();\r\n        this._createAngularSpeedGradientTexture();\r\n        this._createVelocityGradientTexture();\r\n        this._createLimitVelocityGradientTexture();\r\n        this._createDragGradientTexture();\r\n\r\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\r\n\r\n        if (this._isBillboardBased) {\r\n            defines += \"\\n#define BILLBOARD\";\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines += \"\\n#define COLORGRADIENTS\";\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            defines += \"\\n#define SIZEGRADIENTS\";\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            defines += \"\\n#define VELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            defines += \"\\n#define DRAGGRADIENTS\";\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines += \"\\n#define ANIMATESHEET\";\r\n            if (this.spriteRandomStartCell) {\r\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            defines += \"\\n#define NOISE\";\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines += \"\\n#define LOCAL\";\r\n        }\r\n\r\n        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\r\n            return true;\r\n        }\r\n\r\n        this._cachedUpdateDefines = defines;\r\n        this._updateBuffer = this._platform.createUpdateBuffer(defines);\r\n\r\n        return this._platform.isUpdateBufferReady();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        let drawWrapper = this._drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = true;\r\n            }\r\n            this._drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributes: Array<string> = [];\r\n            const uniforms: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\r\n\r\n        if (!hasColorGradients) {\r\n            attributeNamesOrOptions.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"initialDirection\");\r\n        }\r\n\r\n        if (isBillboardStretched) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false): string[] {\r\n        const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\r\n        addClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"sheetInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number = 0) {\r\n        if (this._scene) {\r\n            prepareStringDefinesForClipPlanes(this, this._scene, defines);\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines.push(\"#define LOCAL\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines.push(\"#define COLORGRADIENTS\");\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...GPUParticleSystem._GetAttributeNamesOrOptions(\r\n                !!this._colorGradientsTexture,\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased,\r\n                this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED\r\n            )\r\n        );\r\n\r\n        uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\r\n\r\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarm defines if we are in the pre-warmimg phase\r\n     */\r\n    public animate(preWarm = false): void {\r\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n        this._actualFrame += this._timeDelta;\r\n\r\n        if (!this._stopped) {\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        }\r\n\r\n        if (this.updateInAnimate) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _createFactorGradientTexture(factorGradients: Nullable<IValueGradient[]>, textureName: string) {\r\n        const texture: RawTexture = (<any>this)[textureName];\r\n\r\n        if (!factorGradients || !factorGradients.length || texture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Float32Array(this._rawTextureWidth);\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\r\n                data[x] = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n            });\r\n        }\r\n\r\n        (<any>this)[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        (<any>this)[textureName].name = textureName.substring(1);\r\n    }\r\n\r\n    private _createSizeGradientTexture() {\r\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\r\n    }\r\n\r\n    private _createAngularSpeedGradientTexture() {\r\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n    }\r\n\r\n    private _createVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\r\n    }\r\n\r\n    private _createLimitVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n    }\r\n\r\n    private _createDragGradientTexture() {\r\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\r\n    }\r\n\r\n    private _createColorGradientTexture() {\r\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color4[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                Color4.LerpToRef((<ColorGradient>currentGradient).color1, (<ColorGradient>nextGradient).color1, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = tmpColor.a * 255;\r\n            });\r\n        }\r\n\r\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        this._colorGradientsTexture.name = \"colorGradients\";\r\n    }\r\n\r\n    private _render(blendMode: number, emitterWM: Matrix): number {\r\n        // Enable render effect\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setVector3(\"worldOffset\", this.worldOffset);\r\n        if (this.isLocal) {\r\n            effect.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n        if (this._colorGradientsTexture) {\r\n            effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\r\n        } else {\r\n            effect.setDirectColor4(\"colorDead\", this.colorDead);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\r\n        }\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            bindClipPlane(effect, this, this._scene);\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            const invView = viewMatrix.clone();\r\n            invView.invert();\r\n            effect.setMatrix(\"invView\", invView);\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                this._engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                this._engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        // Bind source VAO\r\n        this._platform.bindDrawBuffers(this._targetIndex, effect, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null);\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        // Render\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.drawElementsType(Constants.MATERIAL_LineStripDrawMode, 0, 10, this._currentActiveCount);\r\n        } else {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._currentActiveCount);\r\n        }\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        if (this._scene?.forceWireframe) {\r\n            this._engine.unbindInstanceAttributes();\r\n        }\r\n\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(emitterWM?: Matrix): void {\r\n        if (!this.emitter || !this._targetBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._recreateUpdateEffect()) {\r\n            return;\r\n        }\r\n\r\n        if (!emitterWM) {\r\n            if ((<AbstractMesh>this.emitter).position) {\r\n                const emitterMesh = <AbstractMesh>this.emitter;\r\n                emitterWM = emitterMesh.getWorldMatrix();\r\n            } else {\r\n                const emitterPosition = <Vector3>this.emitter;\r\n                emitterWM = TmpVectors.Matrix[0];\r\n                Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n            }\r\n        }\r\n\r\n        this._platform.preUpdateParticleBuffer();\r\n\r\n        this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\r\n        this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\r\n        this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\r\n        this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\r\n        this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\r\n        this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateBuffer.setDirectColor4(\"color1\", this.color1);\r\n            this._updateBuffer.setDirectColor4(\"color2\", this.color2);\r\n        }\r\n        this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\r\n        this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\r\n        this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\r\n        this._updateBuffer.setVector3(\"gravity\", this.gravity);\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\r\n        }\r\n        if (this.particleEmitterType) {\r\n            this.particleEmitterType.applyToShader(this._updateBuffer);\r\n        }\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\r\n        }\r\n        if (this.noiseTexture) {\r\n            this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\r\n        }\r\n        if (!this.isLocal) {\r\n            this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n\r\n        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\r\n\r\n        // Switch VAOs\r\n        this._targetIndex++;\r\n        if (this._targetIndex === 2) {\r\n            this._targetIndex = 0;\r\n        }\r\n\r\n        // Switch buffers\r\n        const tmpBuffer = this._sourceBuffer;\r\n        this._sourceBuffer = this._targetBuffer;\r\n        this._targetBuffer = tmpBuffer;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state\r\n     * @param preWarm defines if the system should only update the particles but not render them\r\n     * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\r\n     * @returns the current number of particles\r\n     */\r\n    public render(preWarm = false, forceUpdateOnly = false): number {\r\n        if (!this._started) {\r\n            return 0;\r\n        }\r\n\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        if (!preWarm && this._scene) {\r\n            if (!this._preWarmDone && this.preWarmCycles) {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                    this.render(true, true);\r\n                }\r\n\r\n                this._preWarmDone = true;\r\n            }\r\n\r\n            if (\r\n                this._currentRenderId === this._scene.getRenderId() &&\r\n                (!this._scene.activeCamera || (this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId))\r\n            ) {\r\n                return 0;\r\n            }\r\n\r\n            this._currentRenderId = this._scene.getRenderId();\r\n            if (this._scene.activeCamera) {\r\n                this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\r\n            }\r\n        }\r\n\r\n        // Get everything ready to render\r\n        this._initialize();\r\n\r\n        this._accumulatedCount += this.emitRate * this._timeDelta;\r\n        if (this._accumulatedCount > 1) {\r\n            const intPart = this._accumulatedCount | 0;\r\n            this._accumulatedCount -= intPart;\r\n            this._currentActiveCount += intPart;\r\n        }\r\n\r\n        this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);\r\n\r\n        if (!this._currentActiveCount) {\r\n            return 0;\r\n        }\r\n\r\n        // Enable update effect\r\n        let emitterWM: Matrix;\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            emitterWM = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            emitterWM = TmpVectors.Matrix[0];\r\n            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\r\n        }\r\n\r\n        const engine = this._engine as Engine;\r\n\r\n        if (!this.updateInAnimate) {\r\n            this._update(emitterWM);\r\n        }\r\n\r\n        let outparticles = 0;\r\n        if (!preWarm && !forceUpdateOnly) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n\r\n            if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n                outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\r\n            } else {\r\n                outparticles = this._render(this.blendMode, emitterWM);\r\n            }\r\n\r\n            this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system\r\n     */\r\n    public rebuild(): void {\r\n        const checkUpdateEffect = () => {\r\n            if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {\r\n                setTimeout(checkUpdateEffect, 10);\r\n            } else {\r\n                this._initialize(true);\r\n            }\r\n        };\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._cachedUpdateDefines = \"\";\r\n        this._platform.contextLost();\r\n\r\n        checkUpdateEffect();\r\n    }\r\n\r\n    private _releaseBuffers() {\r\n        if (this._buffer0) {\r\n            this._buffer0.dispose();\r\n            (<any>this._buffer0) = null;\r\n        }\r\n        if (this._buffer1) {\r\n            this._buffer1.dispose();\r\n            (<any>this._buffer1) = null;\r\n        }\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n        this._platform.releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        for (const blendMode in this._drawWrappers) {\r\n            const drawWrapper = this._drawWrappers[blendMode];\r\n            drawWrapper.dispose();\r\n        }\r\n\r\n        this._drawWrappers = {};\r\n\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._releaseBuffers();\r\n        this._platform.releaseVertexBuffers();\r\n\r\n        for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\r\n            const rvb = this._renderVertexBuffers[i];\r\n            for (const key in rvb) {\r\n                rvb[key].dispose();\r\n            }\r\n        }\r\n\r\n        this._renderVertexBuffers = [];\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._colorGradientsTexture.dispose();\r\n            (<any>this._colorGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._sizeGradientsTexture.dispose();\r\n            (<any>this._sizeGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._angularSpeedGradientsTexture.dispose();\r\n            (<any>this._angularSpeedGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._velocityGradientsTexture.dispose();\r\n            (<any>this._velocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._limitVelocityGradientsTexture.dispose();\r\n            (<any>this._limitVelocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._dragGradientsTexture.dispose();\r\n            (<any>this._dragGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            (<any>this._randomTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture2) {\r\n            this._randomTexture2.dispose();\r\n            (<any>this._randomTexture2) = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onStoppedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): GPUParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as any;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                custom[0] = engine.createEffectForParticles(\r\n                    program.shaderPath.fragmentElement,\r\n                    program.shaderOptions.uniforms,\r\n                    program.shaderOptions.samplers,\r\n                    defines,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this\r\n                );\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.activeParticleCount = this.activeParticleCount;\r\n        serializationObject.randomTextureSize = this._randomTextureSize;\r\n        serializationObject.customShader = this.customShader;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a GPU particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the parsed GPU particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): GPUParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        const particleSystem = new GPUParticleSystem(\r\n            name,\r\n            { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize },\r\n            sceneOrEngine,\r\n            null,\r\n            parsedParticleSystem.isAnimationSheetEnabled\r\n        );\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            const program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            const custom: Nullable<Effect> = (engine as any).createEffectForParticles(\r\n                program.shaderPath.fragmentElement,\r\n                program.shaderOptions.uniforms,\r\n                program.shaderOptions.samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                particleSystem\r\n            );\r\n            particleSystem.setCustomEffect(custom, 0);\r\n            particleSystem.customShader = program;\r\n        }\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        if (parsedParticleSystem.activeParticleCount) {\r\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport type { ParticleSystem } from \"./particleSystem\";\r\nimport type { SubEmitter } from \"./subEmitter\";\r\nimport type { ColorGradient, FactorGradient } from \"../Misc/gradients\";\r\n\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * A particle represents one of the element emitted by a particle system.\r\n * This is mainly define by its coordinates, direction, velocity and age.\r\n */\r\nexport class Particle {\r\n    private static _Count = 0;\r\n    /**\r\n     * Unique ID of the particle\r\n     */\r\n    public id: number;\r\n    /**\r\n     * The world position of the particle in the scene.\r\n     */\r\n    public position = Vector3.Zero();\r\n\r\n    /**\r\n     * The world direction of the particle in the scene.\r\n     */\r\n    public direction = Vector3.Zero();\r\n\r\n    /**\r\n     * The color of the particle.\r\n     */\r\n    public color = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * The color change of the particle per step.\r\n     */\r\n    public colorStep = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Defines how long will the life of the particle be.\r\n     */\r\n    public lifeTime = 1.0;\r\n\r\n    /**\r\n     * The current age of the particle.\r\n     */\r\n    public age = 0;\r\n\r\n    /**\r\n     * The current size of the particle.\r\n     */\r\n    public size = 0;\r\n\r\n    /**\r\n     * The current scale of the particle.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * The current angle of the particle.\r\n     */\r\n    public angle = 0;\r\n\r\n    /**\r\n     * Defines how fast is the angle changing.\r\n     */\r\n    public angularSpeed = 0;\r\n\r\n    /**\r\n     * Defines the cell index used by the particle to be rendered from a sprite.\r\n     */\r\n    public cellIndex: number = 0;\r\n\r\n    /**\r\n     * The information required to support color remapping\r\n     */\r\n    public remapData: Vector4;\r\n\r\n    /** @internal */\r\n    public _randomCellOffset?: number;\r\n\r\n    /** @internal */\r\n    public _initialDirection: Nullable<Vector3>;\r\n\r\n    /** @internal */\r\n    public _attachedSubEmitters: Nullable<Array<SubEmitter>> = null;\r\n\r\n    /** @internal */\r\n    public _initialStartSpriteCellID: number;\r\n    /** @internal */\r\n    public _initialEndSpriteCellID: number;\r\n    /** @internal */\r\n    public _initialSpriteCellLoop: boolean;\r\n\r\n    /** @internal */\r\n    public _currentColorGradient: Nullable<ColorGradient>;\r\n    /** @internal */\r\n    public _currentColor1 = new Color4(0, 0, 0, 0);\r\n    /** @internal */\r\n    public _currentColor2 = new Color4(0, 0, 0, 0);\r\n\r\n    /** @internal */\r\n    public _currentSizeGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentSize1 = 0;\r\n    /** @internal */\r\n    public _currentSize2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentAngularSpeedGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentAngularSpeed1 = 0;\r\n    /** @internal */\r\n    public _currentAngularSpeed2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentVelocityGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentVelocity1 = 0;\r\n    /** @internal */\r\n    public _currentVelocity2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentLimitVelocityGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentLimitVelocity1 = 0;\r\n    /** @internal */\r\n    public _currentLimitVelocity2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentDragGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentDrag1 = 0;\r\n    /** @internal */\r\n    public _currentDrag2 = 0;\r\n\r\n    /** @internal */\r\n    public _randomNoiseCoordinates1: Vector3;\r\n    /** @internal */\r\n    public _randomNoiseCoordinates2: Vector3;\r\n\r\n    /** @internal */\r\n    public _localPosition?: Vector3;\r\n\r\n    /**\r\n     * Creates a new instance Particle\r\n     * @param particleSystem the particle system the particle belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * The particle system the particle belongs to.\r\n         */\r\n        public particleSystem: ParticleSystem\r\n    ) {\r\n        this.id = Particle._Count++;\r\n        if (!this.particleSystem.isAnimationSheetEnabled) {\r\n            return;\r\n        }\r\n\r\n        this._updateCellInfoFromSystem();\r\n    }\r\n\r\n    private _updateCellInfoFromSystem(): void {\r\n        this.cellIndex = this.particleSystem.startSpriteCellID;\r\n    }\r\n\r\n    /**\r\n     * Defines how the sprite cell index is updated for the particle\r\n     */\r\n    public updateCellIndex(): void {\r\n        let offsetAge = this.age;\r\n        let changeSpeed = this.particleSystem.spriteCellChangeSpeed;\r\n\r\n        if (this.particleSystem.spriteRandomStartCell) {\r\n            if (this._randomCellOffset === undefined) {\r\n                this._randomCellOffset = Math.random() * this.lifeTime;\r\n            }\r\n\r\n            if (changeSpeed === 0) {\r\n                // Special case when speed = 0 meaning we want to stay on initial cell\r\n                changeSpeed = 1;\r\n                offsetAge = this._randomCellOffset;\r\n            } else {\r\n                offsetAge += this._randomCellOffset;\r\n            }\r\n        }\r\n\r\n        const dist = this._initialEndSpriteCellID - this._initialStartSpriteCellID;\r\n        let ratio: number;\r\n        if (this._initialSpriteCellLoop) {\r\n            ratio = Scalar.Clamp(((offsetAge * changeSpeed) % this.lifeTime) / this.lifeTime);\r\n        } else {\r\n            ratio = Scalar.Clamp((offsetAge * changeSpeed) / this.lifeTime);\r\n        }\r\n        this.cellIndex = (this._initialStartSpriteCellID + ratio * dist) | 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _inheritParticleInfoToSubEmitter(subEmitter: SubEmitter) {\r\n        if ((<AbstractMesh>subEmitter.particleSystem.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>subEmitter.particleSystem.emitter;\r\n            emitterMesh.position.copyFrom(this.position);\r\n            if (subEmitter.inheritDirection) {\r\n                const temp = TmpVectors.Vector3[0];\r\n                this.direction.normalizeToRef(temp);\r\n                emitterMesh.setDirection(temp, 0, Math.PI / 2);\r\n            }\r\n        } else {\r\n            const emitterPosition = <Vector3>subEmitter.particleSystem.emitter;\r\n            emitterPosition.copyFrom(this.position);\r\n        }\r\n        // Set inheritedVelocityOffset to be used when new particles are created\r\n        this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);\r\n        subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);\r\n    }\r\n\r\n    /** @internal */\r\n    public _inheritParticleInfoToSubEmitters() {\r\n        if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {\r\n            this._attachedSubEmitters.forEach((subEmitter) => {\r\n                this._inheritParticleInfoToSubEmitter(subEmitter);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _reset() {\r\n        this.age = 0;\r\n        this.id = Particle._Count++;\r\n        this._currentColorGradient = null;\r\n        this._currentSizeGradient = null;\r\n        this._currentAngularSpeedGradient = null;\r\n        this._currentVelocityGradient = null;\r\n        this._currentLimitVelocityGradient = null;\r\n        this._currentDragGradient = null;\r\n        this.cellIndex = this.particleSystem.startSpriteCellID;\r\n        this._randomCellOffset = undefined;\r\n    }\r\n\r\n    /**\r\n     * Copy the properties of particle to another one.\r\n     * @param other the particle to copy the information to.\r\n     */\r\n    public copyTo(other: Particle) {\r\n        other.position.copyFrom(this.position);\r\n        if (this._initialDirection) {\r\n            if (other._initialDirection) {\r\n                other._initialDirection.copyFrom(this._initialDirection);\r\n            } else {\r\n                other._initialDirection = this._initialDirection.clone();\r\n            }\r\n        } else {\r\n            other._initialDirection = null;\r\n        }\r\n        other.direction.copyFrom(this.direction);\r\n        if (this._localPosition) {\r\n            if (other._localPosition) {\r\n                other._localPosition.copyFrom(this._localPosition);\r\n            } else {\r\n                other._localPosition = this._localPosition.clone();\r\n            }\r\n        }\r\n        other.color.copyFrom(this.color);\r\n        other.colorStep.copyFrom(this.colorStep);\r\n        other.lifeTime = this.lifeTime;\r\n        other.age = this.age;\r\n        other._randomCellOffset = this._randomCellOffset;\r\n        other.size = this.size;\r\n        other.scale.copyFrom(this.scale);\r\n        other.angle = this.angle;\r\n        other.angularSpeed = this.angularSpeed;\r\n        other.particleSystem = this.particleSystem;\r\n        other.cellIndex = this.cellIndex;\r\n        other.id = this.id;\r\n        other._attachedSubEmitters = this._attachedSubEmitters;\r\n        if (this._currentColorGradient) {\r\n            other._currentColorGradient = this._currentColorGradient;\r\n            other._currentColor1.copyFrom(this._currentColor1);\r\n            other._currentColor2.copyFrom(this._currentColor2);\r\n        }\r\n        if (this._currentSizeGradient) {\r\n            other._currentSizeGradient = this._currentSizeGradient;\r\n            other._currentSize1 = this._currentSize1;\r\n            other._currentSize2 = this._currentSize2;\r\n        }\r\n        if (this._currentAngularSpeedGradient) {\r\n            other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;\r\n            other._currentAngularSpeed1 = this._currentAngularSpeed1;\r\n            other._currentAngularSpeed2 = this._currentAngularSpeed2;\r\n        }\r\n        if (this._currentVelocityGradient) {\r\n            other._currentVelocityGradient = this._currentVelocityGradient;\r\n            other._currentVelocity1 = this._currentVelocity1;\r\n            other._currentVelocity2 = this._currentVelocity2;\r\n        }\r\n        if (this._currentLimitVelocityGradient) {\r\n            other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;\r\n            other._currentLimitVelocity1 = this._currentLimitVelocity1;\r\n            other._currentLimitVelocity2 = this._currentLimitVelocity2;\r\n        }\r\n        if (this._currentDragGradient) {\r\n            other._currentDragGradient = this._currentDragGradient;\r\n            other._currentDrag1 = this._currentDrag1;\r\n            other._currentDrag2 = this._currentDrag2;\r\n        }\r\n        if (this.particleSystem.isAnimationSheetEnabled) {\r\n            other._initialStartSpriteCellID = this._initialStartSpriteCellID;\r\n            other._initialEndSpriteCellID = this._initialEndSpriteCellID;\r\n            other._initialSpriteCellLoop = this._initialSpriteCellLoop;\r\n        }\r\n        if (this.particleSystem.useRampGradients) {\r\n            if (other.remapData && this.remapData) {\r\n                other.remapData.copyFrom(this.remapData);\r\n            } else {\r\n                other.remapData = new Vector4(0, 0, 0, 0);\r\n            }\r\n        }\r\n        if (this._randomNoiseCoordinates1) {\r\n            if (other._randomNoiseCoordinates1) {\r\n                other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);\r\n                other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);\r\n            } else {\r\n                other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();\r\n                other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\n\nconst name = \"particlesPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec2 vUV;varying vec4 vColor;uniform vec4 textureMask;uniform sampler2D diffuseSampler;\n#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;uniform sampler2D rampSampler;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec4 textureColor=texture2D(diffuseSampler,vUV);vec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\n#ifdef RAMPGRADIENT\nfloat alpha=baseColor.a;float remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);vec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));baseColor.rgb*=rampColor.rgb;float finalAlpha=baseColor.a;baseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\n#endif\n#ifdef BLENDMULTIPLYMODE\nfloat sourceAlpha=vColor.a*textureColor.a;baseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\n#endif\n#include<logDepthFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\nbaseColor.rgb=toLinearSpace(baseColor.rgb);baseColor=applyImageProcessing(baseColor);\n#endif\n#endif\ngl_FragColor=baseColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const particlesPixelShader = { name, shader };\n","/* eslint-disable import/no-internal-modules */\r\nimport type { Immutable, Nullable } from \"../types\";\r\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    ConeParticleEmitter,\r\n    PointParticleEmitter,\r\n    MeshParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { Particle } from \"./particle\";\r\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/particles.fragment\";\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport { addClipPlaneUniforms, prepareStringDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {\r\n    /**\r\n     * Billboard mode will only apply to Y axis\r\n     */\r\n    public static readonly BILLBOARDMODE_Y = Constants.PARTICLES_BILLBOARDMODE_Y;\r\n    /**\r\n     * Billboard mode will apply to all axes\r\n     */\r\n    public static readonly BILLBOARDMODE_ALL = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED = Constants.PARTICLES_BILLBOARDMODE_STRETCHED;\r\n    /**\r\n     * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED_LOCAL = Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL;\r\n\r\n    /**\r\n     * This function can be defined to provide custom update for active particles.\r\n     * This function will be called instead of regular update (age, position, color, etc.).\r\n     * Do not forget that this function will be called on every frame so try to keep it simple and fast :)\r\n     */\r\n    public updateFunction: (particles: Particle[]) => void;\r\n\r\n    private _emitterWorldMatrix: Matrix;\r\n    private _emitterInverseWorldMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * This function can be defined to specify initial direction for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n    /**\r\n     * This function can be defined to specify initial position for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _inheritedVelocityOffset = new Vector3();\r\n    /**\r\n     * An event triggered when the system is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<IParticleSystem>>;\r\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _particles = new Array<Particle>();\r\n    private _epsilon: number;\r\n    private _capacity: number;\r\n    private _stockParticles = new Array<Particle>();\r\n    private _newPartsExcess = 0;\r\n    private _vertexData: Float32Array;\r\n    private _vertexBuffer: Nullable<Buffer>;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _linesIndexBuffer: Nullable<DataBuffer>;\r\n    private _linesIndexBufferUseInstancing: Nullable<DataBuffer>;\r\n    private _drawWrappers: DrawWrapper[][]; // first index is render pass id, second index is blend mode\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n    private _scaledColorStep = new Color4(0, 0, 0, 0);\r\n    private _colorDiff = new Color4(0, 0, 0, 0);\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _scaledGravity = Vector3.Zero();\r\n    private _currentRenderId = -1;\r\n    private _alive: boolean;\r\n    private _useInstancing = false;\r\n    private _vertexArrayObject: Nullable<WebGLVertexArrayObject>;\r\n\r\n    private _started = false;\r\n    private _stopped = false;\r\n    private _actualFrame = 0;\r\n    private _scaledUpdateSpeed: number;\r\n    private _vertexBufferSize: number;\r\n\r\n    /** @internal */\r\n    public _currentEmitRateGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentEmitRate1 = 0;\r\n    /** @internal */\r\n    public _currentEmitRate2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentStartSizeGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentStartSize1 = 0;\r\n    /** @internal */\r\n    public _currentStartSize2 = 0;\r\n\r\n    /** Indicates that the update of particles is done in the animate function */\r\n    public readonly updateInAnimate = true;\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n    private _rampGradientsTexture: Nullable<RawTexture>;\r\n    private _useRampGradients = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /** Gets or sets a matrix to use to compute view */\r\n    public defaultViewMatrix: Matrix;\r\n\r\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        return this._useRampGradients;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        if (this._useRampGradients === value) {\r\n            return;\r\n        }\r\n\r\n        this._useRampGradients = value;\r\n\r\n        this._resetEffect();\r\n    }\r\n\r\n    // Sub-emitters\r\n    /**\r\n     * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.\r\n     * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])\r\n     */\r\n    public subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;\r\n    // the subEmitters field above converted to a constant type\r\n    private _subEmitters: Array<Array<SubEmitter>>;\r\n    /**\r\n     * @internal\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\r\n    public _disposeEmitterOnDispose = false;\r\n    /**\r\n     * The current active Sub-systems, this property is used by the root particle system only.\r\n     */\r\n    public activeSubSystems: Array<ParticleSystem>;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is CPU based */\r\n    public readonly isGPU = false;\r\n\r\n    private _rootParticleSystem: Nullable<ParticleSystem>;\r\n    //end of Sub-emitter\r\n\r\n    /**\r\n     * Gets the current list of active particles\r\n     */\r\n    public get particles(): Particle[] {\r\n        return this._particles;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return this._stopped && this.isAlive();\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n        if (this._customWrappers[blendMode]!.drawContext) {\r\n            this._customWrappers[blendMode]!.drawContext!.useInstancing = this._useInstancing;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    private _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"particles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param capacity The max number of particles alive at the same time\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     * @param epsilon Offset used to render the particles\r\n     */\r\n    constructor(\r\n        name: string,\r\n        capacity: number,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false,\r\n        epsilon: number = 0.01\r\n    ) {\r\n        super(name);\r\n\r\n        this._capacity = capacity;\r\n\r\n        this._epsilon = epsilon;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = [];\r\n        this._useInstancing = this._engine.getCaps().instancedArrays;\r\n\r\n        this._createIndexBuffer();\r\n        this._createVertexBuffers();\r\n\r\n        // Default emitter type\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n        let noiseTextureData: Nullable<Uint8Array> = null;\r\n\r\n        // Update\r\n        this.updateFunction = (particles: Particle[]): void => {\r\n            let noiseTextureSize: Nullable<ISize> = null;\r\n\r\n            if (this.noiseTexture) {\r\n                // We need to get texture data back to CPU\r\n                noiseTextureSize = this.noiseTexture.getSize();\r\n                this.noiseTexture.getContent()?.then((data) => {\r\n                    noiseTextureData = data as Uint8Array;\r\n                });\r\n            }\r\n\r\n            const sameParticleArray = particles === this._particles;\r\n\r\n            for (let index = 0; index < particles.length; index++) {\r\n                const particle = particles[index];\r\n\r\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\r\n                const previousAge = particle.age;\r\n                particle.age += scaledUpdateSpeed;\r\n\r\n                // Evaluate step to death\r\n                if (particle.age > particle.lifeTime) {\r\n                    const diff = particle.age - previousAge;\r\n                    const oldDiff = particle.lifeTime - previousAge;\r\n\r\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\r\n\r\n                    particle.age = particle.lifeTime;\r\n                }\r\n\r\n                const ratio = particle.age / particle.lifeTime;\r\n\r\n                // Color\r\n                if (this._colorGradients && this._colorGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentColorGradient) {\r\n                            particle._currentColor1.copyFrom(particle._currentColor2);\r\n                            (<ColorGradient>nextGradient).getColorToRef(particle._currentColor2);\r\n                            particle._currentColorGradient = <ColorGradient>currentGradient;\r\n                        }\r\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\r\n                    });\r\n                } else {\r\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\r\n                    particle.color.addInPlace(this._scaledColorStep);\r\n\r\n                    if (particle.color.a < 0) {\r\n                        particle.color.a = 0;\r\n                    }\r\n                }\r\n\r\n                // Angular speed\r\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\r\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\r\n                            particle._currentAngularSpeed2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentAngularSpeedGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\r\n                    });\r\n                }\r\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\r\n\r\n                // Direction\r\n                let directionScale = scaledUpdateSpeed;\r\n\r\n                /// Velocity\r\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentVelocityGradient) {\r\n                            particle._currentVelocity1 = particle._currentVelocity2;\r\n                            particle._currentVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\r\n                    });\r\n                }\r\n\r\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\r\n\r\n                /// Limit velocity\r\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\r\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\r\n                            particle._currentLimitVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentLimitVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\r\n                        const currentVelocity = particle.direction.length();\r\n\r\n                        if (currentVelocity > limitVelocity) {\r\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /// Drag\r\n                if (this._dragGradients && this._dragGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentDragGradient) {\r\n                            particle._currentDrag1 = particle._currentDrag2;\r\n                            particle._currentDrag2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentDragGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\r\n\r\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\r\n                    });\r\n                }\r\n\r\n                if (this.isLocal && particle._localPosition) {\r\n                    particle._localPosition!.addInPlace(this._scaledDirection);\r\n                    Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n                } else {\r\n                    particle.position.addInPlace(this._scaledDirection);\r\n                }\r\n\r\n                // Noise\r\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\r\n                    const fetchedColorR = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.x,\r\n                        particle._randomNoiseCoordinates1.y,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorG = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.z,\r\n                        particle._randomNoiseCoordinates2.x,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorB = this._fetchR(\r\n                        particle._randomNoiseCoordinates2.y,\r\n                        particle._randomNoiseCoordinates2.z,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n\r\n                    const force = TmpVectors.Vector3[0];\r\n                    const scaledForce = TmpVectors.Vector3[1];\r\n\r\n                    force.copyFromFloats(\r\n                        (2 * fetchedColorR - 1) * this.noiseStrength.x,\r\n                        (2 * fetchedColorG - 1) * this.noiseStrength.y,\r\n                        (2 * fetchedColorB - 1) * this.noiseStrength.z\r\n                    );\r\n\r\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\r\n                    particle.direction.addInPlace(scaledForce);\r\n                }\r\n\r\n                // Gravity\r\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\r\n                particle.direction.addInPlace(this._scaledGravity);\r\n\r\n                // Size\r\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentSizeGradient) {\r\n                            particle._currentSize1 = particle._currentSize2;\r\n                            particle._currentSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentSizeGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\r\n                    });\r\n                }\r\n\r\n                // Remap data\r\n                if (this._useRampGradients) {\r\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.x = min;\r\n                            particle.remapData.y = max - min;\r\n                        });\r\n                    }\r\n\r\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.z = min;\r\n                            particle.remapData.w = max - min;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this._isAnimationSheetEnabled) {\r\n                    particle.updateCellIndex();\r\n                }\r\n\r\n                // Update the position of the attached sub-emitters to match their attached particle\r\n                particle._inheritParticleInfoToSubEmitters();\r\n\r\n                if (particle.age >= particle.lifeTime) {\r\n                    // Recycle by swapping with last particle\r\n                    this._emitFromParticle(particle);\r\n                    if (particle._attachedSubEmitters) {\r\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\r\n                            subEmitter.particleSystem.disposeOnStop = true;\r\n                            subEmitter.particleSystem.stop();\r\n                        });\r\n                        particle._attachedSubEmitters = null;\r\n                    }\r\n                    this.recycleParticle(particle);\r\n                    if (sameParticleArray) {\r\n                        index--;\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number, factor2?: number) {\r\n        const newGradient = new FactorGradient(gradient, factor, factor2);\r\n        factorGradients.push(newGradient);\r\n\r\n        factorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    private _removeFactorGradient(factorGradients: Nullable<FactorGradient[]>, gradient: number) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const factorGradient of factorGradients) {\r\n            if (factorGradient.gradient === gradient) {\r\n                factorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new life time gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._lifeTimeGradients) {\r\n            this._lifeTimeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific life time gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._sizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._colorRemapGradients) {\r\n            this._colorRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new alpha remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._alphaRemapGradients) {\r\n            this._alphaRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific alpha remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed  to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._velocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._dragGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._emitRateGradients) {\r\n            this._emitRateGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific emit rate gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._emitRateGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._startSizeGradients) {\r\n            this._startSizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific start size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._startSizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _createRampGradientTexture() {\r\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color3[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\r\n                Color3.LerpToRef((<Color3Gradient>currentGradient).color, (<Color3Gradient>nextGradient).color, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = 255;\r\n            });\r\n        }\r\n\r\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of ramp gradients.\r\n     * You must use addRampGradient and removeRampGradient to update this list\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return this._rampGradients;\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._syncRampGradientTexture();\r\n    }\r\n\r\n    private _syncRampGradientTexture() {\r\n        if (!this._rampGradients) {\r\n            return;\r\n        }\r\n\r\n        this._rampGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._createRampGradientTexture();\r\n    }\r\n\r\n    /**\r\n     * Adds a new ramp gradient used to remap particle colors\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(gradient: number, color: Color3): ParticleSystem {\r\n        if (!this._rampGradients) {\r\n            this._rampGradients = [];\r\n        }\r\n\r\n        const rampGradient = new Color3Gradient(gradient, color);\r\n        this._rampGradients.push(rampGradient);\r\n\r\n        this._syncRampGradientTexture();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific ramp gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(gradient: number): ParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\r\n        this._rampGradientsTexture = null;\r\n\r\n        if (this._rampGradients && this._rampGradients.length > 0) {\r\n            this._createRampGradientTexture();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns this particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1, color2);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._colorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns this particle system\r\n     */\r\n    public removeColorGradient(gradient: number): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const colorGradient of this._colorGradients) {\r\n            if (colorGradient.gradient === gradient) {\r\n                this._colorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const drawWrappers of this._drawWrappers) {\r\n            if (drawWrappers) {\r\n                for (const drawWrapper of drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    private _fetchR(u: number, v: number, width: number, height: number, pixels: Uint8Array): number {\r\n        u = Math.abs(u) * 0.5 + 0.5;\r\n        v = Math.abs(v) * 0.5 + 0.5;\r\n\r\n        const wrappedU = (u * width) % width | 0;\r\n        const wrappedV = (v * height) % height | 0;\r\n\r\n        const position = (wrappedU + wrappedV * width) * 4;\r\n        return pixels[position] / 255;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._resetEffect();\r\n    }\r\n\r\n    private _resetEffect() {\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers() {\r\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexBufferSize += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexBufferSize += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            this._vertexBufferSize += 4;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\r\n        this._vertexData = new Float32Array(this._capacity * vertexSize);\r\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\r\n\r\n        let dataOffset = 0;\r\n        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        dataOffset += 3;\r\n\r\n        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n        dataOffset += 4;\r\n\r\n        const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"angle\"] = options;\r\n        dataOffset += 1;\r\n\r\n        const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"size\"] = size;\r\n        dataOffset += 2;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\r\n            dataOffset += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"direction\"] = directionBuffer;\r\n            dataOffset += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\r\n            dataOffset += 4;\r\n        }\r\n\r\n        let offsets: VertexBuffer;\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\r\n        } else {\r\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n            dataOffset += 2;\r\n        }\r\n        this._vertexBuffers[\"offset\"] = offsets;\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _createIndexBuffer() {\r\n        if (this._useInstancing) {\r\n            this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\r\n            return;\r\n        }\r\n        const indices = [];\r\n        const indicesWireframe = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n        this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets whether there are still active particles in the system.\r\n     * @returns True if it is alive, otherwise false.\r\n     */\r\n    public isAlive(): boolean {\r\n        return this._alive;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    private _prepareSubEmitterInternalArray() {\r\n        this._subEmitters = new Array<Array<SubEmitter>>();\r\n        if (this.subEmitters) {\r\n            this.subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter instanceof ParticleSystem) {\r\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\r\n                } else if (subEmitter instanceof SubEmitter) {\r\n                    this._subEmitters.push([subEmitter]);\r\n                } else if (subEmitter instanceof Array) {\r\n                    this._subEmitters.push(subEmitter);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        // Convert the subEmitters field to the constant type field _subEmitters\r\n        this._prepareSubEmitterInternalArray();\r\n\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._actualFrame = 0;\r\n        if (this._subEmitters && this._subEmitters.length != 0) {\r\n            this.activeSubSystems = new Array<ParticleSystem>();\r\n        }\r\n\r\n        // Reset emit gradient so it acts the same on every start\r\n        if (this._emitRateGradients) {\r\n            if (this._emitRateGradients.length > 0) {\r\n                this._currentEmitRateGradient = this._emitRateGradients[0];\r\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\r\n                this._currentEmitRate2 = this._currentEmitRate1;\r\n            }\r\n            if (this._emitRateGradients.length > 1) {\r\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\r\n            }\r\n        }\r\n        // Reset start size gradient so it acts the same on every start\r\n        if (this._startSizeGradients) {\r\n            if (this._startSizeGradients.length > 0) {\r\n                this._currentStartSizeGradient = this._startSizeGradients[0];\r\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\r\n                this._currentStartSize2 = this._currentStartSize1;\r\n            }\r\n            if (this._startSizeGradients.length > 1) {\r\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\r\n            }\r\n        }\r\n\r\n        if (this.preWarmCycles) {\r\n            if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\r\n                (this.emitter as any).computeWorldMatrix(true);\r\n            }\r\n\r\n            const noiseTextureAsProcedural = this.noiseTexture as ProceduralTexture;\r\n\r\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\r\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\r\n                    setTimeout(() => {\r\n                        for (let index = 0; index < this.preWarmCycles; index++) {\r\n                            this.animate(true);\r\n                            noiseTextureAsProcedural.render();\r\n                        }\r\n                    });\r\n                });\r\n            } else {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n     */\r\n    public stop(stopSubEmitters = true): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n\r\n        this.onStoppedObservable.notifyObservers(this);\r\n\r\n        this._stopped = true;\r\n\r\n        if (stopSubEmitters) {\r\n            this._stopSubEmitters();\r\n        }\r\n    }\r\n\r\n    // animation sheet\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._stockParticles.length = 0;\r\n        this._particles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal (for internal use only)\r\n     */\r\n    public _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void {\r\n        let offset = index * this._vertexBufferSize;\r\n\r\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\r\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\r\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\r\n        this._vertexData[offset++] = particle.color.r;\r\n        this._vertexData[offset++] = particle.color.g;\r\n        this._vertexData[offset++] = particle.color.b;\r\n        this._vertexData[offset++] = particle.color.a;\r\n        this._vertexData[offset++] = particle.angle;\r\n\r\n        this._vertexData[offset++] = particle.scale.x * particle.size;\r\n        this._vertexData[offset++] = particle.scale.y * particle.size;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexData[offset++] = particle.cellIndex;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            if (particle._initialDirection) {\r\n                let initialDirection = particle._initialDirection;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    initialDirection = TmpVectors.Vector3[0];\r\n                }\r\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\r\n                    initialDirection.x = 0.001;\r\n                }\r\n\r\n                this._vertexData[offset++] = initialDirection.x;\r\n                this._vertexData[offset++] = initialDirection.y;\r\n                this._vertexData[offset++] = initialDirection.z;\r\n            } else {\r\n                let direction = particle.direction;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    direction = TmpVectors.Vector3[0];\r\n                }\r\n\r\n                if (direction.x === 0 && direction.z === 0) {\r\n                    direction.x = 0.001;\r\n                }\r\n                this._vertexData[offset++] = direction.x;\r\n                this._vertexData[offset++] = direction.y;\r\n                this._vertexData[offset++] = direction.z;\r\n            }\r\n        } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexData[offset++] = particle.direction.x;\r\n            this._vertexData[offset++] = particle.direction.y;\r\n            this._vertexData[offset++] = particle.direction.z;\r\n        }\r\n\r\n        if (this._useRampGradients && particle.remapData) {\r\n            this._vertexData[offset++] = particle.remapData.x;\r\n            this._vertexData[offset++] = particle.remapData.y;\r\n            this._vertexData[offset++] = particle.remapData.z;\r\n            this._vertexData[offset++] = particle.remapData.w;\r\n        }\r\n\r\n        if (!this._useInstancing) {\r\n            if (this._isAnimationSheetEnabled) {\r\n                if (offsetX === 0) {\r\n                    offsetX = this._epsilon;\r\n                } else if (offsetX === 1) {\r\n                    offsetX = 1 - this._epsilon;\r\n                }\r\n\r\n                if (offsetY === 0) {\r\n                    offsetY = this._epsilon;\r\n                } else if (offsetY === 1) {\r\n                    offsetY = 1 - this._epsilon;\r\n                }\r\n            }\r\n\r\n            this._vertexData[offset++] = offsetX;\r\n            this._vertexData[offset++] = offsetY;\r\n        }\r\n    }\r\n\r\n    // start of sub system methods\r\n\r\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     * @param particle\r\n     */\r\n    public recycleParticle: (particle: Particle) => void = (particle) => {\r\n        // move particle from activeParticle list to stock particles\r\n        const lastParticle = <Particle>this._particles.pop();\r\n        if (lastParticle !== particle) {\r\n            lastParticle.copyTo(particle);\r\n        }\r\n        this._stockParticles.push(lastParticle);\r\n    };\r\n\r\n    private _stopSubEmitters(): void {\r\n        if (!this.activeSubSystems) {\r\n            return;\r\n        }\r\n        this.activeSubSystems.forEach((subSystem) => {\r\n            subSystem.stop(true);\r\n        });\r\n        this.activeSubSystems = new Array<ParticleSystem>();\r\n    }\r\n\r\n    private _createParticle: () => Particle = () => {\r\n        let particle: Particle;\r\n        if (this._stockParticles.length !== 0) {\r\n            particle = <Particle>this._stockParticles.pop();\r\n            particle._reset();\r\n        } else {\r\n            particle = new Particle(this);\r\n        }\r\n\r\n        // Attach emitters\r\n        if (this._subEmitters && this._subEmitters.length > 0) {\r\n            const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\r\n            particle._attachedSubEmitters = [];\r\n            subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter.type === SubEmitterType.ATTACHED) {\r\n                    const newEmitter = subEmitter.clone();\r\n                    (<Array<SubEmitter>>particle._attachedSubEmitters).push(newEmitter);\r\n                    newEmitter.particleSystem.start();\r\n                }\r\n            });\r\n        }\r\n        return particle;\r\n    };\r\n\r\n    private _removeFromRoot(): void {\r\n        if (!this._rootParticleSystem) {\r\n            return;\r\n        }\r\n\r\n        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\r\n        if (index !== -1) {\r\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\r\n        }\r\n\r\n        this._rootParticleSystem = null;\r\n    }\r\n\r\n    private _emitFromParticle: (particle: Particle) => void = (particle) => {\r\n        if (!this._subEmitters || this._subEmitters.length === 0) {\r\n            return;\r\n        }\r\n        const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\r\n\r\n        this._subEmitters[templateIndex].forEach((subEmitter) => {\r\n            if (subEmitter.type === SubEmitterType.END) {\r\n                const subSystem = subEmitter.clone();\r\n                particle._inheritParticleInfoToSubEmitter(subSystem);\r\n                subSystem.particleSystem._rootParticleSystem = this;\r\n                this.activeSubSystems.push(subSystem.particleSystem);\r\n                subSystem.particleSystem.start();\r\n            }\r\n        });\r\n    };\r\n\r\n    // End of sub system methods\r\n\r\n    private _update(newParticles: number): void {\r\n        // Update current\r\n        this._alive = this._particles.length > 0;\r\n\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\r\n        this.updateFunction(this._particles);\r\n\r\n        // Add new ones\r\n        let particle: Particle;\r\n        for (let index = 0; index < newParticles; index++) {\r\n            if (this._particles.length === this._capacity) {\r\n                break;\r\n            }\r\n\r\n            particle = this._createParticle();\r\n\r\n            this._particles.push(particle);\r\n\r\n            // Life time\r\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\r\n                const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\r\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\r\n                    const factorGradient1 = <FactorGradient>currentGradient;\r\n                    const factorGradient2 = <FactorGradient>nextGradient;\r\n                    const lifeTime1 = factorGradient1.getFactor();\r\n                    const lifeTime2 = factorGradient2.getFactor();\r\n                    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\r\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\r\n                });\r\n            } else {\r\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\r\n            }\r\n\r\n            // Emitter\r\n            const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\r\n\r\n            if (this.startPositionFunction) {\r\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            }\r\n\r\n            if (this.isLocal) {\r\n                if (!particle._localPosition) {\r\n                    particle._localPosition = particle.position.clone();\r\n                } else {\r\n                    particle._localPosition.copyFrom(particle.position);\r\n                }\r\n                Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n            }\r\n\r\n            if (this.startDirectionFunction) {\r\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\r\n            }\r\n\r\n            if (emitPower === 0) {\r\n                if (!particle._initialDirection) {\r\n                    particle._initialDirection = particle.direction.clone();\r\n                } else {\r\n                    particle._initialDirection.copyFrom(particle.direction);\r\n                }\r\n            } else {\r\n                particle._initialDirection = null;\r\n            }\r\n\r\n            particle.direction.scaleInPlace(emitPower);\r\n\r\n            // Size\r\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\r\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\r\n            } else {\r\n                particle._currentSizeGradient = this._sizeGradients[0];\r\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\r\n                particle.size = particle._currentSize1;\r\n\r\n                if (this._sizeGradients.length > 1) {\r\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentSize2 = particle._currentSize1;\r\n                }\r\n            }\r\n            // Size and scale\r\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\r\n\r\n            // Adjust scale by start size\r\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentStartSizeGradient) {\r\n                        this._currentStartSize1 = this._currentStartSize2;\r\n                        this._currentStartSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentStartSizeGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\r\n                    particle.scale.scaleInPlace(value);\r\n                });\r\n            }\r\n\r\n            // Angle\r\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\r\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\r\n            } else {\r\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\r\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\r\n                particle._currentAngularSpeed1 = particle.angularSpeed;\r\n\r\n                if (this._angularSpeedGradients.length > 1) {\r\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\r\n                }\r\n            }\r\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\r\n\r\n            // Velocity\r\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                particle._currentVelocityGradient = this._velocityGradients[0];\r\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\r\n\r\n                if (this._velocityGradients.length > 1) {\r\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentVelocity2 = particle._currentVelocity1;\r\n                }\r\n            }\r\n\r\n            // Limit velocity\r\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\r\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\r\n\r\n                if (this._limitVelocityGradients.length > 1) {\r\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\r\n                }\r\n            }\r\n\r\n            // Drag\r\n            if (this._dragGradients && this._dragGradients.length > 0) {\r\n                particle._currentDragGradient = this._dragGradients[0];\r\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\r\n\r\n                if (this._dragGradients.length > 1) {\r\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentDrag2 = particle._currentDrag1;\r\n                }\r\n            }\r\n\r\n            // Color\r\n            if (!this._colorGradients || this._colorGradients.length === 0) {\r\n                const step = Scalar.RandomRange(0, 1.0);\r\n\r\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\r\n\r\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\r\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\r\n            } else {\r\n                particle._currentColorGradient = this._colorGradients[0];\r\n                particle._currentColorGradient.getColorToRef(particle.color);\r\n                particle._currentColor1.copyFrom(particle.color);\r\n\r\n                if (this._colorGradients.length > 1) {\r\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\r\n                } else {\r\n                    particle._currentColor2.copyFrom(particle.color);\r\n                }\r\n            }\r\n\r\n            // Sheet\r\n            if (this._isAnimationSheetEnabled) {\r\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\r\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\r\n                particle._initialSpriteCellLoop = this.spriteCellLoop;\r\n            }\r\n\r\n            // Inherited Velocity\r\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\r\n\r\n            // Ramp\r\n            if (this._useRampGradients) {\r\n                particle.remapData = new Vector4(0, 1, 0, 1);\r\n            }\r\n\r\n            // Noise texture coordinates\r\n            if (this.noiseTexture) {\r\n                if (particle._randomNoiseCoordinates1) {\r\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                } else {\r\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                }\r\n            }\r\n\r\n            // Update the position of the attached sub-emitters to match their attached particle\r\n            particle._inheritParticleInfoToSubEmitters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        if (useRampGradients) {\r\n            attributeNamesOrOptions.push(\"remapData\");\r\n        }\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false): string[] {\r\n        const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\r\n\r\n        addClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"particlesInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number) {\r\n        if (this._scene) {\r\n            prepareStringDefinesForClipPlanes(this, this._scene, defines);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            defines.push(\"#define RAMPGRADIENT\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n                        defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\r\n                    }\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...ParticleSystem._GetAttributeNamesOrOptions(\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL,\r\n                this._useRampGradients\r\n            )\r\n        );\r\n\r\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\r\n\r\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        const currentRenderPassId = this._engine._features.supportRenderPasses ? (this._engine as Engine).currentRenderPassId : Constants.RENDERPASS_MAIN;\r\n        let drawWrappers = this._drawWrappers[currentRenderPassId];\r\n        if (!drawWrappers) {\r\n            drawWrappers = this._drawWrappers[currentRenderPassId] = [];\r\n        }\r\n        let drawWrapper = drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = this._useInstancing;\r\n            }\r\n            drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributesNamesOrOptions: Array<string> = [];\r\n            const effectCreationOption: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n     */\r\n    public animate(preWarmOnly = false): void {\r\n        if (!this._started) {\r\n            return;\r\n        }\r\n\r\n        if (!preWarmOnly && this._scene) {\r\n            // Check\r\n            if (!this.isReady()) {\r\n                return;\r\n            }\r\n\r\n            if (this._currentRenderId === this._scene.getFrameId()) {\r\n                return;\r\n            }\r\n            this._currentRenderId = this._scene.getFrameId();\r\n        }\r\n\r\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n\r\n        // Determine the number of particles we need to create\r\n        let newParticles;\r\n\r\n        if (this.manualEmitCount > -1) {\r\n            newParticles = this.manualEmitCount;\r\n            this._newPartsExcess = 0;\r\n            this.manualEmitCount = 0;\r\n        } else {\r\n            let rate = this.emitRate;\r\n\r\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentEmitRateGradient) {\r\n                        this._currentEmitRate1 = this._currentEmitRate2;\r\n                        this._currentEmitRate2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentEmitRateGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\r\n                });\r\n            }\r\n\r\n            newParticles = (rate * this._scaledUpdateSpeed) >> 0;\r\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\r\n        }\r\n\r\n        if (this._newPartsExcess > 1.0) {\r\n            newParticles += this._newPartsExcess >> 0;\r\n            this._newPartsExcess -= this._newPartsExcess >> 0;\r\n        }\r\n\r\n        this._alive = false;\r\n\r\n        if (!this._stopped) {\r\n            this._actualFrame += this._scaledUpdateSpeed;\r\n\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        } else {\r\n            newParticles = 0;\r\n        }\r\n        this._update(newParticles);\r\n\r\n        // Stopped?\r\n        if (this._stopped) {\r\n            if (!this._alive) {\r\n                this._started = false;\r\n                if (this.onAnimationEnd) {\r\n                    this.onAnimationEnd();\r\n                }\r\n                if (this.disposeOnStop && this._scene) {\r\n                    this._scene._toBeDisposed.push(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!preWarmOnly) {\r\n            // Update VBO\r\n            let offset = 0;\r\n            for (let index = 0; index < this._particles.length; index++) {\r\n                const particle = this._particles[index];\r\n                this._appendParticleVertices(offset, particle);\r\n                offset += this._useInstancing ? 1 : 4;\r\n            }\r\n\r\n            if (this._vertexBuffer) {\r\n                this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\r\n            }\r\n        }\r\n\r\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\r\n            this.stop();\r\n        }\r\n    }\r\n\r\n    private _appendParticleVertices(offset: number, particle: Particle) {\r\n        this._appendParticleVertex(offset++, particle, 0, 0);\r\n        if (!this._useInstancing) {\r\n            this._appendParticleVertex(offset++, particle, 1, 0);\r\n            this._appendParticleVertex(offset++, particle, 1, 1);\r\n            this._appendParticleVertex(offset++, particle, 0, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system.\r\n     */\r\n    public rebuild(): void {\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._spriteBuffer?._rebuild();\r\n\r\n        this._vertexBuffer?._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _render(blendMode: number) {\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        const engine = this._engine;\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        const viewMatrix = this.defaultViewMatrix ?? this._scene!.getViewMatrix();\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\r\n        }\r\n\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            if (!this._rampGradients || !this._rampGradients.length) {\r\n                this._rampGradientsTexture.dispose();\r\n                this._rampGradientsTexture = null;\r\n            }\r\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            bindClipPlane(effect, this, this._scene);\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\r\n        }\r\n\r\n        if (this._vertexArrayObject !== undefined) {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);\r\n            } else {\r\n                if (!this._vertexArrayObject) {\r\n                    this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, null, effect);\r\n                }\r\n\r\n                this._engine.bindVertexArrayObject(this._vertexArrayObject, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : this._indexBuffer);\r\n            }\r\n        } else {\r\n            if (!this._indexBuffer) {\r\n                // Use instancing mode\r\n                engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null, effect);\r\n            } else {\r\n                engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBuffer : this._indexBuffer, effect);\r\n            }\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        if (this._useInstancing) {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.drawElementsType(Constants.MATERIAL_LineStripDrawMode, 0, 10, this._particles.length);\r\n            } else {\r\n                engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._particles.length);\r\n            }\r\n        } else {\r\n            if (this._scene?.forceWireframe) {\r\n                engine.drawElementsType(Constants.MATERIAL_WireFrameFillMode, 0, this._particles.length * 10);\r\n            } else {\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, this._particles.length * 6);\r\n            }\r\n        }\r\n\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state.\r\n     * @returns the current number of particles\r\n     */\r\n    public render(): number {\r\n        // Check\r\n        if (!this.isReady() || !this._particles.length) {\r\n            return 0;\r\n        }\r\n\r\n        const engine = this._engine as any;\r\n        if (engine.setState) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n        }\r\n\r\n        let outparticles = 0;\r\n\r\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\r\n        } else {\r\n            outparticles = this._render(this.blendMode);\r\n        }\r\n\r\n        this._engine.unbindInstanceAttributes();\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        this.resetDrawCache();\r\n\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this._linesIndexBuffer) {\r\n            this._engine._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        if (this._linesIndexBufferUseInstancing) {\r\n            this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);\r\n            this._linesIndexBufferUseInstancing = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._removeFromRoot();\r\n\r\n        if (this.subEmitters && !this._subEmitters) {\r\n            this._prepareSubEmitterInternalArray();\r\n        }\r\n\r\n        if (this._subEmitters && this._subEmitters.length) {\r\n            for (let index = 0; index < this._subEmitters.length; index++) {\r\n                for (const subEmitter of this._subEmitters[index]) {\r\n                    subEmitter.dispose();\r\n                }\r\n            }\r\n\r\n            this._subEmitters = [];\r\n            this.subEmitters = [];\r\n        }\r\n\r\n        if (this._disposeEmitterOnDispose && this.emitter && (this.emitter as AbstractMesh).dispose) {\r\n            (<AbstractMesh>this.emitter).dispose(true);\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.clear();\r\n        }\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n\r\n            this._scene._activeParticleSystems.dispose();\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this.onStoppedObservable.clear();\r\n\r\n        this.reset();\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): ParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as Engine;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n                if (!custom[0]) {\r\n                    this.setCustomEffect(effect, 0);\r\n                } else {\r\n                    custom[0].effect = effect;\r\n                }\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n        if (!this.preventAutoStart) {\r\n            result.start();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.textureMask = this.textureMask.asArray();\r\n        serializationObject.customShader = this.customShader;\r\n        serializationObject.preventAutoStart = this.preventAutoStart;\r\n\r\n        // SubEmitters\r\n        if (this.subEmitters) {\r\n            serializationObject.subEmitters = [];\r\n\r\n            if (!this._subEmitters) {\r\n                this._prepareSubEmitterInternalArray();\r\n            }\r\n\r\n            for (const subs of this._subEmitters) {\r\n                const cell = [];\r\n                for (const sub of subs) {\r\n                    cell.push(sub.serialize(serializeTexture));\r\n                }\r\n\r\n                serializationObject.subEmitters.push(cell);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean) {\r\n        serializationObject.name = particleSystem.name;\r\n        serializationObject.id = particleSystem.id;\r\n\r\n        serializationObject.capacity = particleSystem.getCapacity();\r\n\r\n        serializationObject.disposeOnStop = particleSystem.disposeOnStop;\r\n        serializationObject.manualEmitCount = particleSystem.manualEmitCount;\r\n\r\n        // Emitter\r\n        if ((<AbstractMesh>particleSystem.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>particleSystem.emitter;\r\n            serializationObject.emitterId = emitterMesh.id;\r\n        } else {\r\n            const emitterPosition = <Vector3>particleSystem.emitter;\r\n            serializationObject.emitter = emitterPosition.asArray();\r\n        }\r\n\r\n        // Emitter\r\n        if (particleSystem.particleEmitterType) {\r\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\r\n        }\r\n\r\n        if (particleSystem.particleTexture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = particleSystem.particleTexture.serialize();\r\n            } else {\r\n                serializationObject.textureName = particleSystem.particleTexture.name;\r\n                serializationObject.invertY = !!(particleSystem.particleTexture as any)._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.isLocal = particleSystem.isLocal;\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\r\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\r\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\r\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\r\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\r\n\r\n        // Particle system\r\n        serializationObject.startDelay = particleSystem.startDelay;\r\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\r\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\r\n        serializationObject.billboardMode = particleSystem.billboardMode;\r\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\r\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\r\n        serializationObject.minSize = particleSystem.minSize;\r\n        serializationObject.maxSize = particleSystem.maxSize;\r\n        serializationObject.minScaleX = particleSystem.minScaleX;\r\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\r\n        serializationObject.minScaleY = particleSystem.minScaleY;\r\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\r\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\r\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\r\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\r\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\r\n        serializationObject.emitRate = particleSystem.emitRate;\r\n        serializationObject.gravity = particleSystem.gravity.asArray();\r\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\r\n        serializationObject.color1 = particleSystem.color1.asArray();\r\n        serializationObject.color2 = particleSystem.color2.asArray();\r\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\r\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\r\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\r\n        serializationObject.blendMode = particleSystem.blendMode;\r\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\r\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\r\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\r\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\r\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\r\n        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\r\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\r\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\r\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\r\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\r\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\r\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\r\n        serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\r\n\r\n        const colorGradients = particleSystem.getColorGradients();\r\n        if (colorGradients) {\r\n            serializationObject.colorGradients = [];\r\n            for (const colorGradient of colorGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorGradient.gradient,\r\n                    color1: colorGradient.color1.asArray(),\r\n                };\r\n\r\n                if (colorGradient.color2) {\r\n                    serializedGradient.color2 = colorGradient.color2.asArray();\r\n                } else {\r\n                    serializedGradient.color2 = colorGradient.color1.asArray();\r\n                }\r\n\r\n                serializationObject.colorGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const rampGradients = particleSystem.getRampGradients();\r\n        if (rampGradients) {\r\n            serializationObject.rampGradients = [];\r\n            for (const rampGradient of rampGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: rampGradient.gradient,\r\n                    color: rampGradient.color.asArray(),\r\n                };\r\n\r\n                serializationObject.rampGradients.push(serializedGradient);\r\n            }\r\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\r\n        }\r\n\r\n        const colorRemapGradients = particleSystem.getColorRemapGradients();\r\n        if (colorRemapGradients) {\r\n            serializationObject.colorRemapGradients = [];\r\n            for (const colorRemapGradient of colorRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorRemapGradient.gradient,\r\n                    factor1: colorRemapGradient.factor1,\r\n                };\r\n\r\n                if (colorRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.colorRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\r\n        if (alphaRemapGradients) {\r\n            serializationObject.alphaRemapGradients = [];\r\n            for (const alphaRemapGradient of alphaRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: alphaRemapGradient.gradient,\r\n                    factor1: alphaRemapGradient.factor1,\r\n                };\r\n\r\n                if (alphaRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.alphaRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const sizeGradients = particleSystem.getSizeGradients();\r\n        if (sizeGradients) {\r\n            serializationObject.sizeGradients = [];\r\n            for (const sizeGradient of sizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: sizeGradient.gradient,\r\n                    factor1: sizeGradient.factor1,\r\n                };\r\n\r\n                if (sizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = sizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = sizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.sizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\r\n        if (angularSpeedGradients) {\r\n            serializationObject.angularSpeedGradients = [];\r\n            for (const angularSpeedGradient of angularSpeedGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: angularSpeedGradient.gradient,\r\n                    factor1: angularSpeedGradient.factor1,\r\n                };\r\n\r\n                if (angularSpeedGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\r\n                }\r\n\r\n                serializationObject.angularSpeedGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const velocityGradients = particleSystem.getVelocityGradients();\r\n        if (velocityGradients) {\r\n            serializationObject.velocityGradients = [];\r\n            for (const velocityGradient of velocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: velocityGradient.gradient,\r\n                    factor1: velocityGradient.factor1,\r\n                };\r\n\r\n                if (velocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = velocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = velocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.velocityGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const dragGradients = particleSystem.getDragGradients();\r\n        if (dragGradients) {\r\n            serializationObject.dragGradients = [];\r\n            for (const dragGradient of dragGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: dragGradient.gradient,\r\n                    factor1: dragGradient.factor1,\r\n                };\r\n\r\n                if (dragGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = dragGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = dragGradient.factor1;\r\n                }\r\n\r\n                serializationObject.dragGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const emitRateGradients = particleSystem.getEmitRateGradients();\r\n        if (emitRateGradients) {\r\n            serializationObject.emitRateGradients = [];\r\n            for (const emitRateGradient of emitRateGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: emitRateGradient.gradient,\r\n                    factor1: emitRateGradient.factor1,\r\n                };\r\n\r\n                if (emitRateGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = emitRateGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = emitRateGradient.factor1;\r\n                }\r\n\r\n                serializationObject.emitRateGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const startSizeGradients = particleSystem.getStartSizeGradients();\r\n        if (startSizeGradients) {\r\n            serializationObject.startSizeGradients = [];\r\n            for (const startSizeGradient of startSizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: startSizeGradient.gradient,\r\n                    factor1: startSizeGradient.factor1,\r\n                };\r\n\r\n                if (startSizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = startSizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = startSizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.startSizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const lifeTimeGradients = particleSystem.getLifeTimeGradients();\r\n        if (lifeTimeGradients) {\r\n            serializationObject.lifeTimeGradients = [];\r\n            for (const lifeTimeGradient of lifeTimeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: lifeTimeGradient.gradient,\r\n                    factor1: lifeTimeGradient.factor1,\r\n                };\r\n\r\n                if (lifeTimeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.lifeTimeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\r\n        if (limitVelocityGradients) {\r\n            serializationObject.limitVelocityGradients = [];\r\n            for (const limitVelocityGradient of limitVelocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: limitVelocityGradient.gradient,\r\n                    factor1: limitVelocityGradient.factor1,\r\n                };\r\n\r\n                if (limitVelocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.limitVelocityGradients.push(serializedGradient);\r\n            }\r\n\r\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (particleSystem.noiseTexture) {\r\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string) {\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            scene = null;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n        }\r\n\r\n        const internalClass = GetClass(\"BABYLON.Texture\");\r\n        if (internalClass && scene) {\r\n            // Texture\r\n            if (parsedParticleSystem.texture) {\r\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl) as BaseTexture;\r\n            } else if (parsedParticleSystem.textureName) {\r\n                particleSystem.particleTexture = new internalClass(\r\n                    rootUrl + parsedParticleSystem.textureName,\r\n                    scene,\r\n                    false,\r\n                    parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true\r\n                );\r\n                particleSystem.particleTexture!.name = parsedParticleSystem.textureName;\r\n            }\r\n        }\r\n\r\n        // Emitter\r\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\r\n            particleSystem.emitter = Vector3.Zero();\r\n        } else if (parsedParticleSystem.emitterId && scene) {\r\n            particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\r\n        } else {\r\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\r\n        }\r\n\r\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\r\n\r\n        // Misc.\r\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\r\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\r\n        }\r\n\r\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\r\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\r\n        }\r\n\r\n        if (parsedParticleSystem.billboardMode !== undefined) {\r\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\r\n        }\r\n\r\n        if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\r\n            particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedParticleSystem.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedParticleSystem.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\r\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\r\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\r\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\r\n        }\r\n\r\n        if (parsedParticleSystem.autoAnimate && scene) {\r\n            scene.beginAnimation(\r\n                particleSystem,\r\n                parsedParticleSystem.autoAnimateFrom,\r\n                parsedParticleSystem.autoAnimateTo,\r\n                parsedParticleSystem.autoAnimateLoop,\r\n                parsedParticleSystem.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        // Particle system\r\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\r\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\r\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\r\n        particleSystem.minSize = parsedParticleSystem.minSize;\r\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\r\n\r\n        if (parsedParticleSystem.minScaleX) {\r\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\r\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\r\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\r\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\r\n        }\r\n\r\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\r\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\r\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\r\n        }\r\n\r\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\r\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\r\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\r\n        }\r\n\r\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\r\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\r\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\r\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\r\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\r\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\r\n        if (parsedParticleSystem.noiseStrength) {\r\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\r\n        }\r\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\r\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\r\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\r\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\r\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\r\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\r\n\r\n        if (parsedParticleSystem.colorGradients) {\r\n            for (const colorGradient of parsedParticleSystem.colorGradients) {\r\n                particleSystem.addColorGradient(\r\n                    colorGradient.gradient,\r\n                    Color4.FromArray(colorGradient.color1),\r\n                    colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.rampGradients) {\r\n            for (const rampGradient of parsedParticleSystem.rampGradients) {\r\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\r\n            }\r\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\r\n        }\r\n\r\n        if (parsedParticleSystem.colorRemapGradients) {\r\n            for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\r\n                particleSystem.addColorRemapGradient(\r\n                    colorRemapGradient.gradient,\r\n                    colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor,\r\n                    colorRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.alphaRemapGradients) {\r\n            for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\r\n                particleSystem.addAlphaRemapGradient(\r\n                    alphaRemapGradient.gradient,\r\n                    alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor,\r\n                    alphaRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.sizeGradients) {\r\n            for (const sizeGradient of parsedParticleSystem.sizeGradients) {\r\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.angularSpeedGradients) {\r\n            for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\r\n                particleSystem.addAngularSpeedGradient(\r\n                    angularSpeedGradient.gradient,\r\n                    angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor,\r\n                    angularSpeedGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.velocityGradients) {\r\n            for (const velocityGradient of parsedParticleSystem.velocityGradients) {\r\n                particleSystem.addVelocityGradient(\r\n                    velocityGradient.gradient,\r\n                    velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor,\r\n                    velocityGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.dragGradients) {\r\n            for (const dragGradient of parsedParticleSystem.dragGradients) {\r\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.emitRateGradients) {\r\n            for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\r\n                particleSystem.addEmitRateGradient(\r\n                    emitRateGradient.gradient,\r\n                    emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor,\r\n                    emitRateGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.startSizeGradients) {\r\n            for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\r\n                particleSystem.addStartSizeGradient(\r\n                    startSizeGradient.gradient,\r\n                    startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor,\r\n                    startSizeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.lifeTimeGradients) {\r\n            for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\r\n                particleSystem.addLifeTimeGradient(\r\n                    lifeTimeGradient.gradient,\r\n                    lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor,\r\n                    lifeTimeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.limitVelocityGradients) {\r\n            for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\r\n                particleSystem.addLimitVelocityGradient(\r\n                    limitVelocityGradient.gradient,\r\n                    limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor,\r\n                    limitVelocityGradient.factor2\r\n                );\r\n            }\r\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (parsedParticleSystem.noiseTexture && scene) {\r\n            const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\r\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\r\n        }\r\n\r\n        // Emitter\r\n        let emitterType: IParticleEmitterType;\r\n        if (parsedParticleSystem.particleEmitterType) {\r\n            switch (parsedParticleSystem.particleEmitterType.type) {\r\n                case \"SphereParticleEmitter\":\r\n                    emitterType = new SphereParticleEmitter();\r\n                    break;\r\n                case \"SphereDirectedParticleEmitter\":\r\n                    emitterType = new SphereDirectedParticleEmitter();\r\n                    break;\r\n                case \"ConeEmitter\":\r\n                case \"ConeParticleEmitter\":\r\n                    emitterType = new ConeParticleEmitter();\r\n                    break;\r\n                case \"CylinderParticleEmitter\":\r\n                    emitterType = new CylinderParticleEmitter();\r\n                    break;\r\n                case \"CylinderDirectedParticleEmitter\":\r\n                    emitterType = new CylinderDirectedParticleEmitter();\r\n                    break;\r\n                case \"HemisphericParticleEmitter\":\r\n                    emitterType = new HemisphericParticleEmitter();\r\n                    break;\r\n                case \"PointParticleEmitter\":\r\n                    emitterType = new PointParticleEmitter();\r\n                    break;\r\n                case \"MeshParticleEmitter\":\r\n                    emitterType = new MeshParticleEmitter();\r\n                    break;\r\n                case \"BoxEmitter\":\r\n                case \"BoxParticleEmitter\":\r\n                default:\r\n                    emitterType = new BoxParticleEmitter();\r\n                    break;\r\n            }\r\n\r\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\r\n        } else {\r\n            emitterType = new BoxParticleEmitter();\r\n            emitterType.parse(parsedParticleSystem, scene);\r\n        }\r\n        particleSystem.particleEmitterType = emitterType;\r\n\r\n        // Animation sheet\r\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\r\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\r\n        particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;\r\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\r\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\r\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\r\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\r\n\r\n        particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;\r\n        particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the Parsed particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): ParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let custom: Nullable<Effect> = null;\r\n        let program: any = null;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            custom = (engine as any).createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n        }\r\n        const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\r\n        particleSystem.customShader = program;\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        // SubEmitters\r\n        if (parsedParticleSystem.subEmitters) {\r\n            particleSystem.subEmitters = [];\r\n            for (const cell of parsedParticleSystem.subEmitters) {\r\n                const cellArray = [];\r\n                for (const sub of cell) {\r\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\r\n                }\r\n\r\n                particleSystem.subEmitters.push(cellArray);\r\n            }\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        if (parsedParticleSystem.textureMask) {\r\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\r\n        }\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n\r\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\r\n","import { Mesh } from \"../Meshes/mesh\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\n\r\n// Adds the parsers to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    const individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n\r\n    if (!individualParser) {\r\n        return;\r\n    }\r\n\r\n    // Particles Systems\r\n    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n        for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n            const parsedParticleSystem = parsedData.particleSystems[index];\r\n            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\r\n        }\r\n    }\r\n});\r\n\r\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem: any, scene: Scene, rootUrl: string) => {\r\n    if (parsedParticleSystem.activeParticleCount) {\r\n        const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    } else {\r\n        const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    }\r\n});\r\n\r\ndeclare module \"../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Create an effect to use with particle systems.\r\n         * Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass\r\n         * the particle system for which you want to create a custom effect in the last parameter\r\n         * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)\r\n         * @param uniformsNames defines a list of attribute names\r\n         * @param samplers defines an array of string used to represent textures\r\n         * @param defines defines the string containing the defines to use to compile the shaders\r\n         * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n         * @param onCompiled defines a function to call when the effect creation is successful\r\n         * @param onError defines a function to call when the effect creation has failed\r\n         * @param particleSystem the particle system you want to create the effect for\r\n         * @returns the new Effect\r\n         */\r\n        createEffectForParticles(\r\n            fragmentName: string,\r\n            uniformsNames: string[],\r\n            samplers: string[],\r\n            defines: string,\r\n            fallbacks?: EffectFallbacks,\r\n            onCompiled?: (effect: Effect) => void,\r\n            onError?: (effect: Effect, errors: string) => void,\r\n            particleSystem?: IParticleSystem\r\n        ): Effect;\r\n    }\r\n}\r\n\r\nEngine.prototype.createEffectForParticles = function (\r\n    fragmentName: string,\r\n    uniformsNames: string[] = [],\r\n    samplers: string[] = [],\r\n    defines = \"\",\r\n    fallbacks?: EffectFallbacks,\r\n    onCompiled?: (effect: Effect) => void,\r\n    onError?: (effect: Effect, errors: string) => void,\r\n    particleSystem?: IParticleSystem\r\n): Effect {\r\n    let attributesNamesOrOptions: Array<string> = [];\r\n    let effectCreationOption: Array<string> = [];\r\n    const allSamplers: Array<string> = [];\r\n\r\n    if (particleSystem) {\r\n        particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\r\n    } else {\r\n        attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\r\n        effectCreationOption = ParticleSystem._GetEffectCreationOptions();\r\n    }\r\n\r\n    if (defines.indexOf(\" BILLBOARD\") === -1) {\r\n        defines += \"\\n#define BILLBOARD\\n\";\r\n    }\r\n\r\n    if (particleSystem?.isAnimationSheetEnabled) {\r\n        if (defines.indexOf(\" ANIMATESHEET\") === -1) {\r\n            defines += \"\\n#define ANIMATESHEET\\n\";\r\n        }\r\n    }\r\n\r\n    if (samplers.indexOf(\"diffuseSampler\") === -1) {\r\n        samplers.push(\"diffuseSampler\");\r\n    }\r\n\r\n    return this.createEffect(\r\n        {\r\n            vertex: particleSystem?.vertexShaderName ?? \"particles\",\r\n            fragmentElement: fragmentName,\r\n        },\r\n        attributesNamesOrOptions,\r\n        effectCreationOption.concat(uniformsNames),\r\n        allSamplers.concat(samplers),\r\n        defines,\r\n        fallbacks,\r\n        onCompiled,\r\n        onError\r\n    );\r\n};\r\n\r\ndeclare module \"../Meshes/mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh is the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getEmittedParticleSystems(): IParticleSystem[];\r\n\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getHierarchyEmittedParticleSystems(): IParticleSystem[];\r\n    }\r\n}\r\n\r\nMesh.prototype.getEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results = new Array<IParticleSystem>();\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        if (particleSystem.emitter === this) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n    return results;\r\n};\r\n\r\nMesh.prototype.getHierarchyEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results = new Array<IParticleSystem>();\r\n    const descendants = this.getDescendants();\r\n    descendants.push(this);\r\n\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        const emitter: any = particleSystem.emitter;\r\n\r\n        if (emitter.position && descendants.indexOf(emitter) !== -1) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n","import type { Nullable } from \"../types\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { ParticleSystem } from \"../Particles/particleSystem\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/** Internal class used to store shapes for emitters */\r\nclass ParticleSystemSetEmitterCreationOptions {\r\n    public kind: string;\r\n    public options: any;\r\n    public renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Represents a set of particle systems working together to create a specific effect\r\n */\r\nexport class ParticleSystemSet implements IDisposable {\r\n    /**\r\n     * Gets or sets base Assets URL\r\n     */\r\n    public static BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\r\n\r\n    private _emitterCreationOptions: ParticleSystemSetEmitterCreationOptions;\r\n    private _emitterNode: Nullable<AbstractMesh | Vector3>;\r\n    private _emitterNodeIsOwned = true;\r\n\r\n    /**\r\n     * Gets the particle system list\r\n     */\r\n    public systems = new Array<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets or sets the emitter node used with this set\r\n     */\r\n    public get emitterNode(): Nullable<AbstractMesh | Vector3> {\r\n        return this._emitterNode;\r\n    }\r\n\r\n    public set emitterNode(value: Nullable<AbstractMesh | Vector3>) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNodeIsOwned = false;\r\n        }\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = value;\r\n        }\r\n\r\n        this._emitterNode = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new emitter mesh as a sphere\r\n     * @param options defines the options used to create the sphere\r\n     * @param options.diameter\r\n     * @param options.segments\r\n     * @param options.color\r\n     * @param renderingGroupId defines the renderingGroupId to use for the sphere\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public setEmitterAsSphere(options: { diameter: number; segments: number; color: Color3 }, renderingGroupId: number, scene: Scene) {\r\n        if (this._emitterNodeIsOwned && this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n        }\r\n\r\n        this._emitterNodeIsOwned = true;\r\n\r\n        this._emitterCreationOptions = {\r\n            kind: \"Sphere\",\r\n            options: options,\r\n            renderingGroupId: renderingGroupId,\r\n        };\r\n\r\n        const emitterMesh = CreateSphere(\"emitterSphere\", { diameter: options.diameter, segments: options.segments }, scene);\r\n        emitterMesh.renderingGroupId = renderingGroupId;\r\n\r\n        const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\r\n        material.emissiveColor = options.color;\r\n        emitterMesh.material = material;\r\n\r\n        for (const system of this.systems) {\r\n            system.emitter = emitterMesh;\r\n        }\r\n\r\n        this._emitterNode = emitterMesh;\r\n    }\r\n\r\n    /**\r\n     * Starts all particle systems of the set\r\n     * @param emitter defines an optional mesh to use as emitter for the particle systems\r\n     */\r\n    public start(emitter?: AbstractMesh): void {\r\n        for (const system of this.systems) {\r\n            if (emitter) {\r\n                system.emitter = emitter;\r\n            }\r\n            system.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        for (const system of this.systems) {\r\n            system.dispose();\r\n        }\r\n\r\n        this.systems.length = 0;\r\n\r\n        if (this._emitterNode) {\r\n            if ((this._emitterNode as AbstractMesh).dispose) {\r\n                (this._emitterNode as AbstractMesh).dispose();\r\n            }\r\n            this._emitterNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the set into a JSON compatible object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns a JSON compatible representation of the set\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const result: any = {};\r\n\r\n        result.systems = [];\r\n        for (const system of this.systems) {\r\n            result.systems.push(system.serialize(serializeTexture));\r\n        }\r\n\r\n        if (this._emitterNode) {\r\n            result.emitter = this._emitterCreationOptions;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Parse a new ParticleSystemSet from a serialized source\r\n     * @param data defines a JSON compatible representation of the set\r\n     * @param scene defines the hosting scene\r\n     * @param gpu defines if we want GPU particles or CPU particles\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a new ParticleSystemSet\r\n     */\r\n    public static Parse(data: any, scene: Scene, gpu = false, capacity?: number): ParticleSystemSet {\r\n        const result = new ParticleSystemSet();\r\n        const rootUrl = this.BaseAssetsUrl + \"/textures/\";\r\n\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        for (const system of data.systems) {\r\n            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\r\n        }\r\n\r\n        if (data.emitter) {\r\n            const options = data.emitter.options;\r\n            switch (data.emitter.kind) {\r\n                case \"Sphere\":\r\n                    result.setEmitterAsSphere(\r\n                        {\r\n                            diameter: options.diameter,\r\n                            segments: options.segments,\r\n                            color: Color3.FromArray(options.color),\r\n                        },\r\n                        data.emitter.renderingGroupId,\r\n                        scene\r\n                    );\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ParticleSystem } from \"../Particles/particleSystem\";\r\n\r\n/**\r\n * Type of sub emitter\r\n */\r\nexport enum SubEmitterType {\r\n    /**\r\n     * Attached to the particle over it's lifetime\r\n     */\r\n    ATTACHED,\r\n    /**\r\n     * Created when the particle dies\r\n     */\r\n    END,\r\n}\r\n\r\n/**\r\n * Sub emitter class used to emit particles from an existing particle\r\n */\r\nexport class SubEmitter {\r\n    /**\r\n     * Type of the submitter (Default: END)\r\n     */\r\n    public type = SubEmitterType.END;\r\n    /**\r\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\r\n     * Note: This only is supported when using an emitter of type Mesh\r\n     */\r\n    public inheritDirection = false;\r\n    /**\r\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\r\n     */\r\n    public inheritedVelocityAmount = 0;\r\n\r\n    /**\r\n     * Creates a sub emitter\r\n     * @param particleSystem the particle system to be used by the sub emitter\r\n     */\r\n    constructor(\r\n        /**\r\n         * the particle system to be used by the sub emitter\r\n         */\r\n        public particleSystem: ParticleSystem\r\n    ) {\r\n        // Create mesh as emitter to support rotation\r\n        if (!particleSystem.emitter || !(<AbstractMesh>particleSystem.emitter).dispose) {\r\n            const internalClass = GetClass(\"BABYLON.AbstractMesh\");\r\n            particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\r\n            particleSystem._disposeEmitterOnDispose = true;\r\n        }\r\n    }\r\n    /**\r\n     * Clones the sub emitter\r\n     * @returns the cloned sub emitter\r\n     */\r\n    public clone(): SubEmitter {\r\n        // Clone particle system\r\n        let emitter = this.particleSystem.emitter;\r\n        if (!emitter) {\r\n            emitter = new Vector3();\r\n        } else if (emitter instanceof Vector3) {\r\n            emitter = emitter.clone();\r\n        } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\r\n            const internalClass = GetClass(\"BABYLON.Mesh\");\r\n            emitter = new internalClass(\"\", emitter.getScene());\r\n            (emitter! as any).isVisible = false;\r\n        }\r\n        const clone = new SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));\r\n\r\n        // Clone properties\r\n        clone.particleSystem.name += \"Clone\";\r\n        clone.type = this.type;\r\n        clone.inheritDirection = this.inheritDirection;\r\n        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n\r\n        clone.particleSystem._disposeEmitterOnDispose = true;\r\n        clone.particleSystem.disposeOnStop = true;\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serialize current object to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(serializeTexture: boolean = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.inheritDirection = this.inheritDirection;\r\n        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n        serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _ParseParticleSystem(system: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false): ParticleSystem {\r\n        throw _WarnImport(\"ParseParticle\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new SubEmitter from a serialized JSON version\r\n     * @param serializationObject defines the JSON object to read from\r\n     * @param sceneOrEngine defines the hosting scene or the hosting engine\r\n     * @param rootUrl defines the rootUrl for data loading\r\n     * @returns a new SubEmitter\r\n     */\r\n    public static Parse(serializationObject: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): SubEmitter {\r\n        const system = serializationObject.particleSystem;\r\n        const subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));\r\n        subEmitter.type = serializationObject.type;\r\n        subEmitter.inheritDirection = serializationObject.inheritDirection;\r\n        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\r\n        subEmitter.particleSystem._isSubEmitter = true;\r\n\r\n        return subEmitter;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose() {\r\n        this.particleSystem.dispose();\r\n    }\r\n}\r\n","import type { Nullable, FloatArray } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { TransformNode } from \"../../../Meshes/transformNode\";\r\nimport { PhysicsEngine } from \"../physicsEngine\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n//declare var require: any;\r\ndeclare let CANNON: any;\r\n\r\n/** @internal */\r\nexport class CannonJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"CannonJSPlugin\";\r\n    private _physicsMaterials = new Array();\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _cannonRaycastResult: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _physicsBodiesToRemoveAfterStep = new Array<any>();\r\n    private _firstFrame = true;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSCANNON: any;\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, iterations: number = 10, cannonInjection = CANNON) {\r\n        this.BJSCANNON = cannonInjection;\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        this._extendNamespace();\r\n\r\n        this.world = new this.BJSCANNON.World();\r\n        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\r\n        this.world.solver.iterations = iterations;\r\n        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3): void {\r\n        const vec = gravity;\r\n        this.world.gravity.set(vec.x, vec.y, vec.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        // due to cannon's architecture, the first frame's before-step is skipped.\r\n        if (this._firstFrame) {\r\n            this._firstFrame = false;\r\n            for (const impostor of impostors) {\r\n                if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\r\n                    impostor.beforeStep();\r\n                }\r\n            }\r\n        }\r\n        this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n    }\r\n\r\n    private _removeMarkedPhysicsBodiesFromWorld(): void {\r\n        if (this._physicsBodiesToRemoveAfterStep.length > 0) {\r\n            this._physicsBodiesToRemoveAfterStep.forEach((physicsBody) => {\r\n                if (typeof this.world.removeBody === \"function\") {\r\n                    this.world.removeBody(physicsBody);\r\n                } else {\r\n                    this.world.remove(physicsBody);\r\n                }\r\n            });\r\n            this._physicsBodiesToRemoveAfterStep.length = 0;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n    }\r\n\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyForce(impulse, worldPoint);\r\n    }\r\n\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n\r\n        //parent-child relationship. Does this impostor have a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        //should a new body be created for this impostor?\r\n        if (impostor.isBodyInitRequired()) {\r\n            const shape = this._createShape(impostor);\r\n            if (!shape) {\r\n                Logger.Warn(\"It was not possible to create a physics body for this object.\");\r\n                return;\r\n            }\r\n\r\n            //unregister events if body is being changed\r\n            const oldBody = impostor.physicsBody;\r\n            if (oldBody) {\r\n                this.removePhysicsBody(impostor);\r\n            }\r\n\r\n            //create the body and material\r\n            const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\r\n\r\n            const bodyCreationObject = {\r\n                mass: impostor.getParam(\"mass\"),\r\n                material: material,\r\n            };\r\n            // A simple extend, in case native options were used.\r\n            const nativeOptions = impostor.getParam(\"nativeOptions\");\r\n            for (const key in nativeOptions) {\r\n                if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\r\n                    (<any>bodyCreationObject)[key] = nativeOptions[key];\r\n                }\r\n            }\r\n            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\r\n            impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\r\n            this.world.addEventListener(\"preStep\", impostor.beforeStep);\r\n            this.world.addEventListener(\"postStep\", impostor.afterStep);\r\n            impostor.physicsBody.addShape(shape);\r\n            if (typeof this.world.addBody === \"function\") {\r\n                this.world.addBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.add(impostor.physicsBody);\r\n            }\r\n\r\n            //try to keep the body moving in the right direction by taking old properties.\r\n            //Should be tested!\r\n            if (oldBody) {\r\n                [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\r\n                    const vec = oldBody[param];\r\n                    impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\r\n                });\r\n            }\r\n            this._processChildMeshes(impostor);\r\n        }\r\n\r\n        //now update the body's transformation\r\n        this._updatePhysicsBodyTransformation(impostor);\r\n    }\r\n\r\n    private _processChildMeshes(mainImpostor: PhysicsImpostor) {\r\n        const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\r\n        const mainRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;\r\n        if (mainRotation) {\r\n            mainRotation.conjugateToRef(this._tmpQuaternion);\r\n        } else {\r\n            this._tmpQuaternion.set(0, 0, 0, 1);\r\n        }\r\n\r\n        if (meshChildren.length) {\r\n            const processMesh = (mesh: AbstractMesh) => {\r\n                if (!mesh.rotationQuaternion) {\r\n                    return;\r\n                }\r\n\r\n                const childImpostor = mesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    const parent = childImpostor.parent;\r\n                    if (parent !== mainImpostor && mesh.parent) {\r\n                        const pPosition = mesh.getAbsolutePosition().subtract((mesh.parent as TransformNode).getAbsolutePosition());\r\n                        const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\r\n\r\n                        if (childImpostor.physicsBody) {\r\n                            this.removePhysicsBody(childImpostor);\r\n                            childImpostor.physicsBody = null;\r\n                        }\r\n                        childImpostor.parent = mainImpostor;\r\n                        childImpostor.resetUpdateFlags();\r\n                        mainImpostor.physicsBody.addShape(\r\n                            this._createShape(childImpostor),\r\n                            new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z),\r\n                            new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)\r\n                        );\r\n                        //Add the mass of the children.\r\n                        mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\r\n                    }\r\n                }\r\n                mesh.getChildMeshes(true)\r\n                    .filter((m) => !!m.physicsImpostor)\r\n                    .forEach(processMesh);\r\n            };\r\n            meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);\r\n        }\r\n    }\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\r\n        this.world.removeEventListener(\"preStep\", impostor.beforeStep);\r\n        this.world.removeEventListener(\"postStep\", impostor.afterStep);\r\n\r\n        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\r\n        if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\r\n            this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\r\n        }\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        let constraint: any;\r\n        const jointData = impostorJoint.joint.jointData;\r\n        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n        const constraintData = {\r\n            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\r\n            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\r\n            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\r\n            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\r\n            maxForce: jointData.nativeParams.maxForce,\r\n            collideConnected: !!jointData.collision,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.HingeJoint:\r\n            case PhysicsJoint.Hinge2Joint:\r\n                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.DistanceJoint:\r\n                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, (<DistanceJointData>jointData).maxDistance || 2);\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                const springData = <SpringJointData>jointData;\r\n                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\r\n                    restLength: springData.length,\r\n                    stiffness: springData.stiffness,\r\n                    damping: springData.damping,\r\n                    localAnchorA: constraintData.pivotA,\r\n                    localAnchorB: constraintData.pivotB,\r\n                });\r\n                break;\r\n            }\r\n            case PhysicsJoint.LockJoint:\r\n                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.PointToPointJoint:\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n            default:\r\n                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\r\n                break;\r\n        }\r\n        //set the collideConnected flag after the creation, since DistanceJoint ignores it.\r\n        constraint.collideConnected = !!jointData.collision;\r\n        impostorJoint.joint.physicsJoint = constraint;\r\n        //don't add spring as constraint, as it is not one.\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.addConstraint(constraint);\r\n        } else {\r\n            (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback =\r\n                (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback ||\r\n                function () {\r\n                    constraint.applyForce();\r\n                };\r\n            impostorJoint.mainImpostor.registerAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        } else {\r\n            impostorJoint.mainImpostor.unregisterAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    private _addMaterial(name: string, friction: number, restitution: number) {\r\n        let index;\r\n        let mat;\r\n\r\n        for (index = 0; index < this._physicsMaterials.length; index++) {\r\n            mat = this._physicsMaterials[index];\r\n\r\n            if (mat.friction === friction && mat.restitution === restitution) {\r\n                return mat;\r\n            }\r\n        }\r\n\r\n        const currentMat = new this.BJSCANNON.Material(name);\r\n        currentMat.friction = friction;\r\n        currentMat.restitution = restitution;\r\n\r\n        this._physicsMaterials.push(currentMat);\r\n        return currentMat;\r\n    }\r\n\r\n    private _checkWithEpsilon(value: number): number {\r\n        return value < Epsilon ? Epsilon : value;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                const radiusX = impostorExtents.x;\r\n                const radiusY = impostorExtents.y;\r\n                const radiusZ = impostorExtents.z;\r\n\r\n                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\r\n\r\n                break;\r\n            }\r\n            //TMP also for cylinder - TODO Cannon supports cylinder natively.\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                let nativeParams = impostor.getParam(\"nativeOptions\");\r\n                if (!nativeParams) {\r\n                    nativeParams = {};\r\n                }\r\n                const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\r\n                const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\r\n                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\r\n\r\n                // Rotate 90 degrees as this shape is horizontal in cannon\r\n                const quat = new this.BJSCANNON.Quaternion();\r\n                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n                const translation = new this.BJSCANNON.Vec3(0, 0, 0);\r\n                returnValue.transformAllPoints(translation, quat);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.BoxImpostor: {\r\n                const box = impostorExtents.scale(0.5);\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\r\n                break;\r\n            }\r\n            case PhysicsImpostor.PlaneImpostor:\r\n                Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\r\n                returnValue = new this.BJSCANNON.Plane();\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                // should transform the vertex data to world coordinates!!\r\n                const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\r\n                const rawFaces = object.getIndices ? object.getIndices() : [];\r\n                if (!rawVerts) {\r\n                    Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\r\n                    return;\r\n                }\r\n                // get only scale! so the object could transform correctly.\r\n                const oldPosition = object.position.clone();\r\n                const oldRotation = object.rotation && object.rotation.clone();\r\n                const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n\r\n                const transform = object.computeWorldMatrix(true);\r\n                // convert rawVerts to object space\r\n                const transformedVertices = new Array<number>();\r\n                let index: number;\r\n                for (index = 0; index < rawVerts.length; index += 3) {\r\n                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\r\n                }\r\n\r\n                Logger.Warn(\"MeshImpostor only collides against spheres.\");\r\n                returnValue = new this.BJSCANNON.Trimesh(transformedVertices, <number[]>rawFaces);\r\n                //now set back the transformation!\r\n                object.position.copyFrom(oldPosition);\r\n                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\r\n                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.HeightmapImpostor: {\r\n                const oldPosition2 = object.position.clone();\r\n                const oldRotation2 = object.rotation && object.rotation.clone();\r\n                const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\r\n\r\n                returnValue = this._createHeightmap(object);\r\n                object.position.copyFrom(oldPosition2);\r\n                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\r\n                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\r\n                object.computeWorldMatrix(true);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.ParticleImpostor:\r\n                returnValue = new this.BJSCANNON.Particle();\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {\r\n        let pos = <FloatArray>object.getVerticesData(VertexBuffer.PositionKind);\r\n        const transform = object.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        const transformedVertices = new Array<number>();\r\n        let index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\r\n        }\r\n        pos = transformedVertices;\r\n        const matrix = new Array<Array<any>>();\r\n\r\n        //For now pointDepth will not be used and will be automatically calculated.\r\n        //Future reference - try and find the best place to add a reference to the pointDepth variable.\r\n        const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\r\n        const boundingInfo = object.getBoundingInfo();\r\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\r\n        const minY = boundingInfo.boundingBox.extendSizeWorld.z;\r\n\r\n        const elementSize = (dim * 2) / arraySize;\r\n\r\n        for (let i = 0; i < pos.length; i = i + 3) {\r\n            const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\r\n            const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\r\n            const y = -pos[i + 2] + minY;\r\n            if (!matrix[x]) {\r\n                matrix[x] = [];\r\n            }\r\n            if (!matrix[x][z]) {\r\n                matrix[x][z] = y;\r\n            }\r\n            matrix[x][z] = Math.max(y, matrix[x][z]);\r\n        }\r\n\r\n        for (let x = 0; x <= arraySize; ++x) {\r\n            if (!matrix[x]) {\r\n                let loc = 1;\r\n                while (!matrix[(x + loc) % arraySize]) {\r\n                    loc++;\r\n                }\r\n                matrix[x] = matrix[(x + loc) % arraySize].slice();\r\n                //console.log(\"missing x\", x);\r\n            }\r\n            for (let z = 0; z <= arraySize; ++z) {\r\n                if (!matrix[x][z]) {\r\n                    let loc = 1;\r\n                    let newValue;\r\n                    while (newValue === undefined) {\r\n                        newValue = matrix[x][(z + loc++) % arraySize];\r\n                    }\r\n                    matrix[x][z] = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        const shape = new this.BJSCANNON.Heightfield(matrix, {\r\n            elementSize: elementSize,\r\n        });\r\n\r\n        //For future reference, needed for body transformation\r\n        shape.minY = minY;\r\n\r\n        return shape;\r\n    }\r\n\r\n    private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _tmpPosition: Vector3 = Vector3.Zero();\r\n    private _tmpDeltaPosition: Vector3 = Vector3.Zero();\r\n    private _tmpUnityRotation: Quaternion = new Quaternion();\r\n\r\n    private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        //make sure it is updated...\r\n        object.computeWorldMatrix && object.computeWorldMatrix(true);\r\n        if (!object.getBoundingInfo()) {\r\n            return;\r\n        }\r\n        const center = impostor.getObjectCenter();\r\n        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\r\n        // The delta between the mesh position and the mesh bounding box center\r\n        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\r\n        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\r\n        this._tmpPosition.copyFrom(center);\r\n        let quaternion = object.rotationQuaternion;\r\n\r\n        if (!quaternion) {\r\n            return;\r\n        }\r\n\r\n        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\r\n        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\r\n        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            //-90 DEG in X, precalculated\r\n            quaternion = quaternion.multiply(this._minus90X);\r\n            //Invert! (Precalculated, 90 deg in X)\r\n            //No need to clone. this will never change.\r\n            impostor.setDeltaRotation(this._plus90X);\r\n        }\r\n\r\n        //If it is a heightfield, if should be centered.\r\n        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            const mesh = <AbstractMesh>(<any>object);\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n            //calculate the correct body position:\r\n            const rotationQuaternion = mesh.rotationQuaternion;\r\n            mesh.rotationQuaternion = this._tmpUnityRotation;\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //get original center with no rotation\r\n            const c = center.clone();\r\n\r\n            let oldPivot = mesh.getPivotMatrix();\r\n            if (oldPivot) {\r\n                // create a copy the pivot Matrix as it is modified in place\r\n                oldPivot = oldPivot.clone();\r\n            } else {\r\n                oldPivot = Matrix.Identity();\r\n            }\r\n\r\n            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\r\n            const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\r\n            mesh.setPreTransformMatrix(p);\r\n            mesh.computeWorldMatrix(true);\r\n            // force bounding box recomputation\r\n            boundingInfo = mesh.getBoundingInfo();\r\n\r\n            //calculate the translation\r\n            const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\r\n\r\n            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\r\n            //add it inverted to the delta\r\n            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\r\n            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\r\n            //rotation is back\r\n            mesh.rotationQuaternion = rotationQuaternion;\r\n\r\n            mesh.setPreTransformMatrix(oldPivot);\r\n            mesh.computeWorldMatrix(true);\r\n        } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpDeltaPosition);\r\n        //Now update the impostor object\r\n        impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\r\n        impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\r\n        if (impostor.object.rotationQuaternion) {\r\n            const q = impostor.physicsBody.quaternion;\r\n            impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSCANNON !== undefined;\r\n    }\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.velocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        impostor.physicsBody.mass = mass;\r\n        impostor.physicsBody.updateMassProperties();\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.mass;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.material.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.material.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.wakeUp();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number) {\r\n        joint.physicsJoint.distance = maxDistance;\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        if (!motorIndex) {\r\n            joint.physicsJoint.enableMotor();\r\n            joint.physicsJoint.setMotorSpeed(speed);\r\n            if (maxForce) {\r\n                this.setLimit(joint, maxForce);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, minForce: number, maxForce?: number) {\r\n        joint.physicsJoint.motorEquation.maxForce = maxForce;\r\n        joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.quaternion.x;\r\n            mesh.rotationQuaternion.y = body.quaternion.y;\r\n            mesh.rotationQuaternion.z = body.quaternion.z;\r\n            mesh.rotationQuaternion.w = body.quaternion.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        return shape.boundingSphereRadius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        result.x = shape.halfExtents.x * 2;\r\n        result.y = shape.halfExtents.y * 2;\r\n        result.z = shape.halfExtents.z * 2;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    private _extendNamespace() {\r\n        //this will force cannon to execute at least one step when using interpolation\r\n        const step_tmp1 = new this.BJSCANNON.Vec3();\r\n        const engine = this.BJSCANNON;\r\n        this.BJSCANNON.World.prototype.step = function (dt: number, timeSinceLastCalled: number, maxSubSteps: number) {\r\n            maxSubSteps = maxSubSteps || 10;\r\n            timeSinceLastCalled = timeSinceLastCalled || 0;\r\n            if (timeSinceLastCalled === 0) {\r\n                this.internalStep(dt);\r\n                this.time += dt;\r\n            } else {\r\n                let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\r\n                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\r\n                const t0 = performance.now();\r\n                for (let i = 0; i !== internalSteps; i++) {\r\n                    this.internalStep(dt);\r\n                    if (performance.now() - t0 > dt * 1000) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.time += timeSinceLastCalled;\r\n                const h = this.time % dt;\r\n                const h_div_dt = h / dt;\r\n                const interpvelo = step_tmp1;\r\n                const bodies = this.bodies;\r\n                for (let j = 0; j !== bodies.length; j++) {\r\n                    const b = bodies[j];\r\n                    if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\r\n                        b.position.vsub(b.previousPosition, interpvelo);\r\n                        interpvelo.scale(h_div_dt, interpvelo);\r\n                        b.position.vadd(interpvelo, b.interpolatedPosition);\r\n                    } else {\r\n                        b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\r\n                        b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._raycastResult.reset(from, to);\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._cannonRaycastResult.reset();\r\n        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\r\n\r\n        result.reset(from, to);\r\n        if (this._cannonRaycastResult.hasHit) {\r\n            // TODO: do we also want to get the body it hit?\r\n            result.setHitData(\r\n                {\r\n                    x: this._cannonRaycastResult.hitNormalWorld.x,\r\n                    y: this._cannonRaycastResult.hitNormalWorld.y,\r\n                    z: this._cannonRaycastResult.hitNormalWorld.z,\r\n                },\r\n                {\r\n                    x: this._cannonRaycastResult.hitPointWorld.x,\r\n                    y: this._cannonRaycastResult.hitPointWorld.y,\r\n                    z: this._cannonRaycastResult.hitPointWorld.z,\r\n                }\r\n            );\r\n            result.setHitDistance(this._cannonRaycastResult.distance);\r\n        }\r\n    }\r\n}\r\n\r\nPhysicsEngine.DefaultPluginFactory = () => {\r\n    return new CannonJSPlugin();\r\n};\r\n","import type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\ndeclare let OIMO: any;\r\n\r\n/** @internal */\r\nexport class OimoJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"OimoJSPlugin\";\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSOIMO: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n\r\n    constructor(private _useDeltaForWorldStep: boolean = true, iterations?: number, oimoInjection = OIMO) {\r\n        this.BJSOIMO = oimoInjection;\r\n        this.world = new this.BJSOIMO.World({\r\n            iterations: iterations,\r\n        });\r\n        this.world.clear();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3) {\r\n        this.world.gravity.set(gravity.x, gravity.y, gravity.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this.world.timeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this.world.timeStep;\r\n    }\r\n\r\n    private _tmpImpostorsArray: Array<PhysicsImpostor> = [];\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>) {\r\n        impostors.forEach(function (impostor) {\r\n            impostor.beforeStep();\r\n        });\r\n\r\n        this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\r\n        this.world.step();\r\n\r\n        impostors.forEach((impostor) => {\r\n            impostor.afterStep();\r\n            //update the ordered impostors array\r\n            this._tmpImpostorsArray[impostor.uniqueId] = impostor;\r\n        });\r\n\r\n        //check for collisions\r\n        let contact = this.world.contacts;\r\n\r\n        while (contact !== null) {\r\n            if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n            //is this body colliding with any other? get the impostor\r\n            const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\r\n            const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\r\n\r\n            if (!mainImpostor || !collidingImpostor) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n\r\n            mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            contact = contact.next;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const mass = impostor.physicsBody.mass;\r\n        impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\r\n    }\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\r\n        this.applyImpulse(impostor, force, contactPoint);\r\n    }\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const bodyConfig: any = {\r\n                name: impostor.uniqueId,\r\n                //Oimo must have mass, also for static objects.\r\n                config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\r\n                size: [],\r\n                type: [],\r\n                pos: [],\r\n                posShape: [],\r\n                rot: [],\r\n                rotShape: [],\r\n                move: impostor.getParam(\"mass\") !== 0,\r\n                density: impostor.getParam(\"mass\"),\r\n                friction: impostor.getParam(\"friction\"),\r\n                restitution: impostor.getParam(\"restitution\"),\r\n                //Supporting older versions of Oimo\r\n                world: this.world,\r\n            };\r\n\r\n            const impostors = [impostor];\r\n            const addToArray = (parent: IPhysicsEnabledObject) => {\r\n                if (!parent.getChildMeshes) {\r\n                    return;\r\n                }\r\n                parent.getChildMeshes().forEach(function (m) {\r\n                    if (m.physicsImpostor) {\r\n                        impostors.push(m.physicsImpostor);\r\n                        //m.physicsImpostor._init();\r\n                    }\r\n                });\r\n            };\r\n            addToArray(impostor.object);\r\n\r\n            const checkWithEpsilon = (value: number): number => {\r\n                return Math.max(value, Epsilon);\r\n            };\r\n\r\n            const globalQuaternion: Quaternion = new Quaternion();\r\n\r\n            impostors.forEach((i) => {\r\n                if (!i.object.rotationQuaternion) {\r\n                    return;\r\n                }\r\n                //get the correct bounding box\r\n                const oldQuaternion = i.object.rotationQuaternion;\r\n                globalQuaternion.copyFrom(oldQuaternion);\r\n\r\n                i.object.rotationQuaternion.set(0, 0, 0, 1);\r\n                i.object.computeWorldMatrix(true);\r\n\r\n                const rot = globalQuaternion.toEulerAngles();\r\n                const impostorExtents = i.getObjectExtents();\r\n\r\n                // eslint-disable-next-line no-loss-of-precision\r\n                const radToDeg = 57.295779513082320876;\r\n\r\n                if (i === impostor) {\r\n                    const center = impostor.getObjectCenter();\r\n\r\n                    impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\r\n                    this._tmpPositionVector.divideInPlace(impostor.object.scaling);\r\n\r\n                    //Can also use Array.prototype.push.apply\r\n                    bodyConfig.pos.push(center.x);\r\n                    bodyConfig.pos.push(center.y);\r\n                    bodyConfig.pos.push(center.z);\r\n                    bodyConfig.posShape.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(0, 0, 0);\r\n                } else {\r\n                    const localPosition = i.object.position.clone();\r\n                    bodyConfig.posShape.push(localPosition.x);\r\n                    bodyConfig.posShape.push(localPosition.y);\r\n                    bodyConfig.posShape.push(localPosition.z);\r\n\r\n                    // bodyConfig.pos.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\r\n                }\r\n\r\n                i.object.rotationQuaternion.copyFrom(globalQuaternion);\r\n\r\n                // register mesh\r\n                switch (i.type) {\r\n                    case PhysicsImpostor.ParticleImpostor:\r\n                        Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\r\n                    // eslint-disable-next-line no-fallthrough\r\n                    case PhysicsImpostor.SphereImpostor: {\r\n                        const radiusX = impostorExtents.x;\r\n                        const radiusY = impostorExtents.y;\r\n                        const radiusZ = impostorExtents.z;\r\n\r\n                        const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\r\n\r\n                        bodyConfig.type.push(\"sphere\");\r\n                        //due to the way oimo works with compounds, add 3 times\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.CylinderImpostor: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        bodyConfig.type.push(\"cylinder\");\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        //due to the way oimo works with compounds, add one more value.\r\n                        bodyConfig.size.push(sizeY);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.PlaneImpostor:\r\n                    case PhysicsImpostor.BoxImpostor:\r\n                    default: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x);\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        const sizeZ = checkWithEpsilon(impostorExtents.z);\r\n\r\n                        bodyConfig.type.push(\"box\");\r\n                        //if (i === impostor) {\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        bodyConfig.size.push(sizeZ);\r\n                        //} else {\r\n                        //    bodyConfig.size.push(0,0,0);\r\n                        //}\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                //actually not needed, but hey...\r\n                i.object.rotationQuaternion = oldQuaternion;\r\n            });\r\n            impostor.physicsBody = this.world.add(bodyConfig);\r\n            // set the quaternion, ignoring the previously defined (euler) rotation\r\n            impostor.physicsBody.resetQuaternion(globalQuaternion);\r\n            // update with delta 0, so the body will receive the new rotation.\r\n            impostor.physicsBody.updatePosition(0);\r\n        } else {\r\n            this._tmpPositionVector.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpPositionVector);\r\n\r\n        //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\r\n        //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\r\n    }\r\n\r\n    private _tmpPositionVector: Vector3 = Vector3.Zero();\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        //impostor.physicsBody.dispose();\r\n        this.world.removeRigidBody(impostor.physicsBody);\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        const jointData = impostorJoint.joint.jointData;\r\n        const options = jointData.nativeParams || {};\r\n        let type;\r\n        const nativeJointData: any = {\r\n            body1: mainBody,\r\n            body2: connectedBody,\r\n\r\n            axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\r\n            axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\r\n            pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\r\n            pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\r\n\r\n            min: options.min,\r\n            max: options.max,\r\n            collision: options.collision || jointData.collision,\r\n            spring: options.spring,\r\n\r\n            //supporting older version of Oimo\r\n            world: this.world,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                type = \"jointBall\";\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\r\n                const springData = <SpringJointData>jointData;\r\n                nativeJointData.min = springData.length || nativeJointData.min;\r\n                //Max should also be set, just make sure it is at least min\r\n                nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\r\n            }\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsJoint.DistanceJoint:\r\n                type = \"jointDistance\";\r\n                nativeJointData.max = (<DistanceJointData>jointData).maxDistance;\r\n                break;\r\n            case PhysicsJoint.PrismaticJoint:\r\n                type = \"jointPrisme\";\r\n                break;\r\n            case PhysicsJoint.SliderJoint:\r\n                type = \"jointSlide\";\r\n                break;\r\n            case PhysicsJoint.WheelJoint:\r\n                type = \"jointWheel\";\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n            default:\r\n                type = \"jointHinge\";\r\n                break;\r\n        }\r\n        nativeJointData.type = type;\r\n        impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        //Bug in Oimo prevents us from disposing a joint in the playground\r\n        //joint.joint.physicsJoint.dispose();\r\n        //So we will bruteforce it!\r\n        try {\r\n            this.world.removeJoint(impostorJoint.joint.physicsJoint);\r\n        } catch (e) {\r\n            Logger.Warn(e);\r\n        }\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSOIMO !== undefined;\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        if (!impostor.physicsBody.sleeping) {\r\n            if (impostor.physicsBody.shapes.next) {\r\n                let parent = impostor.physicsBody.shapes;\r\n                while (parent.next) {\r\n                    parent = parent.next;\r\n                }\r\n                impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\r\n            } else {\r\n                const pos = impostor.physicsBody.getPosition();\r\n                impostor.object.position.set(pos.x, pos.y, pos.z);\r\n            }\r\n\r\n            if (impostor.object.rotationQuaternion) {\r\n                const quat = impostor.physicsBody.getQuaternion();\r\n                impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const body = impostor.physicsBody;\r\n        // disable bidirectional for compound meshes\r\n        if (impostor.physicsBody.shapes.next) {\r\n            return;\r\n        }\r\n        body.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n        body.syncShapes();\r\n        body.awake();\r\n    }\r\n\r\n    /*private _getLastShape(body: any): any {\r\n        var lastShape = body.shapes;\r\n        while (lastShape.next) {\r\n            lastShape = lastShape.next;\r\n        }\r\n        return lastShape;\r\n    }*/\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.linearVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        const staticBody: boolean = mass === 0;\r\n        //this will actually set the body's density and not its mass.\r\n        //But this is how oimo treats the mass variable.\r\n        impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\r\n        impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.density;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.shapes.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.shapes.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.awake();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        joint.physicsJoint.limitMotor.upperLimit = maxDistance;\r\n        if (minDistance !== void 0) {\r\n            joint.physicsJoint.limitMotor.lowerLimit = minDistance;\r\n        }\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed: number, force?: number, motorIndex?: number) {\r\n        if (force !== undefined) {\r\n            Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\r\n        } else {\r\n            force = 1e6;\r\n        }\r\n        speed *= -1;\r\n\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setMotor(speed, force);\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number) {\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\r\n        }\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.orientation.x;\r\n            mesh.rotationQuaternion.y = body.orientation.y;\r\n            mesh.rotationQuaternion.z = body.orientation.z;\r\n            mesh.rotationQuaternion.w = body.orientation.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.radius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes;\r\n        result.x = shape.halfWidth * 2;\r\n        result.y = shape.halfHeight * 2;\r\n        result.z = shape.halfDepth * 2;\r\n    }\r\n\r\n    public dispose() {\r\n        this.world.clear();\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        this._raycastResult.reset(from, to);\r\n\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        result.reset(from, to);\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderEffect {\r\n    private _postProcesses: { [Key: string]: Array<PostProcess> };\r\n    private _getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>;\r\n\r\n    private _singleInstance: boolean;\r\n\r\n    private _cameras: { [key: string]: Nullable<Camera> };\r\n    private _indicesForCamera: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Name of the effect\r\n     * @internal\r\n     */\r\n    public _name: string;\r\n\r\n    /**\r\n     * Instantiates a post process render effect.\r\n     * A post process can be used to apply a shader to a texture after it is rendered.\r\n     * @param engine The engine the effect is tied to\r\n     * @param name The name of the effect\r\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n     */\r\n    constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean) {\r\n        this._name = name;\r\n        this._singleInstance = singleInstance || true;\r\n\r\n        this._getPostProcesses = getPostProcesses;\r\n\r\n        this._cameras = {};\r\n        this._indicesForCamera = {};\r\n\r\n        this._postProcesses = {};\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const index in this._postProcesses) {\r\n            if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\r\n                const pps = this._postProcesses[index];\r\n                for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\r\n                    if (!pps[ppIndex].isSupported) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Updates the current state of the effect\r\n     * @internal\r\n     */\r\n    public _update(): void {}\r\n\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any): void {\r\n        let cameraKey;\r\n\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            const cameraName = camera.name;\r\n\r\n            if (this._singleInstance) {\r\n                cameraKey = 0;\r\n            } else {\r\n                cameraKey = cameraName;\r\n            }\r\n\r\n            if (!this._postProcesses[cameraKey]) {\r\n                const postProcess = this._getPostProcesses();\r\n                if (postProcess) {\r\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\r\n                }\r\n            }\r\n\r\n            if (!this._indicesForCamera[cameraName]) {\r\n                this._indicesForCamera[cameraName] = [];\r\n            }\r\n\r\n            this._postProcesses[cameraKey].forEach((postProcess: PostProcess) => {\r\n                const index = camera.attachPostProcess(postProcess);\r\n\r\n                this._indicesForCamera[cameraName].push(index);\r\n            });\r\n\r\n            if (!this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera: Camera = cams[i];\r\n            const cameraName: string = camera.name;\r\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n\r\n            if (postProcesses) {\r\n                postProcesses.forEach((postProcess: PostProcess) => {\r\n                    camera.detachPostProcess(postProcess);\r\n                });\r\n            }\r\n\r\n            if (this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = null;\r\n            }\r\n\r\n            delete this._indicesForCamera[cameraName];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Camera): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            const cameraKey = this._singleInstance ? 0 : cameraName;\r\n\r\n            for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\r\n                const index = this._indicesForCamera[cameraName][j];\r\n                const postProcess = camera._postProcesses[index];\r\n                if (postProcess === undefined || postProcess === null) {\r\n                    cams![i].attachPostProcess(this._postProcesses[cameraKey][j], index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Camera): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                camera.detachPostProcess(postProcess);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of the post processes contained in the effect.\r\n     * @param camera The camera to get the post processes on.\r\n     * @returns The list of the post processes in the effect.\r\n     */\r\n    public getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>> {\r\n        if (this._singleInstance) {\r\n            return this._postProcesses[0];\r\n        } else {\r\n            if (!camera) {\r\n                return null;\r\n            }\r\n            return this._postProcesses[camera.name];\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { PostProcessRenderEffect } from \"./postProcessRenderEffect\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\n\r\nimport type { PrePassRenderer } from \"../../Rendering/prePassRenderer\";\r\n\r\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipeline {\r\n    protected _renderEffects: { [key: string]: PostProcessRenderEffect };\r\n    protected _renderEffectsForIsolatedPass: PostProcessRenderEffect[];\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _cameras: Camera[];\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _name: string;\r\n\r\n    /**\r\n     * Gets pipeline name\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the list of attached cameras */\r\n    public get cameras() {\r\n        return this._cameras;\r\n    }\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipeline\r\n     * @param _engine engine to add the pipeline to\r\n     * @param name name of the pipeline\r\n     */\r\n    constructor(private _engine: Engine, name: string) {\r\n        this._name = name;\r\n\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n\r\n        this._cameras = [];\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns \"PostProcessRenderPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcessRenderPipeline\";\r\n    }\r\n\r\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                if (!this._renderEffects[renderEffectName].isSupported) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds an effect to the pipeline\r\n     * @param renderEffect the effect to add\r\n     */\r\n    public addEffect(renderEffect: PostProcessRenderEffect): void {\r\n        (<any>this._renderEffects)[renderEffect._name] = renderEffect;\r\n    }\r\n\r\n    // private\r\n\r\n    /** @internal */\r\n    public _rebuild() {}\r\n\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera): void;\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera[]): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _enableEffect(renderEffectName: string, cameras: any): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera, unique: boolean): void;\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera[], unique: boolean): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any, unique: boolean): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        const indicesToDelete = [];\r\n        let i: number;\r\n        for (i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            if (this._cameras.indexOf(camera) === -1) {\r\n                this._cameras.push(camera);\r\n            } else if (unique) {\r\n                indicesToDelete.push(i);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < indicesToDelete.length; i++) {\r\n            cams.splice(indicesToDelete[i], 1);\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._attachCameras(cams);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /** @internal */\r\n    public _detachCameras(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._detachCameras(cams);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(): void {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._update();\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            if (!this._cameras[i]) {\r\n                continue;\r\n            }\r\n            const cameraName = this._cameras[i].name;\r\n            if ((<any>this._renderEffectsForIsolatedPass)[cameraName]) {\r\n                (<any>this._renderEffectsForIsolatedPass)[cameraName]._update();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _reset(): void {\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n    }\r\n\r\n    protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean {\r\n        if (!this._engine._features.supportMSAA) {\r\n            return false;\r\n        }\r\n\r\n        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\r\n        const effectKeys = Object.keys(this._renderEffects);\r\n        if (effectKeys.length > 0) {\r\n            const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\r\n            if (postProcesses) {\r\n                postProcesses[0].samples = sampleCount;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the pipeline\r\n     */\r\n    public dispose() {\r\n        // Must be implemented by children\r\n    }\r\n}\r\n","import type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcessRenderPipeline } from \"./postProcessRenderPipeline\";\r\n/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipelineManager {\r\n    private _renderPipelines: { [Key: string]: PostProcessRenderPipeline };\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipelineManager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n     */\r\n    constructor() {\r\n        this._renderPipelines = {};\r\n    }\r\n\r\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\r\n    public get supportedPipelines(): PostProcessRenderPipeline[] {\r\n        const result = [];\r\n\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (pipeline.isSupported) {\r\n                    result.push(pipeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a pipeline to the manager\r\n     * @param renderPipeline The pipeline to add\r\n     */\r\n    public addPipeline(renderPipeline: PostProcessRenderPipeline): void {\r\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\r\n    }\r\n\r\n    /**\r\n     * Remove the pipeline from the manager\r\n     * @param renderPipelineName the name of the pipeline to remove\r\n     */\r\n    public removePipeline(renderPipelineName: string): void {\r\n        delete this._renderPipelines[renderPipelineName];\r\n    }\r\n\r\n    /**\r\n     * Attaches a camera to the pipeline\r\n     * @param renderPipelineName The name of the pipeline to attach to\r\n     * @param cameras the camera to attach\r\n     * @param unique if the camera can be attached multiple times to the pipeline\r\n     */\r\n    public attachCamerasToRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera, unique: boolean = false): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._attachCameras(cameras, unique);\r\n    }\r\n\r\n    /**\r\n     * Detaches a camera from the pipeline\r\n     * @param renderPipelineName The name of the pipeline to detach from\r\n     * @param cameras the camera to detach\r\n     */\r\n    public detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._detachCameras(cameras);\r\n    }\r\n\r\n    /**\r\n     * Enables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to enable the effect in\r\n     * @param renderEffectName the name of the effect to enable\r\n     * @param cameras the cameras that the effect should be enabled on\r\n     */\r\n    public enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._enableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Disables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to disable the effect in\r\n     * @param renderEffectName the name of the effect to disable\r\n     * @param cameras the cameras that the effect should be disabled on\r\n     */\r\n    public disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._disableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n     */\r\n    public update(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (!pipeline.isSupported) {\r\n                    pipeline.dispose();\r\n                    delete this._renderPipelines[renderPipelineName];\r\n                } else {\r\n                    pipeline._update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the manager and pipelines\r\n     */\r\n    public dispose(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"anaglyphPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D leftSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 leftFrag=texture2D(leftSampler,vUV);leftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);vec4 rightFrag=texture2D(textureSampler,vUV);rightFrag=vec4(rightFrag.r,1.0,1.0,1.0);gl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const anaglyphPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/anaglyph.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * Postprocess used to generate anaglyphic rendering\r\n */\r\nexport class AnaglyphPostProcess extends PostProcess {\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"AnaglyphPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnaglyphPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new AnaglyphPostProcess\r\n     * @param name defines postprocess name\r\n     * @param options defines creation options or target ratio scale\r\n     * @param rigCameras defines cameras using this postprocess\r\n     * @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param engine defines hosting engine\r\n     * @param reusable defines if the postprocess will be reused multiple times per frame\r\n     */\r\n    constructor(name: string, options: number | PostProcessOptions, rigCameras: Camera[], samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"anaglyph\", null, [\"leftSampler\"], options, rigCameras[1], samplingMode, engine, reusable);\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"leftSampler\", this._passedProcess);\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnaglyphPostProcess\", AnaglyphPostProcess);\r\n","import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class BloomEffect extends PostProcessRenderEffect {\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _downscale: ExtractHighlightsPostProcess;\r\n    private _blurX: BlurPostProcess;\r\n    private _blurY: BlurPostProcess;\r\n    private _merge: BloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._downscale.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._downscale.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._merge.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._merge.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._blurX.kernel / this._bloomScale;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._blurX.kernel = value * this._bloomScale;\r\n        this._blurY.kernel = value * this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomEffect\r\n     * @param scene The scene the effect belongs to.\r\n     * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param bloomWeight The the strength of bloom.\r\n     * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(scene: Scene, private _bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType = 0, blockCompilation = false) {\r\n        super(\r\n            scene.getEngine(),\r\n            \"bloom\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n        this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\r\n\r\n        this._blurX = new BlurPostProcess(\r\n            \"horizontal blur\",\r\n            new Vector2(1.0, 0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurX.alwaysForcePOT = true;\r\n        this._blurX.autoClear = false;\r\n\r\n        this._blurY = new BlurPostProcess(\r\n            \"vertical blur\",\r\n            new Vector2(0, 1.0),\r\n            10.0,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            undefined,\r\n            blockCompilation\r\n        );\r\n        this._blurY.alwaysForcePOT = true;\r\n        this._blurY.autoClear = false;\r\n\r\n        this.kernel = bloomKernel;\r\n\r\n        this._effects = [this._downscale, this._blurX, this._blurY];\r\n\r\n        this._merge = new BloomMergePostProcess(\r\n            \"bloomMerge\",\r\n            this._downscale,\r\n            this._blurY,\r\n            bloomWeight,\r\n            _bloomScale,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            pipelineTextureType,\r\n            blockCompilation\r\n        );\r\n        this._merge.autoClear = false;\r\n        this._effects.push(this._merge);\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            if (!this._effects[effectIndex].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"bloomMergePixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform sampler2D bloomBlur;varying vec2 vUV;uniform float bloomWeight;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{gl_FragColor=texture2D(textureSampler,vUV);vec3 blurred=texture2D(bloomBlur,vUV).rgb;gl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight); }\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const bloomMergePixelShader = { name, shader };\n","import type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/bloomMerge.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\n\r\n/**\r\n * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.\r\n */\r\nexport class BloomMergePostProcess extends PostProcess {\r\n    /** Weight of the bloom to be added to the original input. */\r\n    @serialize()\r\n    public weight = 1;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BloomMergePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"BloomMergePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomMergePostProcess\r\n     * @param name The name of the effect.\r\n     * @param originalFromInput Post process which's input will be used for the merge.\r\n     * @param blurred Blurred highlights post process which's output will be used.\r\n     * @param weight Weight of the bloom to be added to the original input.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        originalFromInput: PostProcess,\r\n        blurred: PostProcess,\r\n        /** Weight of the bloom to be added to the original input. */\r\n        weight: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"bloomMerge\", [\"bloomWeight\"], [\"bloomBlur\"], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, true);\r\n        this.weight = weight;\r\n        this.externalTextureSamplerBinding = true;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", originalFromInput);\r\n            effect.setTextureFromPostProcessOutput(\"bloomBlur\", blurred);\r\n            effect.setFloat(\"bloomWeight\", this.weight);\r\n        });\r\n\r\n        if (!blockCompilation) {\r\n            this.updateEffect();\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BloomMergePostProcess\", BloomMergePostProcess);\r\n","import { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/chromaticAberration.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen\r\n */\r\nexport class ChromaticAberrationPostProcess extends PostProcess {\r\n    /**\r\n     * The amount of separation of rgb channels (default: 30)\r\n     */\r\n    @serialize()\r\n    aberrationAmount = 30;\r\n\r\n    /**\r\n     * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)\r\n     */\r\n    @serialize()\r\n    radialIntensity = 0;\r\n\r\n    /**\r\n     * The normalized direction in which the rgb channels should be separated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))\r\n     */\r\n    @serialize()\r\n    direction = new Vector2(0.707, 0.707);\r\n\r\n    /**\r\n     * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corner] (default: Vector2(0.5 ,0.5))\r\n     */\r\n    @serialize()\r\n    centerPosition = new Vector2(0.5, 0.5);\r\n\r\n    /** The width of the screen to apply the effect on */\r\n    @serialize()\r\n    screenWidth: number;\r\n\r\n    /** The height of the screen to apply the effect on */\r\n    @serialize()\r\n    screenHeight: number;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ChromaticAberrationPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ChromaticAberrationPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ChromaticAberrationPostProcess\r\n     * @param name The name of the effect.\r\n     * @param screenWidth The width of the screen to apply the effect on.\r\n     * @param screenHeight The height of the screen to apply the effect on.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        screenWidth: number,\r\n        screenHeight: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"chromaticAberration\",\r\n            [\"chromatic_aberration\", \"screen_width\", \"screen_height\", \"direction\", \"radialIntensity\", \"centerPosition\"],\r\n            [],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this.screenWidth = screenWidth;\r\n        this.screenHeight = screenHeight;\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat(\"chromatic_aberration\", this.aberrationAmount);\r\n            effect.setFloat(\"screen_width\", screenWidth);\r\n            effect.setFloat(\"screen_height\", screenHeight);\r\n            effect.setFloat(\"radialIntensity\", this.radialIntensity);\r\n            effect.setFloat2(\"direction\", this.direction.x, this.direction.y);\r\n            effect.setFloat2(\"centerPosition\", this.centerPosition.x, this.centerPosition.y);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ChromaticAberrationPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ChromaticAberrationPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.screenWidth,\r\n                    parsedPostProcess.screenHeight,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ChromaticAberrationPostProcess\", ChromaticAberrationPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"circleOfConfusionPixelShader\";\nconst shader = `uniform sampler2D depthSampler;varying vec2 vUV;uniform vec2 cameraMinMaxZ;uniform float focusDistance;uniform float cocPrecalculation;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float depth=texture2D(depthSampler,vUV).r;\n#define CUSTOM_COC_DEPTH\nfloat pixelDistance=(cameraMinMaxZ.x+cameraMinMaxZ.y*depth)*1000.0; \n#define CUSTOM_COC_PIXELDISTANCE\nfloat coc=abs(cocPrecalculation*((focusDistance-pixelDistance)/pixelDistance));coc=clamp(coc,0.0,1.0);gl_FragColor=vec4(coc,coc,coc,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const circleOfConfusionPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/circleOfConfusion.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\n\r\n/**\r\n * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion\r\n */\r\nexport class CircleOfConfusionPostProcess extends PostProcess {\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    @serialize()\r\n    public lensSize = 50;\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    @serialize()\r\n    public fStop = 1.4;\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    @serialize()\r\n    public focusDistance = 2000;\r\n    /**\r\n     * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)\r\n     */\r\n    @serialize()\r\n    public focalLength = 50;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"CircleOfConfusionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"CircleOfConfusionPostProcess\";\r\n    }\r\n\r\n    private _depthTexture: Nullable<RenderTargetTexture> = null;\r\n    /**\r\n     * Creates a new instance CircleOfConfusionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        depthTexture: Nullable<RenderTargetTexture>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"circleOfConfusion\",\r\n            [\"cameraMinMaxZ\", \"focusDistance\", \"cocPrecalculation\"],\r\n            [\"depthSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n        this._depthTexture = depthTexture;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (!this._depthTexture) {\r\n                Logger.Warn(\"No depth texture set on CircleOfConfusionPostProcess\");\r\n                return;\r\n            }\r\n            effect.setTexture(\"depthSampler\", this._depthTexture);\r\n\r\n            // Circle of confusion calculation, See https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch23.html\r\n            const aperture = this.lensSize / this.fStop;\r\n            const cocPrecalculation = (aperture * this.focalLength) / (this.focusDistance - this.focalLength); // * ((this.focusDistance - pixelDistance)/pixelDistance) [This part is done in shader]\r\n\r\n            effect.setFloat(\"focusDistance\", this.focusDistance);\r\n            effect.setFloat(\"cocPrecalculation\", cocPrecalculation);\r\n            const activeCamera = this._depthTexture.activeCamera!;\r\n            effect.setFloat2(\"cameraMinMaxZ\", activeCamera.minZ, activeCamera.maxZ - activeCamera.minZ);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.\r\n     */\r\n    public set depthTexture(value: RenderTargetTexture) {\r\n        this._depthTexture = value;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CircleOfConfusionPostProcess\", CircleOfConfusionPostProcess);\r\n","import type { Nullable } from \"../types\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcess, PostProcessOptions } from \"./postProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\n\r\n/**\r\n * The DepthOfFieldBlurPostProcess applied a blur in a give direction.\r\n * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels\r\n * based on samples that have a large difference in distance than the center pixel.\r\n * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf\r\n */\r\nexport class DepthOfFieldBlurPostProcess extends BlurPostProcess {\r\n    /**\r\n     * The direction the blur should be applied\r\n     */\r\n    @serialize()\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"DepthOfFieldBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"DepthOfFieldBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance DepthOfFieldBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene the effect belongs to.\r\n     * @param direction The direction the blur should be applied.\r\n     * @param kernel The size of the kernel used to blur.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring across edges\r\n     * @param imageToBlur The image to apply the blur to (default: Current rendered frame)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        circleOfConfusion: PostProcess,\r\n        imageToBlur: Nullable<PostProcess> = null,\r\n        samplingMode = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(\r\n            name,\r\n            direction,\r\n            kernel,\r\n            options,\r\n            camera,\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            (samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE),\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            `#define DOF 1\\n`,\r\n            blockCompilation,\r\n            textureFormat\r\n        );\r\n\r\n        this.direction = direction;\r\n        this.externalTextureSamplerBinding = !!imageToBlur;\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (imageToBlur != null) {\r\n                effect.setTextureFromPostProcess(\"textureSampler\", imageToBlur);\r\n            }\r\n            effect.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", circleOfConfusion);\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DepthOfFieldBlurPostProcess\", DepthOfFieldBlurPostProcess);\r\n","import type { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { CircleOfConfusionPostProcess } from \"./circleOfConfusionPostProcess\";\r\nimport { DepthOfFieldBlurPostProcess } from \"./depthOfFieldBlurPostProcess\";\r\nimport { DepthOfFieldMergePostProcess } from \"./depthOfFieldMergePostProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Specifies the level of max blur that should be applied when using the depth of field effect\r\n */\r\nexport enum DepthOfFieldEffectBlurLevel {\r\n    /**\r\n     * Subtle blur\r\n     */\r\n    Low,\r\n    /**\r\n     * Medium blur\r\n     */\r\n    Medium,\r\n    /**\r\n     * Large blur\r\n     */\r\n    High,\r\n}\r\n/**\r\n * The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.\r\n */\r\nexport class DepthOfFieldEffect extends PostProcessRenderEffect {\r\n    private _circleOfConfusion: CircleOfConfusionPostProcess;\r\n    /**\r\n     * @internal Internal, blurs from high to low\r\n     */\r\n    public _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess>;\r\n    private _depthOfFieldBlurY: Array<DepthOfFieldBlurPostProcess>;\r\n    private _dofMerge: Nullable<DepthOfFieldMergePostProcess>;\r\n\r\n    /**\r\n     * @internal Internal post processes in depth of field effect\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)\r\n     */\r\n    public set focalLength(value: number) {\r\n        this._circleOfConfusion.focalLength = value;\r\n    }\r\n    public get focalLength() {\r\n        return this._circleOfConfusion.focalLength;\r\n    }\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    public set fStop(value: number) {\r\n        this._circleOfConfusion.fStop = value;\r\n    }\r\n    public get fStop() {\r\n        return this._circleOfConfusion.fStop;\r\n    }\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    public set focusDistance(value: number) {\r\n        this._circleOfConfusion.focusDistance = value;\r\n    }\r\n    public get focusDistance() {\r\n        return this._circleOfConfusion.focusDistance;\r\n    }\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    public set lensSize(value: number) {\r\n        this._circleOfConfusion.lensSize = value;\r\n    }\r\n    public get lensSize() {\r\n        return this._circleOfConfusion.lensSize;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance DepthOfFieldEffect\r\n     * @param scene The scene the effect belongs to.\r\n     * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.\r\n     * @param blurLevel\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        depthTexture: Nullable<RenderTargetTexture>,\r\n        blurLevel: DepthOfFieldEffectBlurLevel = DepthOfFieldEffectBlurLevel.Low,\r\n        pipelineTextureType = 0,\r\n        blockCompilation = false\r\n    ) {\r\n        super(\r\n            scene.getEngine(),\r\n            \"depth of field\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n\r\n        // Use R-only formats if supported to store the circle of confusion values.\r\n        // This should be more space and bandwidth efficient than using RGBA.\r\n        const engine = scene.getEngine();\r\n        const circleOfConfusionTextureFormat = engine.isWebGPU || engine.webGLVersion > 1 ? Constants.TEXTUREFORMAT_RED : Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        // Circle of confusion value for each pixel is used to determine how much to blur that pixel\r\n        this._circleOfConfusion = new CircleOfConfusionPostProcess(\r\n            \"circleOfConfusion\",\r\n            depthTexture,\r\n            1,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            pipelineTextureType,\r\n            blockCompilation\r\n        );\r\n\r\n        // Create a pyramid of blurred images (eg. fullSize 1/4 blur, half size 1/2 blur, quarter size 3/4 blur, eith size 4/4 blur)\r\n        // Blur the image but do not blur on sharp far to near distance changes to avoid bleeding artifacts\r\n        // See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf\r\n        this._depthOfFieldBlurY = [];\r\n        this._depthOfFieldBlurX = [];\r\n        let blurCount = 1;\r\n        let kernelSize = 15;\r\n        switch (blurLevel) {\r\n            case DepthOfFieldEffectBlurLevel.High: {\r\n                blurCount = 3;\r\n                kernelSize = 51;\r\n                break;\r\n            }\r\n            case DepthOfFieldEffectBlurLevel.Medium: {\r\n                blurCount = 2;\r\n                kernelSize = 31;\r\n                break;\r\n            }\r\n            default: {\r\n                kernelSize = 15;\r\n                blurCount = 1;\r\n                break;\r\n            }\r\n        }\r\n        const adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);\r\n        let ratio = 1.0;\r\n        for (let i = 0; i < blurCount; i++) {\r\n            const blurY = new DepthOfFieldBlurPostProcess(\r\n                \"vertical blur\",\r\n                scene,\r\n                new Vector2(0, 1.0),\r\n                adjustedKernelSize,\r\n                ratio,\r\n                null,\r\n                this._circleOfConfusion,\r\n                i == 0 ? this._circleOfConfusion : null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                pipelineTextureType,\r\n                blockCompilation,\r\n                i == 0 ? circleOfConfusionTextureFormat : Constants.TEXTUREFORMAT_RGBA\r\n            );\r\n            blurY.autoClear = false;\r\n            ratio = 0.75 / Math.pow(2, i);\r\n            const blurX = new DepthOfFieldBlurPostProcess(\r\n                \"horizontal blur\",\r\n                scene,\r\n                new Vector2(1.0, 0),\r\n                adjustedKernelSize,\r\n                ratio,\r\n                null,\r\n                this._circleOfConfusion,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                pipelineTextureType,\r\n                blockCompilation\r\n            );\r\n            blurX.autoClear = false;\r\n            this._depthOfFieldBlurY.push(blurY);\r\n            this._depthOfFieldBlurX.push(blurX);\r\n        }\r\n\r\n        // Set all post processes on the effect.\r\n        this._effects = [this._circleOfConfusion];\r\n        for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {\r\n            this._effects.push(this._depthOfFieldBlurY[i]);\r\n            this._effects.push(this._depthOfFieldBlurX[i]);\r\n        }\r\n\r\n        // Merge blurred images with original image based on circleOfConfusion\r\n        this._dofMerge = new DepthOfFieldMergePostProcess(\r\n            \"dofMerge\",\r\n            this._circleOfConfusion,\r\n            this._circleOfConfusion,\r\n            this._depthOfFieldBlurX,\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            pipelineTextureType,\r\n            blockCompilation\r\n        );\r\n        this._dofMerge.autoClear = false;\r\n        this._effects.push(this._dofMerge);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the current effect\r\n     * @returns \"DepthOfFieldEffect\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DepthOfFieldEffect\";\r\n    }\r\n\r\n    /**\r\n     * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.\r\n     */\r\n    public set depthTexture(value: RenderTargetTexture) {\r\n        this._circleOfConfusion.depthTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            if (!this._effects[effectIndex].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"depthOfFieldMergePixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)\n#else\n#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)\n#endif\nuniform sampler2D textureSampler;varying vec2 vUV;uniform sampler2D circleOfConfusionSampler;uniform sampler2D blurStep0;\n#if BLUR_LEVEL>0\nuniform sampler2D blurStep1;\n#endif\n#if BLUR_LEVEL>1\nuniform sampler2D blurStep2;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float coc=TEXTUREFUNC(circleOfConfusionSampler,vUV,0.0).r;\n#if BLUR_LEVEL==0\nvec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);gl_FragColor=mix(original,blurred0,coc);\n#endif\n#if BLUR_LEVEL==1\nif(coc<0.5){vec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(original,blurred1,coc/0.5);}else{vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);}\n#endif\n#if BLUR_LEVEL==2\nif(coc<0.33){vec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred2=TEXTUREFUNC(blurStep2,vUV,0.0);gl_FragColor=mix(original,blurred2,coc/0.33);}else if(coc<0.66){vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);vec4 blurred2=TEXTUREFUNC(blurStep2,vUV,0.0);gl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);}else{vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);}\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthOfFieldMergePixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depthOfFieldMerge.fragment\";\r\n\r\n/**\r\n * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.\r\n */\r\nexport class DepthOfFieldMergePostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"DepthOfFieldMergePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"DepthOfFieldMergePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of DepthOfFieldMergePostProcess\r\n     * @param name The name of the effect.\r\n     * @param originalFromInput Post process which's input will be used for the merge.\r\n     * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.\r\n     * @param _blurSteps Blur post processes from low to high which will be mixed with the original image.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        originalFromInput: PostProcess,\r\n        circleOfConfusion: PostProcess,\r\n        private _blurSteps: Array<PostProcess>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"depthOfFieldMerge\",\r\n            [],\r\n            [\"circleOfConfusionSampler\", \"blurStep0\", \"blurStep1\", \"blurStep2\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            true\r\n        );\r\n        this.externalTextureSamplerBinding = true;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", originalFromInput);\r\n            effect.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", circleOfConfusion);\r\n            _blurSteps.forEach((step, index) => {\r\n                effect.setTextureFromPostProcessOutput(\"blurStep\" + (_blurSteps.length - index - 1), step);\r\n            });\r\n        });\r\n\r\n        if (!blockCompilation) {\r\n            this.updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        if (!defines) {\r\n            defines = \"\";\r\n            defines += \"#define BLUR_LEVEL \" + (this._blurSteps.length - 1) + \"\\n\";\r\n        }\r\n        super.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError);\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"extractHighlightsPixelShader\";\nconst shader = `#include<helperFunctions>\nvarying vec2 vUV;uniform sampler2D textureSampler;uniform float threshold;uniform float exposure;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=texture2D(textureSampler,vUV);float luma=dot(LuminanceEncodeApprox,gl_FragColor.rgb*exposure);gl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const extractHighlightsPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { ToGammaSpace } from \"../Maths/math.constants\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/extractHighlights.fragment\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.\r\n */\r\nexport class ExtractHighlightsPostProcess extends PostProcess {\r\n    /**\r\n     * The luminance threshold, pixels below this value will be set to black.\r\n     */\r\n    @serialize()\r\n    public threshold = 0.9;\r\n\r\n    /** @internal */\r\n    public _exposure = 1;\r\n\r\n    /**\r\n     * Post process which has the input texture to be used when performing highlight extraction\r\n     * @internal\r\n     */\r\n    public _inputPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ExtractHighlightsPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExtractHighlightsPostProcess\";\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"extractHighlights\", [\"threshold\", \"exposure\"], null, options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation);\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this.externalTextureSamplerBinding = !!this._inputPostProcess;\r\n            if (this._inputPostProcess) {\r\n                effect.setTextureFromPostProcess(\"textureSampler\", this._inputPostProcess);\r\n            }\r\n            effect.setFloat(\"threshold\", Math.pow(this.threshold, ToGammaSpace));\r\n            effect.setFloat(\"exposure\", this._exposure);\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ExtractHighlightsPostProcess\", ExtractHighlightsPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fxaaPixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\nuniform sampler2D textureSampler;uniform vec2 texelSize;varying vec2 vUV;varying vec2 sampleCoordS;varying vec2 sampleCoordE;varying vec2 sampleCoordN;varying vec2 sampleCoordW;varying vec2 sampleCoordNW;varying vec2 sampleCoordSE;varying vec2 sampleCoordNE;varying vec2 sampleCoordSW;const float fxaaQualitySubpix=1.0;const float fxaaQualityEdgeThreshold=0.166;const float fxaaQualityEdgeThresholdMin=0.0833;const vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\nvoid main(){vec2 posM;posM.x=vUV.x;posM.y=vUV.y;vec4 rgbyM=TEXTUREFUNC(textureSampler,vUV,0.0);float lumaM=FxaaLuma(rgbyM);float lumaS=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordS,0.0));float lumaE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordE,0.0));float lumaN=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordN,0.0));float lumaW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordW,0.0));float maxSM=max(lumaS,lumaM);float minSM=min(lumaS,lumaM);float maxESM=max(lumaE,maxSM);float minESM=min(lumaE,minSM);float maxWN=max(lumaN,lumaW);float minWN=min(lumaN,lumaW);float rangeMax=max(maxWN,maxESM);float rangeMin=min(minWN,minESM);float rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;float range=rangeMax-rangeMin;float rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\n#ifndef MALI\nif(range<rangeMaxClamped) \n{gl_FragColor=rgbyM;return;}\n#endif\nfloat lumaNW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNW,0.0));float lumaSE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSE,0.0));float lumaNE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNE,0.0));float lumaSW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSW,0.0));float lumaNS=lumaN+lumaS;float lumaWE=lumaW+lumaE;float subpixRcpRange=1.0/range;float subpixNSWE=lumaNS+lumaWE;float edgeHorz1=(-2.0*lumaM)+lumaNS;float edgeVert1=(-2.0*lumaM)+lumaWE;float lumaNESE=lumaNE+lumaSE;float lumaNWNE=lumaNW+lumaNE;float edgeHorz2=(-2.0*lumaE)+lumaNESE;float edgeVert2=(-2.0*lumaN)+lumaNWNE;float lumaNWSW=lumaNW+lumaSW;float lumaSWSE=lumaSW+lumaSE;float edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);float edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);float edgeHorz3=(-2.0*lumaW)+lumaNWSW;float edgeVert3=(-2.0*lumaS)+lumaSWSE;float edgeHorz=abs(edgeHorz3)+edgeHorz4;float edgeVert=abs(edgeVert3)+edgeVert4;float subpixNWSWNESE=lumaNWSW+lumaNESE;float lengthSign=texelSize.x;bool horzSpan=edgeHorz>=edgeVert;float subpixA=subpixNSWE*2.0+subpixNWSWNESE;if (!horzSpan)\n{lumaN=lumaW;}\nif (!horzSpan) \n{lumaS=lumaE;}\nif (horzSpan) \n{lengthSign=texelSize.y;}\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;float gradientN=lumaN-lumaM;float gradientS=lumaS-lumaM;float lumaNN=lumaN+lumaM;float lumaSS=lumaS+lumaM;bool pairN=abs(gradientN)>=abs(gradientS);float gradient=max(abs(gradientN),abs(gradientS));if (pairN)\n{lengthSign=-lengthSign;}\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);vec2 posB;posB.x=posM.x;posB.y=posM.y;vec2 offNP;offNP.x=(!horzSpan) ? 0.0 : texelSize.x;offNP.y=(horzSpan) ? 0.0 : texelSize.y;if (!horzSpan) \n{posB.x+=lengthSign*0.5;}\nif (horzSpan)\n{posB.y+=lengthSign*0.5;}\nvec2 posN;posN.x=posB.x-offNP.x*1.5;posN.y=posB.y-offNP.y*1.5;vec2 posP;posP.x=posB.x+offNP.x*1.5;posP.y=posB.y+offNP.y*1.5;float subpixD=((-2.0)*subpixC)+3.0;float lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN,0.0));float subpixE=subpixC*subpixC;float lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP,0.0));if (!pairN) \n{lumaNN=lumaSS;}\nfloat gradientScaled=gradient*1.0/4.0;float lumaMM=lumaM-lumaNN*0.5;float subpixF=subpixD*subpixE;bool lumaMLTZero=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;bool doneN=abs(lumaEndN)>=gradientScaled;bool doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) \n{posN.x-=offNP.x*3.0;}\nif (!doneN) \n{posN.y-=offNP.y*3.0;}\nbool doneNP=(!doneN) || (!doneP);if (!doneP) \n{posP.x+=offNP.x*3.0;}\nif (!doneP)\n{posP.y+=offNP.y*3.0;}\nif (doneNP)\n{if (!doneN) lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN.xy,0.0));if (!doneP) lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP.xy,0.0));if (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;if (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) posN.x-=offNP.x*12.0;if (!doneN) posN.y-=offNP.y*12.0;doneNP=(!doneN) || (!doneP);if (!doneP) posP.x+=offNP.x*12.0;if (!doneP) posP.y+=offNP.y*12.0;}\nfloat dstN=posM.x-posN.x;float dstP=posP.x-posM.x;if (!horzSpan)\n{dstN=posM.y-posN.y;}\nif (!horzSpan) \n{dstP=posP.y-posM.y;}\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;float spanLength=(dstP+dstN);bool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;float spanLengthRcp=1.0/spanLength;bool directionN=dstN<dstP;float dst=min(dstN,dstP);bool goodSpan=directionN ? goodSpanN : goodSpanP;float subpixG=subpixF*subpixF;float pixelOffset=(dst*(-spanLengthRcp))+0.5;float subpixH=subpixG*fxaaQualitySubpix;float pixelOffsetGood=goodSpan ? pixelOffset : 0.0;float pixelOffsetSubpix=max(pixelOffsetGood,subpixH);if (!horzSpan)\n{posM.x+=pixelOffsetSubpix*lengthSign;}\nif (horzSpan)\n{posM.y+=pixelOffsetSubpix*lengthSign;}\n#ifdef MALI\nif(range<rangeMaxClamped) \n{gl_FragColor=rgbyM;}\nelse\n{gl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);}\n#else\ngl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fxaaPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fxaaVertexShader\";\nconst shader = `attribute vec2 position;uniform vec2 texelSize;varying vec2 vUV;varying vec2 sampleCoordS;varying vec2 sampleCoordE;varying vec2 sampleCoordN;varying vec2 sampleCoordW;varying vec2 sampleCoordNW;varying vec2 sampleCoordSE;varying vec2 sampleCoordNE;varying vec2 sampleCoordSW;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd);sampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;sampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;sampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;sampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;sampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;sampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;sampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;sampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fxaaVertexShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/fxaa.fragment\";\r\nimport \"../Shaders/fxaa.vertex\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n/**\r\n * Fxaa post process\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#fxaa\r\n */\r\nexport class FxaaPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"FxaaPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"FxaaPostProcess\";\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(name, \"fxaa\", [\"texelSize\"], null, options, camera, samplingMode || Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, \"fxaa\", undefined, true);\r\n\r\n        const defines = this._getDefines();\r\n        this.updateEffect(defines);\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            const texelSize = this.texelSize;\r\n            effect.setFloat2(\"texelSize\", texelSize.x, texelSize.y);\r\n        });\r\n    }\r\n\r\n    private _getDefines(): Nullable<string> {\r\n        const engine = this.getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const glInfo = engine.getGlInfo();\r\n        if (glInfo && glInfo.renderer && glInfo.renderer.toLowerCase().indexOf(\"mali\") > -1) {\r\n            return \"#define MALI 1\\n\";\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new FxaaPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FxaaPostProcess\", FxaaPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"grainPixelShader\";\nconst shader = `#include<helperFunctions>\nuniform sampler2D textureSampler; \nuniform float intensity;uniform float animatedSeed;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{gl_FragColor=texture2D(textureSampler,vUV);vec2 seed=vUV*(animatedSeed);float grain=dither(seed,intensity);float lum=getLuminance(gl_FragColor.rgb);float grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;gl_FragColor.rgb+=grain*grainAmount;gl_FragColor.rgb=max(gl_FragColor.rgb,0.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const grainPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/grain.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The GrainPostProcess adds noise to the image at mid luminance levels\r\n */\r\nexport class GrainPostProcess extends PostProcess {\r\n    /**\r\n     * The intensity of the grain added (default: 30)\r\n     */\r\n    @serialize()\r\n    public intensity: number = 30;\r\n    /**\r\n     * If the grain should be randomized on every frame\r\n     */\r\n    @serialize()\r\n    public animated: boolean = false;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"GrainPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"GrainPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see GrainPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"grain\", [\"intensity\", \"animatedSeed\"], [], options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation);\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat(\"intensity\", this.intensity);\r\n            effect.setFloat(\"animatedSeed\", this.animated ? Math.random() + 1 : 1);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new GrainPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GrainPostProcess\", GrainPostProcess);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { IImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/imageProcessing.fragment\";\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * ImageProcessingPostProcess\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#imageprocessing\r\n */\r\nexport class ImageProcessingPostProcess extends PostProcess {\r\n    /**\r\n     * Default configuration related to image processing available in the PBR Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        // We are almost sure it is applied by post process as\r\n        // We are in the post process :-)\r\n        value.applyByPostProcess = true;\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration\r\n     * @param doNotBuild\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>, doNotBuild = false): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            let scene = null;\r\n            const engine = this.getEngine();\r\n            const camera = this.getCamera();\r\n\r\n            if (camera) {\r\n                scene = camera.getScene();\r\n            } else if (engine && engine.scenes) {\r\n                const scenes = engine.scenes;\r\n                scene = scenes[scenes.length - 1];\r\n            } else {\r\n                scene = EngineStore.LastCreatedScene;\r\n            }\r\n\r\n            if (scene) {\r\n                this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\r\n            } else {\r\n                this._imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n            }\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._updateParameters();\r\n            });\r\n        }\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        if (!doNotBuild) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        const effect = this.getEffect();\r\n        return !effect || effect.isSupported;\r\n    }\r\n\r\n    /**\r\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public get colorCurves(): Nullable<ColorCurves> {\r\n        return this.imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public set colorCurves(value: Nullable<ColorCurves>) {\r\n        this.imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get colorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set colorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public get colorGradingTexture(): Nullable<BaseTexture> {\r\n        return this.imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public set colorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this.imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get colorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set colorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets exposure used in the effect.\r\n     */\r\n    public get exposure(): number {\r\n        return this.imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * Sets exposure used in the effect.\r\n     */\r\n    public set exposure(value: number) {\r\n        this.imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get toneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set toneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of tone mapping effect.\r\n     */\r\n    public get toneMappingType(): number {\r\n        return this._imageProcessingConfiguration.toneMappingType;\r\n    }\r\n    /**\r\n     * Sets the type of tone mapping effect.\r\n     */\r\n    public set toneMappingType(value: number) {\r\n        this._imageProcessingConfiguration.toneMappingType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets contrast used in the effect.\r\n     */\r\n    public get contrast(): number {\r\n        return this.imageProcessingConfiguration.contrast;\r\n    }\r\n    /**\r\n     * Sets contrast used in the effect.\r\n     */\r\n    public set contrast(value: number) {\r\n        this.imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette stretch size.\r\n     */\r\n    public get vignetteStretch(): number {\r\n        return this.imageProcessingConfiguration.vignetteStretch;\r\n    }\r\n    /**\r\n     * Sets Vignette stretch size.\r\n     */\r\n    public set vignetteStretch(value: number) {\r\n        this.imageProcessingConfiguration.vignetteStretch = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public get vignetteCentreX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    /**\r\n     * Sets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public set vignetteCentreX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public get vignetteCentreY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    /**\r\n     * Sets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public set vignetteCentreY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center Y Offset.\r\n     */\r\n    public get vignetteCenterY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    public set vignetteCenterY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center X Offset.\r\n     */\r\n    public get vignetteCenterX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    public set vignetteCenterX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public get vignetteWeight(): number {\r\n        return this.imageProcessingConfiguration.vignetteWeight;\r\n    }\r\n    /**\r\n     * Sets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public set vignetteWeight(value: number) {\r\n        this.imageProcessingConfiguration.vignetteWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public get vignetteColor(): Color4 {\r\n        return this.imageProcessingConfiguration.vignetteColor;\r\n    }\r\n    /**\r\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public set vignetteColor(value: Color4) {\r\n        this.imageProcessingConfiguration.vignetteColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Camera field of view used by the Vignette effect.\r\n     */\r\n    public get vignetteCameraFov(): number {\r\n        return this.imageProcessingConfiguration.vignetteCameraFov;\r\n    }\r\n    /**\r\n     * Sets Camera field of view used by the Vignette effect.\r\n     */\r\n    public set vignetteCameraFov(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCameraFov = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public get vignetteBlendMode(): number {\r\n        return this.imageProcessingConfiguration.vignetteBlendMode;\r\n    }\r\n    /**\r\n     * Sets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public set vignetteBlendMode(value: number) {\r\n        this.imageProcessingConfiguration.vignetteBlendMode = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the vignette effect is enabled.\r\n     */\r\n    public get vignetteEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.vignetteEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the vignette effect is enabled.\r\n     */\r\n    public set vignetteEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.vignetteEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets intensity of the dithering effect.\r\n     */\r\n    public get ditheringIntensity(): number {\r\n        return this.imageProcessingConfiguration.ditheringIntensity;\r\n    }\r\n    /**\r\n     * Sets intensity of the dithering effect.\r\n     */\r\n    public set ditheringIntensity(value: number) {\r\n        this.imageProcessingConfiguration.ditheringIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the dithering effect is enabled.\r\n     */\r\n    public get ditheringEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.ditheringEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the dithering effect is enabled.\r\n     */\r\n    public set ditheringEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.ditheringEnabled = value;\r\n    }\r\n\r\n    @serialize()\r\n    private _fromLinearSpace = true;\r\n    /**\r\n     * Gets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    public get fromLinearSpace(): boolean {\r\n        return this._fromLinearSpace;\r\n    }\r\n    /**\r\n     * Sets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    public set fromLinearSpace(value: boolean) {\r\n        if (this._fromLinearSpace === value) {\r\n            return;\r\n        }\r\n\r\n        this._fromLinearSpace = value;\r\n        this._updateParameters();\r\n    }\r\n\r\n    /**\r\n     * Defines cache preventing GC.\r\n     */\r\n    private _defines: IImageProcessingConfigurationDefines & { FROMLINEARSPACE: boolean } = {\r\n        IMAGEPROCESSING: false,\r\n        VIGNETTE: false,\r\n        VIGNETTEBLENDMODEMULTIPLY: false,\r\n        VIGNETTEBLENDMODEOPAQUE: false,\r\n        TONEMAPPING: false,\r\n        TONEMAPPING_ACES: false,\r\n        CONTRAST: false,\r\n        COLORCURVES: false,\r\n        COLORGRADING: false,\r\n        COLORGRADING3D: false,\r\n        FROMLINEARSPACE: false,\r\n        SAMPLER3DGREENDEPTH: false,\r\n        SAMPLER3DBGRMAP: false,\r\n        DITHER: false,\r\n        IMAGEPROCESSINGPOSTPROCESS: false,\r\n        EXPOSURE: false,\r\n        SKIPFINALCOLORCLAMP: false,\r\n    };\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        imageProcessingConfiguration?: ImageProcessingConfiguration\r\n    ) {\r\n        super(name, \"imageProcessing\", [], [], options, camera, samplingMode, engine, reusable, null, textureType, \"postprocess\", null, true);\r\n\r\n        // Setup the configuration as forced by the constructor. This would then not force the\r\n        // scene materials output in linear space and let untouched the default forward pass.\r\n        if (imageProcessingConfiguration) {\r\n            imageProcessingConfiguration.applyByPostProcess = true;\r\n            this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);\r\n            // This will cause the shader to be compiled\r\n            this._updateParameters();\r\n        }\r\n        // Setup the default processing configuration to the scene.\r\n        else {\r\n            this._attachImageProcessingConfiguration(null, true);\r\n            this.imageProcessingConfiguration.applyByPostProcess = true;\r\n        }\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            this.imageProcessingConfiguration.bind(effect, this.aspectRatio);\r\n        };\r\n    }\r\n    /**\r\n     *  \"ImageProcessingPostProcess\"\r\n     * @returns \"ImageProcessingPostProcess\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ImageProcessingPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateParameters(): void {\r\n        this._defines.FROMLINEARSPACE = this._fromLinearSpace;\r\n        this.imageProcessingConfiguration.prepareDefines(this._defines, true);\r\n        let defines = \"\";\r\n        for (const define in this._defines) {\r\n            if ((<any>this._defines)[define]) {\r\n                defines += `#define ${define};\\n`;\r\n            }\r\n        }\r\n\r\n        const samplers = [\"textureSampler\"];\r\n        const uniforms = [\"scale\"];\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\r\n        }\r\n\r\n        this.updateEffect(defines, uniforms, samplers);\r\n    }\r\n\r\n    public dispose(camera?: Camera): void {\r\n        super.dispose(camera);\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this.imageProcessingConfiguration.applyByPostProcess = false;\r\n        }\r\n    }\r\n}\r\n","import { Constants } from \"../Engines/constants\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\n\r\n/**\r\n * Contains all parameters needed for the prepass to perform\r\n * motion blur\r\n */\r\nexport class MotionBlurConfiguration implements PrePassEffectConfiguration {\r\n    /**\r\n     * Is motion blur enabled\r\n     */\r\n    public enabled = false;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = \"motionBlur\";\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [Constants.PREPASS_VELOCITY_TEXTURE_TYPE];\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"motionBlurPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform float motionStrength;uniform float motionScale;uniform vec2 screenSize;\n#ifdef OBJECT_BASED\nuniform sampler2D velocitySampler;\n#else\nuniform sampler2D depthSampler;uniform mat4 inverseViewProjection;uniform mat4 prevViewProjection;uniform mat4 projection;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#ifdef GEOMETRY_SUPPORTED\n#ifdef OBJECT_BASED\nvec2 texelSize=1.0/screenSize;vec4 velocityColor=texture2D(velocitySampler,vUV);velocityColor.rg=velocityColor.rg*2.0-vec2(1.0);vec2 velocity=vec2(pow(velocityColor.r,3.0),pow(velocityColor.g,3.0))*velocityColor.a;velocity*=motionScale*motionStrength;float speed=length(velocity/texelSize);int samplesCount=int(clamp(speed,1.0,SAMPLES));velocity=normalize(velocity)*texelSize;float hlim=float(-samplesCount)*0.5+0.5;vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(SAMPLES); ++i)\n{if (i>=samplesCount)\nbreak;vec2 offset=vUV+velocity*(hlim+float(i));\n#if defined(WEBGPU)\nresult+=texture2DLodEXT(textureSampler,offset,0.0);\n#else\nresult+=texture2D(textureSampler,offset);\n#endif\n}\ngl_FragColor=result/float(samplesCount);gl_FragColor.a=1.0;\n#else\nvec2 texelSize=1.0/screenSize;float depth=texture2D(depthSampler,vUV).r;depth=projection[2].z+projection[3].z/depth; \nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);cpos=inverseViewProjection*cpos;cpos/=cpos.w;vec4 ppos=prevViewProjection*cpos;ppos/=ppos.w;ppos.xy=ppos.xy*0.5+0.5;vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;float speed=length(velocity/texelSize);int nSamples=int(clamp(speed,1.0,SAMPLES));vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(SAMPLES); ++i) {if (i>=nSamples)\nbreak;vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\n#if defined(WEBGPU)\nresult+=texture2DLodEXT(textureSampler,offset1,0.0);\n#else\nresult+=texture2D(textureSampler,offset1);\n#endif\n}\ngl_FragColor=result/float(nSamples);\n#endif\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const motionBlurPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport \"../Rendering/geometryBufferRendererSceneComponent\";\r\nimport \"../Shaders/motionBlur.fragment\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n        this._updateEffect();\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this._isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _isObjectBased: boolean = true;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _invViewProjection: Nullable<Matrix> = null;\r\n    private _previousViewProjection: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"motionBlur\",\r\n            [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"],\r\n            [\"velocitySampler\", \"depthSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = true;\r\n            }\r\n        } else {\r\n            scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode(): void {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return this.updateEffect();\r\n        }\r\n\r\n        this._updateEffect();\r\n\r\n        this._invViewProjection = null;\r\n        this._previousViewProjection = null;\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_VELOCITY_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            this._invViewProjection = Matrix.Identity();\r\n            this._previousViewProjection = this._scene.getTransformMatrix().clone();\r\n\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_DEPTH_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        const viewProjection = TmpVectors.Matrix[0];\r\n        viewProjection.copyFrom(this._scene.getTransformMatrix());\r\n\r\n        viewProjection.invertToRef(this._invViewProjection!);\r\n        effect.setMatrix(\"inverseViewProjection\", this._invViewProjection!);\r\n\r\n        effect.setMatrix(\"prevViewProjection\", this._previousViewProjection!);\r\n        this._previousViewProjection!.copyFrom(viewProjection);\r\n\r\n        effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect must be updated (changed mode, samples count, etc.).\r\n     */\r\n    private _updateEffect(): void {\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            const defines: string[] = [\r\n                \"#define GEOMETRY_SUPPORTED\",\r\n                \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1),\r\n                this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\",\r\n            ];\r\n\r\n            this.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new MotionBlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\r\n","import { Constants } from \"../Engines/constants\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\n\r\n/**\r\n * Contains all parameters needed for the prepass to perform\r\n * screen space reflections\r\n */\r\nexport class ScreenSpaceReflectionsConfiguration implements PrePassEffectConfiguration {\r\n    /**\r\n     * Is ssr enabled\r\n     */\r\n    public enabled = false;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = \"screenSpaceReflections\";\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [Constants.PREPASS_NORMAL_TEXTURE_TYPE, Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE, Constants.PREPASS_POSITION_TEXTURE_TYPE];\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\n#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;uniform sampler2D normalSampler;uniform sampler2D positionSampler;\n#endif\nuniform mat4 view;uniform mat4 projection;uniform float stepSize;uniform float strength;uniform float threshold;uniform float roughnessFactor;uniform float reflectionSpecularFalloffExponent;varying vec2 vUV;\n#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {vec3 color;vec4 coords;};/**\n* According to specular,see https:\n*/\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\n{return F0+(1.0-F0)*pow(1.0-cosTheta,5.0);}\n/**\n* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\n* by sampling multiple reflection pixels.\n*/\nReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\n{ReflectionInfo info;info.color=vec3(0.0);vec4 projectedCoord;float sampledDepth;for(int i=0; i<SMOOTH_STEPS; i++)\n{projectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;float depth=sampledDepth-hitCoord.z;dir*=0.5;if(depth>0.0)\nhitCoord-=dir;else\nhitCoord+=dir;info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;}\nprojectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);info.coords=vec4(projectedCoord.xy,sampledDepth,1.0);info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;info.color/=float(SMOOTH_STEPS+1);return info;}\n/**\n* Tests the given world position (hitCoord) according to the given reflection vector (dir)\n* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\n*/\nReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\n{ReflectionInfo info;vec4 projectedCoord;float sampledDepth;dir*=stepSize;for(int i=0; i<REFLECTION_SAMPLES; i++)\n{hitCoord+=dir;projectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;float depth=sampledDepth-hitCoord.z;\n#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\n#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\n{\n#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\n#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);return info;\n#endif\n}}\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);return info;}\nvec3 hash(vec3 a)\n{a=fract(a*0.8);a+=dot(a,a.yxz+19.19);return fract((a.xxy+a.yxx)*a.zyx);}\n#endif\nvoid main()\n{\n#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);vec3 albedo=albedoFull.rgb;float spec=texture2D(reflectivitySampler,vUV).r;if (spec==0.0) {gl_FragColor=albedoFull;return;}\nvec3 normal=(texture2D(normalSampler,vUV)).xyz;vec3 position=(view*texture2D(positionSampler,vUV)).xyz;vec3 reflected=normalize(reflect(normalize(position),normalize(normal)));float roughness=1.0-texture2D(reflectivitySampler,vUV).a;vec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;ReflectionInfo info=getReflectionInfo(jitt+reflected,position);vec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));float screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);vec3 F0=vec3(0.04);F0 =mix(F0,albedo,spec);vec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\n#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\n#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);float albedoMultiplier=1.0-reflectionMultiplier;vec3 SSR=info.color*fresnel;gl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflectionPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\r\n\r\nimport \"../Shaders/screenSpaceReflection.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n * @deprecated Use the new SSRRenderingPipeline instead.\r\n */\r\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\r\n    @serialize()\r\n    public threshold: number = 1.2;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\r\n    @serialize()\r\n    public strength: number = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent: number = 3;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\r\n    @serialize()\r\n    public step: number = 1.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor: number = 0.2;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _enableSmoothReflections: boolean = false;\r\n    private _reflectionSamples: number = 64;\r\n    private _smoothSteps: number = 5;\r\n    private _isSceneRightHanded: boolean;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ScreenSpaceReflectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to calculate reflections.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"screenSpaceReflection\",\r\n            [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"],\r\n            [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this._forceGeometryBuffer) {\r\n            // Get geometry buffer renderer and update effect\r\n            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n            if (geometryBufferRenderer) {\r\n                if (geometryBufferRenderer.isSupported) {\r\n                    geometryBufferRenderer.enablePosition = true;\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n                }\r\n            }\r\n        } else {\r\n            const prePassRenderer = scene.enablePrePassRenderer();\r\n            prePassRenderer?.markAsDirty();\r\n            this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\r\n        }\r\n\r\n        this._updateEffectDefines();\r\n\r\n        // On apply, send uniforms\r\n        this.onApply = (effect: Effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                // Samplers\r\n                const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n            } else if (prePassRenderer) {\r\n                // Samplers\r\n                const positionIndex = prePassRenderer.getIndex(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n            }\r\n\r\n            // Uniforms\r\n            const camera = scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix(true);\r\n            const projectionMatrix = camera.getProjectionMatrix(true);\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setFloat(\"threshold\", this.threshold);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"stepSize\", this.step);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n        };\r\n\r\n        this._isSceneRightHanded = scene.useRightHandedSystem;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    @serialize()\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    @serialize()\r\n    public get reflectionSamples(): number {\r\n        return this._reflectionSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    public set reflectionSamples(samples: number) {\r\n        if (samples === this._reflectionSamples) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionSamples = samples;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    @serialize()\r\n    public get smoothSteps(): number {\r\n        return this._smoothSteps;\r\n    }\r\n\r\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    public set smoothSteps(steps: number) {\r\n        if (steps === this._smoothSteps) {\r\n            return;\r\n        }\r\n\r\n        this._smoothSteps = steps;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\r\n        }\r\n        if (this._isSceneRightHanded) {\r\n            defines.push(\"#define RIGHT_HANDED_SCENE\");\r\n        }\r\n\r\n        defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\r\n        defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\r\n\r\n        this.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ScreenSpaceReflectionPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"sharpenPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform vec2 sharpnessAmounts;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 onePixel=vec2(1.0,1.0)/screenSize;vec4 color=texture2D(textureSampler,vUV);vec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\ncolor*4.0;gl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const sharpenPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/sharpen.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * The SharpenPostProcess applies a sharpen kernel to every pixel\r\n * See http://en.wikipedia.org/wiki/Kernel_(image_processing)\r\n */\r\nexport class SharpenPostProcess extends PostProcess {\r\n    /**\r\n     * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)\r\n     */\r\n    @serialize()\r\n    public colorAmount: number = 1.0;\r\n    /**\r\n     * How much sharpness should be applied (default: 0.3)\r\n     */\r\n    @serialize()\r\n    public edgeAmount: number = 0.3;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"SharpenPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"SharpenPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConvolutionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false\r\n    ) {\r\n        super(name, \"sharpen\", [\"sharpnessAmounts\", \"screenSize\"], null, options, camera, samplingMode, engine, reusable, null, textureType, undefined, null, blockCompilation);\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            effect.setFloat2(\"screenSize\", this.width, this.height);\r\n            effect.setFloat2(\"sharpnessAmounts\", this.edgeAmount, this.colorAmount);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new SharpenPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SharpenPostProcess\", SharpenPostProcess);\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"vrDistortionCorrectionPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 LensCenter;uniform vec2 Scale;uniform vec2 ScaleIn;uniform vec4 HmdWarpParam;vec2 HmdWarp(vec2 in01) {vec2 theta=(in01-LensCenter)*ScaleIn; \nfloat rSq=theta.x*theta.x+theta.y*theta.y;vec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);return LensCenter+Scale*rvector;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 tc=HmdWarp(vUV);if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);else{gl_FragColor=texture2D(textureSampler,tc);}}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const vrDistortionCorrectionPixelShader = { name, shader };\n","import { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { VRCameraMetrics } from \"../Cameras/VR/vrCameraMetrics\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { PostProcess } from \"./postProcess\";\r\n\r\nimport \"../Shaders/vrDistortionCorrection.fragment\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * VRDistortionCorrectionPostProcess used for mobile VR\r\n */\r\nexport class VRDistortionCorrectionPostProcess extends PostProcess {\r\n    private _isRightEye: boolean;\r\n    private _distortionFactors: number[];\r\n    private _postProcessScaleFactor: number;\r\n    private _lensCenterOffset: number;\r\n    private _scaleIn: Vector2;\r\n    private _scaleFactor: Vector2;\r\n    private _lensCenter: Vector2;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"VRDistortionCorrectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRDistortionCorrectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes the VRDistortionCorrectionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param isRightEye If this is for the right eye distortion\r\n     * @param vrMetrics All the required metrics for the VR camera\r\n     */\r\n    constructor(name: string, camera: Nullable<Camera>, isRightEye: boolean, vrMetrics: VRCameraMetrics) {\r\n        super(name, \"vrDistortionCorrection\", [\"LensCenter\", \"Scale\", \"ScaleIn\", \"HmdWarpParam\"], null, vrMetrics.postProcessScaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);\r\n\r\n        this._isRightEye = isRightEye;\r\n        this._distortionFactors = vrMetrics.distortionK;\r\n        this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;\r\n        this._lensCenterOffset = vrMetrics.lensCenterOffset;\r\n        this.adaptScaleToCurrentViewport = true;\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._scaleIn = new Vector2(2, 2 / this.aspectRatio);\r\n            this._scaleFactor = new Vector2(0.5 * (1 / this._postProcessScaleFactor), 0.5 * (1 / this._postProcessScaleFactor) * this.aspectRatio);\r\n            this._lensCenter = new Vector2(this._isRightEye ? 0.5 - this._lensCenterOffset * 0.5 : 0.5 + this._lensCenterOffset * 0.5, 0.5);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"LensCenter\", this._lensCenter.x, this._lensCenter.y);\r\n            effect.setFloat2(\"Scale\", this._scaleFactor.x, this._scaleFactor.y);\r\n            effect.setFloat2(\"ScaleIn\", this._scaleIn.x, this._scaleIn.y);\r\n            effect.setFloat4(\"HmdWarpParam\", this._distortionFactors[0], this._distortionFactors[1], this._distortionFactors[2], this._distortionFactors[3]);\r\n        });\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"vrMultiviewToSingleviewPixelShader\";\nconst shader = `precision mediump sampler2DArray;varying vec2 vUV;uniform sampler2DArray multiviewSampler;uniform int imageIndex;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{gl_FragColor=texture2D(multiviewSampler,vec3(vUV,imageIndex));}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const vrMultiviewToSingleviewPixelShader = { name, shader };\n","import type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { PostProcess } from \"./postProcess\";\r\n\r\nimport \"../Shaders/vrMultiviewToSingleview.fragment\";\r\nimport \"../Engines/Extensions/engine.multiview\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR\r\n * This will not be used for webXR as it supports displaying texture arrays directly\r\n */\r\nexport class VRMultiviewToSingleviewPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"VRMultiviewToSingleviewPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRMultiviewToSingleviewPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a VRMultiviewToSingleview\r\n     * @param name name of the post process\r\n     * @param camera camera to be applied to\r\n     * @param scaleFactor scaling factor to the size of the output texture\r\n     */\r\n    constructor(name: string, camera: Nullable<Camera>, scaleFactor: number) {\r\n        super(name, \"vrMultiviewToSingleview\", [\"imageIndex\"], [\"multiviewSampler\"], scaleFactor, camera, Texture.BILINEAR_SAMPLINGMODE);\r\n\r\n        const cam = camera ?? this.getCamera();\r\n        this.onSizeChangedObservable.add(() => {});\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (cam._scene.activeCamera && cam._scene.activeCamera.isLeftCamera) {\r\n                effect.setInt(\"imageIndex\", 0);\r\n            } else {\r\n                effect.setInt(\"imageIndex\", 1);\r\n            }\r\n            effect.setTexture(\"multiviewSampler\", cam._multiviewTexture);\r\n        });\r\n    }\r\n}\r\n","import { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of reflection probes added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n         */\r\n        reflectionProbes: Array<ReflectionProbe>;\r\n\r\n        /**\r\n         * Removes the given reflection probe from this scene.\r\n         * @param toRemove The reflection probe to remove\r\n         * @returns The index of the removed reflection probe\r\n         */\r\n        removeReflectionProbe(toRemove: ReflectionProbe): number;\r\n\r\n        /**\r\n         * Adds the given reflection probe to this scene.\r\n         * @param newReflectionProbe The reflection probe to add\r\n         */\r\n        addReflectionProbe(newReflectionProbe: ReflectionProbe): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeReflectionProbe = function (toRemove: ReflectionProbe): number {\r\n    if (!this.reflectionProbes) {\r\n        return -1;\r\n    }\r\n\r\n    const index = this.reflectionProbes.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.reflectionProbes.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe: ReflectionProbe): void {\r\n    if (!this.reflectionProbes) {\r\n        this.reflectionProbes = [];\r\n    }\r\n\r\n    this.reflectionProbes.push(newReflectionProbe);\r\n};\r\n\r\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n */\r\nexport class ReflectionProbe {\r\n    private _scene: Scene;\r\n    private _renderTargetTexture: RenderTargetTexture;\r\n    private _projectionMatrix: Matrix;\r\n    private _viewMatrix = Matrix.Identity();\r\n    private _target = Vector3.Zero();\r\n    private _add = Vector3.Zero();\r\n    @serializeAsMeshReference()\r\n    private _attachedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _invertYAxis = false;\r\n    private _sceneUBOs: UniformBuffer[];\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /** Gets or sets probe position (center of the cube map) */\r\n    @serializeAsVector3()\r\n    public position = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the reflection probe.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Creates a new reflection probe\r\n     * @param name defines the name of the probe\r\n     * @param size defines the texture resolution (for each face)\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\r\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\r\n     */\r\n    constructor(\r\n        /** defines the name of the probe */\r\n        public name: string,\r\n        size: number,\r\n        scene: Scene,\r\n        generateMipMaps = true,\r\n        useFloat = false,\r\n        linearSpace = false\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        if (scene.getEngine().supportsUniformBuffers) {\r\n            this._sceneUBOs = [];\r\n            for (let i = 0; i < 6; ++i) {\r\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\r\n            }\r\n        }\r\n\r\n        // Create the scene field if not exist.\r\n        if (!this._scene.reflectionProbes) {\r\n            this._scene.reflectionProbes = new Array<ReflectionProbe>();\r\n        }\r\n        this._scene.reflectionProbes.push(this);\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (useFloat) {\r\n            const caps = this._scene.getEngine().getCaps();\r\n            if (caps.textureHalfFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        }\r\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\r\n        this._renderTargetTexture.gammaSpace = !linearSpace;\r\n        this._renderTargetTexture.invertZ = scene.useRightHandedSystem;\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\r\n                scene.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    this._add.copyFromFloats(1, 0, 0);\r\n                    break;\r\n                case 1:\r\n                    this._add.copyFromFloats(-1, 0, 0);\r\n                    break;\r\n                case 2:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\r\n                    break;\r\n                case 3:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\r\n                    break;\r\n                case 4:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\r\n                    break;\r\n                case 5:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\r\n                    break;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\r\n            }\r\n\r\n            this.position.addToRef(this._add, this._target);\r\n\r\n            const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\r\n            const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\r\n\r\n            lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\r\n\r\n            if (scene.activeCamera) {\r\n                this._projectionMatrix = perspectiveFunction(\r\n                    Math.PI / 2,\r\n                    1,\r\n                    useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ,\r\n                    useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ,\r\n                    this._scene.getEngine().isNDCHalfZRange\r\n                );\r\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n                if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\r\n                    this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\r\n                }\r\n            }\r\n            scene._forcedViewPosition = this.position;\r\n        });\r\n\r\n        let currentApplyByPostProcess: boolean;\r\n\r\n        this._renderTargetTexture.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = scene.getSceneUniformBuffer();\r\n            scene.getEngine()._debugPushGroup?.(`reflection probe generation for ${name}`, 1);\r\n            currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (linearSpace) {\r\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\r\n            }\r\n        });\r\n\r\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\r\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\r\n            scene._forcedViewPosition = null;\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene.updateTransformMatrix(true);\r\n            scene.getEngine()._debugPopGroup?.(1);\r\n        });\r\n    }\r\n\r\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\r\n    public get samples(): number {\r\n        return this._renderTargetTexture.samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        this._renderTargetTexture.samples = value;\r\n    }\r\n\r\n    /** Gets or sets the refresh rate to use (on every frame by default) */\r\n    public get refreshRate(): number {\r\n        return this._renderTargetTexture.refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._renderTargetTexture.refreshRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets the internal CubeTexture used to render to */\r\n    public get cubeTexture(): RenderTargetTexture {\r\n        return this._renderTargetTexture;\r\n    }\r\n\r\n    /** Gets the list of meshes to render */\r\n    public get renderList(): Nullable<AbstractMesh[]> {\r\n        return this._renderTargetTexture.renderList;\r\n    }\r\n\r\n    /**\r\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n     * @param mesh defines the mesh to attach to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>): void {\r\n        this._attachedMesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clean all associated resources\r\n     */\r\n    public dispose() {\r\n        const index = this._scene.reflectionProbes.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this._scene.reflectionProbes.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.reflectionProbes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.reflectionProbes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._renderTargetTexture) {\r\n            this._renderTargetTexture.dispose();\r\n            (<any>this._renderTargetTexture) = null;\r\n        }\r\n\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n            this._sceneUBOs = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the reflection probe information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable reflection probe info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n\r\n        if (fullDetails) {\r\n            ret += \", position: \" + this.position.toString();\r\n\r\n            if (this._attachedMesh) {\r\n                ret += \", attached mesh: \" + this._attachedMesh.name;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the refection probe.\r\n     * @returns \"ReflectionProbe\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ReflectionProbe\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\r\n        serializationObject.isReflectionProbe = true;\r\n        serializationObject.metadata = this.metadata;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed reflection probe if successful\r\n     */\r\n    public static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe> {\r\n        let reflectionProbe: Nullable<ReflectionProbe> = null;\r\n        if (scene.reflectionProbes) {\r\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const rp = scene.reflectionProbes[index];\r\n                if (rp.name === parsedReflectionProbe.name) {\r\n                    reflectionProbe = rp;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        reflectionProbe = SerializationHelper.Parse(\r\n            () => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps),\r\n            parsedReflectionProbe,\r\n            scene,\r\n            rootUrl\r\n        );\r\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\r\n\r\n        if (parsedReflectionProbe._attachedMesh) {\r\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\r\n        }\r\n\r\n        if (parsedReflectionProbe.metadata) {\r\n            reflectionProbe.metadata = parsedReflectionProbe.metadata;\r\n        }\r\n\r\n        return reflectionProbe;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"oitFinalPixelShader\";\nconst shader = `precision highp float;uniform sampler2D uFrontColor;uniform sampler2D uBackColor;void main() {ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec4 frontColor=texelFetch(uFrontColor,fragCoord,0);vec4 backColor=texelFetch(uBackColor,fragCoord,0);float alphaMultiplier=1.0-frontColor.a;glFragColor=vec4(\nfrontColor.rgb+alphaMultiplier*backColor.rgb,\nfrontColor.a+backColor.a\n);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const oitFinalPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"oitBackBlendPixelShader\";\nconst shader = `precision highp float;uniform sampler2D uBackColor;void main() {glFragColor=texelFetch(uBackColor,ivec2(gl_FragCoord.xy),0);if (glFragColor.a==0.0) { \ndiscard;}}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const oitBackBlendPixelShader = { name, shader };\n","/**\r\n * Implementation based on https://medium.com/@shrekshao_71662/dual-depth-peeling-implementation-in-webgl-11baa061ba4b\r\n */\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\r\nimport type { InternalTextureCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\nimport type { PrePassRenderer } from \"./prePassRenderer\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { Material } from \"../Materials/material\";\r\n\r\nimport \"../Shaders/postprocess.vertex\";\r\nimport \"../Shaders/oitFinal.fragment\";\r\nimport \"../Shaders/oitBackBlend.fragment\";\r\n\r\nclass DepthPeelingEffectConfiguration implements PrePassEffectConfiguration {\r\n    /**\r\n     * Is this effect enabled\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = \"depthPeeling\";\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\r\n}\r\n\r\n/**\r\n * The depth peeling renderer that performs\r\n * Order independant transparency (OIT).\r\n * This should not be instanciated directly, as it is part of a scene component\r\n */\r\nexport class DepthPeelingRenderer {\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _depthMrts: MultiRenderTarget[];\r\n    private _thinTextures: ThinTexture[] = [];\r\n    private _colorMrts: MultiRenderTarget[];\r\n    private _blendBackMrt: MultiRenderTarget;\r\n    private _outputRT: RenderTargetTexture;\r\n\r\n    private _blendBackEffectWrapper: EffectWrapper;\r\n    private _blendBackEffectWrapperPingPong: EffectWrapper;\r\n    private _finalEffectWrapper: EffectWrapper;\r\n    private _effectRenderer: EffectRenderer;\r\n\r\n    private _currentPingPongState: number = 0;\r\n    private _prePassEffectConfiguration: DepthPeelingEffectConfiguration;\r\n\r\n    private _blendBackTexture: InternalTexture;\r\n    private _layoutCacheFormat = [[true], [true, true], [true, true, true]];\r\n    private _layoutCache: number[][] = [];\r\n    private _renderPassIds: number[];\r\n    private _candidateSubMeshes: SmartArray<SubMesh> = new SmartArray(10);\r\n    private _excludedSubMeshes: SmartArray<SubMesh> = new SmartArray(10);\r\n    private _excludedMeshes: number[] = [];\r\n\r\n    private static _DEPTH_CLEAR_VALUE = -99999.0;\r\n    private static _MIN_DEPTH = 0;\r\n    private static _MAX_DEPTH = 1;\r\n\r\n    private _colorCache = [\r\n        new Color4(DepthPeelingRenderer._DEPTH_CLEAR_VALUE, DepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),\r\n        new Color4(-DepthPeelingRenderer._MIN_DEPTH, DepthPeelingRenderer._MAX_DEPTH, 0, 0),\r\n        new Color4(0, 0, 0, 0),\r\n    ];\r\n\r\n    private _passCount: number;\r\n    /**\r\n     * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.\r\n     */\r\n    public get passCount(): number {\r\n        return this._passCount;\r\n    }\r\n\r\n    public set passCount(count: number) {\r\n        if (this._passCount === count) {\r\n            return;\r\n        }\r\n        this._passCount = count;\r\n        this._createRenderPassIds();\r\n    }\r\n\r\n    private _useRenderPasses: boolean;\r\n    /**\r\n     * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.\r\n     */\r\n    public get useRenderPasses() {\r\n        return this._useRenderPasses;\r\n    }\r\n\r\n    public set useRenderPasses(usePasses: boolean) {\r\n        if (this._useRenderPasses === usePasses) {\r\n            return;\r\n        }\r\n        this._useRenderPasses = usePasses;\r\n        this._createRenderPassIds();\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to be handled by the depth peeling renderer\r\n     * @param mesh The mesh to exclude from the depth peeling renderer\r\n     */\r\n    public addExcludedMesh(mesh: AbstractMesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list of the depth peeling renderer\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: AbstractMesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instanciates the depth peeling renderer\r\n     * @param scene Scene to attach to\r\n     * @param passCount Number of depth layers to peel\r\n     * @returns The depth peeling renderer\r\n     */\r\n    constructor(scene: Scene, passCount: number = 5) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._passCount = passCount;\r\n\r\n        //  We need a depth texture for opaque\r\n        if (!scene.enablePrePassRenderer()) {\r\n            Logger.Warn(\"Depth peeling for order independant transparency could not enable PrePass, aborting.\");\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < this._layoutCacheFormat.length; ++i) {\r\n            this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);\r\n        }\r\n\r\n        this._renderPassIds = [];\r\n        this.useRenderPasses = false;\r\n\r\n        this._prePassEffectConfiguration = new DepthPeelingEffectConfiguration();\r\n        this._createTextures();\r\n        this._createEffects();\r\n    }\r\n\r\n    private _createRenderPassIds(): void {\r\n        this._releaseRenderPassIds();\r\n        if (this._useRenderPasses) {\r\n            for (let i = 0; i < this._passCount + 1; ++i) {\r\n                if (!this._renderPassIds[i]) {\r\n                    this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _releaseRenderPassIds(): void {\r\n        for (let i = 0; i < this._renderPassIds.length; ++i) {\r\n            this._engine.releaseRenderPassId(this._renderPassIds[i]);\r\n        }\r\n        this._renderPassIds = [];\r\n    }\r\n\r\n    private _createTextures() {\r\n        const size = {\r\n            width: this._engine.getRenderWidth(),\r\n            height: this._engine.getRenderHeight(),\r\n        };\r\n\r\n        // 2 for ping pong\r\n        this._depthMrts = [new MultiRenderTarget(\"depthPeelingDepth0\", size, 3, this._scene), new MultiRenderTarget(\"depthPeelingDepth1\", size, 3, this._scene)];\r\n        this._colorMrts = [\r\n            new MultiRenderTarget(\"depthPeelingColor0\", size, 2, this._scene, { generateDepthBuffer: false }),\r\n            new MultiRenderTarget(\"depthPeelingColor1\", size, 2, this._scene, { generateDepthBuffer: false }),\r\n        ];\r\n        this._blendBackMrt = new MultiRenderTarget(\"depthPeelingBack\", size, 1, this._scene, { generateDepthBuffer: false });\r\n        this._outputRT = new RenderTargetTexture(\"depthPeelingOutput\", size, this._scene, false);\r\n\r\n        // 0 is a depth texture\r\n        // 1 is a color texture\r\n        const optionsArray = [\r\n            {\r\n                format: Constants.TEXTUREFORMAT_RG, // For MSAA we need RGBA\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                type: this._engine.getCaps().textureFloatLinearFiltering ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT,\r\n                label: \"DepthPeelingRenderer-DepthTexture\",\r\n            } as InternalTextureCreationOptions,\r\n            {\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                type: Constants.TEXTURETYPE_HALF_FLOAT, // For MSAA we need FLOAT\r\n                label: \"DepthPeelingRenderer-ColorTexture\",\r\n            } as InternalTextureCreationOptions,\r\n        ];\r\n\r\n        for (let i = 0; i < 2; i++) {\r\n            const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);\r\n            const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\r\n            const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\r\n\r\n            this._depthMrts[i].setInternalTexture(depthTexture, 0);\r\n            this._depthMrts[i].setInternalTexture(frontColorTexture, 1);\r\n            this._depthMrts[i].setInternalTexture(backColorTexture, 2);\r\n            this._colorMrts[i].setInternalTexture(frontColorTexture, 0);\r\n            this._colorMrts[i].setInternalTexture(backColorTexture, 1);\r\n\r\n            this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));\r\n        }\r\n    }\r\n\r\n    // TODO : explore again MSAA with depth peeling when\r\n    // we are able to fetch individual samples in a multisampled renderbuffer\r\n    // public set samples(value: number) {\r\n    //     for (let i = 0; i < 2; i++) {\r\n    //         this._depthMrts[i].samples = value;\r\n    //         this._colorMrts[i].samples = value;\r\n    //     }\r\n    //     this._scene.prePassRenderer!.samples = value;\r\n    // }\r\n\r\n    private _disposeTextures() {\r\n        for (let i = 0; i < this._thinTextures.length; i++) {\r\n            if (i === 6) {\r\n                // Do not dispose the shared texture with the prepass\r\n                continue;\r\n            }\r\n            this._thinTextures[i].dispose();\r\n        }\r\n\r\n        for (let i = 0; i < 2; i++) {\r\n            this._depthMrts[i].dispose(true);\r\n            this._colorMrts[i].dispose(true);\r\n            this._blendBackMrt.dispose(true);\r\n        }\r\n        this._outputRT.dispose();\r\n\r\n        this._thinTextures = [];\r\n        this._colorMrts = [];\r\n        this._depthMrts = [];\r\n    }\r\n\r\n    private _updateTextures() {\r\n        if (this._depthMrts[0].getSize().width !== this._engine.getRenderWidth() || this._depthMrts[0].getSize().height !== this._engine.getRenderHeight()) {\r\n            this._disposeTextures();\r\n            this._createTextures();\r\n        }\r\n        return this._updateTextureReferences();\r\n    }\r\n\r\n    private _updateTextureReferences() {\r\n        const prePassRenderer = this._scene.prePassRenderer;\r\n\r\n        if (!prePassRenderer) {\r\n            return false;\r\n        }\r\n\r\n        // Retrieve opaque color texture\r\n        const textureIndex = prePassRenderer.getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE);\r\n        const prePassTexture = prePassRenderer.defaultRT.textures?.length ? prePassRenderer.defaultRT.textures[textureIndex].getInternalTexture() : null;\r\n\r\n        if (!prePassTexture) {\r\n            return false;\r\n        }\r\n\r\n        if (this._blendBackTexture !== prePassTexture) {\r\n            this._blendBackTexture = prePassTexture;\r\n            this._blendBackMrt.setInternalTexture(this._blendBackTexture, 0);\r\n\r\n            if (this._thinTextures[6]) {\r\n                this._thinTextures[6].dispose();\r\n            }\r\n            this._thinTextures[6] = new ThinTexture(this._blendBackTexture);\r\n\r\n            prePassRenderer.defaultRT.renderTarget!._shareDepth(this._depthMrts[0].renderTarget!);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _createEffects() {\r\n        this._blendBackEffectWrapper = new EffectWrapper({\r\n            fragmentShader: \"oitBackBlend\",\r\n            useShaderStore: true,\r\n            engine: this._engine,\r\n            samplerNames: [\"uBackColor\"],\r\n            uniformNames: [],\r\n        });\r\n        this._blendBackEffectWrapperPingPong = new EffectWrapper({\r\n            fragmentShader: \"oitBackBlend\",\r\n            useShaderStore: true,\r\n            engine: this._engine,\r\n            samplerNames: [\"uBackColor\"],\r\n            uniformNames: [],\r\n        });\r\n\r\n        this._finalEffectWrapper = new EffectWrapper({\r\n            fragmentShader: \"oitFinal\",\r\n            useShaderStore: true,\r\n            engine: this._engine,\r\n            samplerNames: [\"uFrontColor\", \"uBackColor\"],\r\n            uniformNames: [],\r\n        });\r\n\r\n        this._effectRenderer = new EffectRenderer(this._engine);\r\n    }\r\n\r\n    /**\r\n     * Links to the prepass renderer\r\n     * @param prePassRenderer The scene PrePassRenderer\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer) {\r\n        prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n    }\r\n\r\n    /**\r\n     * Binds depth peeling textures on an effect\r\n     * @param effect The effect to bind textures on\r\n     */\r\n    public bind(effect: Effect) {\r\n        effect.setTexture(\"oitDepthSampler\", this._thinTextures[this._currentPingPongState * 3]);\r\n        effect.setTexture(\"oitFrontColorSampler\", this._thinTextures[this._currentPingPongState * 3 + 1]);\r\n    }\r\n\r\n    private _renderSubMeshes(transparentSubMeshes: SmartArray<SubMesh>) {\r\n        let mapMaterialContext: { [uniqueId: number]: IMaterialContext | undefined };\r\n        if (this._useRenderPasses) {\r\n            mapMaterialContext = {};\r\n        }\r\n        for (let j = 0; j < transparentSubMeshes.length; j++) {\r\n            const material = transparentSubMeshes.data[j].getMaterial();\r\n            let previousShaderHotSwapping = true;\r\n            let previousBFC = false;\r\n\r\n            const subMesh = transparentSubMeshes.data[j];\r\n            let drawWrapper: DrawWrapper | undefined;\r\n            let firstDraw = false;\r\n\r\n            if (this._useRenderPasses) {\r\n                drawWrapper = subMesh._getDrawWrapper();\r\n                firstDraw = !drawWrapper;\r\n            }\r\n\r\n            if (material) {\r\n                previousShaderHotSwapping = material.allowShaderHotSwapping;\r\n                previousBFC = material.backFaceCulling;\r\n                material.allowShaderHotSwapping = false;\r\n                material.backFaceCulling = false;\r\n            }\r\n\r\n            subMesh.render(false);\r\n\r\n            if (firstDraw) {\r\n                // first time we draw this submesh: we replace the material context\r\n                drawWrapper = subMesh._getDrawWrapper()!; // we are sure it is now non empty as we just rendered the submesh\r\n                if (drawWrapper.materialContext) {\r\n                    let newMaterialContext = mapMaterialContext![drawWrapper.materialContext.uniqueId];\r\n                    if (!newMaterialContext) {\r\n                        newMaterialContext = mapMaterialContext![drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();\r\n                    }\r\n                    subMesh._getDrawWrapper()!.materialContext = newMaterialContext;\r\n                }\r\n            }\r\n\r\n            if (material) {\r\n                material.allowShaderHotSwapping = previousShaderHotSwapping;\r\n                material.backFaceCulling = previousBFC;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _finalCompose(writeId: number) {\r\n        const output = this._scene.prePassRenderer?.setCustomOutput(this._outputRT);\r\n        if (output) {\r\n            this._engine.bindFramebuffer(this._outputRT.renderTarget!);\r\n        } else {\r\n            this._engine.restoreDefaultFramebuffer();\r\n        }\r\n\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        this._engine.applyStates();\r\n\r\n        this._engine.enableEffect(this._finalEffectWrapper._drawWrapper);\r\n        this._finalEffectWrapper.effect.setTexture(\"uFrontColor\", this._thinTextures[writeId * 3 + 1]);\r\n        this._finalEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[6]);\r\n        this._effectRenderer.render(this._finalEffectWrapper);\r\n    }\r\n\r\n    /**\r\n     * Renders transparent submeshes with depth peeling\r\n     * @param transparentSubMeshes List of transparent meshes to render\r\n     * @returns The array of submeshes that could not be handled by this renderer\r\n     */\r\n    public render(transparentSubMeshes: SmartArray<SubMesh>): SmartArray<SubMesh> {\r\n        this._candidateSubMeshes.length = 0;\r\n        this._excludedSubMeshes.length = 0;\r\n        if (\r\n            !this._blendBackEffectWrapper.effect.isReady() ||\r\n            !this._blendBackEffectWrapperPingPong.effect.isReady() ||\r\n            !this._finalEffectWrapper.effect.isReady() ||\r\n            !this._updateTextures()\r\n        ) {\r\n            return this._excludedSubMeshes;\r\n        }\r\n\r\n        for (let i = 0; i < transparentSubMeshes.length; i++) {\r\n            const subMesh = transparentSubMeshes.data[i];\r\n            const material = subMesh.getMaterial();\r\n            const fillMode = material && subMesh.getRenderingMesh()._getRenderingFillMode(material.fillMode);\r\n\r\n            if (\r\n                material &&\r\n                (fillMode === Material.TriangleFanDrawMode || fillMode === Material.TriangleFillMode || fillMode === Material.TriangleStripDrawMode) &&\r\n                this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1\r\n            ) {\r\n                this._candidateSubMeshes.push(subMesh);\r\n            } else {\r\n                this._excludedSubMeshes.push(subMesh);\r\n            }\r\n        }\r\n\r\n        if (!this._candidateSubMeshes.length) {\r\n            this._engine.bindFramebuffer(this._colorMrts[1].renderTarget!);\r\n            this._engine.bindAttachments(this._layoutCache[1]);\r\n            this._engine.clear(this._colorCache[2], true, false, false);\r\n            this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget!);\r\n\r\n            this._finalCompose(1);\r\n            return this._excludedSubMeshes;\r\n        }\r\n\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n\r\n        (this._scene.prePassRenderer! as any)._enabled = false;\r\n\r\n        if (this._useRenderPasses) {\r\n            this._engine.currentRenderPassId = this._renderPassIds[0];\r\n        }\r\n\r\n        // Clears\r\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget!);\r\n        this._engine.bindAttachments(this._layoutCache[0]);\r\n        this._engine.clear(this._colorCache[0], true, false, false);\r\n        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget!);\r\n\r\n        this._engine.bindFramebuffer(this._depthMrts[1].renderTarget!);\r\n        this._engine.bindAttachments(this._layoutCache[0]);\r\n        this._engine.clear(this._colorCache[1], true, false, false);\r\n        this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget!);\r\n\r\n        this._engine.bindFramebuffer(this._colorMrts[0].renderTarget!);\r\n        this._engine.bindAttachments(this._layoutCache[1]);\r\n        this._engine.clear(this._colorCache[2], true, false, false);\r\n        this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget!);\r\n\r\n        this._engine.bindFramebuffer(this._colorMrts[1].renderTarget!);\r\n        this._engine.bindAttachments(this._layoutCache[1]);\r\n        this._engine.clear(this._colorCache[2], true, false, false);\r\n        this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget!);\r\n\r\n        // Draw depth for first pass\r\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget!);\r\n        this._engine.bindAttachments(this._layoutCache[0]);\r\n\r\n        this._engine.setAlphaMode(Constants.ALPHA_ONEONE_ONEONE); // in WebGPU, when using MIN or MAX equation, the src / dst color factors should not use SRC_ALPHA and the src / dst alpha factors must be 1 else WebGPU will throw a validation error\r\n        this._engine.setAlphaEquation(Constants.ALPHA_EQUATION_MAX);\r\n        this._engine.depthCullingState.depthMask = false;\r\n        this._engine.depthCullingState.depthTest = true;\r\n        this._engine.applyStates();\r\n\r\n        this._currentPingPongState = 1;\r\n        // Render\r\n        this._renderSubMeshes(this._candidateSubMeshes);\r\n        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget!);\r\n\r\n        this._scene.resetCachedMaterial();\r\n\r\n        // depth peeling ping-pong\r\n        let readId = 0;\r\n        let writeId = 0;\r\n\r\n        for (let i = 0; i < this._passCount; i++) {\r\n            readId = i % 2;\r\n            writeId = 1 - readId;\r\n            this._currentPingPongState = readId;\r\n\r\n            if (this._useRenderPasses) {\r\n                this._engine.currentRenderPassId = this._renderPassIds[i + 1];\r\n            }\r\n\r\n            // Clears\r\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget!);\r\n            this._engine.bindAttachments(this._layoutCache[0]);\r\n            this._engine.clear(this._colorCache[0], true, false, false);\r\n            this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget!);\r\n\r\n            this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget!);\r\n            this._engine.bindAttachments(this._layoutCache[1]);\r\n            this._engine.clear(this._colorCache[2], true, false, false);\r\n            this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget!);\r\n\r\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget!);\r\n            this._engine.bindAttachments(this._layoutCache[2]);\r\n\r\n            this._engine.setAlphaMode(Constants.ALPHA_ONEONE_ONEONE); // the value does not matter (as MAX operation does not use them) but the src and dst color factors should not use SRC_ALPHA else WebGPU will throw a validation error\r\n            this._engine.setAlphaEquation(Constants.ALPHA_EQUATION_MAX);\r\n            this._engine.depthCullingState.depthTest = false;\r\n            this._engine.applyStates();\r\n\r\n            // Render\r\n            this._renderSubMeshes(this._candidateSubMeshes);\r\n            this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget!);\r\n\r\n            this._scene.resetCachedMaterial();\r\n\r\n            // Back color\r\n            this._engine.bindFramebuffer(this._blendBackMrt.renderTarget!);\r\n            this._engine.bindAttachments(this._layoutCache[0]);\r\n            this._engine.setAlphaEquation(Constants.ALPHA_EQUATION_ADD);\r\n            this._engine.setAlphaMode(Constants.ALPHA_LAYER_ACCUMULATE);\r\n            this._engine.applyStates();\r\n\r\n            const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;\r\n            this._engine.enableEffect(blendBackEffectWrapper._drawWrapper);\r\n            blendBackEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[writeId * 3 + 2]);\r\n            this._effectRenderer.render(blendBackEffectWrapper);\r\n            this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget!);\r\n        }\r\n\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n\r\n        // Final composition on default FB\r\n        this._finalCompose(writeId);\r\n\r\n        (this._scene.prePassRenderer! as any)._enabled = true;\r\n        this._engine.depthCullingState.depthMask = true;\r\n        this._engine.depthCullingState.depthTest = true;\r\n\r\n        return this._excludedSubMeshes;\r\n    }\r\n\r\n    /**\r\n     * Disposes the depth peeling renderer and associated ressources\r\n     */\r\n    public dispose() {\r\n        this._disposeTextures();\r\n        this._blendBackEffectWrapper.dispose();\r\n        this._finalEffectWrapper.dispose();\r\n        this._effectRenderer.dispose();\r\n        this._releaseRenderPassIds();\r\n    }\r\n}\r\n","import { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\nimport type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { CopyTextureToTexture } from \"core/Misc/copyTextureToTexture\";\r\n\r\n/** @internal */\r\nexport class FluidRenderingDepthTextureCopy {\r\n    private _engine: Engine;\r\n    private _depthRTWrapper: RenderTargetWrapper;\r\n    private _copyTextureToTexture: CopyTextureToTexture;\r\n\r\n    public get depthRTWrapper() {\r\n        return this._depthRTWrapper;\r\n    }\r\n\r\n    constructor(engine: Engine, width: number, height: number, samples = 1) {\r\n        this._engine = engine;\r\n        this._copyTextureToTexture = new CopyTextureToTexture(engine, true);\r\n\r\n        this._depthRTWrapper = this._engine.createRenderTargetTexture(\r\n            { width, height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                format: Constants.TEXTUREFORMAT_R,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: true,\r\n                generateStencilBuffer: false,\r\n                samples,\r\n                noColorAttachment: true,\r\n                label: \"FluidRenderingDepthTextureCopyRTT\",\r\n            }\r\n        );\r\n        this._depthRTWrapper.createDepthStencilTexture(0, false, false, 1, undefined, \"FluidRenderingDepthTextureCopyRTTDepthStencil\");\r\n    }\r\n\r\n    public copy(source: InternalTexture): boolean {\r\n        return this._copyTextureToTexture.copy(source, this._depthRTWrapper);\r\n    }\r\n\r\n    public dispose() {\r\n        this._depthRTWrapper.dispose();\r\n        this._copyTextureToTexture.dispose();\r\n    }\r\n}\r\n","import type { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines the base object used for fluid rendering.\r\n * It is based on a list of vertices (particles)\r\n */\r\nexport abstract class FluidRenderingObject {\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _effectsAreDirty: boolean;\r\n    protected _depthEffectWrapper: Nullable<EffectWrapper>;\r\n    protected _thicknessEffectWrapper: Nullable<EffectWrapper>;\r\n\r\n    /** Defines the priority of the object. Objects will be rendered in ascending order of priority */\r\n    public priority = 0;\r\n\r\n    protected _particleSize = 0.1;\r\n\r\n    /** Observable triggered when the size of the particle is changed */\r\n    public onParticleSizeChanged = new Observable<FluidRenderingObject>();\r\n\r\n    /** Gets or sets the size of the particle */\r\n    public get particleSize() {\r\n        return this._particleSize;\r\n    }\r\n\r\n    public set particleSize(size: number) {\r\n        if (size === this._particleSize) {\r\n            return;\r\n        }\r\n\r\n        this._particleSize = size;\r\n        this.onParticleSizeChanged.notifyObservers(this);\r\n    }\r\n\r\n    /** Defines the alpha value of a particle */\r\n    public particleThicknessAlpha = 0.05;\r\n\r\n    /** Indicates if the object uses instancing or not */\r\n    public get useInstancing() {\r\n        return !this.indexBuffer;\r\n    }\r\n\r\n    private _useVelocity = false;\r\n\r\n    /** Indicates if velocity of particles should be used when rendering the object. The vertex buffer set must contain a \"velocity\" buffer for this to work! */\r\n    public get useVelocity() {\r\n        return this._useVelocity;\r\n    }\r\n\r\n    public set useVelocity(use: boolean) {\r\n        if (this._useVelocity === use || !this._hasVelocity()) {\r\n            return;\r\n        }\r\n\r\n        this._useVelocity = use;\r\n        this._effectsAreDirty = true;\r\n    }\r\n\r\n    private _hasVelocity() {\r\n        return !!this.vertexBuffers?.velocity;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers\r\n     */\r\n    public abstract get vertexBuffers(): { [key: string]: VertexBuffer };\r\n\r\n    /**\r\n     * Gets the index buffer (or null if the object is using instancing)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the class\r\n     */\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObject\";\r\n    }\r\n\r\n    /**\r\n     * Instantiates a fluid rendering object\r\n     * @param scene The scene the object is part of\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._effectsAreDirty = true;\r\n        this._depthEffectWrapper = null;\r\n        this._thicknessEffectWrapper = null;\r\n    }\r\n\r\n    protected _createEffects(): void {\r\n        const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\r\n        const attributeNames = [\"position\", \"offset\"];\r\n        const defines: string[] = [];\r\n\r\n        this._effectsAreDirty = false;\r\n\r\n        if (this.useVelocity) {\r\n            attributeNames.push(\"velocity\");\r\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\r\n        }\r\n\r\n        if (this._scene.useRightHandedSystem) {\r\n            defines.push(\"#define FLUIDRENDERING_RHS\");\r\n        }\r\n\r\n        this._depthEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidRenderingParticleDepth\",\r\n            fragmentShader: \"fluidRenderingParticleDepth\",\r\n            attributeNames,\r\n            uniformNames,\r\n            samplerNames: [],\r\n            defines,\r\n        });\r\n\r\n        uniformNames.push(\"particleAlpha\");\r\n\r\n        this._thicknessEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidRenderingParticleThickness\",\r\n            fragmentShader: \"fluidRenderingParticleThickness\",\r\n            attributeNames: [\"position\", \"offset\"],\r\n            uniformNames,\r\n            samplerNames: [],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the object is ready to be rendered\r\n     * @returns True if everything is ready for the object to be rendered, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        if (this._effectsAreDirty) {\r\n            this._createEffects();\r\n        }\r\n\r\n        if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\r\n            return false;\r\n        }\r\n\r\n        const depthEffect = this._depthEffectWrapper._drawWrapper.effect!;\r\n        const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect!;\r\n\r\n        return depthEffect.isReady() && thicknessEffect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles (vertices) of this object\r\n     * @returns The number of particles\r\n     */\r\n    public abstract get numParticles(): number;\r\n\r\n    /**\r\n     * Render the depth texture for this object\r\n     */\r\n    public renderDepthTexture(): void {\r\n        const numParticles = this.numParticles;\r\n\r\n        if (!this._depthEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\r\n        const depthEffect = depthDrawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(depthDrawWrapper);\r\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);\r\n\r\n        depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n        depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, numParticles);\r\n        } else {\r\n            this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, numParticles);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the thickness texture for this object\r\n     */\r\n    public renderThicknessTexture(): void {\r\n        const numParticles = this.numParticles;\r\n\r\n        if (!this._thicknessEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\r\n        const thicknessEffect = thicknessDrawWrapper.effect!;\r\n\r\n        this._engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        this._engine.enableEffect(thicknessDrawWrapper);\r\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);\r\n\r\n        thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        thicknessEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\r\n        thicknessEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, numParticles);\r\n        } else {\r\n            this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, numParticles);\r\n        }\r\n\r\n        this._engine.setDepthWrite(true);\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Render the diffuse texture for this object\r\n     */\r\n    public renderDiffuseTexture(): void {\r\n        // do nothing by default\r\n    }\r\n\r\n    /**\r\n     * Releases the ressources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._depthEffectWrapper?.dispose();\r\n        this._thicknessEffectWrapper?.dispose();\r\n    }\r\n}\r\n","import { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\n\r\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\r\n\r\n/**\r\n * Defines a rendering object based on a list of custom buffers\r\n * The list must contain at least a \"position\" buffer!\r\n */\r\nexport class FluidRenderingObjectCustomParticles extends FluidRenderingObject {\r\n    private _numParticles: number;\r\n    private _diffuseEffectWrapper: Nullable<EffectWrapper>;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer };\r\n\r\n    /**\r\n     * Gets the name of the class\r\n     */\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObjectCustomParticles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers\r\n     */\r\n    public get vertexBuffers(): { [key: string]: VertexBuffer } {\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the class\r\n     * @param scene The scene the particles should be rendered into\r\n     * @param buffers The list of buffers (must contain at least one \"position\" buffer!). Note that you don't have to pass all (or any!) buffers at once in the constructor, you can use the addBuffers method to add more later.\r\n     * @param numParticles Number of vertices to take into account from the buffers\r\n     */\r\n    constructor(scene: Scene, buffers: { [key: string]: FloatArray }, numParticles: number) {\r\n        super(scene);\r\n\r\n        this._numParticles = numParticles;\r\n        this._diffuseEffectWrapper = null;\r\n        this._vertexBuffers = {};\r\n\r\n        this.addBuffers(buffers);\r\n    }\r\n\r\n    /**\r\n     * Add some new buffers\r\n     * @param buffers List of buffers\r\n     */\r\n    public addBuffers(buffers: { [key: string]: FloatArray }) {\r\n        for (const name in buffers) {\r\n            let stride: number | undefined;\r\n            let instanced = true;\r\n\r\n            switch (name) {\r\n                case \"velocity\":\r\n                    stride = 3;\r\n                    break;\r\n                case \"offset\":\r\n                    instanced = false;\r\n                    break;\r\n            }\r\n\r\n            this._vertexBuffers[name] = new VertexBuffer(this._engine, buffers[name], name, true, false, stride, instanced);\r\n        }\r\n    }\r\n\r\n    protected _createEffects(): void {\r\n        super._createEffects();\r\n\r\n        const uniformNames = [\"view\", \"projection\", \"size\"];\r\n        const attributeNames = [\"position\", \"offset\", \"color\"];\r\n\r\n        this._diffuseEffectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidRenderingParticleDiffuse\",\r\n            fragmentShader: \"fluidRenderingParticleDiffuse\",\r\n            attributeNames,\r\n            uniformNames,\r\n            samplerNames: [],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the object is ready to be rendered\r\n     * @returns True if everything is ready for the object to be rendered, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this._vertexBuffers[\"offset\"]) {\r\n            this._vertexBuffers[\"offset\"] = new VertexBuffer(this._engine, [0, 0, 1, 0, 0, 1, 1, 1], \"offset\", false, false, 2);\r\n        }\r\n\r\n        return super.isReady() && (this._diffuseEffectWrapper?.effect!.isReady() ?? false);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles in this object\r\n     * @returns The number of particles\r\n     */\r\n    public get numParticles(): number {\r\n        return this._numParticles;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of particles in this object\r\n     * @param num The number of particles to take into account\r\n     */\r\n    public setNumParticles(num: number) {\r\n        this._numParticles = num;\r\n    }\r\n\r\n    /**\r\n     * Render the diffuse texture for this object\r\n     */\r\n    public renderDiffuseTexture(): void {\r\n        const numParticles = this.numParticles;\r\n\r\n        if (!this._diffuseEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const diffuseDrawWrapper = this._diffuseEffectWrapper._drawWrapper;\r\n        const diffuseEffect = diffuseDrawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(diffuseDrawWrapper);\r\n        this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, diffuseEffect);\r\n\r\n        diffuseEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        diffuseEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        if (this._particleSize !== null) {\r\n            diffuseEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n        }\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, numParticles);\r\n        } else {\r\n            this._engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, numParticles);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases the ressources used by the class\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._diffuseEffectWrapper?.dispose();\r\n\r\n        for (const name in this._vertexBuffers) {\r\n            this._vertexBuffers[name].dispose();\r\n        }\r\n\r\n        this._vertexBuffers = {};\r\n    }\r\n}\r\n","import type { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Effect } from \"core/Materials/effect\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\r\n\r\n/**\r\n * Defines a rendering object based on a particle system\r\n */\r\nexport class FluidRenderingObjectParticleSystem extends FluidRenderingObject {\r\n    private _particleSystem: IParticleSystem;\r\n    private _originalRender: () => number;\r\n    private _blendMode: number;\r\n    private _onBeforeDrawParticleObserver: Nullable<Observer<Nullable<Effect>>>;\r\n    private _updateInAnimate: boolean;\r\n\r\n    /** Gets the particle system */\r\n    public get particleSystem() {\r\n        return this._particleSystem;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the class\r\n     */\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObjectParticleSystem\";\r\n    }\r\n\r\n    private _useTrueRenderingForDiffuseTexture = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the diffuse texture should be generated based on the regular rendering of the particle system (default: true).\r\n     * Sometimes, generating the diffuse texture this way may be sub-optimal. In that case, you can disable this property, in which case the particle system will be\r\n     * rendered using a ALPHA_COMBINE mode instead of the one used by the particle system.\r\n     */\r\n    public get useTrueRenderingForDiffuseTexture() {\r\n        return this._useTrueRenderingForDiffuseTexture;\r\n    }\r\n\r\n    public set useTrueRenderingForDiffuseTexture(use: boolean) {\r\n        if (this._useTrueRenderingForDiffuseTexture === use) {\r\n            return;\r\n        }\r\n\r\n        this._useTrueRenderingForDiffuseTexture = use;\r\n\r\n        if (use) {\r\n            this._particleSystem.blendMode = this._blendMode;\r\n            this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);\r\n            this._onBeforeDrawParticleObserver = null;\r\n        } else {\r\n            this._particleSystem.blendMode = -1;\r\n            this._onBeforeDrawParticleObserver = this._particleSystem.onBeforeDrawParticlesObservable.add(() => {\r\n                this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers\r\n     */\r\n    public get vertexBuffers(): { [key: string]: VertexBuffer } {\r\n        return this._particleSystem.vertexBuffers as { [key: string]: VertexBuffer };\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer (or null if the object is using instancing)\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return this._particleSystem.indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the class\r\n     * @param scene The scene the particle system is part of\r\n     * @param ps The particle system\r\n     */\r\n    constructor(scene: Scene, ps: IParticleSystem) {\r\n        super(scene);\r\n\r\n        this._particleSystem = ps;\r\n\r\n        this._originalRender = ps.render.bind(ps);\r\n        this._blendMode = ps.blendMode;\r\n        this._onBeforeDrawParticleObserver = null;\r\n        this._updateInAnimate = this._particleSystem.updateInAnimate;\r\n        this._particleSystem.updateInAnimate = true;\r\n        this._particleSystem.render = () => 0;\r\n\r\n        this.particleSize = (ps.minSize + ps.maxSize) / 2;\r\n\r\n        this.useTrueRenderingForDiffuseTexture = false;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the object is ready to be rendered\r\n     * @returns True if everything is ready for the object to be rendered, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return super.isReady() && this._particleSystem.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles in this particle system\r\n     * @returns The number of particles\r\n     */\r\n    public get numParticles(): number {\r\n        return this._particleSystem.getActiveCount();\r\n    }\r\n\r\n    /**\r\n     * Render the diffuse texture for this object\r\n     */\r\n    public renderDiffuseTexture(): void {\r\n        this._originalRender();\r\n    }\r\n\r\n    /**\r\n     * Releases the ressources used by the class\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver);\r\n        this._onBeforeDrawParticleObserver = null;\r\n        this._particleSystem.render = this._originalRender;\r\n        this._particleSystem.blendMode = this._blendMode;\r\n        this._particleSystem.updateInAnimate = this._updateInAnimate;\r\n    }\r\n}\r\n","import type { Camera } from \"core/Cameras/camera\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { PostProcess } from \"core/PostProcesses/postProcess\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\n/** @internal */\r\nexport class FluidRenderingTextures {\r\n    protected _name: string;\r\n    protected _scene: Scene;\r\n    protected _camera: Nullable<Camera>;\r\n    protected _engine: Engine;\r\n    protected _width: number;\r\n    protected _height: number;\r\n    protected _blurTextureSizeX: number;\r\n    protected _blurTextureSizeY: number;\r\n    protected _textureType: number;\r\n    protected _textureFormat: number;\r\n    protected _blurTextureType: number;\r\n    protected _blurTextureFormat: number;\r\n    protected _useStandardBlur: boolean;\r\n    protected _generateDepthBuffer: boolean;\r\n    protected _samples: number;\r\n    protected _postProcessRunningIndex: number;\r\n\r\n    protected _rt: Nullable<RenderTargetWrapper>;\r\n    protected _texture: Nullable<Texture>;\r\n    protected _rtBlur: Nullable<RenderTargetWrapper>;\r\n    protected _textureBlurred: Nullable<Texture>;\r\n    protected _blurPostProcesses: Nullable<PostProcess[]>;\r\n\r\n    public enableBlur = true;\r\n\r\n    public blurSizeDivisor = 1;\r\n\r\n    public blurFilterSize = 7;\r\n\r\n    private _blurNumIterations = 3;\r\n\r\n    public get blurNumIterations() {\r\n        return this._blurNumIterations;\r\n    }\r\n\r\n    public set blurNumIterations(numIterations: number) {\r\n        if (this._blurNumIterations === numIterations) {\r\n            return;\r\n        }\r\n\r\n        this._blurNumIterations = numIterations;\r\n        if (this._blurPostProcesses !== null) {\r\n            const blurX = this._blurPostProcesses[0];\r\n            const blurY = this._blurPostProcesses[1];\r\n\r\n            this._blurPostProcesses = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\r\n            }\r\n        }\r\n    }\r\n\r\n    public blurMaxFilterSize = 100;\r\n\r\n    public blurDepthScale = 10;\r\n\r\n    public particleSize = 0.02;\r\n\r\n    public onDisposeObservable: Observable<FluidRenderingTextures> = new Observable<FluidRenderingTextures>();\r\n\r\n    public get renderTarget() {\r\n        return this._rt;\r\n    }\r\n\r\n    public get renderTargetBlur() {\r\n        return this._rtBlur;\r\n    }\r\n\r\n    public get texture() {\r\n        return this._texture;\r\n    }\r\n\r\n    public get textureBlur() {\r\n        return this._textureBlurred;\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        width: number,\r\n        height: number,\r\n        blurTextureSizeX: number,\r\n        blurTextureSizeY: number,\r\n        textureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        textureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        blurTextureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        blurTextureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        useStandardBlur = false,\r\n        camera: Nullable<Camera> = null,\r\n        generateDepthBuffer = true,\r\n        samples = 1\r\n    ) {\r\n        this._name = name;\r\n        this._scene = scene;\r\n        this._camera = camera;\r\n        this._engine = scene.getEngine();\r\n        this._width = width;\r\n        this._height = height;\r\n        this._blurTextureSizeX = blurTextureSizeX;\r\n        this._blurTextureSizeY = blurTextureSizeY;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._blurTextureType = blurTextureType;\r\n        this._blurTextureFormat = blurTextureFormat;\r\n        this._useStandardBlur = useStandardBlur;\r\n        this._generateDepthBuffer = generateDepthBuffer;\r\n        this._samples = samples;\r\n        this._postProcessRunningIndex = 0;\r\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\r\n\r\n        this._rt = null;\r\n        this._texture = null;\r\n        this._rtBlur = null;\r\n        this._textureBlurred = null;\r\n        this._blurPostProcesses = null;\r\n    }\r\n\r\n    public initialize(): void {\r\n        this.dispose();\r\n\r\n        this._createRenderTarget();\r\n\r\n        if (this.enableBlur && this._texture) {\r\n            const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(\r\n                this._texture,\r\n                this._blurTextureType,\r\n                this._blurTextureFormat,\r\n                this.blurSizeDivisor,\r\n                this._name,\r\n                this._useStandardBlur\r\n            );\r\n            this._rtBlur = rtBlur;\r\n            this._textureBlurred = textureBlurred;\r\n            this._blurPostProcesses = blurPostProcesses;\r\n        }\r\n    }\r\n\r\n    public applyBlurPostProcesses(): void {\r\n        if (this.enableBlur && this._blurPostProcesses) {\r\n            this._postProcessRunningIndex = 0;\r\n            this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\r\n            this._engine.unBindFramebuffer(this._rtBlur!);\r\n        }\r\n    }\r\n\r\n    protected _createRenderTarget(): void {\r\n        this._rt = this._engine.createRenderTargetTexture(\r\n            { width: this._width, height: this._height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: this._textureType,\r\n                format: this._textureFormat,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: this._generateDepthBuffer,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n                label: `FluidRenderingRTT-${this._name}`,\r\n            }\r\n        );\r\n\r\n        const renderTexture = this._rt.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        this._texture = new Texture(null, this._scene);\r\n        this._texture.name = \"rtt\" + this._name;\r\n        this._texture._texture = renderTexture;\r\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n    }\r\n\r\n    protected _createBlurPostProcesses(\r\n        textureBlurSource: ThinTexture,\r\n        textureType: number,\r\n        textureFormat: number,\r\n        blurSizeDivisor: number,\r\n        debugName: string,\r\n        useStandardBlur = false\r\n    ): [RenderTargetWrapper, Texture, PostProcess[]] {\r\n        const engine = this._scene.getEngine();\r\n        const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\r\n        const useBilinearFiltering =\r\n            (textureType === Constants.TEXTURETYPE_FLOAT && engine.getCaps().textureFloatLinearFiltering) ||\r\n            (textureType === Constants.TEXTURETYPE_HALF_FLOAT && engine.getCaps().textureHalfFloatLinearFiltering);\r\n\r\n        const rtBlur = this._engine.createRenderTargetTexture(\r\n            { width: targetSize.x, height: targetSize.y },\r\n            {\r\n                generateMipMaps: false,\r\n                type: textureType,\r\n                format: textureFormat,\r\n                samplingMode: useBilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n                label: `FluidRenderingRTTBlur-${debugName}`,\r\n            }\r\n        );\r\n\r\n        const renderTexture = rtBlur.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        const texture = new Texture(null, this._scene);\r\n        texture.name = \"rttBlurred\" + debugName;\r\n        texture._texture = renderTexture;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        texture.anisotropicFilteringLevel = 1;\r\n\r\n        if (useStandardBlur) {\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        } else {\r\n            const uniforms: string[] = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\r\n\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        }\r\n    }\r\n\r\n    private _fixReusablePostProcess(pp: PostProcess) {\r\n        if (!pp.isReusable()) {\r\n            return;\r\n        }\r\n\r\n        pp.onActivateObservable.add(() => {\r\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n        pp.onApplyObservable.add(() => {\r\n            // now we can advance to the next texture\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n    }\r\n\r\n    private _getProjectedParticleConstant() {\r\n        return (this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2)) / Math.tan((this._camera?.fov ?? (45 * Math.PI) / 180) / 2);\r\n    }\r\n\r\n    private _getDepthThreshold() {\r\n        return (this.particleSize / 2) * this.blurDepthScale;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.onDisposeObservable.hasObservers()) {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        }\r\n\r\n        this._rt?.dispose();\r\n        this._rt = null;\r\n        this._texture?.dispose();\r\n        this._texture = null;\r\n        this._rtBlur?.dispose();\r\n        this._rtBlur = null;\r\n        this._textureBlurred?.dispose();\r\n        this._textureBlurred = null;\r\n        if (this._blurPostProcesses) {\r\n            this._blurPostProcesses[0].dispose();\r\n            this._blurPostProcesses[1].dispose();\r\n        }\r\n        this._blurPostProcesses = null;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"mrtFragmentDeclaration\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nlayout(location=0) out vec4 glFragData[{X}];\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const mrtFragmentDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/mrtFragmentDeclaration\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\n\nconst name = \"geometryPixelShader\";\nconst shader = `#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\n#ifdef BUMP\nvarying mat4 vWorldView;varying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#ifdef VELOCITY\nvarying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#if defined(REFLECTIVITY)\n#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nuniform sampler2D reflectivitySampler;varying vec2 vReflectivityUV;\n#endif\n#ifdef ALBEDOTEXTURE\nvarying vec2 vAlbedoUV;uniform sampler2D albedoSampler;\n#endif\n#ifdef REFLECTIVITYCOLOR\nuniform vec3 reflectivityColor;\n#endif\n#ifdef ALBEDOCOLOR\nuniform vec3 albedoColor;\n#endif\n#ifdef METALLIC\nuniform float metallic;\n#endif\n#if defined(ROUGHNESS) || defined(GLOSSINESS)\nuniform float glossiness;\n#endif\n#endif\n#if defined(ALPHATEST) && defined(NEED_UV)\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<helperFunctions>\nvoid main() {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nvec3 normalOutput;\n#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\n#include<bumpFragment>\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\n#else\nnormalOutput=normalize(vNormalV);\n#endif\n#ifdef PREPASS\n#ifdef PREPASS_DEPTH\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\n#endif\n#else\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);gl_FragData[1]=vec4(normalOutput,1.0);\n#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef REFLECTIVITY\nvec4 reflectivity=vec4(0.0,0.0,0.0,1.0);\n#ifdef METALLICWORKFLOW\nfloat metal=1.0;float roughness=1.0;\n#ifdef ORMTEXTURE\nmetal*=texture2D(reflectivitySampler,vReflectivityUV).b;roughness*=texture2D(reflectivitySampler,vReflectivityUV).g;\n#endif\n#ifdef METALLIC\nmetal*=metallic;\n#endif\n#ifdef ROUGHNESS\nroughness*=(1.0-glossiness); \n#endif\nreflectivity.a-=roughness;vec3 color=vec3(1.0);\n#ifdef ALBEDOTEXTURE\ncolor=texture2D(albedoSampler,vAlbedoUV).rgb;\n#ifdef GAMMAALBEDO\ncolor=toLinearSpace(color);\n#endif\n#endif\n#ifdef ALBEDOCOLOR\ncolor*=albedoColor.xyz;\n#endif\nreflectivity.rgb=mix(vec3(0.04),color,metal);\n#else\n#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nreflectivity=texture2D(reflectivitySampler,vReflectivityUV);\n#ifdef GAMMAREFLECTIVITYTEXTURE\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\n#endif\n#else \n#ifdef REFLECTIVITYCOLOR\nreflectivity.rgb=toLinearSpace(reflectivityColor.xyz);reflectivity.a=1.0;\n#endif\n#endif\n#ifdef GLOSSINESSS\nreflectivity.a*=glossiness; \n#endif\n#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const geometryPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"geometryVertexDeclaration\";\nconst shader = `uniform mat4 viewProjection;uniform mat4 view;`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const geometryVertexDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\n\nconst name = \"geometryUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const geometryUboDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/geometryVertexDeclaration\";\nimport \"./ShadersInclude/geometryUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/bumpVertex\";\n\nconst name = \"geometryVertexShader\";\nconst shader = `precision highp float;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n#include<__decl__geometryVertex>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;attribute vec3 normal;\n#ifdef NEED_UV\nvarying vec2 vUV;\n#ifdef ALPHATEST\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef BUMP\nuniform mat4 bumpMatrix;varying vec2 vBumpUV;\n#endif\n#ifdef REFLECTIVITY\nuniform mat4 reflectivityMatrix;uniform mat4 albedoMatrix;varying vec2 vReflectivityUV;varying vec2 vAlbedoUV;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef BUMP\nvarying mat4 vWorldView;\n#endif\n#ifdef BUMP\nvarying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#ifdef VELOCITY\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=vec4(finalWorld*vec4(positionUpdated,1.0));\n#ifdef BUMP\nvWorldView=view*finalWorld;vNormalW=normalUpdated;\n#else\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\n#endif\nvViewPos=view*worldPos;\n#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvPositionW=worldPos.xyz/worldPos.w;\n#endif\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\n#ifdef NEED_UV\n#ifdef UV1\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#else\nvUV=uv;\n#endif\n#ifdef BUMP_UV1\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV1\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef ALBEDO_UV1\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#endif\n#ifdef UV2\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#else\nvUV=uv2;\n#endif\n#ifdef BUMP_UV2\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV2\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\n#endif\n#ifdef ALBEDO_UV2\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#endif\n#include<bumpVertex>\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const geometryVertexShader = { name, shader };\n","import { Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"../Materials/material\";\r\n\r\nimport \"../Shaders/geometry.fragment\";\r\nimport \"../Shaders/geometry.vertex\";\r\nimport { MaterialFlags } from \"../Materials/materialFlags\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\n/** @internal */\r\ninterface ISavedTransformationMatrix {\r\n    world: Matrix;\r\n    viewProjection: Matrix;\r\n}\r\n\r\n/** list the uniforms used by the geometry renderer */\r\nconst uniforms = [\r\n    \"world\",\r\n    \"mBones\",\r\n    \"viewProjection\",\r\n    \"diffuseMatrix\",\r\n    \"view\",\r\n    \"previousWorld\",\r\n    \"previousViewProjection\",\r\n    \"mPreviousBones\",\r\n    \"bumpMatrix\",\r\n    \"reflectivityMatrix\",\r\n    \"albedoMatrix\",\r\n    \"reflectivityColor\",\r\n    \"albedoColor\",\r\n    \"metallic\",\r\n    \"glossiness\",\r\n    \"vTangentSpaceParams\",\r\n    \"vBumpInfos\",\r\n    \"morphTargetInfluences\",\r\n    \"morphTargetTextureInfo\",\r\n    \"morphTargetTextureIndices\",\r\n];\r\naddClipPlaneUniforms(uniforms);\r\n\r\n/**\r\n * This renderer is helpful to fill one of the render target with a geometry buffer.\r\n */\r\nexport class GeometryBufferRenderer {\r\n    /**\r\n     * Constant used to retrieve the depth texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.DEPTH_TEXTURE_INDEX)\r\n     */\r\n    public static readonly DEPTH_TEXTURE_TYPE = 0;\r\n    /**\r\n     * Constant used to retrieve the normal texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.NORMAL_TEXTURE_INDEX)\r\n     */\r\n    public static readonly NORMAL_TEXTURE_TYPE = 1;\r\n    /**\r\n     * Constant used to retrieve the position texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\r\n     */\r\n    public static readonly POSITION_TEXTURE_TYPE = 2;\r\n    /**\r\n     * Constant used to retrieve the velocity texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\r\n     */\r\n    public static readonly VELOCITY_TEXTURE_TYPE = 3;\r\n    /**\r\n     * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\r\n     * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\r\n     */\r\n    public static readonly REFLECTIVITY_TEXTURE_TYPE = 4;\r\n\r\n    /**\r\n     * Dictionary used to store the previous transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @internal\r\n     */\r\n    public _previousTransformationMatrices: { [index: number]: ISavedTransformationMatrix } = {};\r\n    /**\r\n     * Dictionary used to store the previous bones transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @internal\r\n     */\r\n    public _previousBonesTransformationMatrices: { [index: number]: Float32Array } = {};\r\n    /**\r\n     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\r\n     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\r\n     */\r\n    public excludedSkinnedMeshesFromVelocity: AbstractMesh[] = [];\r\n\r\n    /** Gets or sets a boolean indicating if transparent meshes should be rendered */\r\n    public renderTransparentMeshes = true;\r\n\r\n    private _scene: Scene;\r\n    private _resizeObserver: Nullable<Observer<Engine>> = null;\r\n    private _multiRenderTarget: MultiRenderTarget;\r\n    private _ratio: number;\r\n    private _enablePosition: boolean = false;\r\n    private _enableVelocity: boolean = false;\r\n    private _enableReflectivity: boolean = false;\r\n    private _depthFormat: number;\r\n    private _clearColor = new Color4(0, 0, 0, 0);\r\n    private _clearDepthColor = new Color4(1e8, 0, 0, 1); // \"infinity\" value - depth in the depth texture is view.z, not a 0..1 value!\r\n\r\n    private _positionIndex: number = -1;\r\n    private _velocityIndex: number = -1;\r\n    private _reflectivityIndex: number = -1;\r\n    private _depthIndex: number = -1;\r\n    private _normalIndex: number = -1;\r\n\r\n    private _linkedWithPrePass: boolean = false;\r\n    private _prePassRenderer: PrePassRenderer;\r\n    private _attachmentsFromPrePass: number[];\r\n    private _useUbo: boolean;\r\n\r\n    protected _cachedDefines: string;\r\n\r\n    /**\r\n     * @internal\r\n     * Sets up internal structures to share outputs with PrePassRenderer\r\n     * This method should only be called by the PrePassRenderer itself\r\n     */\r\n    public _linkPrePassRenderer(prePassRenderer: PrePassRenderer) {\r\n        this._linkedWithPrePass = true;\r\n        this._prePassRenderer = prePassRenderer;\r\n\r\n        if (this._multiRenderTarget) {\r\n            // prevents clearing of the RT since it's done by prepass\r\n            this._multiRenderTarget.onClearObservable.clear();\r\n            this._multiRenderTarget.onClearObservable.add(() => {\r\n                // pass\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\r\n     * This method should only be called by the PrePassRenderer itself\r\n     */\r\n    public _unlinkPrePassRenderer() {\r\n        this._linkedWithPrePass = false;\r\n        this._createRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Resets the geometry buffer layout\r\n     */\r\n    public _resetLayout() {\r\n        this._enablePosition = false;\r\n        this._enableReflectivity = false;\r\n        this._enableVelocity = false;\r\n        this._attachmentsFromPrePass = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Replaces a texture in the geometry buffer renderer\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _forceTextureType(geometryBufferType: number, index: number) {\r\n        if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\r\n            this._positionIndex = index;\r\n            this._enablePosition = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\r\n            this._velocityIndex = index;\r\n            this._enableVelocity = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\r\n            this._reflectivityIndex = index;\r\n            this._enableReflectivity = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {\r\n            this._depthIndex = index;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {\r\n            this._normalIndex = index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Sets texture attachments\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _setAttachments(attachments: number[]) {\r\n        this._attachmentsFromPrePass = attachments;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _linkInternalTexture(internalTexture: InternalTexture) {\r\n        this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);\r\n    }\r\n\r\n    /**\r\n     * Gets the render list (meshes to be rendered) used in the G buffer.\r\n     */\r\n    public get renderList() {\r\n        return this._multiRenderTarget.renderList;\r\n    }\r\n\r\n    /**\r\n     * Set the render list (meshes to be rendered) used in the G buffer.\r\n     */\r\n    public set renderList(meshes: Nullable<AbstractMesh[]>) {\r\n        this._multiRenderTarget.renderList = meshes;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not G buffer are supported by the running hardware.\r\n     * This requires draw buffer supports\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._multiRenderTarget.isSupported;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given texture type in the G-Buffer textures array\r\n     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\r\n     * @returns the index of the given texture type in the G-Buffer textures array\r\n     */\r\n    public getTextureIndex(textureType: number): number {\r\n        switch (textureType) {\r\n            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\r\n                return this._positionIndex;\r\n            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\r\n                return this._velocityIndex;\r\n            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\r\n                return this._reflectivityIndex;\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects positions are enabled for the G buffer.\r\n     */\r\n    public get enablePosition(): boolean {\r\n        return this._enablePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not objects positions are enabled for the G buffer.\r\n     */\r\n    public set enablePosition(enable: boolean) {\r\n        this._enablePosition = enable;\r\n\r\n        // PrePass handles index and texture links\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects velocities are enabled for the G buffer.\r\n     */\r\n    public get enableVelocity(): boolean {\r\n        return this._enableVelocity;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not objects velocities are enabled for the G buffer.\r\n     */\r\n    public set enableVelocity(enable: boolean) {\r\n        this._enableVelocity = enable;\r\n\r\n        if (!enable) {\r\n            this._previousTransformationMatrices = {};\r\n        }\r\n\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n\r\n        this._scene.needsPreviousWorldMatrices = enable;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.\r\n     */\r\n    public get enableReflectivity(): boolean {\r\n        return this._enableReflectivity;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not objects reflectivity are enabled for the G buffer.\r\n     * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:\r\n     * pbr.useRoughnessFromMetallicTextureAlpha = false;\r\n     * pbr.useRoughnessFromMetallicTextureGreen = true;\r\n     * pbr.useMetallnessFromMetallicTextureBlue = true;\r\n     */\r\n    public set enableReflectivity(enable: boolean) {\r\n        this._enableReflectivity = enable;\r\n\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\r\n     * If set to false, the depth texture is always cleared with 0.\r\n     */\r\n    public useSpecificClearForDepthTexture = false;\r\n\r\n    /**\r\n     * Gets the scene associated with the buffer.\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used by the buffer during its creation.\r\n     * How big is the buffer related to the main canvas.\r\n     */\r\n    public get ratio(): number {\r\n        return this._ratio;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"GeometryBufferRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Creates a new G Buffer for the scene\r\n     * @param scene The scene the buffer belongs to\r\n     * @param ratio How big is the buffer related to the main canvas (default: 1)\r\n     * @param depthFormat Format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH16)\r\n     */\r\n    constructor(scene: Scene, ratio: number = 1, depthFormat = Constants.TEXTUREFORMAT_DEPTH16) {\r\n        this._scene = scene;\r\n        this._ratio = ratio;\r\n        this._useUbo = scene.getEngine().supportsUniformBuffers;\r\n        this._depthFormat = depthFormat;\r\n\r\n        GeometryBufferRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        // Render target\r\n        this._createRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Checks whether everything is ready to render a submesh to the G buffer.\r\n     * @param subMesh the submesh to check readiness for\r\n     * @param useInstances is the mesh drawn using instance or not\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = <any>subMesh.getMaterial();\r\n\r\n        if (material && material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            let needUv = false;\r\n            if (material.needAlphaTesting() && material.getAlphaTestTexture()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n                defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);\r\n                needUv = true;\r\n            }\r\n\r\n            if (material.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                defines.push(\"#define BUMP\");\r\n                defines.push(`#define BUMP_UV${material.bumpTexture.coordinatesIndex + 1}`);\r\n                needUv = true;\r\n            }\r\n\r\n            if (this._enableReflectivity) {\r\n                let metallicWorkflow = false;\r\n                // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\r\n                if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\r\n                    // if it is a PBR material in MetallicRoughness Mode:\r\n                    if (material.metallicRoughnessTexture !== null) {\r\n                        defines.push(\"#define ORMTEXTURE\");\r\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        needUv = true;\r\n                        metallicWorkflow = true;\r\n                    }\r\n                    if (material.metallic !== null) {\r\n                        defines.push(\"#define METALLIC\");\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        metallicWorkflow = true;\r\n                    }\r\n                    if (material.roughness !== null) {\r\n                        defines.push(\"#define ROUGHNESS\");\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        metallicWorkflow = true;\r\n                    }\r\n                    if (metallicWorkflow) {\r\n                        if (material.baseTexture !== null) {\r\n                            defines.push(\"#define ALBEDOTEXTURE\");\r\n                            defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);\r\n                            if (material.baseTexture.gammaSpace) {\r\n                                defines.push(\"#define GAMMAALBEDO\");\r\n                            }\r\n                            needUv = true;\r\n                        }\r\n                        if (material.baseColor !== null) {\r\n                            defines.push(\"#define ALBEDOCOLOR\");\r\n                        }\r\n                    }\r\n                } else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\r\n                    // if it is a PBR material in Specular/Glossiness Mode:\r\n                    if (material.specularGlossinessTexture !== null) {\r\n                        defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\r\n                        defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);\r\n                        needUv = true;\r\n                        if (material.specularGlossinessTexture.gammaSpace) {\r\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\r\n                        }\r\n                    } else {\r\n                        if (material.specularColor !== null) {\r\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\r\n                        }\r\n                    }\r\n                    if (material.glossiness !== null) {\r\n                        defines.push(\"#define GLOSSINESS\");\r\n                    }\r\n                } else if (material.getClassName() === \"PBRMaterial\") {\r\n                    // if it is the bigger PBRMaterial\r\n                    if (material.metallicTexture !== null) {\r\n                        defines.push(\"#define ORMTEXTURE\");\r\n                        defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        needUv = true;\r\n                        metallicWorkflow = true;\r\n                    }\r\n                    if (material.metallic !== null) {\r\n                        defines.push(\"#define METALLIC\");\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        metallicWorkflow = true;\r\n                    }\r\n\r\n                    if (material.roughness !== null) {\r\n                        defines.push(\"#define ROUGHNESS\");\r\n                        defines.push(\"#define METALLICWORKFLOW\");\r\n                        metallicWorkflow = true;\r\n                    }\r\n\r\n                    if (metallicWorkflow) {\r\n                        if (material.albedoTexture !== null) {\r\n                            defines.push(\"#define ALBEDOTEXTURE\");\r\n                            defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);\r\n                            if (material.albedoTexture.gammaSpace) {\r\n                                defines.push(\"#define GAMMAALBEDO\");\r\n                            }\r\n                            needUv = true;\r\n                        }\r\n                        if (material.albedoColor !== null) {\r\n                            defines.push(\"#define ALBEDOCOLOR\");\r\n                        }\r\n                    } else {\r\n                        // SpecularGlossiness Model\r\n                        if (material.reflectivityTexture !== null) {\r\n                            defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\r\n                            defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);\r\n                            if (material.reflectivityTexture.gammaSpace) {\r\n                                defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\r\n                            }\r\n                            needUv = true;\r\n                        } else if (material.reflectivityColor !== null) {\r\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\r\n                        }\r\n                        if (material.microSurface !== null) {\r\n                            defines.push(\"#define GLOSSINESS\");\r\n                        }\r\n                    }\r\n                } else if (material.getClassName() === \"StandardMaterial\") {\r\n                    // if StandardMaterial:\r\n                    if (material.specularTexture !== null) {\r\n                        defines.push(\"#define REFLECTIVITYTEXTURE\");\r\n                        defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);\r\n                        if (material.specularTexture.gammaSpace) {\r\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\r\n                        }\r\n                        needUv = true;\r\n                    }\r\n                    if (material.specularColor !== null) {\r\n                        defines.push(\"#define REFLECTIVITYCOLOR\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (needUv) {\r\n                defines.push(\"#define NEED_UV\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    attribs.push(VertexBuffer.UVKind);\r\n                    defines.push(\"#define UV1\");\r\n                }\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                    attribs.push(VertexBuffer.UV2Kind);\r\n                    defines.push(\"#define UV2\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // PrePass\r\n        if (this._linkedWithPrePass) {\r\n            defines.push(\"#define PREPASS\");\r\n            if (this._depthIndex !== -1) {\r\n                defines.push(\"#define DEPTH_INDEX \" + this._depthIndex);\r\n                defines.push(\"#define PREPASS_DEPTH\");\r\n            }\r\n            if (this._normalIndex !== -1) {\r\n                defines.push(\"#define NORMAL_INDEX \" + this._normalIndex);\r\n                defines.push(\"#define PREPASS_NORMAL\");\r\n            }\r\n        }\r\n\r\n        // Buffers\r\n        if (this._enablePosition) {\r\n            defines.push(\"#define POSITION\");\r\n            defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\r\n        }\r\n\r\n        if (this._enableVelocity) {\r\n            defines.push(\"#define VELOCITY\");\r\n            defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\r\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\r\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\r\n            }\r\n        }\r\n\r\n        if (this._enableReflectivity) {\r\n            defines.push(\"#define REFLECTIVITY\");\r\n            defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs, this._enableVelocity);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Setup textures count\r\n        if (this._linkedWithPrePass) {\r\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachmentsFromPrePass.length);\r\n        } else {\r\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\r\n        }\r\n\r\n        prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        // Get correct effect\r\n        const engine = this._scene.getEngine();\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\r\n                    \"geometry\",\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        samplers: [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\", \"albedoSampler\", \"morphTargets\"],\r\n                        defines: join,\r\n                        onCompiled: null,\r\n                        fallbacks: null,\r\n                        onError: null,\r\n                        uniformBuffersNames: [\"Scene\"],\r\n                        indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    },\r\n                    engine\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying G Buffer.\r\n     * @returns the buffer\r\n     */\r\n    public getGBuffer(): MultiRenderTarget {\r\n        return this._multiRenderTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples used to render the buffer (anti aliasing).\r\n     */\r\n    public get samples(): number {\r\n        return this._multiRenderTarget.samples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples used to render the buffer (anti aliasing).\r\n     */\r\n    public set samples(value: number) {\r\n        this._multiRenderTarget.samples = value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the renderer and frees up associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._resizeObserver) {\r\n            const engine = this._scene.getEngine();\r\n            engine.onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n        this.getGBuffer().dispose();\r\n    }\r\n\r\n    private _assignRenderTargetIndices(): [number, string[]] {\r\n        const textureNames: string[] = [];\r\n        let count = 2;\r\n\r\n        textureNames.push(\"gBuffer_Depth\", \"gBuffer_Normal\");\r\n\r\n        if (this._enablePosition) {\r\n            this._positionIndex = count;\r\n            count++;\r\n            textureNames.push(\"gBuffer_Position\");\r\n        }\r\n\r\n        if (this._enableVelocity) {\r\n            this._velocityIndex = count;\r\n            count++;\r\n            textureNames.push(\"gBuffer_Velocity\");\r\n        }\r\n\r\n        if (this._enableReflectivity) {\r\n            this._reflectivityIndex = count;\r\n            count++;\r\n            textureNames.push(\"gBuffer_Reflectivity\");\r\n        }\r\n\r\n        return [count, textureNames];\r\n    }\r\n\r\n    protected _createRenderTargets(): void {\r\n        const engine = this._scene.getEngine();\r\n        const [count, textureNames] = this._assignRenderTargetIndices();\r\n\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        } else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {\r\n            type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n\r\n        this._multiRenderTarget = new MultiRenderTarget(\r\n            \"gBuffer\",\r\n            { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio },\r\n            count,\r\n            this._scene,\r\n            { generateMipMaps: false, generateDepthTexture: true, defaultType: type, depthTextureFormat: this._depthFormat },\r\n            textureNames.concat(\"gBuffer_DepthBuffer\")\r\n        );\r\n        if (!this.isSupported) {\r\n            return;\r\n        }\r\n        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._multiRenderTarget.refreshRate = 1;\r\n        this._multiRenderTarget.renderParticles = false;\r\n        this._multiRenderTarget.renderList = null;\r\n\r\n        // Depth is always the first texture in the geometry buffer renderer!\r\n        const layoutAttachmentsAll = [true];\r\n        const layoutAttachmentsAllButDepth = [false];\r\n        const layoutAttachmentsDepthOnly = [true];\r\n\r\n        for (let i = 1; i < count; ++i) {\r\n            layoutAttachmentsAll.push(true);\r\n            layoutAttachmentsDepthOnly.push(false);\r\n            layoutAttachmentsAllButDepth.push(true);\r\n        }\r\n\r\n        const attachmentsAll = engine.buildTextureLayout(layoutAttachmentsAll);\r\n        const attachmentsAllButDepth = engine.buildTextureLayout(layoutAttachmentsAllButDepth);\r\n        const attachmentsDepthOnly = engine.buildTextureLayout(layoutAttachmentsDepthOnly);\r\n\r\n        this._multiRenderTarget.onClearObservable.add((engine) => {\r\n            engine.bindAttachments(this.useSpecificClearForDepthTexture ? attachmentsAllButDepth : attachmentsAll);\r\n            engine.clear(this._clearColor, true, true, true);\r\n            if (this.useSpecificClearForDepthTexture) {\r\n                engine.bindAttachments(attachmentsDepthOnly);\r\n                engine.clear(this._clearDepthColor, true, true, true);\r\n            }\r\n            engine.bindAttachments(attachmentsAll);\r\n        });\r\n\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            if (this._multiRenderTarget) {\r\n                this._multiRenderTarget.resize({ width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio });\r\n            }\r\n        });\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = <any>subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            // Velocity\r\n            if (this._enableVelocity && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\r\n                    world: Matrix.Identity(),\r\n                    viewProjection: scene.getTransformMatrix(),\r\n                };\r\n\r\n                if (renderingMesh.skeleton) {\r\n                    const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\r\n                    this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(\r\n                        bonesTransformations,\r\n                        new Float32Array(bonesTransformations.length)\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n            const world = effectiveMesh.getWorldMatrix();\r\n\r\n            if (this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                const drawWrapper = subMesh._getDrawWrapper();\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!this._useUbo) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"view\", scene.getViewMatrix());\r\n                } else {\r\n                    MaterialHelper.BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\r\n                    this._scene.finalizeSceneUbo();\r\n                }\r\n\r\n                let sideOrientation: Nullable<number>;\r\n                const instanceDataStorage = (renderingMesh as Mesh)._instanceDataStorage;\r\n\r\n                if (!instanceDataStorage.isFrozen && (material.backFaceCulling || renderingMesh.overrideMaterialSideOrientation !== null)) {\r\n                    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n                    sideOrientation = renderingMesh.overrideMaterialSideOrientation;\r\n                    if (sideOrientation === null) {\r\n                        sideOrientation = material.sideOrientation;\r\n                    }\r\n                    if (mainDeterminant < 0) {\r\n                        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n                    }\r\n                } else {\r\n                    sideOrientation = instanceDataStorage.sideOrientation;\r\n                }\r\n\r\n                material._preBind(drawWrapper, sideOrientation);\r\n\r\n                // Alpha test\r\n                if (material.needAlphaTesting()) {\r\n                    const alphaTexture = material.getAlphaTestTexture();\r\n                    if (alphaTexture) {\r\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                    }\r\n                }\r\n\r\n                // Bump\r\n                if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {\r\n                    effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\r\n                    effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\r\n                    effect.setTexture(\"bumpSampler\", material.bumpTexture);\r\n                    effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\r\n                }\r\n\r\n                // Reflectivity\r\n                if (this._enableReflectivity) {\r\n                    // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\r\n                    if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\r\n                        // if it is a PBR material in MetallicRoughness Mode:\r\n                        if (material.metallicRoughnessTexture !== null) {\r\n                            effect.setTexture(\"reflectivitySampler\", material.metallicRoughnessTexture);\r\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicRoughnessTexture.getTextureMatrix());\r\n                        }\r\n                        if (material.metallic !== null) {\r\n                            effect.setFloat(\"metallic\", material.metallic);\r\n                        }\r\n                        if (material.roughness !== null) {\r\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\r\n                        }\r\n                        if (material.baseTexture !== null) {\r\n                            effect.setTexture(\"albedoSampler\", material.baseTexture);\r\n                            effect.setMatrix(\"albedoMatrix\", material.baseTexture.getTextureMatrix());\r\n                        }\r\n                        if (material.baseColor !== null) {\r\n                            effect.setColor3(\"albedoColor\", material.baseColor);\r\n                        }\r\n                    } else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\r\n                        // if it is a PBR material in Specular/Glossiness Mode:\r\n                        if (material.specularGlossinessTexture !== null) {\r\n                            effect.setTexture(\"reflectivitySampler\", material.specularGlossinessTexture);\r\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularGlossinessTexture.getTextureMatrix());\r\n                        } else {\r\n                            if (material.specularColor !== null) {\r\n                                effect.setColor3(\"reflectivityColor\", material.specularColor);\r\n                            }\r\n                        }\r\n                        if (material.glossiness !== null) {\r\n                            effect.setFloat(\"glossiness\", material.glossiness);\r\n                        }\r\n                    } else if (material.getClassName() === \"PBRMaterial\") {\r\n                        // if it is the bigger PBRMaterial\r\n                        if (material.metallicTexture !== null) {\r\n                            effect.setTexture(\"reflectivitySampler\", material.metallicTexture);\r\n                            effect.setMatrix(\"reflectivityMatrix\", material.metallicTexture.getTextureMatrix());\r\n                        }\r\n                        if (material.metallic !== null) {\r\n                            effect.setFloat(\"metallic\", material.metallic);\r\n                        }\r\n\r\n                        if (material.roughness !== null) {\r\n                            effect.setFloat(\"glossiness\", 1.0 - material.roughness);\r\n                        }\r\n\r\n                        if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {\r\n                            // MetallicRoughness Model\r\n                            if (material.albedoTexture !== null) {\r\n                                effect.setTexture(\"albedoSampler\", material.albedoTexture);\r\n                                effect.setMatrix(\"albedoMatrix\", material.albedoTexture.getTextureMatrix());\r\n                            }\r\n                            if (material.albedoColor !== null) {\r\n                                effect.setColor3(\"albedoColor\", material.albedoColor);\r\n                            }\r\n                        } else {\r\n                            // SpecularGlossiness Model\r\n                            if (material.reflectivityTexture !== null) {\r\n                                effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\r\n                                effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\r\n                            } else if (material.reflectivityColor !== null) {\r\n                                effect.setColor3(\"reflectivityColor\", material.reflectivityColor);\r\n                            }\r\n                            if (material.microSurface !== null) {\r\n                                effect.setFloat(\"glossiness\", material.microSurface);\r\n                            }\r\n                        }\r\n                    } else if (material.getClassName() === \"StandardMaterial\") {\r\n                        // if StandardMaterial:\r\n                        if (material.specularTexture !== null) {\r\n                            effect.setTexture(\"reflectivitySampler\", material.specularTexture);\r\n                            effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\r\n                        }\r\n                        if (material.specularColor !== null) {\r\n                            effect.setColor3(\"reflectivityColor\", material.specularColor);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Clip plane\r\n                bindClipPlane(effect, material, this._scene);\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    if (this._enableVelocity) {\r\n                        effect.setMatrices(\"mPreviousBones\", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Velocity\r\n                if (this._enableVelocity) {\r\n                    effect.setMatrix(\"previousWorld\", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\r\n                    effect.setMatrix(\"previousViewProjection\", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\r\n                }\r\n\r\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\r\n                    effect.setMatrix(\"world\", world);\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {\r\n                    if (!isInstance) {\r\n                        effect.setMatrix(\"world\", w);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Velocity\r\n            if (this._enableVelocity) {\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();\r\n                if (renderingMesh.skeleton) {\r\n                    this._copyBonesTransformationMatrices(\r\n                        renderingMesh.skeleton.getTransformMatrices(renderingMesh),\r\n                        this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]\r\n                    );\r\n                }\r\n            }\r\n        };\r\n\r\n        this._multiRenderTarget.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        this._multiRenderTarget.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (this._linkedWithPrePass) {\r\n                if (!this._prePassRenderer.enabled) {\r\n                    return;\r\n                }\r\n                this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass);\r\n            }\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            engine.setDepthWrite(false);\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.renderTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            }\r\n            engine.setDepthWrite(true);\r\n        };\r\n    }\r\n\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    private _copyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n        for (let i = 0; i < source.length; i++) {\r\n            target[i] = source[i];\r\n        }\r\n\r\n        return target;\r\n    }\r\n}\r\n","import type { IMultiRenderTargetOptions } from \"./multiRenderTarget\";\r\nimport { MultiRenderTarget } from \"./multiRenderTarget\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { RenderTargetTexture } from \"./renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * A multi render target designed to render the prepass.\r\n * Prepass is a scene component used to render information in multiple textures\r\n * alongside with the scene materials rendering.\r\n * Note : This is an internal class, and you should NOT need to instanciate this.\r\n * Only the `PrePassRenderer` should instanciate this class.\r\n * It is more likely that you need a regular `MultiRenderTarget`\r\n * @internal\r\n */\r\nexport class PrePassRenderTarget extends MultiRenderTarget {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _beforeCompositionPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Image processing post process for composition\r\n     */\r\n    public imageProcessingPostProcess: ImageProcessingPostProcess;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _engine: Engine;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _scene: Scene;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _outputPostProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _internalTextureDirty = false;\r\n\r\n    /**\r\n     * Is this render target enabled for prepass rendering\r\n     */\r\n    public enabled: boolean = false;\r\n\r\n    /**\r\n     * Render target associated with this prePassRenderTarget\r\n     * If this is `null`, it means this prePassRenderTarget is associated with the scene\r\n     */\r\n    public renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n\r\n    public constructor(name: string, renderTargetTexture: Nullable<RenderTargetTexture>, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions | undefined) {\r\n        super(name, size, count, scene, options);\r\n\r\n        this.renderTargetTexture = renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a composition effect for this RT\r\n     * @internal\r\n     */\r\n    public _createCompositionEffect() {\r\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\r\n        this.imageProcessingPostProcess._updateParameters();\r\n    }\r\n\r\n    /**\r\n     * Checks that the size of this RT is still adapted to the desired render size.\r\n     * @internal\r\n     */\r\n    public _checkSize() {\r\n        const requiredWidth = this._engine.getRenderWidth(true);\r\n        const requiredHeight = this._engine.getRenderHeight(true);\r\n\r\n        const width = this.getRenderWidth();\r\n        const height = this.getRenderHeight();\r\n\r\n        if (width !== requiredWidth || height !== requiredHeight) {\r\n            this.resize({ width: requiredWidth, height: requiredHeight });\r\n\r\n            this._internalTextureDirty = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        super.updateCount(count, options, textureNames);\r\n        this._internalTextureDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the post processes chains applied to this RT.\r\n     * @internal\r\n     */\r\n    public _resetPostProcessChain() {\r\n        this._beforeCompositionPostProcesses.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Diposes this render target\r\n     */\r\n    public dispose() {\r\n        const scene = this._scene;\r\n\r\n        super.dispose();\r\n\r\n        if (scene && scene.prePassRenderer) {\r\n            const index = scene.prePassRenderer.renderTargets.indexOf(this);\r\n\r\n            if (index !== -1) {\r\n                scene.prePassRenderer.renderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.imageProcessingPostProcess) {\r\n            this.imageProcessingPostProcess.dispose();\r\n        }\r\n\r\n        if (this.renderTargetTexture) {\r\n            this.renderTargetTexture._prePassRenderTarget = null;\r\n        }\r\n\r\n        if (this._outputPostProcess) {\r\n            this._outputPostProcess.autoClear = true;\r\n            this._outputPostProcess.restoreDefaultInputTexture();\r\n        }\r\n    }\r\n}\r\n","import { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\n\r\n/**\r\n * Renders a pre pass of the scene\r\n * This means every mesh in the scene will be rendered to a render target texture\r\n * And then this texture will be composited to the rendering canvas with post processes\r\n * It is necessary for effects like subsurface scattering or deferred shading\r\n */\r\nexport class PrePassRenderer {\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"PrePassRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * To save performance, we can excluded skinned meshes from the prepass\r\n     */\r\n    public excludedSkinnedMesh: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Force material to be excluded from the prepass\r\n     * Can be useful when `useGeometryBufferFallback` is set to `true`\r\n     * and you don't want a material to show in the effect.\r\n     */\r\n    public excludedMaterials: Material[] = [];\r\n\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Number of textures in the multi render target texture where the scene is directly rendered\r\n     */\r\n    public mrtCount: number = 0;\r\n\r\n    private _mrtTypes: number[] = [];\r\n    private _mrtFormats: number[] = [];\r\n    private _mrtLayout: number[] = [];\r\n    private _mrtNames: string[] = [];\r\n    private _textureIndices: number[] = [];\r\n\r\n    private _multiRenderAttachments: number[];\r\n    private _defaultAttachments: number[];\r\n    private _clearAttachments: number[];\r\n    private _clearDepthAttachments: number[];\r\n\r\n    /**\r\n     * Returns the index of a texture in the multi render target texture array.\r\n     * @param type Texture type\r\n     * @returns The index\r\n     */\r\n    public getIndex(type: number): number {\r\n        return this._textureIndices[type];\r\n    }\r\n\r\n    /**\r\n     * How many samples are used for MSAA of the scene render target\r\n     */\r\n    public get samples() {\r\n        return this.defaultRT.samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this.defaultRT.samples = n;\r\n    }\r\n\r\n    private _useSpecificClearForDepthTexture = false;\r\n\r\n    /**\r\n     * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\r\n     * If set to false, the depth texture is always cleared with 0.\r\n     */\r\n    public get useSpecificClearForDepthTexture() {\r\n        return this._useSpecificClearForDepthTexture;\r\n    }\r\n\r\n    public set useSpecificClearForDepthTexture(value: boolean) {\r\n        if (this._useSpecificClearForDepthTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._useSpecificClearForDepthTexture = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Describes the types and formats of the textures used by the pre-pass renderer\r\n     */\r\n    public static TextureFormats = [\r\n        {\r\n            purpose: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Irradiance\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Position\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Velocity\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Reflectivity\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_COLOR_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Color\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_R,\r\n            name: \"prePass_Depth\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Normal\",\r\n        },\r\n        {\r\n            purpose: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            name: \"prePass_Albedo\",\r\n        },\r\n    ];\r\n\r\n    private _isDirty: boolean = true;\r\n\r\n    /**\r\n     * The render target where the scene is directly rendered\r\n     */\r\n    public defaultRT: PrePassRenderTarget;\r\n\r\n    /**\r\n     * Configuration for prepass effects\r\n     */\r\n    private _effectConfigurations: PrePassEffectConfiguration[] = [];\r\n\r\n    /**\r\n     * @returns the prepass render target for the rendering pass.\r\n     * If we are currently rendering a render target, it returns the PrePassRenderTarget\r\n     * associated with that render target. Otherwise, it returns the scene default PrePassRenderTarget\r\n     */\r\n    public getRenderTarget(): PrePassRenderTarget {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Managed by the scene component\r\n     * @param prePassRenderTarget\r\n     */\r\n    public _setRenderTarget(prePassRenderTarget: Nullable<PrePassRenderTarget>): void {\r\n        if (prePassRenderTarget) {\r\n            this._currentTarget = prePassRenderTarget;\r\n        } else {\r\n            this._currentTarget = this.defaultRT;\r\n            this._engine.currentRenderPassId = this._scene.activeCamera?.renderPassId ?? this._currentTarget.renderPassId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the currently rendered prePassRenderTarget is the one\r\n     * associated with the scene.\r\n     */\r\n    public get currentRTisSceneRT(): boolean {\r\n        return this._currentTarget === this.defaultRT;\r\n    }\r\n\r\n    private _geometryBuffer: Nullable<GeometryBufferRenderer>;\r\n\r\n    /**\r\n     * Prevents the PrePassRenderer from using the GeometryBufferRenderer as a fallback\r\n     */\r\n    public doNotUseGeometryRendererFallback = true;\r\n\r\n    private _refreshGeometryBufferRendererLink() {\r\n        if (!this.doNotUseGeometryRendererFallback) {\r\n            this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\r\n\r\n            if (!this._geometryBuffer) {\r\n                // Not supported\r\n                this.doNotUseGeometryRendererFallback = true;\r\n                return;\r\n            }\r\n\r\n            this._geometryBuffer._linkPrePassRenderer(this);\r\n        } else {\r\n            if (this._geometryBuffer) {\r\n                this._geometryBuffer._unlinkPrePassRenderer();\r\n            }\r\n            this._geometryBuffer = null;\r\n            this._scene.disableGeometryBufferRenderer();\r\n        }\r\n    }\r\n\r\n    private _currentTarget: PrePassRenderTarget;\r\n\r\n    /**\r\n     * All the render targets generated by prepass\r\n     */\r\n    public renderTargets: PrePassRenderTarget[] = [];\r\n\r\n    private readonly _clearColor = new Color4(0, 0, 0, 0);\r\n    private readonly _clearDepthColor = new Color4(1e8, 0, 0, 1); // \"infinity\" value - depth in the depth texture is view.z, not a 0..1 value!\r\n\r\n    private _enabled: boolean = false;\r\n\r\n    private _needsCompositionForThisPass = false;\r\n    private _postProcessesSourceForThisPass: Nullable<PostProcess>[];\r\n\r\n    /**\r\n     * Indicates if the prepass is enabled\r\n     */\r\n    public get enabled() {\r\n        return this._enabled;\r\n    }\r\n\r\n    /**\r\n     * Set to true to disable gamma transform in PrePass.\r\n     * Can be useful in case you already proceed to gamma transform on a material level\r\n     * and your post processes don't need to be in linear color space.\r\n     */\r\n    public disableGammaTransform = false;\r\n\r\n    /**\r\n     * Instantiates a prepass renderer\r\n     * @param scene The scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this._engine._caps.textureFloat && this._engine._caps.textureFloatLinearFiltering) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        } else if (this._engine._caps.textureHalfFloat && this._engine._caps.textureHalfFloatLinearFiltering) {\r\n            type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n\r\n        if (type !== Constants.TEXTURETYPE_FLOAT) {\r\n            for (let i = 0; i < PrePassRenderer.TextureFormats.length; ++i) {\r\n                if (PrePassRenderer.TextureFormats[i].type === Constants.TEXTURETYPE_FLOAT) {\r\n                    PrePassRenderer.TextureFormats[Constants.PREPASS_DEPTH_TEXTURE_TYPE].type = type;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrePassRenderer._SceneComponentInitialization(this._scene);\r\n        this.defaultRT = this._createRenderTarget(\"sceneprePassRT\", null);\r\n        this._currentTarget = this.defaultRT;\r\n    }\r\n\r\n    /**\r\n     * Creates a new PrePassRenderTarget\r\n     * This should be the only way to instantiate a `PrePassRenderTarget`\r\n     * @param name Name of the `PrePassRenderTarget`\r\n     * @param renderTargetTexture RenderTarget the `PrePassRenderTarget` will be attached to.\r\n     * Can be `null` if the created `PrePassRenderTarget` is attached to the scene (default framebuffer).\r\n     * @internal\r\n     */\r\n    public _createRenderTarget(name: string, renderTargetTexture: Nullable<RenderTargetTexture>): PrePassRenderTarget {\r\n        const rt = new PrePassRenderTarget(name, renderTargetTexture, { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, 0, this._scene, {\r\n            generateMipMaps: false,\r\n            generateStencilBuffer: this._engine.isStencilEnable,\r\n            defaultType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            types: [],\r\n            drawOnlyOnFirstAttachmentByDefault: true,\r\n        });\r\n\r\n        this.renderTargets.push(rt);\r\n\r\n        if (this._enabled) {\r\n            // The pre-pass renderer is already enabled, so make sure we create the render target with the correct number of textures\r\n            this._update();\r\n        }\r\n\r\n        return rt;\r\n    }\r\n\r\n    /**\r\n     * Indicates if rendering a prepass is supported\r\n     */\r\n    public get isSupported() {\r\n        return this._scene.getEngine().getCaps().drawBuffersExtension;\r\n    }\r\n\r\n    /**\r\n     * Sets the proper output textures to draw in the engine.\r\n     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\r\n     * @param subMesh Submesh on which the effect is applied\r\n     */\r\n    public bindAttachmentsForEffect(effect: Effect, subMesh: SubMesh) {\r\n        const material = subMesh.getMaterial();\r\n        const isPrePassCapable = material && material.isPrePassCapable;\r\n        const excluded = material && this.excludedMaterials.indexOf(material) !== -1;\r\n\r\n        if (this.enabled && this._currentTarget.enabled) {\r\n            if (effect._multiTarget && isPrePassCapable && !excluded) {\r\n                this._engine.bindAttachments(this._multiRenderAttachments);\r\n            } else {\r\n                if (this._engine._currentRenderTarget) {\r\n                    this._engine.bindAttachments(this._defaultAttachments);\r\n                } else {\r\n                    this._engine.restoreSingleAttachment();\r\n                }\r\n\r\n                if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {\r\n                    this._geometryBuffer.renderList!.push(subMesh.getRenderingMesh());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _reinitializeAttachments() {\r\n        const multiRenderLayout = [];\r\n        const clearLayout = [false];\r\n        const clearDepthLayout = [false];\r\n        const defaultLayout = [true];\r\n\r\n        for (let i = 0; i < this.mrtCount; i++) {\r\n            multiRenderLayout.push(true);\r\n\r\n            if (i > 0) {\r\n                if (this._useSpecificClearForDepthTexture && this._mrtLayout[i] === Constants.PREPASS_DEPTH_TEXTURE_TYPE) {\r\n                    clearLayout.push(false);\r\n                    clearDepthLayout.push(true);\r\n                } else {\r\n                    clearLayout.push(true);\r\n                    clearDepthLayout.push(false);\r\n                }\r\n                defaultLayout.push(false);\r\n            }\r\n        }\r\n\r\n        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\r\n        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\r\n        this._clearDepthAttachments = this._engine.buildTextureLayout(clearDepthLayout);\r\n        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\r\n    }\r\n\r\n    private _resetLayout() {\r\n        for (let i = 0; i < PrePassRenderer.TextureFormats.length; i++) {\r\n            this._textureIndices[PrePassRenderer.TextureFormats[i].purpose] = -1;\r\n        }\r\n\r\n        this._textureIndices[Constants.PREPASS_COLOR_TEXTURE_TYPE] = 0;\r\n        this._mrtLayout = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\r\n        this._mrtTypes = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].type];\r\n        this._mrtFormats = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].format];\r\n        this._mrtNames = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].name];\r\n        this.mrtCount = 1;\r\n    }\r\n\r\n    private _updateGeometryBufferLayout() {\r\n        this._refreshGeometryBufferRendererLink();\r\n\r\n        if (this._geometryBuffer) {\r\n            this._geometryBuffer._resetLayout();\r\n\r\n            const texturesActivated = [];\r\n\r\n            for (let i = 0; i < this._mrtLayout.length; i++) {\r\n                texturesActivated.push(false);\r\n            }\r\n\r\n            this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture()!);\r\n\r\n            const matches = [\r\n                {\r\n                    prePassConstant: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n                    geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n                    geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,\r\n                },\r\n            ];\r\n\r\n            // replace textures in the geometryBuffer RT\r\n            for (let i = 0; i < matches.length; i++) {\r\n                const index = this._mrtLayout.indexOf(matches[i].prePassConstant);\r\n                if (index !== -1) {\r\n                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\r\n                    texturesActivated[index] = true;\r\n                }\r\n            }\r\n\r\n            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores attachments for single texture draw.\r\n     */\r\n    public restoreAttachments() {\r\n        if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {\r\n            if (this._engine._currentRenderTarget) {\r\n                this._engine.bindAttachments(this._defaultAttachments);\r\n            } else {\r\n                this._engine.restoreSingleAttachment();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _beforeDraw(camera?: Camera, faceIndex?: number, layer?: number) {\r\n        // const previousEnabled = this._enabled && this._currentTarget.enabled;\r\n\r\n        if (this._isDirty) {\r\n            this._update();\r\n        }\r\n\r\n        if (!this._enabled || !this._currentTarget.enabled) {\r\n            return;\r\n        }\r\n\r\n        if (this._geometryBuffer) {\r\n            this._geometryBuffer.renderList = [];\r\n        }\r\n\r\n        this._setupOutputForThisPass(this._currentTarget, camera);\r\n    }\r\n\r\n    private _prepareFrame(prePassRenderTarget: PrePassRenderTarget, faceIndex?: number, layer?: number) {\r\n        if (prePassRenderTarget.renderTargetTexture) {\r\n            prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);\r\n        } else if (this._postProcessesSourceForThisPass.length) {\r\n            this._scene.postProcessManager._prepareFrame();\r\n        } else {\r\n            this._engine.restoreDefaultFramebuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an intermediary texture between prepass and postprocesses. This texture\r\n     * will be used as input for post processes\r\n     * @param rt\r\n     * @returns true if there are postprocesses that will use this texture,\r\n     * false if there is no postprocesses - and the function has no effect\r\n     */\r\n    public setCustomOutput(rt: RenderTargetTexture) {\r\n        const firstPP = this._postProcessesSourceForThisPass[0];\r\n        if (!firstPP) {\r\n            return false;\r\n        }\r\n\r\n        firstPP.inputTexture = rt.renderTarget!;\r\n\r\n        return true;\r\n    }\r\n\r\n    private _renderPostProcesses(prePassRenderTarget: PrePassRenderTarget, faceIndex?: number) {\r\n        const firstPP = this._postProcessesSourceForThisPass[0];\r\n        const outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;\r\n\r\n        // Build post process chain for this prepass post draw\r\n        let postProcessChain = this._currentTarget._beforeCompositionPostProcesses;\r\n\r\n        if (this._needsCompositionForThisPass) {\r\n            postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);\r\n        }\r\n\r\n        // Activates and renders the chain\r\n        if (postProcessChain.length) {\r\n            this._scene.postProcessManager._prepareFrame(this._currentTarget.renderTarget?.texture, postProcessChain);\r\n            this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _afterDraw(faceIndex?: number, layer?: number) {\r\n        if (this._enabled && this._currentTarget.enabled) {\r\n            this._prepareFrame(this._currentTarget, faceIndex, layer);\r\n            this._renderPostProcesses(this._currentTarget, faceIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the current prepass render target (in the sense of settings pixels to the scene clear color value)\r\n     * @internal\r\n     */\r\n    public _clear() {\r\n        if (this._enabled && this._currentTarget.enabled) {\r\n            this._bindFrameBuffer();\r\n\r\n            // Clearing other attachment with 0 on all other attachments\r\n            this._engine.bindAttachments(this._clearAttachments);\r\n            this._engine.clear(this._clearColor, true, false, false);\r\n            if (this._useSpecificClearForDepthTexture) {\r\n                this._engine.bindAttachments(this._clearDepthAttachments);\r\n                this._engine.clear(this._clearDepthColor, true, false, false);\r\n            }\r\n            // Regular clear color with the scene clear color of the 1st attachment\r\n            this._engine.bindAttachments(this._defaultAttachments);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _bindFrameBuffer() {\r\n        if (this._enabled && this._currentTarget.enabled) {\r\n            this._currentTarget._checkSize();\r\n            const internalTexture = this._currentTarget.renderTarget;\r\n            if (internalTexture) {\r\n                this._engine.bindFramebuffer(internalTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setEnabled(enabled: boolean) {\r\n        this._enabled = enabled;\r\n    }\r\n\r\n    private _setRenderTargetEnabled(prePassRenderTarget: PrePassRenderTarget, enabled: boolean) {\r\n        prePassRenderTarget.enabled = enabled;\r\n        if (!enabled) {\r\n            this._unlinkInternalTexture(prePassRenderTarget);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an effect configuration to the prepass render target.\r\n     * If an effect has already been added, it won't add it twice and will return the configuration\r\n     * already present.\r\n     * @param cfg the effect configuration\r\n     * @returns the effect configuration now used by the prepass\r\n     */\r\n    public addEffectConfiguration(cfg: PrePassEffectConfiguration): PrePassEffectConfiguration {\r\n        // Do not add twice\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].name === cfg.name) {\r\n                return this._effectConfigurations[i];\r\n            }\r\n        }\r\n\r\n        this._effectConfigurations.push(cfg);\r\n        return cfg;\r\n    }\r\n\r\n    /**\r\n     * Retrieves an effect configuration by name\r\n     * @param name\r\n     * @returns the effect configuration, or null if not present\r\n     */\r\n    public getEffectConfiguration(name: string): Nullable<PrePassEffectConfiguration> {\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].name === name) {\r\n                return this._effectConfigurations[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _enable() {\r\n        const previousMrtCount = this.mrtCount;\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].enabled) {\r\n                this._enableTextures(this._effectConfigurations[i].texturesRequired);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.renderTargets.length; i++) {\r\n            if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {\r\n                this.renderTargets[i].updateCount(this.mrtCount, { types: this._mrtTypes, formats: this._mrtFormats }, this._mrtNames.concat(\"prePass_DepthBuffer\"));\r\n            }\r\n\r\n            this.renderTargets[i]._resetPostProcessChain();\r\n\r\n            for (let j = 0; j < this._effectConfigurations.length; j++) {\r\n                if (this._effectConfigurations[j].enabled) {\r\n                    // TODO : subsurface scattering has 1 scene-wide effect configuration\r\n                    // solution : do not stock postProcess on effectConfiguration, but in the prepassRenderTarget (hashmap configuration => postProcess)\r\n                    // And call createPostProcess whenever the post process does not exist in the RT\r\n                    if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {\r\n                        this._effectConfigurations[j].createPostProcess!();\r\n                    }\r\n\r\n                    if (this._effectConfigurations[j].postProcess) {\r\n                        this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess!);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._reinitializeAttachments();\r\n        this._setEnabled(true);\r\n        this._updateGeometryBufferLayout();\r\n    }\r\n\r\n    private _disable() {\r\n        this._setEnabled(false);\r\n\r\n        for (let i = 0; i < this.renderTargets.length; i++) {\r\n            this._setRenderTargetEnabled(this.renderTargets[i], false);\r\n        }\r\n\r\n        this._resetLayout();\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            this._effectConfigurations[i].enabled = false;\r\n        }\r\n    }\r\n\r\n    private _getPostProcessesSource(prePassRenderTarget: PrePassRenderTarget, camera?: Camera): Nullable<PostProcess>[] {\r\n        if (camera) {\r\n            return camera._postProcesses;\r\n        } else if (prePassRenderTarget.renderTargetTexture) {\r\n            if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {\r\n                const camera = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;\r\n                return camera ? camera._postProcesses : [];\r\n            } else if (prePassRenderTarget.renderTargetTexture.postProcesses) {\r\n                return prePassRenderTarget.renderTargetTexture.postProcesses;\r\n            } else {\r\n                return [];\r\n            }\r\n        } else {\r\n            return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];\r\n        }\r\n    }\r\n\r\n    private _setupOutputForThisPass(prePassRenderTarget: PrePassRenderTarget, camera?: Camera) {\r\n        // Order is : draw ===> prePassRenderTarget._postProcesses ==> ipp ==> camera._postProcesses\r\n        const secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;\r\n        this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);\r\n        this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter((pp) => {\r\n            return pp != null;\r\n        });\r\n        this._scene.autoClear = true;\r\n\r\n        const cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);\r\n        this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;\r\n\r\n        const firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);\r\n        const firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];\r\n        let firstPP = null;\r\n\r\n        // Setting the scene-wide post process configuration\r\n        this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;\r\n\r\n        // Create composition effect if needed\r\n        if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {\r\n            prePassRenderTarget._createCompositionEffect();\r\n        }\r\n\r\n        // Setting the prePassRenderTarget as input texture of the first PP\r\n        if (firstPrePassPP) {\r\n            firstPP = firstPrePassPP;\r\n        } else if (this._needsCompositionForThisPass) {\r\n            firstPP = prePassRenderTarget.imageProcessingPostProcess;\r\n        } else if (firstCameraPP) {\r\n            firstPP = firstCameraPP;\r\n        }\r\n\r\n        this._bindFrameBuffer();\r\n        this._linkInternalTexture(prePassRenderTarget, firstPP);\r\n    }\r\n\r\n    private _linkInternalTexture(prePassRenderTarget: PrePassRenderTarget, postProcess: Nullable<PostProcess>) {\r\n        if (postProcess) {\r\n            postProcess.autoClear = false;\r\n            postProcess.inputTexture = prePassRenderTarget.renderTarget!;\r\n        }\r\n\r\n        if (prePassRenderTarget._outputPostProcess !== postProcess) {\r\n            if (prePassRenderTarget._outputPostProcess) {\r\n                this._unlinkInternalTexture(prePassRenderTarget);\r\n            }\r\n            prePassRenderTarget._outputPostProcess = postProcess;\r\n        }\r\n\r\n        if (prePassRenderTarget._internalTextureDirty) {\r\n            this._updateGeometryBufferLayout();\r\n            prePassRenderTarget._internalTextureDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unlinkInternalTexture(prePassRenderTarget: PrePassRenderTarget) {\r\n        if (prePassRenderTarget._outputPostProcess) {\r\n            prePassRenderTarget._outputPostProcess.autoClear = true;\r\n            prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();\r\n            prePassRenderTarget._outputPostProcess = null;\r\n        }\r\n    }\r\n\r\n    private _needsImageProcessing(): boolean {\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _hasImageProcessing(postProcesses: Nullable<PostProcess>[]): boolean {\r\n        let isIPPAlreadyPresent = false;\r\n        if (postProcesses) {\r\n            for (let i = 0; i < postProcesses.length; i++) {\r\n                if (postProcesses[i]?.getClassName() === \"ImageProcessingPostProcess\") {\r\n                    isIPPAlreadyPresent = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isIPPAlreadyPresent;\r\n    }\r\n\r\n    /**\r\n     * Internal, gets the first post proces.\r\n     * @param postProcesses\r\n     * @returns the first post process to be run on this camera.\r\n     */\r\n    private _getFirstPostProcess(postProcesses: Nullable<PostProcess>[]): Nullable<PostProcess> {\r\n        for (let ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {\r\n            if (postProcesses[ppIndex] !== null) {\r\n                return postProcesses[ppIndex];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Enables a texture on the MultiRenderTarget for prepass\r\n     * @param types\r\n     */\r\n    private _enableTextures(types: number[]) {\r\n        // For velocity : enable storage of previous matrices for instances\r\n        this._scene.needsPreviousWorldMatrices = false;\r\n\r\n        for (let i = 0; i < types.length; i++) {\r\n            const type = types[i];\r\n\r\n            if (this._textureIndices[type] === -1) {\r\n                this._textureIndices[type] = this._mrtLayout.length;\r\n                this._mrtLayout.push(type);\r\n\r\n                this._mrtTypes.push(PrePassRenderer.TextureFormats[type].type);\r\n                this._mrtFormats.push(PrePassRenderer.TextureFormats[type].format);\r\n                this._mrtNames.push(PrePassRenderer.TextureFormats[type].name);\r\n                this.mrtCount++;\r\n            }\r\n\r\n            if (type === Constants.PREPASS_VELOCITY_TEXTURE_TYPE) {\r\n                this._scene.needsPreviousWorldMatrices = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the prepass renderer is up to date if it has been dirtified.\r\n     */\r\n    public update() {\r\n        if (this._isDirty) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _update() {\r\n        this._disable();\r\n        let enablePrePass = false;\r\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n\r\n        if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {\r\n            this._scene._depthPeelingRenderer.setPrePassRenderer(this);\r\n            enablePrePass = true;\r\n        }\r\n\r\n        for (let i = 0; i < this._scene.materials.length; i++) {\r\n            if (this._scene.materials[i].setPrePassRenderer(this)) {\r\n                enablePrePass = true;\r\n            }\r\n        }\r\n\r\n        if (enablePrePass) {\r\n            this._setRenderTargetEnabled(this.defaultRT, true);\r\n        }\r\n\r\n        let postProcesses;\r\n\r\n        for (let i = 0; i < this.renderTargets.length; i++) {\r\n            if (this.renderTargets[i].renderTargetTexture) {\r\n                postProcesses = this._getPostProcessesSource(this.renderTargets[i]);\r\n            } else {\r\n                const camera = this._scene.activeCamera;\r\n                if (!camera) {\r\n                    continue;\r\n                }\r\n\r\n                postProcesses = camera._postProcesses;\r\n            }\r\n\r\n            if (!postProcesses) {\r\n                continue;\r\n            }\r\n\r\n            postProcesses = <Nullable<PostProcess[]>>postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n\r\n            if (postProcesses) {\r\n                for (let j = 0; j < postProcesses.length; j++) {\r\n                    if (postProcesses[j].setPrePassRenderer(this)) {\r\n                        this._setRenderTargetEnabled(this.renderTargets[i], true);\r\n                        enablePrePass = true;\r\n                    }\r\n                }\r\n\r\n                if (this._hasImageProcessing(postProcesses)) {\r\n                    this._scene.imageProcessingConfiguration.applyByPostProcess = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._markAllMaterialsAsPrePassDirty();\r\n        this._isDirty = false;\r\n\r\n        if (enablePrePass) {\r\n            this._enable();\r\n        }\r\n    }\r\n\r\n    private _markAllMaterialsAsPrePassDirty() {\r\n        const materials = this._scene.materials;\r\n\r\n        for (let i = 0; i < materials.length; i++) {\r\n            materials[i].markAsDirty(Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the prepass renderer.\r\n     */\r\n    public dispose() {\r\n        for (let i = this.renderTargets.length - 1; i >= 0; i--) {\r\n            this.renderTargets[i].dispose();\r\n        }\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].dispose) {\r\n                this._effectConfigurations[i].dispose!();\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Constants } from \"../Engines/constants\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\n\r\n/**\r\n * Contains all parameters needed for the prepass to perform\r\n * screen space reflections\r\n */\r\nexport class ScreenSpaceReflections2Configuration implements PrePassEffectConfiguration {\r\n    /**\r\n     * Is ssr enabled\r\n     */\r\n    public enabled = false;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = \"screenSpaceReflections2\";\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [Constants.PREPASS_NORMAL_TEXTURE_TYPE, Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE, Constants.PREPASS_DEPTH_TEXTURE_TYPE];\r\n}\r\n","import { Constants } from \"../Engines/constants\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\n\r\n/**\r\n * Contains all parameters needed for the prepass to perform\r\n * screen space subsurface scattering\r\n */\r\nexport class SSAO2Configuration implements PrePassEffectConfiguration {\r\n    /**\r\n     * Is subsurface enabled\r\n     */\r\n    public enabled = false;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = \"ssao2\";\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [Constants.PREPASS_NORMAL_TEXTURE_TYPE, Constants.PREPASS_DEPTH_TEXTURE_TYPE];\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fibonacci\";\nconst shader = `#define rcp(x) 1./x\n#define GOLDEN_RATIO 1.618033988749895\n#define TWO_PI 6.2831855\nvec2 Golden2dSeq(int i,float n)\n{return vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));}\nvec2 SampleDiskGolden(int i,int sampleCount)\n{vec2 f=Golden2dSeq(i,float(sampleCount));return vec2(sqrt(f.x),TWO_PI*f.y);}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fibonacci = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"diffusionProfile\";\nconst shader = `uniform vec3 diffusionS[5];uniform float diffusionD[5];uniform float filterRadii[5];`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const diffusionProfile = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fibonacci\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/diffusionProfile\";\n\nconst name = \"subSurfaceScatteringPixelShader\";\nconst shader = `#include<fibonacci>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<diffusionProfile>\nvarying vec2 vUV;uniform vec2 texelSize;uniform sampler2D textureSampler;uniform sampler2D irradianceSampler;uniform sampler2D depthSampler;uniform sampler2D albedoSampler;uniform vec2 viewportSize;uniform float metersPerUnit;const float LOG2_E=1.4426950408889634;const float SSS_PIXELS_PER_SAMPLE=4.;const int _SssSampleBudget=40;\n#define rcp(x) 1./x\n#define Sq(x) x*x\n#define SSS_BILATERAL_FILTER true\nvec3 EvalBurleyDiffusionProfile(float r,vec3 S)\n{vec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); \nvec3 expSum=exp_13*(1.+exp_13*exp_13); \nreturn (S*rcp(8.*PI))*expSum; }\nvec2 SampleBurleyDiffusionProfile(float u,float rcpS)\n{u=1.-u; \nfloat g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));float n=exp2(log2(g)*(-1.0/3.0)); \nfloat p=(g*n)*n; \nfloat c=1.+p+n; \nfloat d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); \nfloat x=(3./LOG2_E)*log2(c)-d; \nfloat rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));float r=x*rcpS;float rcpPdf=(8.*PI*rcpS)*rcpExp; \nreturn vec2(r,rcpPdf);}\nvec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)\n{\n#ifndef SSS_BILATERAL_FILTER\nz=0.;\n#endif\nfloat r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));float area=rcpPdf;\n#if SSS_CLAMP_ARTIFACT\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);\n#else\nreturn EvalBurleyDiffusionProfile(r,S)*area;\n#endif\n}\nvoid EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,\nfloat phase,inout vec3 totalIrradiance,inout vec3 totalWeight)\n{float scale =rcp(float(n));float offset=rcp(float(n))*0.5;float sinPhase,cosPhase;sinPhase=sin(phase);cosPhase=cos(phase);vec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);float r=bdp.x;float rcpPdf=bdp.y;float phi=SampleDiskGolden(i,n).y;float sinPhi,cosPhi;sinPhi=sin(phi);cosPhi=cos(phi);float sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; \nfloat cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; \nvec2 vec=r*vec2(cosPsi,sinPsi);vec2 position; \nfloat xy2;position=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;xy2 =r*r;vec4 textureSample=texture2D(irradianceSampler,position);float viewZ=texture2D(depthSampler,position).r;vec3 irradiance =textureSample.rgb;if (testLightingForSSS(textureSample.a))\n{float relZ=viewZ-centerPosVS.z;vec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);totalIrradiance+=weight*irradiance;totalWeight +=weight;}\nelse\n{}}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);vec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;int diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));float centerDepth =0.;vec4 inputColor=texture2D(textureSampler,vUV);bool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);if (passedStencilTest)\n{centerDepth=texture2D(depthSampler,vUV).r;}\nif (!passedStencilTest) { \ngl_FragColor=inputColor;return;}\nfloat distScale =1.;vec3 S =diffusionS[diffusionProfileIndex];float d =diffusionD[diffusionProfileIndex];float filterRadius=filterRadii[diffusionProfileIndex];vec2 centerPosNDC=vUV;vec2 cornerPosNDC=vUV+0.5*texelSize;vec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; \nvec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; \nfloat mmPerUnit =1000.*(metersPerUnit*rcp(distScale));float unitsPerMm=rcp(mmPerUnit);float unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);float pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;float filterArea =PI*Sq(filterRadius*pixelsPerMm);int sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));int sampleBudget=_SssSampleBudget;int texturingMode=0;vec3 albedo =texture2D(albedoSampler,vUV).rgb;if (distScale==0. || sampleCount<1)\n{\n#ifdef DEBUG_SSS_SAMPLES\nvec3 green=vec3(0.,1.,0.);gl_FragColor=vec4(green,1.0);return;\n#endif\ngl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);return;}\n#ifdef DEBUG_SSS_SAMPLES\nvec3 red =vec3(1.,0.,0.);vec3 blue=vec3(0.,0.,1.);gl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);return;\n#endif\nfloat phase=0.;int n=min(sampleCount,sampleBudget);vec3 centerWeight =vec3(0.); \nvec3 totalIrradiance=vec3(0.);vec3 totalWeight =vec3(0.);for (int i=0; i<n; i++)\n{EvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\nphase,totalIrradiance,totalWeight);}\ntotalWeight=max(totalWeight,HALF_MIN);gl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringPixelShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\nimport \"../Shaders/imageProcessing.fragment\";\r\nimport \"../Shaders/subSurfaceScattering.fragment\";\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * Sub surface scattering post process\r\n */\r\nexport class SubSurfaceScatteringPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"SubSurfaceScatteringPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubSurfaceScatteringPostProcess\";\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ) {\r\n        super(\r\n            name,\r\n            \"subSurfaceScattering\",\r\n            [\"texelSize\", \"viewportSize\", \"metersPerUnit\"],\r\n            [\"diffusionS\", \"diffusionD\", \"filterRadii\", \"irradianceSampler\", \"depthSampler\", \"albedoSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode || Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            \"postprocess\",\r\n            undefined,\r\n            true\r\n        );\r\n        this._scene = scene;\r\n\r\n        this.updateEffect();\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (!scene.prePassRenderer || !scene.subSurfaceConfiguration) {\r\n                Logger.Error(\"PrePass and subsurface configuration needs to be enabled for subsurface scattering.\");\r\n                return;\r\n            }\r\n            const texelSize = this.texelSize;\r\n            effect.setFloat(\"metersPerUnit\", scene.subSurfaceConfiguration.metersPerUnit);\r\n            effect.setFloat2(\"texelSize\", texelSize.x, texelSize.y);\r\n            effect.setTexture(\"irradianceSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE)]);\r\n            effect.setTexture(\"depthSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE)]);\r\n            effect.setTexture(\"albedoSampler\", scene.prePassRenderer.getRenderTarget().textures[scene.prePassRenderer.getIndex(Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE)]);\r\n            effect.setFloat2(\r\n                \"viewportSize\",\r\n                Math.tan(scene.activeCamera!.fov / 2) * scene.getEngine().getAspectRatio(scene.activeCamera!, true),\r\n                Math.tan(scene.activeCamera!.fov / 2)\r\n            );\r\n            effect.setArray3(\"diffusionS\", scene.subSurfaceConfiguration.ssDiffusionS);\r\n            effect.setArray(\"diffusionD\", scene.subSurfaceConfiguration.ssDiffusionD);\r\n            effect.setArray(\"filterRadii\", scene.subSurfaceConfiguration.ssFilterRadii);\r\n        });\r\n    }\r\n}\r\n","import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { SubSurfaceScatteringPostProcess } from \"../PostProcesses/subSurfaceScatteringPostProcess\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Contains all parameters needed for the prepass to perform\r\n * screen space subsurface scattering\r\n */\r\nexport class SubSurfaceConfiguration implements PrePassEffectConfiguration {\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"SubSurfaceSceneComponent\");\r\n    };\r\n\r\n    private _ssDiffusionS: number[] = [];\r\n    private _ssFilterRadii: number[] = [];\r\n    private _ssDiffusionD: number[] = [];\r\n\r\n    /**\r\n     * Post process to attach for screen space subsurface scattering\r\n     */\r\n    public postProcess: SubSurfaceScatteringPostProcess;\r\n\r\n    /**\r\n     * Diffusion profile color for subsurface scattering\r\n     */\r\n    public get ssDiffusionS() {\r\n        return this._ssDiffusionS;\r\n    }\r\n\r\n    /**\r\n     * Diffusion profile max color channel value for subsurface scattering\r\n     */\r\n    public get ssDiffusionD() {\r\n        return this._ssDiffusionD;\r\n    }\r\n\r\n    /**\r\n     * Diffusion profile filter radius for subsurface scattering\r\n     */\r\n    public get ssFilterRadii() {\r\n        return this._ssFilterRadii;\r\n    }\r\n\r\n    /**\r\n     * Is subsurface enabled\r\n     */\r\n    public enabled = false;\r\n\r\n    /**\r\n     * Does the output of this prepass need to go through imageprocessing\r\n     */\r\n    public needsImageProcessing = true;\r\n\r\n    /**\r\n     * Name of the configuration\r\n     */\r\n    public name = SceneComponentConstants.NAME_SUBSURFACE;\r\n\r\n    /**\r\n     * Diffusion profile colors for subsurface scattering\r\n     * You can add one diffusion color using `addDiffusionProfile` on `scene.prePassRenderer`\r\n     * See ...\r\n     * Note that you can only store up to 5 of them\r\n     */\r\n    public ssDiffusionProfileColors: Color3[] = [];\r\n\r\n    /**\r\n     * Defines the ratio real world => scene units.\r\n     * Used for subsurface scattering\r\n     */\r\n    public metersPerUnit: number = 1;\r\n\r\n    /**\r\n     * Textures that should be present in the MRT for this effect to work\r\n     */\r\n    public readonly texturesRequired: number[] = [\r\n        Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n        Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n        Constants.PREPASS_COLOR_TEXTURE_TYPE,\r\n        Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n    ];\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Builds a subsurface configuration object\r\n     * @param scene The scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        // Adding default diffusion profile\r\n        this.addDiffusionProfile(new Color3(1, 1, 1));\r\n        this._scene = scene;\r\n\r\n        SubSurfaceConfiguration._SceneComponentInitialization(this._scene);\r\n    }\r\n\r\n    /**\r\n     * Adds a new diffusion profile.\r\n     * Useful for more realistic subsurface scattering on diverse materials.\r\n     * @param color The color of the diffusion profile. Should be the average color of the material.\r\n     * @returns The index of the diffusion profile for the material subsurface configuration\r\n     */\r\n    public addDiffusionProfile(color: Color3): number {\r\n        if (this.ssDiffusionD.length >= 5) {\r\n            // We only suppport 5 diffusion profiles\r\n            Logger.Error(\"You already reached the maximum number of diffusion profiles.\");\r\n            return 0; // default profile\r\n        }\r\n\r\n        // Do not add doubles\r\n        for (let i = 0; i < this._ssDiffusionS.length / 3; i++) {\r\n            if (this._ssDiffusionS[i * 3] === color.r && this._ssDiffusionS[i * 3 + 1] === color.g && this._ssDiffusionS[i * 3 + 2] === color.b) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        this._ssDiffusionS.push(color.r, color.b, color.g);\r\n        this._ssDiffusionD.push(Math.max(Math.max(color.r, color.b), color.g));\r\n        this._ssFilterRadii.push(this.getDiffusionProfileParameters(color));\r\n        this.ssDiffusionProfileColors.push(color);\r\n\r\n        return this._ssDiffusionD.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Creates the sss post process\r\n     * @returns The created post process\r\n     */\r\n    public createPostProcess(): SubSurfaceScatteringPostProcess {\r\n        this.postProcess = new SubSurfaceScatteringPostProcess(\"subSurfaceScattering\", this._scene, 1, null, undefined, this._scene.getEngine());\r\n        this.postProcess.autoClear = false;\r\n\r\n        return this.postProcess;\r\n    }\r\n\r\n    /**\r\n     * Deletes all diffusion profiles.\r\n     * Note that in order to render subsurface scattering, you should have at least 1 diffusion profile.\r\n     */\r\n    public clearAllDiffusionProfiles() {\r\n        this._ssDiffusionD = [];\r\n        this._ssDiffusionS = [];\r\n        this._ssFilterRadii = [];\r\n        this.ssDiffusionProfileColors = [];\r\n    }\r\n\r\n    /**\r\n     * Disposes this object\r\n     */\r\n    public dispose() {\r\n        this.clearAllDiffusionProfiles();\r\n        if (this.postProcess) {\r\n            this.postProcess.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * https://zero-radiance.github.io/post/sampling-diffusion/\r\n     *\r\n     * Importance sample the normalized diffuse reflectance profile for the computed value of 's'.\r\n     * ------------------------------------------------------------------------------------\r\n     * R[r, phi, s]   = s * (Exp[-r * s] + Exp[-r * s / 3]) / (8 * Pi * r)\r\n     * PDF[r, phi, s] = r * R[r, phi, s]\r\n     * CDF[r, s]      = 1 - 1/4 * Exp[-r * s] - 3/4 * Exp[-r * s / 3]\r\n     * ------------------------------------------------------------------------------------\r\n     * We importance sample the color channel with the widest scattering distance.\r\n     */\r\n    public getDiffusionProfileParameters(color: Color3) {\r\n        const cdf = 0.997;\r\n        const maxScatteringDistance = Math.max(color.r, color.g, color.b);\r\n\r\n        return this._sampleBurleyDiffusionProfile(cdf, maxScatteringDistance);\r\n    }\r\n\r\n    /**\r\n     * Performs sampling of a Normalized Burley diffusion profile in polar coordinates.\r\n     * 'u' is the random number (the value of the CDF): [0, 1).\r\n     * rcp(s) = 1 / ShapeParam = ScatteringDistance.\r\n     * Returns the sampled radial distance, s.t. (u = 0 -> r = 0) and (u = 1 -> r = Inf).\r\n     * @param u\r\n     * @param rcpS\r\n     */\r\n    private _sampleBurleyDiffusionProfile(u: number, rcpS: number) {\r\n        u = 1 - u; // Convert CDF to CCDF\r\n\r\n        const g = 1 + 4 * u * (2 * u + Math.sqrt(1 + 4 * u * u));\r\n        const n = Math.pow(g, -1.0 / 3.0); // g^(-1/3)\r\n        const p = g * n * n; // g^(+1/3)\r\n        const c = 1 + p + n; // 1 + g^(+1/3) + g^(-1/3)\r\n        const x = 3 * Math.log(c / (4 * u));\r\n\r\n        return x * rcpS;\r\n    }\r\n}\r\n","import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesComputeShader\";\nconst shader = `struct Particle {position : vec3<f32>,\nage : f32,\nsize : vec3<f32>,\nlife : f32,\nseed : vec4<f32>,\ndirection : vec3<f32>,\ndummy0: f32,\n#ifdef CUSTOMEMITTER\ninitialPosition : vec3<f32>,\ndummy1: f32,\n#endif\n#ifndef COLORGRADIENTS\ncolor : vec4<f32>,\n#endif\n#ifndef BILLBOARD\ninitialDirection : vec3<f32>,\ndummy2: f32,\n#endif\n#ifdef NOISE\nnoiseCoordinates1 : vec3<f32>,\ndummy3: f32,\nnoiseCoordinates2 : vec3<f32>,\ndummy4: f32,\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nangle : f32,\n#else\nangle : vec2<f32>,\n#endif\n#ifdef ANIMATESHEET\ncellIndex : f32,\n#ifdef ANIMATESHEETRANDOMSTART\ncellStartOffset : f32,\n#endif\n#endif\n};struct Particles {particles : array<Particle>,};struct SimParams {currentCount : f32,\ntimeDelta : f32,\nstopFactor : f32,\nrandomTextureSize: i32,\nlifeTime : vec2<f32>,\nemitPower : vec2<f32>,\n#ifndef COLORGRADIENTS\ncolor1 : vec4<f32>,\ncolor2 : vec4<f32>,\n#endif\nsizeRange : vec2<f32>,\nscaleRange : vec4<f32>,\nangleRange : vec4<f32>,\ngravity : vec3<f32>,\n#ifdef LIMITVELOCITYGRADIENTS\nlimitVelocityDamping : f32,\n#endif\n#ifdef ANIMATESHEET\ncellInfos : vec4<f32>,\n#endif\n#ifdef NOISE\nnoiseStrength : vec3<f32>,\n#endif\n#ifndef LOCAL\nemitterWM : mat4x4<f32>,\n#endif\n#ifdef BOXEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\nminEmitBox : vec3<f32>,\nmaxEmitBox : vec3<f32>,\n#endif\n#ifdef CONEEMITTER\nradius : vec2<f32>,\nconeAngle : f32,\nheight : vec2<f32>,\ndirectionRandomizer : f32,\n#endif\n#ifdef CYLINDEREMITTER\nradius : f32,\nheight : f32,\nradiusRange : f32,\n#ifdef DIRECTEDCYLINDEREMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#else\ndirectionRandomizer : f32,\n#endif\n#endif\n#ifdef HEMISPHERICEMITTER\nradius : f32,\nradiusRange : f32,\ndirectionRandomizer : f32,\n#endif\n#ifdef POINTEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#endif\n#ifdef SPHEREEMITTER\nradius : f32,\nradiusRange : f32,\n#ifdef DIRECTEDSPHEREEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#else\ndirectionRandomizer : f32,\n#endif\n#endif\n};@binding(0) @group(0) var<uniform> params : SimParams;@binding(1) @group(0) var<storage,read> particlesIn : Particles;@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;@binding(3) @group(0) var randomTexture : texture_2d<f32>;@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;\n#ifdef SIZEGRADIENTS\n@binding(0) @group(1) var sizeGradientSampler : sampler;@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;\n#endif \n#ifdef ANGULARSPEEDGRADIENTS\n@binding(2) @group(1) var angularSpeedGradientSampler : sampler;@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;\n#endif \n#ifdef VELOCITYGRADIENTS\n@binding(4) @group(1) var velocityGradientSampler : sampler;@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\n@binding(6) @group(1) var limitVelocityGradientSampler : sampler;@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;\n#endif\n#ifdef DRAGGRADIENTS\n@binding(8) @group(1) var dragGradientSampler : sampler;@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;\n#endif\n#ifdef NOISE\n@binding(10) @group(1) var noiseSampler : sampler;@binding(11) @group(1) var noiseTexture : texture_2d<f32>;\n#endif\nfn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {return textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;}\nfn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {return textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);}\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {let index : u32=GlobalInvocationID.x;let vertexID : f32=f32(index);if (index>=u32(params.currentCount)) {return;}\nlet PI : f32=3.14159;let timeDelta : f32=params.timeDelta;let newAge : f32=particlesIn.particles[index].age+timeDelta;let life : f32=particlesIn.particles[index].life;let seed : vec4<f32>=particlesIn.particles[index].seed;let direction : vec3<f32>=particlesIn.particles[index].direction;if (newAge>=life && params.stopFactor != 0.) {var newPosition : vec3<f32>;var newDirection : vec3<f32>;let randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);let outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;particlesOut.particles[index].life=outLife;particlesOut.particles[index].age=newAge-life;particlesOut.particles[index].seed=seed;var sizex : f32;\n#ifdef SIZEGRADIENTS \nsizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;\n#else\nsizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;\n#endif\nparticlesOut.particles[index].size=vec3<f32>(\nsizex,\nparams.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,\nparams.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);\n#ifndef COLORGRADIENTS\nparticlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;\n#endif\n#ifndef ANGULARSPEEDGRADIENTS \nparticlesOut.particles[index].angle=vec2<f32>(\nparams.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,\nparams.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);\n#else\nparticlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;\n#endif \n#if defined(POINTEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=vec3<f32>(0.,0.,0.);newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\n#elif defined(BOXEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;newDirection=params.direction1+(params.direction2-params.direction1)*randoms3; \n#elif defined(HEMISPHERICEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);newDirection=normalize(newPosition+params.directionRandomizer*randoms3);\n#elif defined(SPHEREEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);\n#else\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\n#endif\n#elif defined(CYLINDEREMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let yPos : f32=(-0.5+randoms2.x)*params.height;var angle : f32=randoms2.y*PI*2.;let inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);let positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));let xPos : f32=positionRadius*cos(angle);let zPos : f32=positionRadius*sin(angle);newPosition=vec3<f32>(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\n#else\nangle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;newDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));newDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let s : f32=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nlet h : f32=0.0001;\n#else\nvar h : f32=randoms2.y*params.height.y;h=1.-h*h; \n#endif\nvar lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;lRadius=lRadius*h;let randX : f32=lRadius*sin(s);let randZ : f32=lRadius*cos(s);let randY : f32=h *params.height.x;newPosition=vec3<f32>(randX,randY,randZ); \nif (abs(cos(params.coneAngle))==1.0) {newDirection=vec3<f32>(0.,1.0,0.);} else {let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newDirection=normalize(newPosition+params.directionRandomizer*randoms3); }\n#elif defined(CUSTOMEMITTER)\nnewPosition=particlesIn.particles[index].initialPosition;particlesOut.particles[index].initialPosition=newPosition;\n#else \nnewPosition=vec3<f32>(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));\n#endif\nlet power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;\n#ifdef LOCAL\nparticlesOut.particles[index].position=newPosition;\n#else\nparticlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nlet initial : vec3<f32>=newDirection;\n#else \nlet initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;\n#endif\nparticlesOut.particles[index].direction=initial*power;\n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET \nparticlesOut.particles[index].cellIndex=params.cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\nparticlesOut.particles[index].cellStartOffset=randoms.a*outLife;\n#endif \n#endif\n#ifdef NOISE\nparticlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;\n#endif\n} else {var directionScale : f32=timeDelta;particlesOut.particles[index].age=newAge;let ageGradient : f32=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);\n#endif\nlet position : vec3<f32>=particlesIn.particles[index].position;\n#if defined(CUSTOMEMITTER)\nparticlesOut.particles[index].position=position+(direction-position)*ageGradient; \nparticlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;\n#else\nparticlesOut.particles[index].position=position+direction*directionScale;\n#endif\nparticlesOut.particles[index].life=life;particlesOut.particles[index].seed=seed;\n#ifndef COLORGRADIENTS \nparticlesOut.particles[index].color=particlesIn.particles[index].color;\n#endif\n#ifdef SIZEGRADIENTS\nparticlesOut.particles[index].size=vec3<f32>(\ntextureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,\nparticlesIn.particles[index].size.yz);\n#else\nparticlesOut.particles[index].size=particlesIn.particles[index].size;\n#endif \n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\n#else\nvar updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nlet limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;let currentVelocity : f32=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*params.limitVelocityDamping;}\n#endif\nparticlesOut.particles[index].direction=updatedDirection;\n#ifdef NOISE\nlet noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;let noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;let fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;particlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;particlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;\n#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nlet angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;particlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;\n#else\nlet angle : vec2<f32>=particlesIn.particles[index].angle;particlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET \nvar offsetAge : f32=particlesOut.particles[index].age;let dist : f32=params.cellInfos.y-params.cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\nlet cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;particlesOut.particles[index].cellStartOffset=cellStartOffset;offsetAge=offsetAge+cellStartOffset;\n#else\nlet cellStartOffset : f32=0.;\n#endif \nvar ratio : f32;if (params.cellInfos.w==1.0) {ratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);}\nelse {ratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);}\nparticlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));\n#endif\n}}\n`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesComputeShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"boundingBoxRendererUboDeclaration\";\nconst shader = `#ifdef WEBGL2\nuniform vec4 color;uniform mat4 world;uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#else\nlayout(std140,column_major) uniform;uniform BoundingBoxRenderer {vec4 color;mat4 world;mat4 viewProjection;mat4 viewProjectionR;};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererUboDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingCompatibility\";\nconst shader = `#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingCompatibility = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"screenSpaceRayTrace\";\nconst shader = `float distanceSquared(vec2 a,vec2 b) { a-=b; return dot(a,a); }\n/**\n\\param csOrigin Camera-space ray origin,which must be \nwithin the view volume and must have z>0.01 and project within the valid screen rectangle\n\\param csDirection Unit length camera-space ray direction\n\\param projectToPixelMatrix A projection matrix that maps to **pixel** coordinates \n(**not** [-1,+1] normalized device coordinates).\n\\param csZBuffer The camera-space Z buffer\n\\param csZBufferSize Dimensions of csZBuffer\n\\param csZThickness Camera space csZThickness to ascribe to each pixel in the depth buffer\n\\param nearPlaneZ Positive number. Doesn't have to be THE actual near plane,just a reasonable value\nfor clipping rays headed towards the camera\n\\param stride Step in horizontal or vertical pixels between samples. This is a float\nbecause integer math is slow on GPUs,but should be set to an integer>=1\n\\param jitterFraction Number between 0 and 1 for how far to bump the ray in stride units\nto conceal banding artifacts,plus the stride ray offset.\n\\param maxSteps Maximum number of iterations. Higher gives better images but may be slow\n\\param maxRayTraceDistance Maximum camera-space distance to trace before returning a miss\n\\param selfCollisionNumSkip Number of steps to skip at start when raytracing to avoid self collisions.\n1 is a reasonable value,depending on the scene you may need to set this value to 2\n\\param hitPixel Pixel coordinates of the first intersection with the scene\n\\param numIterations number of iterations performed\n\\param csHitPoint Camera space location of the ray hit\n*/\n#define inline\nbool traceScreenSpaceRay1(\nvec3 csOrigin,\nvec3 csDirection,\nmat4 projectToPixelMatrix,\nsampler2D csZBuffer,\nvec2 csZBufferSize,\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nsampler2D csZBackBuffer,\nfloat csZBackSizeFactor,\n#endif\nfloat csZThickness,\nfloat nearPlaneZ,\nfloat stride,\nfloat jitterFraction,\nfloat maxSteps,\nfloat maxRayTraceDistance,\nfloat selfCollisionNumSkip,\nout vec2 startPixel,\nout vec2 hitPixel,\nout vec3 csHitPoint,\nout float numIterations\n#ifdef SSRAYTRACE_DEBUG\n,out vec3 debugColor\n#endif\n)\n{\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)>-nearPlaneZ ? (-nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\n#else\nfloat rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)<nearPlaneZ ? (nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;\n#endif\nvec3 csEndPoint=csOrigin+csDirection*rayLength;hitPixel=vec2(-1.0,-1.0);vec4 H0=projectToPixelMatrix*vec4(csOrigin,1.0);vec4 H1=projectToPixelMatrix*vec4(csEndPoint,1.0);float k0=1.0/H0.w;float k1=1.0/H1.w;vec3 Q0=csOrigin*k0;vec3 Q1=csEndPoint*k1;vec2 P0=H0.xy*k0;vec2 P1=H1.xy*k1;\n#ifdef SSRAYTRACE_CLIP_TO_FRUSTUM\nfloat xMax=csZBufferSize.x-0.5,xMin=0.5,yMax=csZBufferSize.y-0.5,yMin=0.5;float alpha=0.0;if ((P1.y>yMax) || (P1.y<yMin)) {alpha=(P1.y-((P1.y>yMax) ? yMax : yMin))/(P1.y-P0.y);}\nif ((P1.x>xMax) || (P1.x<xMin)) {alpha=max(alpha,(P1.x-((P1.x>xMax) ? xMax : xMin))/(P1.x-P0.x));}\nP1=mix(P1,P0,alpha); k1=mix(k1,k0,alpha); Q1=mix(Q1,Q0,alpha);\n#endif\nP1+=vec2((distanceSquared(P0,P1)<0.0001) ? 0.01 : 0.0);vec2 delta=P1-P0;bool permute=false;if (abs(delta.x)<abs(delta.y)) { \npermute=true;delta=delta.yx;P0=P0.yx;P1=P1.yx; }\nfloat stepDirection=sign(delta.x);float invdx=stepDirection/delta.x;vec2 dP=vec2(stepDirection,delta.y*invdx);vec3 dQ=(Q1-Q0)*invdx;float dk=(k1-k0)*invdx;float zMin=min(csEndPoint.z,csOrigin.z);float zMax=max(csEndPoint.z,csOrigin.z);dP*=stride; dQ*=stride; dk*=stride;P0+=dP*jitterFraction; Q0+=dQ*jitterFraction; k0+=dk*jitterFraction;vec4 pqk=vec4(P0,Q0.z,k0);vec4 dPQK=vec4(dP,dQ.z,dk);startPixel=permute ? P0.yx : P0.xy;float prevZMaxEstimate=csOrigin.z;float rayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;float sceneZMax=rayZMax+1e4;float end=P1.x*stepDirection;bool hit=false;float stepCount;for (stepCount=0.0;stepCount<=selfCollisionNumSkip ||\n(pqk.x*stepDirection)<=end &&\nstepCount<maxSteps &&\n!hit &&\nsceneZMax != 0.0; \npqk+=dPQK,++stepCount)\n{hitPixel=permute ? pqk.yx : pqk.xy;rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;if (rayZMin>rayZMax) { \nfloat t=rayZMin; rayZMin=rayZMax; rayZMax=t;}\nsceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;hit=(rayZMax>=sceneBackZ-csZThickness) && (rayZMin<=sceneZMax);\n#else\nhit=(rayZMax>=sceneZMax-csZThickness) && (rayZMin<=sceneZMax);\n#endif\n#else\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nfloat sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;hit=(rayZMin<=sceneBackZ+csZThickness) && (rayZMax>=sceneZMax) && (sceneZMax != 0.0);\n#else\nhit=(rayZMin<=sceneZMax+csZThickness) && (rayZMax>=sceneZMax);\n#endif\n#endif\n}\npqk-=dPQK;stepCount-=1.0;if (((pqk.x+dPQK.x)*stepDirection)>end || (stepCount+1.0)>=maxSteps || sceneZMax==0.0) {hit=false;}\n#ifdef SSRAYTRACE_ENABLE_REFINEMENT\nif (stride>1.0 && hit) {pqk-=dPQK;stepCount-=1.0;float invStride=1.0/stride;dPQK*=invStride;float refinementStepCount=0.0;prevZMaxEstimate=pqk.z/pqk.w;rayZMax=prevZMaxEstimate;sceneZMax=rayZMax+1e7;for (;refinementStepCount<=1.0 ||\n(refinementStepCount<=stride*1.4) &&\n(rayZMax<sceneZMax) && (sceneZMax != 0.0);pqk+=dPQK,refinementStepCount+=1.0)\n{rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;rayZMax=max(rayZMax,rayZMin);hitPixel=permute ? pqk.yx : pqk.xy;sceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;}\npqk-=dPQK;refinementStepCount-=1.0;stepCount+=refinementStepCount/stride;}\n#endif\nQ0.xy+=dQ.xy*stepCount;Q0.z=pqk.z;csHitPoint=Q0/pqk.w;numIterations=stepCount+1.0;\n#ifdef SSRAYTRACE_DEBUG\nif (((pqk.x+dPQK.x)*stepDirection)>end) {debugColor=vec3(0,0,1);} else if ((stepCount+1.0)>=maxSteps) {debugColor=vec3(1,0,0);} else if (sceneZMax==0.0) {debugColor=vec3(1,1,0);} else {debugColor=vec3(0,stepCount/maxSteps,0);}\n#endif\nreturn hit;}\n/**\ntexCoord: in the [0,1] range\ndepth: depth in view space (range [znear,zfar]])\n*/\nvec3 computeViewPosFromUVDepth(vec2 texCoord,float depth,mat4 projection,mat4 invProjectionMatrix) {vec4 ndc;ndc.xy=texCoord*2.0-1.0;\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nndc.z=-projection[2].z-projection[3].z/depth;\n#else\nndc.z=projection[2].z+projection[3].z/depth;\n#endif\nndc.w=1.0;vec4 eyePos=invProjectionMatrix*ndc;eyePos.xyz/=eyePos.w;return eyePos.xyz;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceRayTrace = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"blackAndWhitePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform float degree;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec3 color=texture2D(textureSampler,vUV).rgb;float luminance=dot(color,vec3(0.3,0.59,0.11)); \nvec3 blackAndWhite=vec3(luminance,luminance,luminance);gl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const blackAndWhitePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"boundingBoxRendererFragmentDeclaration\";\nconst shader = `uniform vec4 color;\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererFragmentDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/boundingBoxRendererFragmentDeclaration\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration\";\n\nconst name = \"boundingBoxRendererPixelShader\";\nconst shader = `#include<__decl__boundingBoxRendererFragment>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"boundingBoxRendererVertexDeclaration\";\nconst shader = `uniform mat4 world;uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererVertexDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/boundingBoxRendererVertexDeclaration\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration\";\n\nconst name = \"boundingBoxRendererVertexShader\";\nconst shader = `attribute vec3 position;\n#include<__decl__boundingBoxRendererVertex>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec4 worldPos=world*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const boundingBoxRendererVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"chromaticAberrationPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \nuniform float chromatic_aberration;uniform float radialIntensity;uniform vec2 direction;uniform vec2 centerPosition;uniform float screen_width;uniform float screen_height;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);vec2 directionOfEffect=direction;if(directionOfEffect.x==0. && directionOfEffect.y==0.){directionOfEffect=normalize(centered_screen_pos);}\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\n+ centered_screen_pos.y*centered_screen_pos.y;float radius=sqrt(radius2);vec4 original=texture2D(textureSampler,vUV);vec3 ref_indices=vec3(-0.3,0.0,0.3);float ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;float ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;vec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);vec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);vec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);original.r=texture2D(textureSampler,ref_coords_r).r;original.g=texture2D(textureSampler,ref_coords_g).g;original.b=texture2D(textureSampler,ref_coords_b).b;original.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);gl_FragColor=original;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const chromaticAberrationPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"colorCorrectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \nuniform sampler2D colorTable; \nvarying vec2 vUV;const float SLICE_COUNT=16.0; \nvec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {float sliceSize=1.0/width; \nfloat slicePixelSize=sliceSize/width; \nfloat sliceInnerSize=slicePixelSize*(width-1.0); \nfloat zSlice0=min(floor(uv.z*width),width-1.0);float zSlice1=min(zSlice0+1.0,width-1.0);float xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;float s0=xOffset+(zSlice0*sliceSize);float s1=xOffset+(zSlice1*sliceSize);vec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));vec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));float zOffset=mod(uv.z*width,1.0);vec4 result=mix(slice0Color,slice1Color,zOffset);return result;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 screen_color=texture2D(textureSampler,vUV);gl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorCorrectionPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"convolutionPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform float kernel[9];\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec2 onePixel=vec2(1.0,1.0)/screenSize;vec4 colorSum =\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];float kernelWeight =\nkernel[0] +\nkernel[1] +\nkernel[2] +\nkernel[3] +\nkernel[4] +\nkernel[5] +\nkernel[6] +\nkernel[7] +\nkernel[8];if (kernelWeight<=0.0) {kernelWeight=1.0;}\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const convolutionPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"copyTextureToTexturePixelShader\";\nconst shader = `uniform float conversion;uniform sampler2D textureSampler;varying vec2 vUV;\n#include<helperFunctions>\nvoid main(void) \n{vec4 color=texture2D(textureSampler,vUV);\n#ifdef DEPTH_TEXTURE\ngl_FragDepth=color.r;\n#else\nif (conversion==1.) {color=toLinearSpace(color);} else if (conversion==2.) {color=toGammaSpace(color);}\ngl_FragColor=color;\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const copyTextureToTexturePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"depthOfFieldPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform sampler2D highlightsSampler;uniform sampler2D depthSampler;uniform sampler2D grainSampler;uniform float grain_amount;uniform bool blur_noise;uniform float screen_width;uniform float screen_height;uniform float distortion;uniform bool dof_enabled;uniform float screen_distance; \nuniform float aperture;uniform float darken;uniform float edge_blur;uniform bool highlights;uniform float near;uniform float far;varying vec2 vUV;\n#define PI 3.14159265\n#define TWOPI 6.28318530\n#define inverse_focal_length 0.1 \nvec2 centered_screen_pos;vec2 distorted_coords;float radius2;float radius;vec2 rand(vec2 co)\n{float noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));float noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));return clamp(vec2(noise1,noise2),0.0,1.0);}\nvec2 getDistortedCoords(vec2 coords) {if (distortion==0.0) { return coords; }\nvec2 direction=1.0*normalize(centered_screen_pos);vec2 dist_coords=vec2(0.5,0.5);dist_coords.x=0.5+direction.x*radius2*1.0;dist_coords.y=0.5+direction.y*radius2*1.0;float dist_amount=clamp(distortion*0.23,0.0,1.0);dist_coords=mix(coords,dist_coords,dist_amount);return dist_coords;}\nfloat sampleScreen(inout vec4 color,in vec2 offset,in float weight) {vec2 coords=distorted_coords;float angle=rand(coords*100.0).x*TWOPI;coords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));color+=texture2D(textureSampler,coords)*weight;return weight;}\nfloat getBlurLevel(float size) {return min(3.0,ceil(size/1.0));}\nvec4 getBlurColor(float size) {vec4 col=texture2D(textureSampler,distorted_coords);float blur_level=getBlurLevel(size);float w=(size/screen_width);float h=(size/screen_height);float total_weight=1.0;vec2 sample_coords;total_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);total_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);total_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);total_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);total_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);total_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);total_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);total_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);total_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);total_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);if (blur_level>1.0) {total_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);total_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);total_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);total_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);total_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);total_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);total_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);total_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);total_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);total_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);}\nif (blur_level>2.0) {total_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);total_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);total_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);total_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);total_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);total_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);total_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);total_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);total_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);}\ncol/=total_weight; \nif (darken>0.0) {col.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);}\nreturn col;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);radius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;radius=sqrt(radius2);distorted_coords=getDistortedCoords(vUV); \nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \nfloat depth=texture2D(depthSampler,distorted_coords).r; \nfloat distance=near+(far-near)*depth; \nvec4 color=texture2D(textureSampler,vUV); \nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));if (dof_enabled==false || coc<0.07) { coc=0.0; }\nfloat edge_blur_amount=0.0;if (edge_blur>0.0) {edge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;}\nfloat blur_amount=max(edge_blur_amount,coc);if (blur_amount==0.0) {gl_FragColor=texture2D(textureSampler,distorted_coords);}\nelse {gl_FragColor=getBlurColor(blur_amount*1.7);if (highlights) {gl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;}\nif (blur_noise) {vec2 noise=rand(distorted_coords)*0.01*blur_amount;vec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);gl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;}}\nif (grain_amount>0.0) {vec4 grain_color=texture2D(grainSampler,texels_coords*0.003);gl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;}}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const depthOfFieldPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"displayPassPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D passSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{gl_FragColor=texture2D(passSampler,vUV);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const displayPassPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"filterPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform mat4 kernelMatrix;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec3 baseColor=texture2D(textureSampler,vUV).rgb;vec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;gl_FragColor=vec4(updatedColor,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const filterPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingBilateralBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform int maxFilterSize;uniform vec2 blurDir;uniform float projectedParticleConstant;uniform float depthThreshold;varying vec2 vUV;void main(void) {float depth=textureLod(textureSampler,vUV,0.).x;if (depth>=1e6 || depth<=0.) {glFragColor=vec4(vec3(depth),1.);return;}\nint filterSize=min(maxFilterSize,int(ceil(projectedParticleConstant/depth)));float sigma=float(filterSize)/3.0;float two_sigma2=2.0*sigma*sigma;float sigmaDepth=depthThreshold/3.0;float two_sigmaDepth2=2.0*sigmaDepth*sigmaDepth;float sum=0.;float wsum=0.;float sumVel=0.;for (int x=-filterSize; x<=filterSize; ++x) {vec2 coords=vec2(x);vec2 sampleDepthVel=textureLod(textureSampler,vUV+coords*blurDir,0.).rg;float r=dot(coords,coords);float w=exp(-r/two_sigma2);float rDepth=sampleDepthVel.r-depth;float wd=exp(-rDepth*rDepth/two_sigmaDepth2);sum+=sampleDepthVel.r*w*wd;sumVel+=sampleDepthVel.g*w*wd;wsum+=w*wd;}\nglFragColor=vec4(sum/wsum,sumVel/wsum,0.,1.);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingBilateralBlurPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDepthPixelShader\";\nconst shader = `uniform mat4 projection;varying vec2 uv;varying vec3 viewPos;varying float sphereRadius;\n#ifdef FLUIDRENDERING_VELOCITY\nvarying float velocityNorm;\n#endif\nvoid main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;normal.z=sqrt(1.0-r2);\n#ifndef FLUIDRENDERING_RHS\nnormal.z=-normal.z;\n#endif\nvec4 realViewPos=vec4(viewPos+normal*sphereRadius,1.0);vec4 clipSpacePos=projection*realViewPos;\n#ifdef WEBGPU\ngl_FragDepth=clipSpacePos.z/clipSpacePos.w;\n#else\ngl_FragDepth=(clipSpacePos.z/clipSpacePos.w)*0.5+0.5;\n#endif\n#ifdef FLUIDRENDERING_RHS\nrealViewPos.z=-realViewPos.z;\n#endif\n#ifdef FLUIDRENDERING_VELOCITY\nglFragColor=vec4(realViewPos.z,velocityNorm,0.,1.);\n#else\nglFragColor=vec4(realViewPos.z,0.,0.,1.);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleDepthPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDepthVertexShader\";\nconst shader = `attribute vec3 position;attribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;varying vec3 viewPos;varying float sphereRadius;\n#ifdef FLUIDRENDERING_VELOCITY\nattribute vec3 velocity;varying float velocityNorm;\n#endif\nvoid main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;viewPos=(view*vec4(position,1.0)).xyz;gl_Position=projection*vec4(viewPos+cornerPos,1.0);uv=offset;sphereRadius=size.x/2.0;\n#ifdef FLUIDRENDERING_VELOCITY\nvelocityNorm=length(velocity);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleDepthVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDiffusePixelShader\";\nconst shader = `uniform float particleAlpha;varying vec2 uv;varying vec3 diffuseColor;void main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;glFragColor=vec4(diffuseColor,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleDiffusePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDiffuseVertexShader\";\nconst shader = `attribute vec3 position;attribute vec2 offset;attribute vec4 color;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;varying vec3 diffuseColor;void main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;gl_Position=projection*vec4(viewPos,1.0);uv=offset;diffuseColor=color.rgb;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleDiffuseVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleThicknessPixelShader\";\nconst shader = `uniform float particleAlpha;varying vec2 uv;void main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;float thickness=sqrt(1.0-r2);glFragColor=vec4(vec3(particleAlpha*thickness),1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleThicknessPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleThicknessVertexShader\";\nconst shader = `attribute vec3 position;attribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;void main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;gl_Position=projection*vec4(viewPos,1.0);uv=offset;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingParticleThicknessVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingRenderPixelShader\";\nconst shader = `/* disable_uniformity_analysis */\n#define IOR 1.333\n#define ETA 1.0/IOR\n#define F0 0.02\nuniform sampler2D textureSampler;uniform sampler2D depthSampler;\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nuniform sampler2D diffuseSampler;\n#else\nuniform vec3 diffuseColor;\n#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\nuniform float thickness;uniform sampler2D bgDepthSampler;\n#else\nuniform float minimumThickness;uniform sampler2D thicknessSampler;\n#endif\n#ifdef FLUIDRENDERING_ENVIRONMENT\nuniform samplerCube reflectionSampler;\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nuniform sampler2D debugSampler;\n#endif\nuniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform mat4 invProjectionMatrix;uniform vec2 texelSize;uniform vec3 dirLight;uniform float cameraFar;uniform float density;uniform float refractionStrength;uniform float fresnelClamp;uniform float specularPower;varying vec2 vUV;vec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {vec4 ndc;ndc.xy=texCoord*2.0-1.0;\n#ifdef FLUIDRENDERING_RHS\nndc.z=-projectionMatrix[2].z+projectionMatrix[3].z/depth;\n#else\nndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;\n#endif\nndc.w=1.0;vec4 eyePos=invProjectionMatrix*ndc;eyePos.xyz/=eyePos.w;return eyePos.xyz;}\nvec3 getViewPosFromTexCoord(vec2 texCoord) {float depth=textureLod(depthSampler,texCoord,0.).x;return computeViewPosFromUVDepth(texCoord,depth);}\nvoid main(void) {vec2 texCoord=vUV;\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvec4 color=texture2D(debugSampler,texCoord);\n#ifdef FLUIDRENDERING_DEBUG_DEPTH\nglFragColor=vec4(color.rgb/vec3(2.0),1.);if (color.r>0.999 && color.g>0.999) {glFragColor=texture2D(textureSampler,texCoord);}\n#else\nglFragColor=vec4(color.rgb,1.);if (color.r<0.001 && color.g<0.001 && color.b<0.001) {glFragColor=texture2D(textureSampler,texCoord);}\n#endif\nreturn;\n#endif\nvec2 depthVel=textureLod(depthSampler,texCoord,0.).rg;float depth=depthVel.r;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nfloat thickness=texture2D(thicknessSampler,texCoord).x;\n#else\nfloat bgDepth=texture2D(bgDepthSampler,texCoord).x;float depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;depthNonLinear=depthNonLinear*0.5+0.5;\n#endif\nvec4 backColor=texture2D(textureSampler,texCoord);\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nif (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {\n#else\nif (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {\n#endif\nglFragColor=backColor;return;}\nvec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);vec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;vec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;vec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));if (abs(ddx.z)>abs(ddx2.z)) {ddx=ddx2;}\nvec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));if (abs(ddy.z)>abs(ddy2.z)) {ddy=ddy2;}\nvec3 normal=normalize(cross(ddy,ddx));\n#ifdef FLUIDRENDERING_RHS\nnormal=-normal;\n#endif\n#ifndef WEBGPU\nif(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {normal=vec3(0.,0.,-1.);}\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\nglFragColor=vec4(normal*0.5+0.5,1.0);return;\n#endif\nvec3 rayDir=normalize(viewPos); \n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvec3 diffuseColor=textureLod(diffuseSampler,texCoord,0.0).rgb;\n#endif\nvec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));vec3 H =normalize(lightDir-rayDir);float specular=pow(max(0.0,dot(H,normal)),specularPower);\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\nfloat diffuse =max(0.0,dot(lightDir,normal))*1.0;glFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);return;\n#endif\nvec3 refractionDir=refract(rayDir,normal,ETA);vec4 transmitted=textureLod(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength),0.0);vec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); \nvec3 refractionColor=transmitted.rgb*transmittance;\n#ifdef FLUIDRENDERING_ENVIRONMENT\nvec3 reflectionDir=reflect(rayDir,normal);vec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);float fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);vec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;\n#else\nvec3 finalColor=refractionColor+specular;\n#endif\n#ifdef FLUIDRENDERING_VELOCITY\nfloat velocity=depthVel.g;finalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));\n#endif\nglFragColor=vec4(finalColor,transmitted.a);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingRenderPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingStandardBlurPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform int filterSize;uniform vec2 blurDir;varying vec2 vUV;void main(void) {vec4 s=textureLod(textureSampler,vUV,0.);if (s.r==0.) {glFragColor=vec4(0.,0.,0.,1.);return;}\nfloat sigma=float(filterSize)/3.0;float twoSigma2=2.0*sigma*sigma;vec4 sum=vec4(0.);float wsum=0.;for (int x=-filterSize; x<=filterSize; ++x) {vec2 coords=vec2(x);vec4 sampl=textureLod(textureSampler,vUV+coords*blurDir,0.);float w=exp(-coords.x*coords.x/twoSigma2);sum+=sampl*w;wsum+=w;}\nsum/=wsum;glFragColor=vec4(sum.rgb,1.);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fluidRenderingStandardBlurPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowBlurPostProcessPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform vec2 direction;uniform float blurWidth;float getLuminance(vec3 color)\n{return dot(color,vec3(0.2126,0.7152,0.0722));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float weights[7];weights[0]=0.05;weights[1]=0.1;weights[2]=0.2;weights[3]=0.3;weights[4]=0.2;weights[5]=0.1;weights[6]=0.05;vec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);vec2 texelStep=texelSize*direction*blurWidth;vec2 start=vUV-3.0*texelStep;vec4 baseColor=vec4(0.,0.,0.,0.);vec2 texelOffset=vec2(0.,0.);for (int i=0; i<7; i++)\n{vec4 texel=texture2D(textureSampler,start+texelOffset);baseColor.a+=texel.a*weights[i];float luminance=getLuminance(baseColor.rgb);float luminanceTexel=getLuminance(texel.rgb);float choice=step(luminanceTexel,luminance);baseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;texelOffset+=texelStep;}\ngl_FragColor=baseColor;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowBlurPostProcessPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowMapMergePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#ifdef EMISSIVE\nuniform sampler2D textureSampler2;\n#endif\nuniform float offset;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef EMISSIVE\nbaseColor+=texture2D(textureSampler2,vUV);baseColor*=offset;\n#else\nbaseColor.a=abs(offset-baseColor.a);\n#ifdef STROKE\nfloat alpha=smoothstep(.0,.1,baseColor.a);baseColor.a=alpha;baseColor.rgb=baseColor.rgb*alpha;\n#endif\n#endif\n#if LDR\nbaseColor=clamp(baseColor,0.,1.0);\n#endif\ngl_FragColor=baseColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapMergePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowMapMergeVertexShader\";\nconst shader = `attribute vec2 position;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const glowMapMergeVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesVertexShader\";\nconst shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;uniform float timeDelta;uniform float stopFactor;\n#ifndef LOCAL\nuniform mat4 emitterWM;\n#endif\nuniform vec2 lifeTime;uniform vec2 emitPower;uniform vec2 sizeRange;uniform vec4 scaleRange;\n#ifndef COLORGRADIENTS\nuniform vec4 color1;uniform vec4 color2;\n#endif\nuniform vec3 gravity;uniform sampler2D randomSampler;uniform sampler2D randomSampler2;uniform vec4 angleRange;\n#ifdef BOXEMITTER\nuniform vec3 direction1;uniform vec3 direction2;uniform vec3 minEmitBox;uniform vec3 maxEmitBox;\n#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;uniform vec3 direction2;\n#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;uniform float radiusRange;uniform float directionRandomizer;\n#endif\n#ifdef SPHEREEMITTER\nuniform float radius;uniform float radiusRange;\n#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;uniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;uniform float height;uniform float radiusRange;\n#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;uniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;uniform float coneAngle;uniform vec2 height;uniform float directionRandomizer;\n#endif\nin vec3 position;\n#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\n#endif\nin float age;in float life;in vec4 seed;in vec3 size;\n#ifndef COLORGRADIENTS\nin vec4 color;\n#endif\nin vec3 direction;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\n#else\nin vec2 angle;\n#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;in vec3 noiseCoordinates2;\n#endif\nout vec3 outPosition;\n#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\n#endif\nout float outAge;out float outLife;out vec4 outSeed;out vec3 outSize;\n#ifndef COLORGRADIENTS\nout vec4 outColor;\n#endif\nout vec3 outDirection;\n#ifndef BILLBOARD\nout vec3 outInitialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\n#else\nout vec2 outAngle;\n#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;out vec3 outNoiseCoordinates2;\n#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\n#endif \n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;uniform float limitVelocityDamping;\n#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\n#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;uniform sampler2D noiseSampler;\n#endif\n#ifdef ANIMATESHEET\nuniform vec4 cellInfos;\n#endif\nvec3 getRandomVec3(float offset) {return texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;}\nvec4 getRandomVec4(float offset) {return texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));}\nvoid main() {float newAge=age+timeDelta; \nif (newAge>=life && stopFactor != 0.) {vec3 newPosition;vec3 newDirection;vec4 randoms=getRandomVec4(seed.x);outLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;outAge=newAge-life;outSeed=seed;\n#ifdef SIZEGRADIENTS \noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\n#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\n#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;outSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \n#ifndef COLORGRADIENTS\noutColor=color1+(color2-color1)*randoms.b;\n#endif\n#ifndef ANGULARSPEEDGRADIENTS \noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;outAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#endif \n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=vec3(0,0,0);newDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;newDirection=direction1+(direction2-direction1)*randoms3; \n#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);newDirection=newPosition+directionRandomizer*randoms3; \n#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\n#else\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\n#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float yPos=(randoms2.x-0.5)*height;float angle=randoms2.y*PI*2.;float inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));float positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));float xPos=positionRadius*cos(angle);float zPos=positionRadius*sin(angle);newPosition=vec3(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;newDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));newDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);float s=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\n#else\nfloat h=randoms2.y*height.y;h=1.-h*h; \n#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;lRadius=lRadius*h;float randX=lRadius*sin(s);float randZ=lRadius*cos(s);float randY=h *height.x;newPosition=vec3(randX,randY,randZ); \nif (abs(cos(coneAngle))==1.0) {newDirection=vec3(0.,1.0,0.);} else {vec3 randoms3=getRandomVec3(seed.z);newDirection=normalize(newPosition+directionRandomizer*randoms3); }\n#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;outInitialPosition=initialPosition;\n#else \nnewPosition=vec3(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\n#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\n#ifdef LOCAL\noutPosition=newPosition;\n#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#ifndef BILLBOARD \noutInitialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\n#else \nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\n#endif\noutDirection=initial*power;\n#ifndef BILLBOARD \noutInitialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET \noutCellIndex=cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\n#endif \n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;\n#endif\n} else {float directionScale=timeDelta;outAge=newAge;float ageGradient=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient; \noutInitialPosition=initialPosition;\n#else\noutPosition=position+direction*directionScale;\n#endif\noutLife=life;outSeed=seed;\n#ifndef COLORGRADIENTS \noutColor=color;\n#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;outSize.yz=size.yz;\n#else\noutSize=size;\n#endif \n#ifndef BILLBOARD \noutInitialDirection=initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#else\nvec3 updatedDirection=direction+gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;float currentVelocity=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*limitVelocityDamping;}\n#endif\noutDirection=updatedDirection;\n#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;float fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;float fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;vec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;outDirection=outDirection+force*timeDelta;outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;\n#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;outAngle=angle+angularSpeed*timeDelta;\n#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET \nfloat offsetAge=outAge;float dist=cellInfos.y-cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;offsetAge+=cellStartOffset;\n#else\nfloat cellStartOffset=0.;\n#endif \nfloat ratio=0.;if (cellInfos.w==1.0) {ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);}\nelse {ratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);}\noutCellIndex=float(int(cellInfos.x+ratio*dist));\n#endif\n}}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuUpdateParticlesVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"highlightsPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;const vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec4 tex=texture2D(textureSampler,vUV);vec3 c=tex.rgb;float luma=dot(c.rgb,RGBLuminanceCoefficients);gl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); }`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const highlightsPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\n\nconst name = \"imageProcessingPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 result=texture2D(textureSampler,vUV);\n#ifdef IMAGEPROCESSING\n#ifndef FROMLINEARSPACE\nresult.rgb=toLinearSpace(result.rgb);\n#endif\nresult=applyImageProcessing(result);\n#else\n#ifdef FROMLINEARSPACE\nresult=applyImageProcessing(result);\n#endif\n#endif\ngl_FragColor=result;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"layerPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef LINEAR\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=baseColor*color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"layerVertexShader\";\nconst shader = `attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const layerVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lensHighlightsPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \nuniform float gain;uniform float threshold;uniform float screen_width;uniform float screen_height;varying vec2 vUV;vec4 highlightColor(vec4 color) {vec4 highlight=color;float luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));float lum_threshold;if (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\nelse { lum_threshold=0.5+0.44*threshold; }\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);highlight*=luminance*gain;highlight.a=1.0;return highlight;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 original=texture2D(textureSampler,vUV);if (gain==-1.0) {gl_FragColor=vec4(0.0,0.0,0.0,1.0);return;}\nfloat w=2.0/screen_width;float h=2.0/screen_height;float weight=1.0;vec4 blurred=vec4(0.0,0.0,0.0,0.0);\n#ifdef PENTAGON\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\n#else\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\n#endif\nblurred/=39.0;gl_FragColor=blurred;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lensHighlightsPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"linePixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\nuniform vec4 color;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const linePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"lineVertexShader\";\nconst shader = `#include<instancesDeclaration>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;attribute vec4 normal;uniform mat4 viewProjection;uniform float width;uniform float aspectRatio;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nmat4 worldViewProjection=viewProjection*finalWorld;vec4 viewPosition=worldViewProjection*vec4(position,1.0);vec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);vec2 currentScreen=viewPosition.xy/viewPosition.w;vec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;currentScreen.x*=aspectRatio;nextScreen.x*=aspectRatio;vec2 dir=normalize(nextScreen-currentScreen);vec2 normalDir=vec2(-dir.y,dir.x);normalDir*=width/2.0;normalDir.x/=aspectRatio;vec4 offset=vec4(normalDir*normal.w,0.0,0.0);gl_Position=viewPosition+offset;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#include<clipPlaneVertex>\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lineVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererPixelShader\";\nconst shader = `precision highp float;varying vec2 vDecalTC;uniform sampler2D textureSampler;void main(void) {if (vDecalTC.x<0. || vDecalTC.x>1. || vDecalTC.y<0. || vDecalTC.y>1.) {discard;}\ngl_FragColor=texture2D(textureSampler,vDecalTC);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"meshUVSpaceRendererVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 projMatrix;varying vec2 vDecalTC;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nvoid main(void) {vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);mat3 normWorldSM=mat3(finalWorld);vec3 vNormalW;\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvNormalW=normalize(normWorldSM*normalUpdated);\n#endif\nvec3 normalView=normalize((projMatrix*vec4(vNormalW,0.0)).xyz);vec3 decalTC=(projMatrix*worldPos).xyz;vDecalTC=decalTC.xy;gl_Position=vec4(uv*2.0-1.0,normalView.z>0.0 ? 2. : decalTC.z,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const meshUVSpaceRendererVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"noisePixelShader\";\nconst shader = `uniform float brightness;uniform float persistence;uniform float timeScale;varying vec2 vUV;vec2 hash22(vec2 p)\n{p=p*mat2(127.1,311.7,269.5,183.3);p=-1.0+2.0*fract(sin(p)*43758.5453123);return sin(p*6.283+timeScale);}\nfloat interpolationNoise(vec2 p)\n{vec2 pi=floor(p);vec2 pf=p-pi;vec2 w=pf*pf*(3.-2.*pf);float f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));float f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));float f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));float f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));float xm1=mix(f00,f10,w.x);float xm2=mix(f01,f11,w.x);float ym=mix(xm1,xm2,w.y); \nreturn ym;}\nfloat perlinNoise2D(float x,float y)\n{float sum=0.0;float frequency=0.0;float amplitude=0.0;for(int i=0; i<OCTAVES; i++)\n{frequency=pow(2.0,float(i));amplitude=pow(persistence,float(i));sum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;}\nreturn sum;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float x=abs(vUV.x);float y=abs(vUV.y);float noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);gl_FragColor=vec4(noise,noise,noise,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const noisePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\n\nconst name = \"outlinePixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform vec4 color;\n#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#include<logDepthFragment>\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const outlinePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"outlineVertexShader\";\nconst shader = `attribute vec3 position;attribute vec3 normal;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\nuniform float offset;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nvec3 offsetPosition=positionUpdated+(normalUpdated*offset);\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(offsetPosition,1.0);gl_Position=viewProjection*worldPos;\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const outlineVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"particlesVertexShader\";\nconst shader = `attribute vec3 position;attribute vec4 color;attribute float angle;attribute vec2 size;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\n#endif\nattribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;\n#ifdef ANIMATESHEET\nuniform vec3 particlesInfos; \n#endif\nvarying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\n#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;return position+alignedCorner;}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\n#ifdef BILLBOARDSTRETCHED_LOCAL\nvec3 row1=direction;\n#else\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\n#endif\nmat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;return position+alignedCorner;}\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 cornerPos;cornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size;\n#ifdef BILLBOARD\nvec3 rotatedCorner;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=position-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner);vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=position-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner);vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;vPositionW=(invView*vec4(viewPos,1)).xyz;\n#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\n#endif\ngl_Position=projection*vec4(viewPos,1.0);\n#else\nvec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(direction);vPositionW=rotate(yaxis,rotatedCorner);gl_Position=projection*view*vec4(vPositionW,1.0);\n#endif\nvColor=color;\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex*particlesInfos.z);float columnOffset=cellIndex-rowOffset/particlesInfos.z;vec2 uvScale=particlesInfos.xy;vec2 uvOffset=vec2(offset.x ,1.0-offset.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=offset;\n#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const particlesVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"refractionPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D refractionSampler;uniform vec3 baseColor;uniform float depth;uniform float colorLevel;void main() {float ref=1.0-texture2D(refractionSampler,vUV).r;vec2 uv=vUV-vec2(0.5);vec2 offset=uv*depth*ref;vec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;gl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const refractionPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceCurvaturePixelShader\";\nconst shader = `precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D normalSampler;uniform float curvature_ridge;uniform float curvature_valley;\n#ifndef CURVATURE_OFFSET\n#define CURVATURE_OFFSET 1\n#endif\nfloat curvature_soft_clamp(float curvature,float control)\n{if (curvature<0.5/control)\nreturn curvature*(1.0-curvature*control);return 0.25/control;}\nfloat calculate_curvature(ivec2 texel,float ridge,float valley)\n{vec2 normal_up =texelFetch(normalSampler,texel+ivec2(0, CURVATURE_OFFSET),0).rb;vec2 normal_down =texelFetch(normalSampler,texel+ivec2(0,-CURVATURE_OFFSET),0).rb;vec2 normal_left =texelFetch(normalSampler,texel+ivec2(-CURVATURE_OFFSET,0),0).rb;vec2 normal_right=texelFetch(normalSampler,texel+ivec2( CURVATURE_OFFSET,0),0).rb;float normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));if (normal_diff<0.0)\nreturn -2.0*curvature_soft_clamp(-normal_diff,valley);return 2.0*curvature_soft_clamp(normal_diff,ridge);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{ivec2 texel=ivec2(gl_FragCoord.xy);vec4 baseColor=texture2D(textureSampler,vUV);float curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);baseColor.rgb*=curvature+1.0;gl_FragColor=baseColor;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceCurvaturePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/screenSpaceRayTrace\";\n\nconst name = \"screenSpaceReflection2PixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)\n#define TEXTURECUBEFUNC(s,c,lod) textureLod(s,c,lod)\n#else\n#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)\n#define TEXTURECUBEFUNC(s,c,bias) textureCube(s,c,bias)\n#endif\nuniform sampler2D textureSampler;varying vec2 vUV;\n#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;uniform sampler2D normalSampler;uniform sampler2D depthSampler;\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nuniform sampler2D backDepthSampler;uniform float backSizeFactor;\n#endif\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nuniform samplerCube envCubeSampler;\n#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize;\n#endif\n#endif\nuniform mat4 view;uniform mat4 invView;uniform mat4 projection;uniform mat4 invProjectionMatrix;uniform mat4 projectionPixel;uniform float nearPlaneZ;uniform float stepSize;uniform float maxSteps;uniform float strength;uniform float thickness;uniform float roughnessFactor;uniform float reflectionSpecularFalloffExponent;uniform float maxDistance;uniform float selfCollisionNumSkip;uniform float reflectivityThreshold;\n#include<helperFunctions>\n#include<pbrBRDFFunctions>\n#include<screenSpaceRayTrace>\nvec3 hash(vec3 a)\n{a=fract(a*0.8);a+=dot(a,a.yxz+19.19);return fract((a.xxy+a.yxx)*a.zyx);}\nfloat computeAttenuationForIntersection(ivec2 hitPixel,vec2 hitUV,vec3 vsRayOrigin,vec3 vsHitPoint,vec3 reflectionVector,float maxRayDistance,float numIterations) {float attenuation=1.0;\n#ifdef SSR_ATTENUATE_SCREEN_BORDERS\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-hitUV.xy));attenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\n#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE\nattenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);\n#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_NUMITERATIONS\nattenuation*=1.0-(numIterations/maxSteps);\n#endif\n#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION\nvec3 reflectionNormal=texelFetch(normalSampler,hitPixel,0).xyz;float directionBasedAttenuation=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));attenuation*=directionBasedAttenuation;\n#endif\nreturn attenuation;}\n#endif\nvoid main()\n{\n#ifdef SSR_SUPPORTED\nvec4 colorFull=TEXTUREFUNC(textureSampler,vUV,0.0);vec3 color=colorFull.rgb;vec4 reflectivity=TEXTUREFUNC(reflectivitySampler,vUV,0.0);\n#ifndef SSR_DISABLE_REFLECTIVITY_TEST\nif (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=reflectivityThreshold) {\n#ifdef SSR_USE_BLUR\ngl_FragColor=vec4(0.);\n#else\ngl_FragColor=colorFull;\n#endif\nreturn;}\n#endif\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\ncolor=toLinearSpace(color);\n#endif\nvec2 texSize=vec2(textureSize(depthSampler,0));vec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz; \nfloat depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;vec3 csPosition=computeViewPosFromUVDepth(vUV,depth,projection,invProjectionMatrix);vec3 csViewDirection=normalize(csPosition);vec3 csReflectedVector=reflect(csViewDirection,csNormal);\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nvec3 wReflectedVector=vec3(invView*vec4(csReflectedVector,0.0));\n#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nvec4 worldPos=invView*vec4(csPosition,1.0);wReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),vReflectionSize,vReflectionPosition);\n#endif\n#ifdef SSR_INVERTCUBICMAP\nwReflectedVector.y*=-1.0;\n#endif\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nwReflectedVector.z*=-1.0;\n#endif\nvec3 envColor=TEXTURECUBEFUNC(envCubeSampler,wReflectedVector,0.0).xyz;\n#ifdef SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE\nenvColor=toLinearSpace(envColor);\n#endif\n#else\nvec3 envColor=color;\n#endif\nfloat reflectionAttenuation=1.0;bool rayHasHit=false;vec2 startPixel;vec2 hitPixel;vec3 hitPoint;float numIterations;\n#ifdef SSRAYTRACE_DEBUG\nvec3 debugColor;\n#endif\n#ifdef SSR_ATTENUATE_FACING_CAMERA\nreflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));\n#endif\nif (reflectionAttenuation>0.0) {\n#ifdef SSR_USE_BLUR\nvec3 jitt=vec3(0.);\n#else\nfloat roughness=1.0-reflectivity.a;vec3 jitt=mix(vec3(0.0),hash(csPosition)-vec3(0.5),roughness)*roughnessFactor; \n#endif\nvec2 uv2=vUV*texSize;float c=(uv2.x+uv2.y)*0.25;float jitter=mod(c,1.0); \nrayHasHit=traceScreenSpaceRay1(\ncsPosition,\nnormalize(csReflectedVector+jitt),\nprojectionPixel,\ndepthSampler,\ntexSize,\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nbackDepthSampler,\nbackSizeFactor,\n#endif\nthickness,\nnearPlaneZ,\nstepSize,\njitter,\nmaxSteps,\nmaxDistance,\nselfCollisionNumSkip,\nstartPixel,\nhitPixel,\nhitPoint,\nnumIterations\n#ifdef SSRAYTRACE_DEBUG\n,debugColor\n#endif\n);}\n#ifdef SSRAYTRACE_DEBUG\ngl_FragColor=vec4(debugColor,1.);return;\n#endif\nvec3 F0=reflectivity.rgb;vec3 fresnel=fresnelSchlickGGX(max(dot(csNormal,-csViewDirection),0.0),F0,vec3(1.));vec3 SSR=envColor;if (rayHasHit) {vec3 reflectedColor=texelFetch(textureSampler,ivec2(hitPixel),0).rgb;\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\nreflectedColor=toLinearSpace(reflectedColor);\n#endif\nreflectionAttenuation*=computeAttenuationForIntersection(ivec2(hitPixel),hitPixel/texSize,csPosition,hitPoint,csReflectedVector,maxDistance,numIterations);SSR=reflectedColor*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;}\n#ifndef SSR_BLEND_WITH_FRESNEL\nSSR*=fresnel;\n#endif\n#ifdef SSR_USE_BLUR\nfloat blur_radius=0.0;float roughness=1.0-reflectivity.a*(1.0-roughnessFactor);if (roughness>0.001) {float cone_angle=min(roughness,0.999)*3.14159265*0.5;float cone_len=distance(startPixel,hitPixel);float op_len=2.0*tan(cone_angle)*cone_len; \nfloat a=op_len;float h=cone_len;float a2=a*a;float fh2=4.0f*h*h;blur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);}\ngl_FragColor=vec4(SSR,blur_radius/255.0); \n#else\n#ifdef SSR_BLEND_WITH_FRESNEL\nvec3 reflectionMultiplier=clamp(pow(fresnel*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\n#else\nvec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\n#endif\nvec3 colorMultiplier=1.0-reflectionMultiplier;vec3 finalColor=(color*colorMultiplier)+(SSR*reflectionMultiplier);\n#ifdef SSR_OUTPUT_IS_GAMMA_SPACE\nfinalColor=toGammaSpace(finalColor);\n#endif\ngl_FragColor=vec4(finalColor,colorFull.a);\n#endif\n#else\ngl_FragColor=TEXTUREFUNC(textureSampler,vUV,0.0);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflection2PixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflection2BlurPixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)\n#else\n#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)\n#endif\nuniform sampler2D textureSampler;varying vec2 vUV;uniform vec2 texelOffsetScale;const float weights[8]=float[8] (0.071303,0.131514,0.189879,0.321392,0.452906, 0.584419,0.715932,0.847445);void processSample(vec2 uv,float i,vec2 stepSize,inout vec4 accumulator,inout float denominator)\n{vec2 offsetUV=stepSize*i+uv;float coefficient=weights[int(2.0-abs(i))];accumulator+=TEXTUREFUNC(textureSampler,offsetUV,0.0)*coefficient;denominator+=coefficient;}\nvoid main()\n{vec4 colorFull=TEXTUREFUNC(textureSampler,vUV,0.0);if (dot(colorFull,vec4(1.0))==0.0) {gl_FragColor=colorFull;return;}\nfloat blurRadius=colorFull.a*255.0; \nvec2 stepSize=texelOffsetScale.xy*blurRadius;vec4 accumulator=TEXTUREFUNC(textureSampler,vUV,0.0)*0.214607;float denominator=0.214607;processSample(vUV,1.0,stepSize,accumulator,denominator);processSample(vUV,1.0*0.2,stepSize,accumulator,denominator);processSample(vUV,1.0*0.4,stepSize,accumulator,denominator);processSample(vUV,1.0*0.6,stepSize,accumulator,denominator);processSample(vUV,1.0*0.8,stepSize,accumulator,denominator);processSample(vUV,1.0*1.2,stepSize,accumulator,denominator);processSample(vUV,1.0*1.4,stepSize,accumulator,denominator);processSample(vUV,1.0*1.6,stepSize,accumulator,denominator);processSample(vUV,1.0*1.8,stepSize,accumulator,denominator);processSample(vUV,1.0*2.0,stepSize,accumulator,denominator);processSample(vUV,-1.0,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.2,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.4,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.6,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.8,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.2,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.4,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.6,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.8,stepSize,accumulator,denominator);processSample(vUV,-1.0*2.0,stepSize,accumulator,denominator);gl_FragColor=vec4(accumulator.rgb/denominator,colorFull.a);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflection2BlurPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/screenSpaceRayTrace\";\n\nconst name = \"screenSpaceReflection2BlurCombinerPixelShader\";\nconst shader = `uniform sampler2D textureSampler; \nuniform sampler2D mainSampler;uniform sampler2D reflectivitySampler;uniform float strength;uniform float reflectionSpecularFalloffExponent;uniform float reflectivityThreshold;varying vec2 vUV;\n#include<helperFunctions>\n#ifdef SSR_BLEND_WITH_FRESNEL\n#include<pbrBRDFFunctions>\n#include<screenSpaceRayTrace>\nuniform mat4 projection;uniform mat4 invProjectionMatrix;uniform sampler2D normalSampler;uniform sampler2D depthSampler;\n#endif\nvoid main()\n{\n#ifdef SSRAYTRACE_DEBUG\ngl_FragColor=texture2D(textureSampler,vUV);\n#else\nvec3 SSR=texture2D(textureSampler,vUV).rgb;vec4 color=texture2D(mainSampler,vUV);vec4 reflectivity=texture2D(reflectivitySampler,vUV);\n#ifndef SSR_DISABLE_REFLECTIVITY_TEST\nif (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=reflectivityThreshold) {gl_FragColor=color;return;}\n#endif\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\ncolor=toLinearSpace(color);\n#endif\n#ifdef SSR_BLEND_WITH_FRESNEL\nvec2 texSize=vec2(textureSize(depthSampler,0));vec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz;float depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;vec3 csPosition=computeViewPosFromUVDepth(vUV,depth,projection,invProjectionMatrix);vec3 csViewDirection=normalize(csPosition);vec3 F0=reflectivity.rgb;vec3 fresnel=fresnelSchlickGGX(max(dot(csNormal,-csViewDirection),0.0),F0,vec3(1.));vec3 reflectionMultiplier=clamp(pow(fresnel*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\n#else\nvec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);\n#endif\nvec3 colorMultiplier=1.0-reflectionMultiplier;vec3 finalColor=(color.rgb*colorMultiplier)+(SSR*reflectionMultiplier);\n#ifdef SSR_OUTPUT_IS_GAMMA_SPACE\nfinalColor=toGammaSpace(finalColor);\n#endif\ngl_FragColor=vec4(finalColor,color.a);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflection2BlurCombinerPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"spriteMapPixelShader\";\nconst shader = `#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\nprecision highp float;varying vec3 vPosition;varying vec2 vUV;varying vec2 tUV;uniform float time;uniform float spriteCount;uniform sampler2D spriteSheet;uniform vec2 spriteMapSize;uniform vec2 outputSize;uniform vec2 stageSize;uniform sampler2D frameMap;uniform sampler2D tileMaps[LAYERS];uniform sampler2D animationMap;uniform vec3 colorMul;float mt;const float fdStep=1./4.;const float aFrameSteps=1./MAX_ANIMATION_FRAMES;mat4 getFrameData(float frameID){float fX=frameID/spriteCount;return mat4(\ntexture2D(frameMap,vec2(fX,0.),0.),\ntexture2D(frameMap,vec2(fX,fdStep*1.),0.),\ntexture2D(frameMap,vec2(fX,fdStep*2.),0.),\nvec4(0.)\n);}\nvoid main(){vec4 color=vec4(0.);vec2 tileUV=fract(tUV);\n#ifdef FLIPU\ntileUV.y=1.0-tileUV.y;\n#endif\nvec2 tileID=floor(tUV);vec2 sheetUnits=1./spriteMapSize;float spriteUnits=1./spriteCount;vec2 stageUnits=1./stageSize;for(int i=0; i<LAYERS; i++) {float frameID;\n#define LAYER_ID_SWITCH\nvec4 animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,0.),0.);if(animationData.y>0.) {mt=mod(time*animationData.z,1.0);for(float f=0.; f<MAX_ANIMATION_FRAMES; f++){if(animationData.y>mt){frameID=animationData.x;break;}\nanimationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.);}}\nmat4 frameData=getFrameData(frameID+0.5);vec2 frameSize=(frameData[0].zw)/spriteMapSize;vec2 offset=frameData[0].xy*sheetUnits;vec2 ratio=frameData[2].xy/frameData[0].zw;if (frameData[2].z==1.){tileUV.xy=tileUV.yx;}\nvec4 nc=texture2D(spriteSheet,tileUV*frameSize+offset);if (i==0){color=nc;} else {float alpha=min(color.a+nc.a,1.0);vec3 mixed=mix(color.xyz,nc.xyz,nc.a);color=vec4(mixed,alpha);}}\ncolor.xyz*=colorMul;gl_FragColor=color;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const spriteMapPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"spriteMapVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;varying vec3 vPosition;varying vec2 vUV;varying vec2 tUV;varying vec2 stageUnits;varying vec2 levelUnits;varying vec2 tileID;uniform float time;uniform mat4 worldViewProjection;uniform vec2 outputSize;uniform vec2 stageSize;uniform vec2 spriteMapSize;uniform float stageScale;void main() {vec4 p=vec4( position,1. );vPosition=p.xyz;vUV=uv;tUV=uv*stageSize; \ngl_Position=worldViewProjection*p;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const spriteMapVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssaoPixelShader\";\nconst shader = `uniform sampler2D textureSampler;varying vec2 vUV;\n#ifdef SSAO\nuniform sampler2D randomSampler;uniform float randTextureTiles;uniform float samplesFactor;uniform vec3 sampleSphere[SAMPLES];uniform float totalStrength;uniform float radius;uniform float area;uniform float fallOff;uniform float base;vec3 normalFromDepth(float depth,vec2 coords)\n{vec2 offset1=vec2(0.0,radius);vec2 offset2=vec2(radius,0.0);float depth1=texture2D(textureSampler,coords+offset1).r;float depth2=texture2D(textureSampler,coords+offset2).r;vec3 p1=vec3(offset1,depth1-depth);vec3 p2=vec3(offset2,depth2-depth);vec3 normal=cross(p1,p2);normal.z=-normal.z;return normalize(normal);}\nvoid main()\n{vec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);float depth=texture2D(textureSampler,vUV).r;vec3 position=vec3(vUV,depth);vec3 normal=normalFromDepth(depth,vUV);float radiusDepth=radius/depth;float occlusion=0.0;vec3 ray;vec3 hemiRay;float occlusionDepth;float difference;for (int i=0; i<SAMPLES; i++)\n{ray=radiusDepth*reflect(sampleSphere[i],random);hemiRay=position+sign(dot(ray,normal))*ray;occlusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;difference=depth-occlusionDepth;occlusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));}\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;float result=clamp(ao+base,0.0,1.0);gl_FragColor.r=result;gl_FragColor.g=result;gl_FragColor.b=result;gl_FragColor.a=1.0;}\n#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const ssaoPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssao2PixelShader\";\nconst shader = `precision highp float;uniform sampler2D textureSampler;varying vec2 vUV;\n#ifdef SSAO\nfloat scales[16]=float[16](\n0.1,\n0.11406250000000001,\n0.131640625,\n0.15625,\n0.187890625,\n0.2265625,\n0.272265625,\n0.325,\n0.384765625,\n0.4515625,\n0.525390625,\n0.60625,\n0.694140625,\n0.7890625,\n0.891015625,\n1.0\n);uniform float near;uniform float radius;uniform sampler2D depthSampler;uniform sampler2D randomSampler;uniform sampler2D normalSampler;uniform float randTextureTiles;uniform float samplesFactor;uniform vec3 sampleSphere[SAMPLES];uniform float totalStrength;uniform float base;uniform float xViewport;uniform float yViewport;uniform mat3 depthProjection;uniform float maxZ;uniform float minZAspect;uniform vec2 texelSize;uniform mat4 projection;void main()\n{vec3 random=textureLod(randomSampler,vUV*randTextureTiles,0.0).rgb;float depth=textureLod(depthSampler,vUV,0.0).r;float depthSign=depth/abs(depth);depth=depth*depthSign;vec3 normal=textureLod(normalSampler,vUV,0.0).rgb;float occlusion=0.0;float correctedRadius=min(radius,minZAspect*depth/near);vec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);vec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);vec3 origin=vViewRay*vDepthFactor;vec3 rvec=random*2.0-1.0;rvec.z=0.0;float dotProduct=dot(rvec,normal);rvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);vec3 tangent=normalize(rvec-normal*dot(rvec,normal));vec3 bitangent=cross(normal,tangent);mat3 tbn=mat3(tangent,bitangent,normal);float difference;for (int i=0; i<SAMPLES; ++i) {vec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];samplePosition=samplePosition*correctedRadius+origin;vec4 offset=vec4(samplePosition,1.0);offset=projection*offset;offset.xyz/=offset.w;offset.xy=offset.xy*0.5+0.5;if (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {continue;}\nfloat sampleDepth=abs(textureLod(depthSampler,offset.xy,0.0).r);difference=depthSign*samplePosition.z-sampleDepth;float rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);occlusion+=step(EPSILON,difference)*rangeCheck;}\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));float ao=1.0-totalStrength*occlusion*samplesFactor;float result=clamp(ao+base,0.0,1.0);gl_FragColor=vec4(vec3(result),1.0);}\n#endif\n#ifdef BLUR\nuniform float outSize;uniform float soften;uniform float tolerance;uniform int samples;\n#ifndef BLUR_BYPASS\nuniform sampler2D depthSampler;\n#ifdef BLUR_LEGACY\n#define inline\nfloat blur13Bilateral(sampler2D image,vec2 uv,vec2 step) {float result=0.0;vec2 off1=vec2(1.411764705882353)*step;vec2 off2=vec2(3.2941176470588234)*step;vec2 off3=vec2(5.176470588235294)*step;float compareDepth=abs(textureLod(depthSampler,uv,0.0).r);float sampleDepth;float weight;float weightSum=30.0;result+=textureLod(image,uv,0.0).r*30.0;sampleDepth=abs(textureLod(depthSampler,uv+off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureLod(image,uv+off1,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureLod(image,uv-off1,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv+off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv+off2,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv-off2,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv+off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv+off3,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv-off3,0.0).r*weight;return result/weightSum;}\n#endif\n#endif\nvoid main()\n{float result=0.0;\n#ifdef BLUR_BYPASS\nresult=textureLod(textureSampler,vUV,0.0).r;\n#else\n#ifdef BLUR_H\nvec2 step=vec2(1.0/outSize,0.0);\n#else\nvec2 step=vec2(0.0,1.0/outSize);\n#endif\n#ifdef BLUR_LEGACY\nresult=blur13Bilateral(textureSampler,vUV,step);\n#else\nfloat compareDepth=abs(textureLod(depthSampler,vUV,0.0).r);float weightSum=0.0;for (int i=-samples; i<samples; i+=2)\n{vec2 samplePos=vUV+step*(float(i)+0.5);float sampleDepth=abs(textureLod(depthSampler,samplePos,0.0).r);float falloff=smoothstep(0.0,\nfloat(samples),\nfloat(samples)-abs(float(i))*soften);float minDivider=tolerance*0.5+0.003;float weight=falloff/( minDivider+abs(compareDepth-sampleDepth));result+=textureLod(textureSampler,samplePos,0.0).r*weight;weightSum+=weight;}\nresult/=weightSum;\n#endif\n#endif\ngl_FragColor.rgb=vec3(result);gl_FragColor.a=1.0;}\n#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const ssao2PixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssaoCombinePixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform sampler2D originalColor;uniform vec4 viewport;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);vec4 sceneColor=texture2D(originalColor,vUV);gl_FragColor=sceneColor*ssaoColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const ssaoCombinePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/packingFunctions\";\n\nconst name = \"standardPixelShader\";\nconst shader = `uniform sampler2D textureSampler;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#if defined(PASS_POST_PROCESS)\nvoid main(void)\n{vec4 color=texture2D(textureSampler,vUV);gl_FragColor=color;}\n#endif\n#if defined(DOWN_SAMPLE_X4)\nuniform vec2 dsOffsets[16];void main(void)\n{vec4 average=vec4(0.0,0.0,0.0,0.0);average=texture2D(textureSampler,vUV+dsOffsets[0]);average+=texture2D(textureSampler,vUV+dsOffsets[1]);average+=texture2D(textureSampler,vUV+dsOffsets[2]);average+=texture2D(textureSampler,vUV+dsOffsets[3]);average+=texture2D(textureSampler,vUV+dsOffsets[4]);average+=texture2D(textureSampler,vUV+dsOffsets[5]);average+=texture2D(textureSampler,vUV+dsOffsets[6]);average+=texture2D(textureSampler,vUV+dsOffsets[7]);average+=texture2D(textureSampler,vUV+dsOffsets[8]);average+=texture2D(textureSampler,vUV+dsOffsets[9]);average+=texture2D(textureSampler,vUV+dsOffsets[10]);average+=texture2D(textureSampler,vUV+dsOffsets[11]);average+=texture2D(textureSampler,vUV+dsOffsets[12]);average+=texture2D(textureSampler,vUV+dsOffsets[13]);average+=texture2D(textureSampler,vUV+dsOffsets[14]);average+=texture2D(textureSampler,vUV+dsOffsets[15]);average/=16.0;gl_FragColor=average;}\n#endif\n#if defined(BRIGHT_PASS)\nuniform vec2 dsOffsets[4];uniform float brightThreshold;void main(void)\n{vec4 average=vec4(0.0,0.0,0.0,0.0);average=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));average*=0.25;float luminance=length(average.rgb);if (luminance<brightThreshold) {average=vec4(0.0,0.0,0.0,1.0);}\ngl_FragColor=average;}\n#endif\n#if defined(TEXTURE_ADDER)\nuniform sampler2D otherSampler;uniform sampler2D lensSampler;uniform float exposure;void main(void)\n{vec3 colour=texture2D(textureSampler,vUV).rgb;colour*=exposure;vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;colour+=colour*texture2D(lensSampler,vUV).rgb;vec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);gl_FragColor=finalColor;}\n#endif\n#if defined(VLS)\n#define PI 3.1415926535897932384626433832795\nuniform mat4 shadowViewProjection;uniform mat4 lightWorld;uniform vec3 cameraPosition;uniform vec3 sunDirection;uniform vec3 sunColor;uniform vec2 depthValues;uniform float scatteringCoefficient;uniform float scatteringPower;uniform sampler2D shadowMapSampler;uniform sampler2D positionSampler;float computeScattering(float lightDotView)\n{float result=1.0-scatteringCoefficient*scatteringCoefficient;result/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));return result;}\nvoid main(void)\n{vec3 worldPos=texture2D(positionSampler,vUV).rgb;vec3 startPosition=cameraPosition;vec3 rayVector=worldPos-startPosition;float rayLength=length(rayVector);vec3 rayDirection=rayVector/rayLength;float stepLength=rayLength/NB_STEPS;vec3 stepL=rayDirection*stepLength;vec3 currentPosition=startPosition;vec3 accumFog=vec3(0.0);for (int i=0; i<int(NB_STEPS); i++)\n{vec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);float depthMetric= (worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depthMetric,0.0,1.0);worldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;worldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);float shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;if (shadowMapValue>shadowPixelDepth)\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));currentPosition+=stepL;}\naccumFog/=NB_STEPS;vec3 color=accumFog*scatteringPower;gl_FragColor=vec4(color*exp(color) ,1.0);}\n#endif\n#if defined(VLSMERGE)\nuniform sampler2D originalSampler;void main(void)\n{gl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);}\n#endif\n#if defined(LUMINANCE)\nuniform vec2 lumOffsets[4];void main()\n{float average=0.0;vec4 color=vec4(0.0);float maximum=-1e20;vec3 weight=vec3(0.299,0.587,0.114);for (int i=0; i<4; i++)\n{color=texture2D(textureSampler,vUV+ lumOffsets[i]);float GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\n#ifdef WEIGHTED_AVERAGE\nfloat GreyValue=dot(color.rgb,weight);\n#endif\n#ifdef BRIGHTNESS\nfloat GreyValue=max(color.r,max(color.g,color.b));\n#endif\n#ifdef HSL_COMPONENT\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\n#endif\n#ifdef MAGNITUDE\nfloat GreyValue=length(color.rgb);\n#endif\nmaximum=max(maximum,GreyValue);average+=(0.25*log(1e-5+GreyValue));}\naverage=exp(average);gl_FragColor=vec4(average,maximum,0.0,1.0);}\n#endif\n#if defined(LUMINANCE_DOWN_SAMPLE)\nuniform vec2 dsOffsets[9];uniform float halfDestPixelSize;\n#ifdef FINAL_DOWN_SAMPLER\n#include<packingFunctions>\n#endif\nvoid main()\n{vec4 color=vec4(0.0);float average=0.0;for (int i=0; i<9; i++)\n{color=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);average+=color.r;}\naverage/=9.0;\n#ifdef FINAL_DOWN_SAMPLER\ngl_FragColor=pack(average);\n#else\ngl_FragColor=vec4(average,average,0.0,1.0);\n#endif\n}\n#endif\n#if defined(HDR)\nuniform sampler2D textureAdderSampler;uniform float averageLuminance;void main()\n{vec4 color=texture2D(textureAdderSampler,vUV);\n#ifndef AUTO_EXPOSURE\nvec4 adjustedColor=color/averageLuminance;color=adjustedColor;color.a=1.0;\n#endif\ngl_FragColor=color;}\n#endif\n#if defined(LENS_FLARE)\n#define GHOSTS 3\nuniform sampler2D lensColorSampler;uniform float strength;uniform float ghostDispersal;uniform float haloWidth;uniform vec2 resolution;uniform float distortionStrength;float hash(vec2 p)\n{float h=dot(p,vec2(127.1,311.7));return -1.0+2.0*fract(sin(h)*43758.5453123);}\nfloat noise(in vec2 p)\n{vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*(3.0-2.0*f);return mix(mix(hash(i+vec2(0.0,0.0)),\nhash(i+vec2(1.0,0.0)),u.x),\nmix(hash(i+vec2(0.0,1.0)),\nhash(i+vec2(1.0,1.0)),u.x),u.y);}\nfloat fbm(vec2 p)\n{float f=0.0;f+=0.5000*noise(p); p*=2.02;f+=0.2500*noise(p); p*=2.03;f+=0.1250*noise(p); p*=2.01;f+=0.0625*noise(p); p*=2.04;f/=0.9375;return f;}\nvec3 pattern(vec2 uv)\n{vec2 p=-1.0+2.0*uv;float p2=dot(p,p);float f=fbm(vec2(15.0*p2))/2.0;float r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));float g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));float b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));return (1.0-f)*vec3(r,g,b);}\nfloat luminance(vec3 color)\n{return dot(color.rgb,vec3(0.2126,0.7152,0.0722));}\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\n{return vec4(\ntexture2D(tex,texcoord+direction*distortion.r).r,\ntexture2D(tex,texcoord+direction*distortion.g).g,\ntexture2D(tex,texcoord+direction*distortion.b).b,\n1.0\n);}\nvoid main(void)\n{vec2 uv=-vUV+vec2(1.0);vec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;vec2 texelSize=1.0/resolution;vec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);vec4 result=vec4(0.0);float ghostIndice=1.0;for (int i=0; i<GHOSTS; ++i)\n{vec2 offset=fract(uv+ghostDir*ghostIndice);float weight=length(vec2(0.5)-offset)/length(vec2(0.5));weight=pow(1.0-weight,10.0);result+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;ghostIndice+=1.0;}\nvec2 haloVec=normalize(ghostDir)*haloWidth;float weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));weight=pow(1.0-weight,10.0);result+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;result*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));gl_FragColor=result;}\n#endif\n#if defined(LENS_FLARE_COMPOSE)\nuniform sampler2D otherSampler;uniform sampler2D lensDirtSampler;uniform sampler2D lensStarSampler;uniform mat4 lensStarMatrix;void main(void)\n{vec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;vec4 lensMod=texture2D(lensDirtSampler,vUV);lensMod+=texture2D(lensStarSampler,vUV/*lensFlareCoords*/);vec4 result=texture2D(textureSampler,vUV)*lensMod;gl_FragColor=texture2D(otherSampler,vUV)+result;}\n#endif\n#if defined(DEPTH_OF_FIELD)\nuniform sampler2D otherSampler;uniform sampler2D depthSampler;uniform float distance;void main(void)\n{vec4 sharp=texture2D(otherSampler,vUV);vec4 blur=texture2D(textureSampler,vUV);float dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);float factor=0.0;if (dist<0.05)\nfactor=1.0;else if (dist<0.1)\nfactor=20.0*(0.1-dist);else if (dist<0.5)\nfactor=0.0;else\nfactor=2.0*(dist-0.5);factor=clamp(factor,0.0,0.90);gl_FragColor=mix(sharp,blur,factor);}\n#endif\n#if defined(MOTION_BLUR)\nuniform mat4 inverseViewProjection;uniform mat4 prevViewProjection;uniform vec2 screenSize;uniform float motionScale;uniform float motionStrength;uniform sampler2D depthSampler;void main(void)\n{vec2 texelSize=1.0/screenSize;float depth=texture2D(depthSampler,vUV).r;vec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);cpos=cpos*inverseViewProjection;vec4 ppos=cpos*prevViewProjection;ppos.xyz/=ppos.w;ppos.xy=ppos.xy*0.5+0.5;vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;float speed=length(velocity/texelSize);int nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {if (i>=nSamples)\nbreak;vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);result+=texture2D(textureSampler,offset1);}\ngl_FragColor=result/float(nSamples);}\n#endif\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const standardPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"stereoscopicInterlacePixelShader\";\nconst shader = `const vec3 TWO=vec3(2.0,2.0,2.0);varying vec2 vUV;uniform sampler2D camASampler;uniform sampler2D textureSampler;uniform vec2 stepSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{bool useCamA;bool useCamB;vec2 texCoord1;vec2 texCoord2;vec3 frag1;vec3 frag2;\n#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;useCamA=!useCamB;texCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);texCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\n#else\n#ifdef IS_STEREOSCOPIC_INTERLACED\nfloat rowNum=floor(vUV.y/stepSize.y);useCamA=mod(rowNum,2.0)==1.0;useCamB=mod(rowNum,2.0)==0.0;texCoord1=vec2(vUV.x,vUV.y);texCoord2=vec2(vUV.x,vUV.y);\n#else\nuseCamB=vUV.y>0.5;useCamA=!useCamB;texCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);texCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\n#endif\n#endif\nif (useCamB){frag1=texture2D(textureSampler,texCoord1).rgb;frag2=texture2D(textureSampler,texCoord2).rgb;}else if (useCamA){frag1=texture2D(camASampler ,texCoord1).rgb;frag2=texture2D(camASampler ,texCoord2).rgb;}else {discard;}\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const stereoscopicInterlacePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"tonemapPixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;uniform float _ExposureAdjustment;\n#if defined(HABLE_TONEMAPPING)\nconst float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;const float W=11.2;\n#endif\nfloat Luminance(vec3 c)\n{return dot(c,vec3(0.22,0.707,0.071));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{vec3 colour=texture2D(textureSampler,vUV).rgb;\n#if defined(REINHARD_TONEMAPPING)\nfloat lum=Luminance(colour.rgb); \nfloat lumTm=lum*_ExposureAdjustment;float scale=lumTm/(1.0+lumTm); \ncolour*=scale/lum;\n#elif defined(HABLE_TONEMAPPING)\ncolour*=_ExposureAdjustment;const float ExposureBias=2.0;vec3 x=ExposureBias*colour;vec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;x=vec3(W,W,W);vec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);colour=curr*whiteScale;\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=_ExposureAdjustment;vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour= vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\n#endif\ngl_FragColor=vec4(colour.rgb,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const tonemapPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"velocityPixelShader\";\nconst shader = `precision highp float;\n#define CUSTOM_FRAGMENT_BEGIN\nvarying vec4 clipPos;varying vec4 previousClipPos;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nhighp vec4 motionVector=( clipPos/clipPos.w-previousClipPos/previousClipPos.w );gl_FragColor=motionVector;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const velocityPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\n\nconst name = \"velocityVertexShader\";\nconst shader = `#define CUSTOM_VERTEX_BEGIN\n#define VELOCITY\nattribute vec3 position;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform mat4 previousViewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;uniform mat4 previousViewProjectionR;\n#endif\nvarying vec4 clipPos;varying vec4 previousClipPos;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vec4 previousWorldPos=finalPreviousWorld*vec4(positionUpdated,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {clipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;} else {clipPos=viewProjectionR*worldPos;previousClipPos=previousViewProjectionR*previousWorldPos;gl_Position=clipPos;}\n#elif\nclipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const velocityVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"volumetricLightScatteringPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform sampler2D lightScatteringSampler;uniform float decay;uniform float exposure;uniform float weight;uniform float density;uniform vec2 meshPositionOnScreen;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec2 tc=vUV;vec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);deltaTexCoord*=1.0/float(NUM_SAMPLES)*density;float illuminationDecay=1.0;vec4 color=texture2D(lightScatteringSampler,tc)*0.4;for(int i=0; i<NUM_SAMPLES; i++) {tc-=deltaTexCoord;vec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;dataSample*=illuminationDecay*weight;color+=dataSample;illuminationDecay*=decay;}\nvec4 realColor=texture2D(textureSampler,vUV);gl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"volumetricLightScatteringPassPixelShader\";\nconst shader = `#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\n#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);if (diffuseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPassPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"volumetricLightScatteringPassVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const volumetricLightScatteringPassVertexShader = { name, shader };\n","import type { IVector3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * ThinSprite Class used to represent a thin sprite\r\n * This is the base class for sprites but can also directly be used with ThinEngine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n */\r\nexport class ThinSprite {\r\n    /** Gets or sets the cell index in the sprite sheet */\r\n    public cellIndex: number;\r\n    /** Gets or sets the cell reference in the sprite sheet, uses sprite's filename when added to sprite sheet */\r\n    public cellRef: string;\r\n    /** Gets or sets the current world position */\r\n    public position: IVector3Like;\r\n    /** Gets or sets the main color */\r\n    public color: IColor4Like;\r\n    /** Gets or sets the width */\r\n    public width = 1.0;\r\n    /** Gets or sets the height */\r\n    public height = 1.0;\r\n    /** Gets or sets rotation angle */\r\n    public angle = 0;\r\n    /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */\r\n    public invertU = false;\r\n    /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */\r\n    public invertV = false;\r\n    /** Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true */\r\n    public isVisible = true;\r\n\r\n    /**\r\n     * Returns a boolean indicating if the animation is started\r\n     */\r\n    public get animationStarted() {\r\n        return this._animationStarted;\r\n    }\r\n\r\n    /** Gets the initial key for the animation (setting it will restart the animation)  */\r\n    public get fromIndex() {\r\n        return this._fromIndex;\r\n    }\r\n\r\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\r\n    public get toIndex() {\r\n        return this._toIndex;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\r\n    public get loopAnimation() {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\r\n    public get delay() {\r\n        return Math.max(this._delay, 1);\r\n    }\r\n\r\n    /** @internal */\r\n    public _xOffset: number;\r\n    /** @internal */\r\n    public _yOffset: number;\r\n    /** @internal */\r\n    public _xSize: number;\r\n    /** @internal */\r\n    public _ySize: number;\r\n\r\n    private _animationStarted = false;\r\n    protected _loopAnimation = false;\r\n    protected _fromIndex = 0;\r\n    protected _toIndex = 0;\r\n    protected _delay = 0;\r\n    private _direction = 1;\r\n    private _time = 0;\r\n    private _onBaseAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Creates a new Thin Sprite\r\n     */\r\n    constructor() {\r\n        this.position = { x: 1.0, y: 1.0, z: 1.0 };\r\n        this.color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\r\n    }\r\n\r\n    /**\r\n     * Starts an animation\r\n     * @param from defines the initial key\r\n     * @param to defines the end key\r\n     * @param loop defines if the animation must loop\r\n     * @param delay defines the start delay (in ms)\r\n     * @param onAnimationEnd defines a callback for when the animation ends\r\n     */\r\n    public playAnimation(from: number, to: number, loop: boolean, delay: number, onAnimationEnd: Nullable<() => void>): void {\r\n        this._fromIndex = from;\r\n        this._toIndex = to;\r\n        this._loopAnimation = loop;\r\n        this._delay = delay || 1;\r\n        this._animationStarted = true;\r\n        this._onBaseAnimationEnd = onAnimationEnd;\r\n\r\n        if (from < to) {\r\n            this._direction = 1;\r\n        } else {\r\n            this._direction = -1;\r\n            this._toIndex = from;\r\n            this._fromIndex = to;\r\n        }\r\n\r\n        this.cellIndex = from;\r\n        this._time = 0;\r\n    }\r\n\r\n    /** Stops current animation (if any) */\r\n    public stopAnimation(): void {\r\n        this._animationStarted = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(deltaTime: number): void {\r\n        if (!this._animationStarted) {\r\n            return;\r\n        }\r\n\r\n        this._time += deltaTime;\r\n        if (this._time > this._delay) {\r\n            this._time = this._time % this._delay;\r\n            this.cellIndex += this._direction;\r\n            if ((this._direction > 0 && this.cellIndex > this._toIndex) || (this._direction < 0 && this.cellIndex < this._fromIndex)) {\r\n                if (this._loopAnimation) {\r\n                    this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;\r\n                } else {\r\n                    this.cellIndex = this._toIndex;\r\n                    this._animationStarted = false;\r\n                    if (this._onBaseAnimationEnd) {\r\n                        this._onBaseAnimationEnd();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ActionManager } from \"../Actions/actionManager\";\r\nimport type { ISpriteManager, SpriteManager } from \"./spriteManager\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { ThinSprite } from \"./thinSprite\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\n\r\n/**\r\n * Class used to represent a sprite\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n */\r\nexport class Sprite extends ThinSprite implements IAnimatable {\r\n    /** Gets or sets the current world position */\r\n    public position: Vector3;\r\n    /** Gets or sets the main color */\r\n    public color: Color4;\r\n    /** Gets or sets a boolean indicating that this sprite should be disposed after animation ends */\r\n    public disposeWhenFinishedAnimating: boolean;\r\n    /** Gets the list of attached animations */\r\n    public animations: Nullable<Array<Animation>> = new Array<Animation>();\r\n    /** Gets or sets a boolean indicating if the sprite can be picked */\r\n    public isPickable = false;\r\n    /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\r\n    public useAlphaForPicking = false;\r\n\r\n    /**\r\n     * Gets or sets the associated action manager\r\n     */\r\n    public actionManager: Nullable<ActionManager>;\r\n\r\n    /**\r\n     * An event triggered when the control has been disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Sprite>();\r\n\r\n    private _manager: ISpriteManager;\r\n    private _onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Gets or sets the sprite size\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    public set size(value: number) {\r\n        this.width = value;\r\n        this.height = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the manager of this sprite\r\n     */\r\n    public get manager() {\r\n        return this._manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Sprite\r\n     * @param name defines the name\r\n     * @param manager defines the manager\r\n     */\r\n    constructor(\r\n        /** defines the name */\r\n        public name: string,\r\n        manager: ISpriteManager\r\n    ) {\r\n        super();\r\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this.position = Vector3.Zero();\r\n\r\n        this._manager = manager;\r\n        this._manager.sprites.push(this);\r\n        this.uniqueId = this._manager.scene.getUniqueId();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Sprite\"\r\n     * @returns \"Sprite\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sprite\";\r\n    }\r\n\r\n    /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\r\n    public get fromIndex() {\r\n        return this._fromIndex;\r\n    }\r\n    public set fromIndex(value: number) {\r\n        this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\r\n    public get toIndex() {\r\n        return this._toIndex;\r\n    }\r\n    public set toIndex(value: number) {\r\n        this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\r\n    public get loopAnimation() {\r\n        return this._loopAnimation;\r\n    }\r\n    public set loopAnimation(value: boolean) {\r\n        this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\r\n    public get delay() {\r\n        return Math.max(this._delay, 1);\r\n    }\r\n    public set delay(value: number) {\r\n        this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Starts an animation\r\n     * @param from defines the initial key\r\n     * @param to defines the end key\r\n     * @param loop defines if the animation must loop\r\n     * @param delay defines the start delay (in ms)\r\n     * @param onAnimationEnd defines a callback to call when animation ends\r\n     */\r\n    public playAnimation(from: number, to: number, loop: boolean, delay: number, onAnimationEnd: Nullable<() => void> = null): void {\r\n        this._onAnimationEnd = onAnimationEnd;\r\n\r\n        super.playAnimation(from, to, loop, delay, this._endAnimation);\r\n    }\r\n\r\n    private _endAnimation = () => {\r\n        if (this._onAnimationEnd) {\r\n            this._onAnimationEnd();\r\n        }\r\n        if (this.disposeWhenFinishedAnimating) {\r\n            this.dispose();\r\n        }\r\n    };\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        for (let i = 0; i < this._manager.sprites.length; i++) {\r\n            if (this._manager.sprites[i] == this) {\r\n                this._manager.sprites.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.position = this.position.asArray();\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.width = this.width;\r\n        serializationObject.height = this.height;\r\n        serializationObject.angle = this.angle;\r\n        serializationObject.cellIndex = this.cellIndex;\r\n        serializationObject.cellRef = this.cellRef;\r\n        serializationObject.invertU = this.invertU;\r\n        serializationObject.invertV = this.invertV;\r\n        serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\r\n        serializationObject.isPickable = this.isPickable;\r\n        serializationObject.isVisible = this.isVisible;\r\n        serializationObject.useAlphaForPicking = this.useAlphaForPicking;\r\n\r\n        serializationObject.animationStarted = this.animationStarted;\r\n        serializationObject.fromIndex = this.fromIndex;\r\n        serializationObject.toIndex = this.toIndex;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.delay = this.delay;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite\r\n     * @param parsedSprite The JSON object to parse\r\n     * @param manager defines the hosting manager\r\n     * @returns the new sprite\r\n     */\r\n    public static Parse(parsedSprite: any, manager: SpriteManager): Sprite {\r\n        const sprite = new Sprite(parsedSprite.name, manager);\r\n\r\n        sprite.position = Vector3.FromArray(parsedSprite.position);\r\n        sprite.color = Color4.FromArray(parsedSprite.color);\r\n        sprite.width = parsedSprite.width;\r\n        sprite.height = parsedSprite.height;\r\n        sprite.angle = parsedSprite.angle;\r\n        sprite.cellIndex = parsedSprite.cellIndex;\r\n        sprite.cellRef = parsedSprite.cellRef;\r\n        sprite.invertU = parsedSprite.invertU;\r\n        sprite.invertV = parsedSprite.invertV;\r\n        sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\r\n        sprite.isPickable = parsedSprite.isPickable;\r\n        sprite.isVisible = parsedSprite.isVisible;\r\n        sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\r\n\r\n        sprite._fromIndex = parsedSprite.fromIndex;\r\n        sprite._toIndex = parsedSprite.toIndex;\r\n        sprite._loopAnimation = parsedSprite.loopAnimation;\r\n        sprite._delay = parsedSprite.delay;\r\n\r\n        if (parsedSprite.animationStarted) {\r\n            sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"spritesPixelShader\";\nconst shader = `uniform bool alphaTest;varying vec4 vColor;varying vec2 vUV;uniform sampler2D diffuseSampler;\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#ifdef PIXEL_PERFECT\nvec2 uvPixelPerfect(vec2 uv) {vec2 res=vec2(textureSize(diffuseSampler,0));uv=uv*res;vec2 seam=floor(uv+0.5);uv=seam+clamp((uv-seam)/fwidth(uv),-0.5,0.5);return uv/res;}\n#endif\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#ifdef PIXEL_PERFECT\nvec2 uv=uvPixelPerfect(vUV);\n#else\nvec2 uv=vUV;\n#endif\nvec4 color=texture2D(diffuseSampler,uv);float fAlphaTest=float(alphaTest);if (fAlphaTest != 0.)\n{if (color.a<0.95)\ndiscard;}\ncolor*=vColor;\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const spritesPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\n\nconst name = \"spritesVertexShader\";\nconst shader = `attribute vec4 position;attribute vec2 options;attribute vec2 offsets;attribute vec2 inverts;attribute vec4 cellInfo;attribute vec4 color;uniform mat4 view;uniform mat4 projection;varying vec2 vUV;varying vec4 vColor;\n#include<fogVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \nvec2 cornerPos;float angle=position.w;vec2 size=vec2(options.x,options.y);vec2 offset=offsets.xy;cornerPos=vec2(offset.x-0.5,offset.y -0.5)*size;vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;gl_Position=projection*vec4(viewPos,1.0); \nvColor=color;vec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));vec2 uvPlace=cellInfo.xy;vec2 uvSize=cellInfo.zw;vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vUV.y=uvPlace.y+uvSize.y*uvOffset.y;\n#ifdef FOG\nvFogDistance=viewPos;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const spritesVertexShader = { name, shader };\n","import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IMatrixLike } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\n\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\n\r\nimport \"../Shaders/sprites.fragment\";\r\nimport \"../Shaders/sprites.vertex\";\r\n\r\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\r\n */\r\nexport class SpriteRenderer {\r\n    /**\r\n     * Defines the texture of the spritesheet\r\n     */\r\n    public texture: Nullable<ThinTexture>;\r\n\r\n    /**\r\n     * Defines the default width of a cell in the spritesheet\r\n     */\r\n    public cellWidth: number;\r\n\r\n    /**\r\n     * Defines the default height of a cell in the spritesheet\r\n     */\r\n    public cellHeight: number;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public blendMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\r\n    public autoResetAlpha = true;\r\n\r\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\r\n    public fogEnabled = true;\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._capacity;\r\n    }\r\n\r\n    private _pixelPerfect = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\r\n     * Note that pixel perfect mode is not supported in WebGL 1\r\n     */\r\n    public get pixelPerfect() {\r\n        return this._pixelPerfect;\r\n    }\r\n\r\n    public set pixelPerfect(value: boolean) {\r\n        if (this._pixelPerfect === value) {\r\n            return;\r\n        }\r\n\r\n        this._pixelPerfect = value;\r\n        this._createEffects();\r\n    }\r\n\r\n    private readonly _engine: ThinEngine;\r\n    private readonly _useVAO: boolean = false;\r\n    private readonly _useInstancing: boolean = false;\r\n    private readonly _scene: Nullable<Scene>;\r\n\r\n    private readonly _capacity: number;\r\n    private readonly _epsilon: number;\r\n\r\n    private _vertexBufferSize: number;\r\n    private _vertexData: Float32Array;\r\n    private _buffer: Buffer;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: DataBuffer;\r\n    private _drawWrapperBase: DrawWrapper;\r\n    private _drawWrapperFog: DrawWrapper;\r\n    private _drawWrapperDepth: DrawWrapper;\r\n    private _drawWrapperFogDepth: DrawWrapper;\r\n    private _vertexArrayObject: WebGLVertexArrayObject;\r\n\r\n    /**\r\n     * Creates a new sprite Renderer\r\n     * @param engine defines the engine the renderer works with\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(engine: ThinEngine, capacity: number, epsilon: number = 0.01, scene: Nullable<Scene> = null) {\r\n        this._capacity = capacity;\r\n        this._epsilon = epsilon;\r\n\r\n        this._engine = engine;\r\n        this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;\r\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\r\n        this._scene = scene;\r\n\r\n        if (!this._useInstancing) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        // VBO\r\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\r\n        // 16 when using instances\r\n        this._vertexBufferSize = this._useInstancing ? 16 : 18;\r\n        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\r\n        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\r\n\r\n        const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\r\n        const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\r\n\r\n        let offset = 6;\r\n        let offsets: VertexBuffer;\r\n\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\r\n        } else {\r\n            offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n            offset += 2;\r\n        }\r\n\r\n        const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n        const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\r\n        const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        this._vertexBuffers[\"options\"] = options;\r\n        this._vertexBuffers[\"offsets\"] = offsets;\r\n        this._vertexBuffers[\"inverts\"] = inverts;\r\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n\r\n        this._createEffects();\r\n    }\r\n\r\n    private _createEffects() {\r\n        this._drawWrapperBase?.dispose();\r\n        this._drawWrapperFog?.dispose();\r\n        this._drawWrapperDepth?.dispose();\r\n        this._drawWrapperFogDepth?.dispose();\r\n\r\n        this._drawWrapperBase = new DrawWrapper(this._engine);\r\n        this._drawWrapperFog = new DrawWrapper(this._engine);\r\n        this._drawWrapperDepth = new DrawWrapper(this._engine, false);\r\n        this._drawWrapperFogDepth = new DrawWrapper(this._engine, false);\r\n\r\n        if (this._drawWrapperBase.drawContext) {\r\n            this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFog.drawContext) {\r\n            this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperDepth.drawContext) {\r\n            this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n        if (this._drawWrapperFogDepth.drawContext) {\r\n            this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\r\n        }\r\n\r\n        const defines = this._pixelPerfect ? \"#define PIXEL_PERFECT\\n\" : \"\";\r\n\r\n        this._drawWrapperBase.effect = this._engine.createEffect(\r\n            \"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"],\r\n            [\"diffuseSampler\"],\r\n            defines\r\n        );\r\n\r\n        this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\r\n        this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\r\n\r\n        if (this._scene) {\r\n            this._drawWrapperFog.effect = this._scene\r\n                .getEngine()\r\n                .createEffect(\r\n                    \"sprites\",\r\n                    [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n                    [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"],\r\n                    [\"diffuseSampler\"],\r\n                    defines + \"#define FOG\"\r\n                );\r\n            this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\r\n            this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     * @param sprites defines the list of sprites to render\r\n     * @param deltaTime defines the time since last frame\r\n     * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n     * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n     * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n     */\r\n    public render(\r\n        sprites: ThinSprite[],\r\n        deltaTime: number,\r\n        viewMatrix: IMatrixLike,\r\n        projectionMatrix: IMatrixLike,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void> = null\r\n    ): void {\r\n        if (!this.texture || !this.texture.isReady() || !sprites.length) {\r\n            return;\r\n        }\r\n\r\n        let drawWrapper = this._drawWrapperBase;\r\n        let drawWrapperDepth = this._drawWrapperDepth;\r\n        let shouldRenderFog = false;\r\n        if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\r\n            drawWrapper = this._drawWrapperFog;\r\n            drawWrapperDepth = this._drawWrapperFogDepth;\r\n            shouldRenderFog = true;\r\n        }\r\n\r\n        const effect = drawWrapper.effect!;\r\n\r\n        // Check\r\n        if (!effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\r\n        const baseSize = this.texture.getBaseSize();\r\n\r\n        // Sprites\r\n        const max = Math.min(this._capacity, sprites.length);\r\n\r\n        let offset = 0;\r\n        let noSprite = true;\r\n        for (let index = 0; index < max; index++) {\r\n            const sprite = sprites[index];\r\n            if (!sprite || !sprite.isVisible) {\r\n                continue;\r\n            }\r\n\r\n            noSprite = false;\r\n            sprite._animate(deltaTime);\r\n\r\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            if (!this._useInstancing) {\r\n                this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            }\r\n        }\r\n\r\n        if (noSprite) {\r\n            return;\r\n        }\r\n\r\n        this._buffer.update(this._vertexData);\r\n\r\n        const culling = !!engine.depthCullingState.cull;\r\n        const zOffset = engine.depthCullingState.zOffset;\r\n        const zOffsetUnits = engine.depthCullingState.zOffsetUnits;\r\n\r\n        engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        effect.setTexture(\"diffuseSampler\", this.texture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", projectionMatrix);\r\n\r\n        // Scene Info\r\n        if (shouldRenderFog) {\r\n            const scene = this._scene!;\r\n\r\n            // Fog\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n            engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        } else {\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // Draw order\r\n        engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? Constants.GEQUAL : Constants.LEQUAL;\r\n        if (!this.disableDepthWrite) {\r\n            effect.setBool(\"alphaTest\", true);\r\n            engine.setColorWrite(false);\r\n            engine.enableEffect(drawWrapperDepth);\r\n            if (this._useInstancing) {\r\n                engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n            } else {\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n            }\r\n            engine.enableEffect(drawWrapper);\r\n            engine.setColorWrite(true);\r\n            effect.setBool(\"alphaTest\", false);\r\n        }\r\n\r\n        engine.setAlphaMode(this.blendMode);\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, offset);\r\n        } else {\r\n            engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, (offset / 4) * 6);\r\n        }\r\n\r\n        if (this.autoResetAlpha) {\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._scene!.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n    }\r\n\r\n    private _appendSpriteVertex(\r\n        index: number,\r\n        sprite: ThinSprite,\r\n        offsetX: number,\r\n        offsetY: number,\r\n        baseSize: ISize,\r\n        useRightHandedSystem: boolean,\r\n        customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void>\r\n    ): void {\r\n        let arrayOffset = index * this._vertexBufferSize;\r\n\r\n        if (offsetX === 0) {\r\n            offsetX = this._epsilon;\r\n        } else if (offsetX === 1) {\r\n            offsetX = 1 - this._epsilon;\r\n        }\r\n\r\n        if (offsetY === 0) {\r\n            offsetY = this._epsilon;\r\n        } else if (offsetY === 1) {\r\n            offsetY = 1 - this._epsilon;\r\n        }\r\n\r\n        if (customSpriteUpdate) {\r\n            customSpriteUpdate(sprite, baseSize);\r\n        } else {\r\n            if (!sprite.cellIndex) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n\r\n            const rowSize = baseSize.width / this.cellWidth;\r\n            const offset = (sprite.cellIndex / rowSize) >> 0;\r\n            sprite._xOffset = ((sprite.cellIndex - offset * rowSize) * this.cellWidth) / baseSize.width;\r\n            sprite._yOffset = (offset * this.cellHeight) / baseSize.height;\r\n            sprite._xSize = this.cellWidth;\r\n            sprite._ySize = this.cellHeight;\r\n        }\r\n\r\n        // Positions\r\n        this._vertexData[arrayOffset] = sprite.position.x;\r\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\r\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\r\n        this._vertexData[arrayOffset + 3] = sprite.angle;\r\n        // Options\r\n        this._vertexData[arrayOffset + 4] = sprite.width;\r\n        this._vertexData[arrayOffset + 5] = sprite.height;\r\n\r\n        if (!this._useInstancing) {\r\n            this._vertexData[arrayOffset + 6] = offsetX;\r\n            this._vertexData[arrayOffset + 7] = offsetY;\r\n        } else {\r\n            arrayOffset -= 2;\r\n        }\r\n\r\n        // Inverts according to Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\r\n        } else {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\r\n        }\r\n\r\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\r\n\r\n        this._vertexData[arrayOffset + 10] = sprite._xOffset;\r\n        this._vertexData[arrayOffset + 11] = sprite._yOffset;\r\n        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\r\n        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\r\n\r\n        // Color\r\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\r\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\r\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\r\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        const indices = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the renderer (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        if (this._indexBuffer) {\r\n            this._buildIndexBuffer();\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            this._vertexArrayObject = undefined as any;\r\n        }\r\n\r\n        this._buffer._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n\r\n        this._spriteBuffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._buffer) {\r\n            this._buffer.dispose();\r\n            (<any>this._buffer) = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            (<any>this._indexBuffer) = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            (<any>this._vertexArrayObject) = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            (<any>this.texture) = null;\r\n        }\r\n        this._drawWrapperBase.dispose();\r\n        this._drawWrapperFog.dispose();\r\n        this._drawWrapperDepth.dispose();\r\n        this._drawWrapperFogDepth.dispose();\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Sprite } from \"./sprite\";\r\nimport type { ISpriteManager } from \"./spriteManager\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _pointerOverSprite: Nullable<Sprite>;\r\n\r\n        /** @internal */\r\n        _pickedDownSprite: Nullable<Sprite>;\r\n\r\n        /** @internal */\r\n        _tempSpritePickingRay: Nullable<Ray>;\r\n\r\n        /**\r\n         * All of the sprite managers added to this scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n         */\r\n        spriteManagers?: Array<ISpriteManager>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is about to start\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onBeforeSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is done\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onAfterSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /** @internal */\r\n        _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Launch a ray to try to pick a sprite in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Use the given ray to pick a sprite in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** @internal */\r\n        _internalMultiPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Launch a ray to try to pick sprites in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Use the given ray to pick sprites in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /**\r\n         * Force the sprite under the pointer\r\n         * @param sprite defines the sprite to use\r\n         */\r\n        setPointerOverSprite(sprite: Nullable<Sprite>): void;\r\n\r\n        /**\r\n         * Gets the sprite under the pointer\r\n         * @returns a Sprite or null if no sprite is under the pointer\r\n         */\r\n        getPointerOverSprite(): Nullable<Sprite>;\r\n    }\r\n}\r\n\r\nScene.prototype._internalPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers && this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\r\n            if (!result || !result.hit) {\r\n                continue;\r\n            }\r\n\r\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n                continue;\r\n            }\r\n\r\n            pickingInfo = result;\r\n\r\n            if (fastCheck) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPickSprites = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfos = new Array<PickingInfo>();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers && this.spriteManagers.length > 0) {\r\n        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            const spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            const results = spriteManager.multiIntersects(ray, camera, predicate);\r\n\r\n            if (results !== null) {\r\n                pickingInfos = pickingInfos.concat(results);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = this.createPickingRayInCameraSpace(x, y, camera);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPickSprite = function (x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay!, camera);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay!, predicate, camera);\r\n};\r\n\r\nScene.prototype.multiPickSpriteWithRay = function (ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\r\n};\r\n\r\nScene.prototype.setPointerOverSprite = function (sprite: Nullable<Sprite>): void {\r\n    if (this._pointerOverSprite === sprite) {\r\n        return;\r\n    }\r\n\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n\r\n    this._pointerOverSprite = sprite;\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n};\r\n\r\nScene.prototype.getPointerOverSprite = function (): Nullable<Sprite> {\r\n    return this._pointerOverSprite;\r\n};\r\n\r\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\r\nexport class SpriteSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SPRITE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /** @internal */\r\n    private _spritePredicate: (sprite: Sprite) => boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.spriteManagers = new Array<ISpriteManager>();\r\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\r\n        this.scene.onBeforeSpritesRenderingObservable = new Observable<Scene>();\r\n        this.scene.onAfterSpritesRenderingObservable = new Observable<Scene>();\r\n        this._spritePredicate = (sprite: Sprite): boolean => {\r\n            if (!sprite.actionManager) {\r\n                return false;\r\n            }\r\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\r\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\r\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        /** Nothing to do for sprites */\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforeSpritesRenderingObservable.clear();\r\n        this.scene.onAfterSpritesRenderingObservable.clear();\r\n\r\n        const spriteManagers = this.scene.spriteManagers;\r\n        if (!spriteManagers) {\r\n            return;\r\n        }\r\n        while (spriteManagers.length) {\r\n            spriteManagers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _pickSpriteButKeepRay(originalPointerInfo: Nullable<PickingInfo>, x: number, y: number, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n        const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\r\n        if (result) {\r\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _pointerMove(\r\n        unTranslatedPointerX: number,\r\n        unTranslatedPointerY: number,\r\n        pickResult: Nullable<PickingInfo>,\r\n        isMeshPicked: boolean,\r\n        element: Nullable<HTMLElement>\r\n    ): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverSprite(null);\r\n        } else {\r\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                scene.setPointerOverSprite(pickResult.pickedSprite);\r\n                if (!scene.doNotHandleCursors && element) {\r\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\r\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\r\n                    } else {\r\n                        element.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            } else {\r\n                scene.setPointerOverSprite(null);\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerDown(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: IPointerEvent): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        scene._pickedDownSprite = null;\r\n        if (scene.spriteManagers && scene.spriteManagers.length > 0) {\r\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                if (pickResult.pickedSprite.actionManager) {\r\n                    scene._pickedDownSprite = pickResult.pickedSprite;\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnLeftPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 1:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnCenterPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                        case 2:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(\r\n                                Constants.ACTION_OnRightPickTrigger,\r\n                                ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                            );\r\n                            break;\r\n                    }\r\n                    if (pickResult.pickedSprite.actionManager) {\r\n                        pickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickDownTrigger,\r\n                            ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt)\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerUp(\r\n        unTranslatedPointerX: number,\r\n        unTranslatedPointerY: number,\r\n        pickResult: Nullable<PickingInfo>,\r\n        evt: IPointerEvent,\r\n        doubleClick: boolean\r\n    ): Nullable<PickingInfo> {\r\n        const scene = this.scene;\r\n        if (scene.spriteManagers && scene.spriteManagers.length > 0) {\r\n            const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (spritePickResult) {\r\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\r\n                    if (spritePickResult.pickedSprite.actionManager) {\r\n                        spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                            Constants.ACTION_OnPickUpTrigger,\r\n                            ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                        );\r\n\r\n                        if (spritePickResult.pickedSprite.actionManager) {\r\n                            if (!this.scene._inputManager._isPointerSwiping()) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                                    Constants.ACTION_OnPickTrigger,\r\n                                    ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                                );\r\n                            }\r\n\r\n                            if (doubleClick) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(\r\n                                    Constants.ACTION_OnDoublePickTrigger,\r\n                                    ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt)\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\r\n                    scene._pickedDownSprite.actionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n}\r\n","import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport type { Observer, Observable, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\n\r\n/**\r\n * This is the base class for all WebXR features.\r\n * Since most features require almost the same resources and callbacks, this class can be used to simplify the development\r\n * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class\r\n */\r\nexport abstract class WebXRAbstractFeature implements IWebXRFeature {\r\n    private _attached: boolean = false;\r\n    private _removeOnDetach: {\r\n        observer: Nullable<Observer<any>>;\r\n        observable: Observable<any>;\r\n    }[] = [];\r\n\r\n    /**\r\n     * Is this feature disposed?\r\n     */\r\n    public isDisposed: boolean = false;\r\n\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    public disableAutoAttach: boolean = false;\r\n\r\n    /**\r\n     * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    public xrNativeFeatureName: string = \"\";\r\n\r\n    /**\r\n     * Construct a new (abstract) WebXR feature\r\n     * @param _xrSessionManager the xr session manager for this feature\r\n     */\r\n    constructor(protected _xrSessionManager: WebXRSessionManager) {}\r\n\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    public get attached() {\r\n        return this._attached;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful, false is failed or already attached\r\n     */\r\n    public attach(force?: boolean): boolean {\r\n        // do not attach a disposed feature\r\n        if (this.isDisposed) {\r\n            return false;\r\n        }\r\n        if (!force) {\r\n            if (this.attached) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (this.attached) {\r\n                // detach first, to be sure\r\n                this.detach();\r\n            }\r\n        }\r\n\r\n        this._attached = true;\r\n        this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     *\r\n     * @returns true if successful, false if failed or already detached\r\n     */\r\n    public detach(): boolean {\r\n        if (!this._attached) {\r\n            this.disableAutoAttach = true;\r\n            return false;\r\n        }\r\n        this._attached = false;\r\n        this._removeOnDetach.forEach((toRemove) => {\r\n            toRemove.observable.remove(toRemove.observer);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this.detach();\r\n        this.isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    public isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This is used to register callbacks that will automatically be removed when detach is called.\r\n     * @param observable the observable to which the observer will be attached\r\n     * @param callback the callback to register\r\n     */\r\n    protected _addNewAttachObserver<T>(observable: Observable<T>, callback: (eventData: T, eventState: EventState) => void) {\r\n        this._removeOnDetach.push({\r\n            observable,\r\n            observer: observable.add(callback),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code in this function will be executed on each xrFrame received from the browser.\r\n     * This function will not execute after the feature is detached.\r\n     * @param _xrFrame the current frame\r\n     */\r\n    protected abstract _onXRFrame(_xrFrame: XRFrame): void;\r\n}\r\n","import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPointerSelectionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y)\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.pointerDownTriggered = true;\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n","import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long should the \"long press\" take before teleport\r\n     */\r\n    timeToTeleport?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * Color of the teleportation ray when it is blocked by a mesh in the pickBlockerMeshes array\r\n     * Defaults to red.\r\n     */\r\n    blockedRayColor?: Color4;\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n                blocked: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _blockedRayColor: Color4;\r\n    private _cachedColor4White = new Color4(1, 1, 1, 1);\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRTeleportationOptions) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n        this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\r\n\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        controllerData.teleportationState.blocked = true;\r\n                        this._setTargetMeshVisibility(false);\r\n                        this._showParabolicPath(pick);\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        controllerData.teleportationState.blocked = false;\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible);\r\n            } else {\r\n                this._setTargetMeshVisibility(false);\r\n            }\r\n        } else {\r\n            this._disposeBezierCurve();\r\n            this._setTargetMeshVisibility(false);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n                blocked: false,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // simulate \"forward\" thumbstick push\r\n                                    controllerData.teleportationState.forward = true;\r\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                    controllerData.teleportationState.currentRotation = 0;\r\n                                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                    setAndStartTimer({\r\n                                        timeout: timeToSelect,\r\n                                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                        breakCondition: () => !mainComponent.pressed,\r\n                                        onEnded: () => {\r\n                                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                                this._teleportForward(xrController.uniqueId);\r\n                                            }\r\n                                        },\r\n                                    });\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.blocked) {\r\n                                    controllerData.teleportationState.blocked = false;\r\n                                    this._setTargetMeshVisibility(false);\r\n                                }\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    controllerData.teleportationState.forward = true;\r\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                    controllerData.teleportationState.currentRotation = 0;\r\n                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                    setAndStartTimer({\r\n                        timeout: timeToSelect,\r\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                        onEnded: () => {\r\n                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                this._teleportForward(xrController.uniqueId);\r\n                            }\r\n                        },\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean, force?: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disposeBezierCurve() {\r\n        if (this._quadraticBezierCurve) {\r\n            this._quadraticBezierCurve.dispose();\r\n            this._quadraticBezierCurve = null;\r\n        }\r\n    }\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\r\n        const colorsArray = new Array(26).fill(color || this._cachedColor4White);\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve as LinesMesh, updatable: true, colors: colorsArray },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n","import type { IDisposable, Scene } from \"../../scene\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\n\r\n/**\r\n * Handedness type in xrInput profiles. These can be used to define layouts in the Layout Map.\r\n */\r\nexport type MotionControllerHandedness = \"none\" | \"left\" | \"right\";\r\n/**\r\n * The type of components available in motion controllers.\r\n * This is not the name of the component.\r\n */\r\nexport type MotionControllerComponentType = \"trigger\" | \"squeeze\" | \"touchpad\" | \"thumbstick\" | \"button\";\r\n\r\n/**\r\n * The state of a controller component\r\n */\r\nexport type MotionControllerComponentStateType = \"default\" | \"touched\" | \"pressed\";\r\n\r\n/**\r\n * The schema of motion controller layout.\r\n * No object will be initialized using this interface\r\n * This is used just to define the profile.\r\n */\r\nexport interface IMotionControllerLayout {\r\n    /**\r\n     * Path to load the assets. Usually relative to the base path\r\n     */\r\n    assetPath: string;\r\n    /**\r\n     * Available components (unsorted)\r\n     */\r\n    components: {\r\n        /**\r\n         * A map of component Ids\r\n         */\r\n        [componentId: string]: {\r\n            /**\r\n             * The type of input the component outputs\r\n             */\r\n            type: MotionControllerComponentType;\r\n            /**\r\n             * The indices of this component in the gamepad object\r\n             */\r\n            gamepadIndices: {\r\n                /**\r\n                 * Index of button\r\n                 */\r\n                button?: number;\r\n                /**\r\n                 * If available, index of x-axis\r\n                 */\r\n                xAxis?: number;\r\n                /**\r\n                 * If available, index of y-axis\r\n                 */\r\n                yAxis?: number;\r\n            };\r\n            /**\r\n             * The mesh's root node name\r\n             */\r\n            rootNodeName: string;\r\n            /**\r\n             * Animation definitions for this model\r\n             */\r\n            visualResponses: {\r\n                [stateKey: string]: {\r\n                    /**\r\n                     * What property will be animated\r\n                     */\r\n                    componentProperty: \"xAxis\" | \"yAxis\" | \"button\" | \"state\";\r\n                    /**\r\n                     * What states influence this visual response\r\n                     */\r\n                    states: MotionControllerComponentStateType[];\r\n                    /**\r\n                     * Type of animation - movement or visibility\r\n                     */\r\n                    valueNodeProperty: \"transform\" | \"visibility\";\r\n                    /**\r\n                     * Base node name to move. Its position will be calculated according to the min and max nodes\r\n                     */\r\n                    valueNodeName?: string;\r\n                    /**\r\n                     * Minimum movement node\r\n                     */\r\n                    minNodeName?: string;\r\n                    /**\r\n                     * Max movement node\r\n                     */\r\n                    maxNodeName?: string;\r\n                };\r\n            };\r\n            /**\r\n             * If touch enabled, what is the name of node to display user feedback\r\n             */\r\n            touchPointNodeName?: string;\r\n        };\r\n    };\r\n    /**\r\n     * Is it xr standard mapping or not\r\n     */\r\n    gamepadMapping: \"\" | \"xr-standard\";\r\n    /**\r\n     * Base root node of this entire model\r\n     */\r\n    rootNodeName: string;\r\n    /**\r\n     * Defines the main button component id\r\n     */\r\n    selectComponentId: string;\r\n}\r\n\r\n/**\r\n * A definition for the layout map in the input profile\r\n */\r\nexport interface IMotionControllerLayoutMap {\r\n    /**\r\n     * Layouts with handedness type as a key\r\n     */\r\n    [handedness: string /* handedness */]: IMotionControllerLayout;\r\n}\r\n\r\n/**\r\n * The XR Input profile schema\r\n * Profiles can be found here:\r\n * https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles\r\n */\r\nexport interface IMotionControllerProfile {\r\n    /**\r\n     * fallback profiles for this profileId\r\n     */\r\n    fallbackProfileIds: string[];\r\n    /**\r\n     * The layout map, with handedness as key\r\n     */\r\n    layouts: IMotionControllerLayoutMap;\r\n    /**\r\n     * The id of this profile\r\n     * correlates to the profile(s) in the xrInput.profiles array\r\n     */\r\n    profileId: string;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller button animation\r\n * The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerButtonMeshMap {\r\n    /**\r\n     * the mesh that defines the pressed value mesh position.\r\n     * This is used to find the max-position of this button\r\n     */\r\n    pressedMesh: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the unpressed value mesh position.\r\n     * This is used to find the min (or initial) position of this button\r\n     */\r\n    unpressedMesh: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when value changes\r\n     */\r\n    valueMesh: AbstractMesh;\r\n}\r\n\r\n/**\r\n * A helper-interface for the 3 meshes needed for controller axis animation.\r\n * This will be expanded when touchpad animations are fully supported\r\n * The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh\r\n */\r\nexport interface IMotionControllerMeshMap {\r\n    /**\r\n     * the mesh that defines the maximum value mesh position.\r\n     */\r\n    maxMesh?: AbstractMesh;\r\n    /**\r\n     * the mesh that defines the minimum value mesh position.\r\n     */\r\n    minMesh?: AbstractMesh;\r\n    /**\r\n     * The mesh that will be changed when axis value changes\r\n     */\r\n    valueMesh?: AbstractMesh;\r\n}\r\n\r\n/**\r\n * The elements needed for change-detection of the gamepad objects in motion controllers\r\n */\r\nexport interface IMinimalMotionControllerObject {\r\n    /**\r\n     * Available axes of this controller\r\n     */\r\n    axes: number[];\r\n    /**\r\n     * An array of available buttons\r\n     */\r\n    buttons: Array<{\r\n        /**\r\n         * Value of the button/trigger\r\n         */\r\n        value: number;\r\n        /**\r\n         * If the button/trigger is currently touched\r\n         */\r\n        touched: boolean;\r\n        /**\r\n         * If the button/trigger is currently pressed\r\n         */\r\n        pressed: boolean;\r\n    }>;\r\n\r\n    /**\r\n     * EXPERIMENTAL haptic support.\r\n     */\r\n    hapticActuators?: Array<{\r\n        pulse: (value: number, duration: number) => Promise<boolean>;\r\n    }>;\r\n}\r\n\r\n/**\r\n * An Abstract Motion controller\r\n * This class receives an xrInput and a profile layout and uses those to initialize the components\r\n * Each component has an observable to check for changes in value and state\r\n */\r\nexport abstract class WebXRAbstractMotionController implements IDisposable {\r\n    private _initComponent = (id: string) => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        const componentDef = this.layout.components[id];\r\n        const type = componentDef.type;\r\n        const buttonIndex = componentDef.gamepadIndices.button;\r\n        // search for axes\r\n        const axes: number[] = [];\r\n        if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\r\n            axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\r\n        }\r\n\r\n        this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\r\n    };\r\n\r\n    private _modelReady: boolean = false;\r\n\r\n    /**\r\n     * A map of components (WebXRControllerComponent) in this motion controller\r\n     * Components have a ComponentType and can also have both button and axis definitions\r\n     */\r\n    public readonly components: {\r\n        [id: string]: WebXRControllerComponent;\r\n    } = {};\r\n\r\n    /**\r\n     * Disable the model's animation. Can be set at any time.\r\n     */\r\n    public disableAnimation: boolean = false;\r\n    /**\r\n     * Observers registered here will be triggered when the model of this controller is done loading\r\n     */\r\n    public onModelLoadedObservable: Observable<WebXRAbstractMotionController> = new Observable();\r\n    /**\r\n     * The profile id of this motion controller\r\n     */\r\n    public abstract profileId: string;\r\n    /**\r\n     * The root mesh of the model. It is null if the model was not yet initialized\r\n     */\r\n    public rootMesh: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * constructs a new abstract motion controller\r\n     * @param scene the scene to which the model of the controller will be added\r\n     * @param layout The profile layout to load\r\n     * @param gamepadObject The gamepad object correlating to this controller\r\n     * @param handedness handedness (left/right/none) of this controller\r\n     * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\r\n     * @param _controllerCache a cache holding controller models already loaded in this session\r\n     */\r\n    constructor(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected layout: IMotionControllerLayout,\r\n        /**\r\n         * The gamepad object correlating to this controller\r\n         */\r\n        public gamepadObject: IMinimalMotionControllerObject,\r\n        /**\r\n         * handedness (left/right/none) of this controller\r\n         */\r\n        public handedness: MotionControllerHandedness,\r\n        /**\r\n         * @internal\r\n         */\r\n        public _doNotLoadControllerMesh: boolean = false,\r\n        private _controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        // initialize the components\r\n        if (layout.components) {\r\n            Object.keys(layout.components).forEach(this._initComponent);\r\n        }\r\n        // Model is loaded in WebXRInput\r\n    }\r\n\r\n    /**\r\n     * Dispose this controller, the model mesh and all its components\r\n     */\r\n    public dispose(): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).dispose());\r\n        if (this.rootMesh) {\r\n            this.rootMesh.getChildren(undefined, true).forEach((node) => {\r\n                node.setEnabled(false);\r\n            });\r\n            this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all components of specific type\r\n     * @param type the type to search for\r\n     * @returns an array of components with this type\r\n     */\r\n    public getAllComponentsOfType(type: MotionControllerComponentType): WebXRControllerComponent[] {\r\n        return this.getComponentIds()\r\n            .map((id) => this.components[id])\r\n            .filter((component) => component.type === type);\r\n    }\r\n\r\n    /**\r\n     * get a component based an its component id as defined in layout.components\r\n     * @param id the id of the component\r\n     * @returns the component correlates to the id or undefined if not found\r\n     */\r\n    public getComponent(id: string): WebXRControllerComponent {\r\n        return this.components[id];\r\n    }\r\n\r\n    /**\r\n     * Get the list of components available in this motion controller\r\n     * @returns an array of strings correlating to available components\r\n     */\r\n    public getComponentIds(): string[] {\r\n        return Object.keys(this.components);\r\n    }\r\n\r\n    /**\r\n     * Get the first component of specific type\r\n     * @param type type of component to find\r\n     * @returns a controller component or null if not found\r\n     */\r\n    public getComponentOfType(type: MotionControllerComponentType): Nullable<WebXRControllerComponent> {\r\n        return this.getAllComponentsOfType(type)[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Get the main (Select) component of this controller as defined in the layout\r\n     * @returns the main component of this controller\r\n     */\r\n    public getMainComponent(): WebXRControllerComponent {\r\n        return this.getComponent(this.layout.selectComponentId);\r\n    }\r\n\r\n    /**\r\n     * Loads the model correlating to this controller\r\n     * When the mesh is loaded, the onModelLoadedObservable will be triggered\r\n     * @returns A promise fulfilled with the result of the model loading\r\n     */\r\n    public async loadModel(): Promise<boolean> {\r\n        const useGeneric = !this._getModelLoadingConstraints();\r\n        let loadingParams = this._getGenericFilenameAndPath();\r\n        // Checking if GLB loader is present\r\n        if (useGeneric) {\r\n            Logger.Warn(\"Falling back to generic models\");\r\n        } else {\r\n            loadingParams = this._getFilenameAndPath();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const meshesLoaded = (meshes: AbstractMesh[]) => {\r\n                if (useGeneric) {\r\n                    this._getGenericParentMesh(meshes);\r\n                } else {\r\n                    this._setRootMesh(meshes);\r\n                }\r\n                this._processLoadedModel(meshes);\r\n                this._modelReady = true;\r\n                this.onModelLoadedObservable.notifyObservers(this);\r\n                resolve(true);\r\n            };\r\n            if (this._controllerCache) {\r\n                // look for it in the cache\r\n                const found = this._controllerCache.filter((c) => {\r\n                    return c.filename === loadingParams.filename && c.path === loadingParams.path;\r\n                });\r\n                if (found[0]) {\r\n                    found[0].meshes.forEach((mesh) => mesh.setEnabled(true));\r\n                    meshesLoaded(found[0].meshes);\r\n                    return;\r\n                    // found, don't continue to load\r\n                }\r\n            }\r\n            SceneLoader.ImportMesh(\r\n                \"\",\r\n                loadingParams.path,\r\n                loadingParams.filename,\r\n                this.scene,\r\n                (meshes) => {\r\n                    if (this._controllerCache) {\r\n                        this._controllerCache.push({\r\n                            ...loadingParams,\r\n                            meshes,\r\n                        });\r\n                    }\r\n                    meshesLoaded(meshes);\r\n                },\r\n                null,\r\n                (_scene: Scene, message: string) => {\r\n                    Logger.Log(message);\r\n                    Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);\r\n                    reject(message);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update this model using the current XRFrame\r\n     * @param xrFrame the current xr frame to use and update the model\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame): void {\r\n        this.getComponentIds().forEach((id) => this.getComponent(id).update(this.gamepadObject));\r\n        this.updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Backwards compatibility due to a deeply-integrated typo\r\n     */\r\n    public get handness() {\r\n        return this.handedness;\r\n    }\r\n\r\n    /**\r\n     * Pulse (vibrate) this controller\r\n     * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\r\n     * Consecutive calls to this function will cancel the last pulse call\r\n     *\r\n     * @param value the strength of the pulse in 0.0...1.0 range\r\n     * @param duration Duration of the pulse in milliseconds\r\n     * @param hapticActuatorIndex optional index of actuator (will usually be 0)\r\n     * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\r\n     */\r\n    public pulse(value: number, duration: number, hapticActuatorIndex: number = 0): Promise<boolean> {\r\n        if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\r\n            return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\r\n        } else {\r\n            return Promise.resolve(false);\r\n        }\r\n    }\r\n\r\n    // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n    protected _getChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name === name, false)[0];\r\n    }\r\n\r\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n    protected _getImmediateChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined {\r\n        return <AbstractMesh | undefined>node.getChildren((n) => n.name == name, true)[0];\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axisMap\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @internal\r\n     */\r\n    protected _lerpTransform(axisMap: IMotionControllerMeshMap, axisValue: number, fixValueCoordinates?: boolean): void {\r\n        if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\r\n            return;\r\n        }\r\n\r\n        if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\r\n        Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\r\n        Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\r\n    }\r\n\r\n    /**\r\n     * Update the model itself with the current frame data\r\n     * @param xrFrame the frame to use for updating the model mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected updateModel(xrFrame: XRFrame): void {\r\n        if (!this._modelReady) {\r\n            return;\r\n        }\r\n        this._updateModel(xrFrame);\r\n    }\r\n\r\n    /**\r\n     * Get the filename and path for this controller's model\r\n     * @returns a map of filename and path\r\n     */\r\n    protected abstract _getFilenameAndPath(): { filename: string; path: string };\r\n    /**\r\n     * This function is called before the mesh is loaded. It checks for loading constraints.\r\n     * For example, this function can check if the GLB loader is available\r\n     * If this function returns false, the generic controller will be loaded instead\r\n     * @returns Is the client ready to load the mesh\r\n     */\r\n    protected abstract _getModelLoadingConstraints(): boolean;\r\n    /**\r\n     * This function will be called after the model was successfully loaded and can be used\r\n     * for mesh transformations before it is available for the user\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _processLoadedModel(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * Set the root mesh for this controller. Important for the WebXR controller class\r\n     * @param meshes the loaded meshes\r\n     */\r\n    protected abstract _setRootMesh(meshes: AbstractMesh[]): void;\r\n    /**\r\n     * A function executed each frame that updates the mesh (if needed)\r\n     * @param xrFrame the current xrFrame\r\n     */\r\n    protected abstract _updateModel(xrFrame: XRFrame): void;\r\n\r\n    private _getGenericFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    private _getGenericParentMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            if (!mesh.parent) {\r\n                mesh.isPickable = false;\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n}\r\n","import type { IMinimalMotionControllerObject, MotionControllerComponentType } from \"./webXRAbstractMotionController\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { IDisposable } from \"../../scene\";\r\n\r\n/**\r\n * X-Y values for axes in WebXR\r\n */\r\nexport interface IWebXRMotionControllerAxesValue {\r\n    /**\r\n     * The value of the x axis\r\n     */\r\n    x: number;\r\n    /**\r\n     * The value of the y-axis\r\n     */\r\n    y: number;\r\n}\r\n\r\n/**\r\n * changed / previous values for the values of this component\r\n */\r\nexport interface IWebXRMotionControllerComponentChangesValues<T> {\r\n    /**\r\n     * current (this frame) value\r\n     */\r\n    current: T;\r\n    /**\r\n     * previous (last change) value\r\n     */\r\n    previous: T;\r\n}\r\n\r\n/**\r\n * Represents changes in the component between current frame and last values recorded\r\n */\r\nexport interface IWebXRMotionControllerComponentChanges {\r\n    /**\r\n     * will be populated with previous and current values if axes changed\r\n     */\r\n    axes?: IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue>;\r\n    /**\r\n     * will be populated with previous and current values if pressed changed\r\n     */\r\n    pressed?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if touched changed\r\n     */\r\n    touched?: IWebXRMotionControllerComponentChangesValues<boolean>;\r\n    /**\r\n     * will be populated with previous and current values if value changed\r\n     */\r\n    value?: IWebXRMotionControllerComponentChangesValues<number>;\r\n}\r\n/**\r\n * This class represents a single component (for example button or thumbstick) of a motion controller\r\n */\r\nexport class WebXRControllerComponent implements IDisposable {\r\n    private _axes: IWebXRMotionControllerAxesValue = {\r\n        x: 0,\r\n        y: 0,\r\n    };\r\n    private _changes: IWebXRMotionControllerComponentChanges = {};\r\n    private _currentValue: number = 0;\r\n    private _hasChanges: boolean = false;\r\n    private _pressed: boolean = false;\r\n    private _touched: boolean = false;\r\n\r\n    /**\r\n     * button component type\r\n     */\r\n    public static BUTTON_TYPE: MotionControllerComponentType = \"button\";\r\n    /**\r\n     * squeeze component type\r\n     */\r\n    public static SQUEEZE_TYPE: MotionControllerComponentType = \"squeeze\";\r\n    /**\r\n     * Thumbstick component type\r\n     */\r\n    public static THUMBSTICK_TYPE: MotionControllerComponentType = \"thumbstick\";\r\n    /**\r\n     * Touchpad component type\r\n     */\r\n    public static TOUCHPAD_TYPE: MotionControllerComponentType = \"touchpad\";\r\n    /**\r\n     * trigger component type\r\n     */\r\n    public static TRIGGER_TYPE: MotionControllerComponentType = \"trigger\";\r\n\r\n    /**\r\n     * If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when\r\n     * the axes data changes\r\n     */\r\n    public onAxisValueChangedObservable: Observable<{ x: number; y: number }> = new Observable();\r\n    /**\r\n     * Observers registered here will be triggered when the state of a button changes\r\n     * State change is either pressed / touched / value\r\n     */\r\n    public onButtonStateChangedObservable: Observable<WebXRControllerComponent> = new Observable();\r\n\r\n    /**\r\n     * Creates a new component for a motion controller.\r\n     * It is created by the motion controller itself\r\n     *\r\n     * @param id the id of this component\r\n     * @param type the type of the component\r\n     * @param _buttonIndex index in the buttons array of the gamepad\r\n     * @param _axesIndices indices of the values in the axes array of the gamepad\r\n     */\r\n    constructor(\r\n        /**\r\n         * the id of this component\r\n         */\r\n        public id: string,\r\n        /**\r\n         * the type of the component\r\n         */\r\n        public type: MotionControllerComponentType,\r\n        private _buttonIndex: number = -1,\r\n        private _axesIndices: number[] = []\r\n    ) {}\r\n\r\n    /**\r\n     * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }\r\n     */\r\n    public get axes(): IWebXRMotionControllerAxesValue {\r\n        return this._axes;\r\n    }\r\n\r\n    /**\r\n     * Get the changes. Elements will be populated only if they changed with their previous and current value\r\n     */\r\n    public get changes(): IWebXRMotionControllerComponentChanges {\r\n        return this._changes;\r\n    }\r\n\r\n    /**\r\n     * Return whether or not the component changed the last frame\r\n     */\r\n    public get hasChanges(): boolean {\r\n        return this._hasChanges;\r\n    }\r\n\r\n    /**\r\n     * is the button currently pressed\r\n     */\r\n    public get pressed(): boolean {\r\n        return this._pressed;\r\n    }\r\n\r\n    /**\r\n     * is the button currently touched\r\n     */\r\n    public get touched(): boolean {\r\n        return this._touched;\r\n    }\r\n\r\n    /**\r\n     * Get the current value of this component\r\n     */\r\n    public get value(): number {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Dispose this component\r\n     */\r\n    public dispose(): void {\r\n        this.onAxisValueChangedObservable.clear();\r\n        this.onButtonStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Are there axes correlating to this component\r\n     * @returns true is axes data is available\r\n     */\r\n    public isAxes(): boolean {\r\n        return this._axesIndices.length !== 0;\r\n    }\r\n\r\n    /**\r\n     * Is this component a button (hence - pressable)\r\n     * @returns true if can be pressed\r\n     */\r\n    public isButton(): boolean {\r\n        return this._buttonIndex !== -1;\r\n    }\r\n\r\n    /**\r\n     * update this component using the gamepad object it is in. Called on every frame\r\n     * @param nativeController the native gamepad controller object\r\n     */\r\n    public update(nativeController: IMinimalMotionControllerObject) {\r\n        let buttonUpdated = false;\r\n        let axesUpdate = false;\r\n        this._hasChanges = false;\r\n        this._changes = {};\r\n\r\n        if (this.isButton()) {\r\n            const button = nativeController.buttons[this._buttonIndex];\r\n            // defensive, in case a profile was forced\r\n            if (!button) {\r\n                return;\r\n            }\r\n            if (this._currentValue !== button.value) {\r\n                this.changes.value = {\r\n                    current: button.value,\r\n                    previous: this._currentValue,\r\n                };\r\n                buttonUpdated = true;\r\n                this._currentValue = button.value;\r\n            }\r\n            if (this._touched !== button.touched) {\r\n                this.changes.touched = {\r\n                    current: button.touched,\r\n                    previous: this._touched,\r\n                };\r\n                buttonUpdated = true;\r\n                this._touched = button.touched;\r\n            }\r\n            if (this._pressed !== button.pressed) {\r\n                this.changes.pressed = {\r\n                    current: button.pressed,\r\n                    previous: this._pressed,\r\n                };\r\n                buttonUpdated = true;\r\n                this._pressed = button.pressed;\r\n            }\r\n        }\r\n\r\n        if (this.isAxes()) {\r\n            if (this._axes.x !== nativeController.axes[this._axesIndices[0]]) {\r\n                this.changes.axes = {\r\n                    current: {\r\n                        x: nativeController.axes[this._axesIndices[0]],\r\n                        y: this._axes.y,\r\n                    },\r\n                    previous: {\r\n                        x: this._axes.x,\r\n                        y: this._axes.y,\r\n                    },\r\n                };\r\n                this._axes.x = nativeController.axes[this._axesIndices[0]];\r\n                axesUpdate = true;\r\n            }\r\n\r\n            if (this._axes.y !== nativeController.axes[this._axesIndices[1]]) {\r\n                if (this.changes.axes) {\r\n                    this.changes.axes.current.y = nativeController.axes[this._axesIndices[1]];\r\n                } else {\r\n                    this.changes.axes = {\r\n                        current: {\r\n                            x: this._axes.x,\r\n                            y: nativeController.axes[this._axesIndices[1]],\r\n                        },\r\n                        previous: {\r\n                            x: this._axes.x,\r\n                            y: this._axes.y,\r\n                        },\r\n                    };\r\n                }\r\n                this._axes.y = nativeController.axes[this._axesIndices[1]];\r\n                axesUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (buttonUpdated) {\r\n            this._hasChanges = true;\r\n            this.onButtonStateChangedObservable.notifyObservers(this);\r\n        }\r\n        if (axesUpdate) {\r\n            this._hasChanges = true;\r\n            this.onAxisValueChangedObservable.notifyObservers(this._axes);\r\n        }\r\n    }\r\n}\r\n","import type { IMinimalMotionControllerObject, MotionControllerHandedness, IMotionControllerLayoutMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\n\r\n/**\r\n * A generic trigger-only motion controller for WebXR\r\n */\r\nexport class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {\r\n    /**\r\n     * Static version of the profile id of this controller\r\n     */\r\n    public static ProfileId = \"generic-trigger\";\r\n\r\n    public profileId = WebXRGenericTriggerMotionController.ProfileId;\r\n\r\n    constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness) {\r\n        super(scene, GenericTriggerLayout[handedness], gamepadObject, handedness);\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: \"generic.babylon\",\r\n            path: \"https://controllers.babylonjs.com/generic/\",\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processLoadedModel(meshes: AbstractMesh[]): void {\r\n        // nothing to do\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\r\n\r\n        meshes.forEach((mesh) => {\r\n            mesh.isPickable = false;\r\n            if (!mesh.parent) {\r\n                mesh.setParent(this.rootMesh);\r\n            }\r\n        });\r\n\r\n        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\r\n    }\r\n\r\n    protected _updateModel(): void {\r\n        // no-op\r\n    }\r\n}\r\n\r\n// https://github.com/immersive-web/webxr-input-profiles/blob/master/packages/registry/profiles/generic/generic-trigger-touchpad-thumbstick.json\r\nconst GenericTriggerLayout: IMotionControllerLayoutMap = {\r\n    left: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-left\",\r\n        assetPath: \"left.glb\",\r\n    },\r\n    right: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-right\",\r\n        assetPath: \"right.glb\",\r\n    },\r\n    none: {\r\n        selectComponentId: \"xr-standard-trigger\",\r\n        components: {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            \"xr-standard-trigger\": {\r\n                type: \"trigger\",\r\n                gamepadIndices: {\r\n                    button: 0,\r\n                },\r\n                rootNodeName: \"xr_standard_trigger\",\r\n                visualResponses: {},\r\n            },\r\n        },\r\n        gamepadMapping: \"xr-standard\",\r\n        rootNodeName: \"generic-trigger-none\",\r\n        assetPath: \"none.glb\",\r\n    },\r\n};\r\n","import type { WebXRAbstractMotionController, IMotionControllerProfile } from \"./webXRAbstractMotionController\";\r\nimport { WebXRGenericTriggerMotionController } from \"./webXRGenericMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { WebXRProfiledMotionController } from \"./webXRProfiledMotionController\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\n\r\n/**\r\n * A construction function type to create a new controller based on an xrInput object\r\n */\r\nexport type MotionControllerConstructor = (xrInput: XRInputSource, scene: Scene) => WebXRAbstractMotionController;\r\n\r\n/**\r\n * The MotionController Manager manages all registered motion controllers and loads the right one when needed.\r\n *\r\n * When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets\r\n * it should be replaced with auto-loaded controllers.\r\n *\r\n * When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes\r\n */\r\n\r\nconst controllerCache: Array<{\r\n    filename: string;\r\n    path: string;\r\n    meshes: AbstractMesh[];\r\n}> = [];\r\n\r\n/**\r\n * Motion controller manager is managing the different webxr profiles and makes sure the right\r\n * controller is being loaded.\r\n */\r\nexport class WebXRMotionControllerManager {\r\n    private static _AvailableControllers: { [type: string]: MotionControllerConstructor } = {};\r\n    private static _Fallbacks: { [profileId: string]: string[] } = {};\r\n    // cache for loading\r\n    private static _ProfileLoadingPromises: { [profileName: string]: Promise<IMotionControllerProfile> } = {};\r\n    private static _ProfilesList: Nullable<Promise<{ [profile: string]: string }>>;\r\n\r\n    /**\r\n     * The base URL of the online controller repository. Can be changed at any time.\r\n     */\r\n    public static BaseRepositoryUrl = \"https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist\";\r\n    /**\r\n     * Which repository gets priority - local or online\r\n     */\r\n    public static PrioritizeOnlineRepository: boolean = true;\r\n    /**\r\n     * Use the online repository, or use only locally-defined controllers\r\n     */\r\n    public static UseOnlineRepository: boolean = true;\r\n\r\n    /**\r\n     * Disable the controller cache and load the models each time a new WebXRProfileMotionController is loaded.\r\n     * Defaults to true.\r\n     */\r\n    public static DisableControllerCache: boolean = true;\r\n\r\n    /**\r\n     * Clear the cache used for profile loading and reload when requested again\r\n     */\r\n    public static ClearProfilesCache() {\r\n        this._ProfilesList = null;\r\n        this._ProfileLoadingPromises = {};\r\n    }\r\n\r\n    /**\r\n     * Register the default fallbacks.\r\n     * This function is called automatically when this file is imported.\r\n     */\r\n    public static DefaultFallbacks() {\r\n        this.RegisterFallbacksForProfileId(\"google-daydream\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive-focus\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"htc-vive\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"magicleap-one\", [\"generic-trigger-squeeze-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"windows-mixed-reality\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"microsoft-mixed-reality\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-go\", [\"generic-trigger-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch-v2\", [\"oculus-touch\", \"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"oculus-touch\", [\"generic-trigger-squeeze-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-gearvr\", [\"windows-mixed-reality\", \"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"samsung-odyssey\", [\"generic-touchpad\"]);\r\n        this.RegisterFallbacksForProfileId(\"valve-index\", [\"generic-trigger-squeeze-touchpad-thumbstick\"]);\r\n        this.RegisterFallbacksForProfileId(\"generic-hand-select\", [\"generic-trigger\"]);\r\n    }\r\n\r\n    /**\r\n     * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.\r\n     * @param profileId the profile to which a fallback needs to be found\r\n     * @returns an array with corresponding fallback profiles\r\n     */\r\n    public static FindFallbackWithProfileId(profileId: string): string[] {\r\n        const returnArray = this._Fallbacks[profileId] || [];\r\n\r\n        returnArray.unshift(profileId);\r\n        return returnArray;\r\n    }\r\n\r\n    /**\r\n     * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.\r\n     * The order of search:\r\n     *\r\n     * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller\r\n     * 2) (If not found) search in the gamepad id and try using it (legacy versions only)\r\n     * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)\r\n     * 4) return the generic trigger controller if none were found\r\n     *\r\n     * @param xrInput the xrInput to which a new controller is initialized\r\n     * @param scene the scene to which the model will be added\r\n     * @param forceProfile force a certain profile for this controller\r\n     * @returns A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found\r\n     */\r\n    public static GetMotionControllerWithXRInput(xrInput: XRInputSource, scene: Scene, forceProfile?: string): Promise<WebXRAbstractMotionController> {\r\n        const profileArray: string[] = [];\r\n        if (forceProfile) {\r\n            profileArray.push(forceProfile);\r\n        }\r\n        profileArray.push(...(xrInput.profiles || []));\r\n\r\n        // emulator support\r\n        if (profileArray.length && !profileArray[0]) {\r\n            // remove the first \"undefined\" that the emulator is adding\r\n            profileArray.pop();\r\n        }\r\n\r\n        // legacy support - try using the gamepad id\r\n        if (xrInput.gamepad && xrInput.gamepad.id) {\r\n            switch (xrInput.gamepad.id) {\r\n                case xrInput.gamepad.id.match(/oculus touch/gi) ? xrInput.gamepad.id : undefined:\r\n                    // oculus in gamepad id\r\n                    profileArray.push(\"oculus-touch-v2\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // make sure microsoft/windows mixed reality works correctly\r\n        const windowsMRIdx = profileArray.indexOf(\"windows-mixed-reality\");\r\n        if (windowsMRIdx !== -1) {\r\n            profileArray.splice(windowsMRIdx, 0, \"microsoft-mixed-reality\");\r\n        }\r\n\r\n        if (!profileArray.length) {\r\n            profileArray.push(\"generic-trigger\");\r\n        }\r\n\r\n        if (this.UseOnlineRepository) {\r\n            const firstFunction = this.PrioritizeOnlineRepository ? this._LoadProfileFromRepository : this._LoadProfilesFromAvailableControllers;\r\n            const secondFunction = this.PrioritizeOnlineRepository ? this._LoadProfilesFromAvailableControllers : this._LoadProfileFromRepository;\r\n\r\n            return firstFunction.call(this, profileArray, xrInput, scene).catch(() => {\r\n                return secondFunction.call(this, profileArray, xrInput, scene);\r\n            });\r\n        } else {\r\n            // use only available functions\r\n            return this._LoadProfilesFromAvailableControllers(profileArray, xrInput, scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a new controller based on its profile. This function will be called by the controller classes themselves.\r\n     *\r\n     * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.\r\n     *\r\n     * @param type the profile type to register\r\n     * @param constructFunction the function to be called when loading this profile\r\n     */\r\n    public static RegisterController(type: string, constructFunction: MotionControllerConstructor) {\r\n        this._AvailableControllers[type] = constructFunction;\r\n    }\r\n\r\n    /**\r\n     * Register a fallback to a specific profile.\r\n     * @param profileId the profileId that will receive the fallbacks\r\n     * @param fallbacks A list of fallback profiles\r\n     */\r\n    public static RegisterFallbacksForProfileId(profileId: string, fallbacks: string[]): void {\r\n        if (this._Fallbacks[profileId]) {\r\n            this._Fallbacks[profileId].push(...fallbacks);\r\n        } else {\r\n            this._Fallbacks[profileId] = fallbacks;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will update the list of profiles available in the repository\r\n     * @returns a promise that resolves to a map of profiles available online\r\n     */\r\n    public static UpdateProfilesList() {\r\n        this._ProfilesList = Tools.LoadFileAsync(this.BaseRepositoryUrl + \"/profiles/profilesList.json\", false).then((data) => {\r\n            return JSON.parse(data.toString());\r\n        });\r\n        return this._ProfilesList;\r\n    }\r\n\r\n    /**\r\n     * Clear the controller's cache (usually happens at the end of a session)\r\n     */\r\n    public static ClearControllerCache() {\r\n        controllerCache.forEach((cacheItem) => {\r\n            cacheItem.meshes.forEach((mesh) => {\r\n                mesh.dispose(false, true);\r\n            });\r\n        });\r\n        controllerCache.length = 0;\r\n    }\r\n\r\n    private static _LoadProfileFromRepository(profileArray: string[], xrInput: XRInputSource, scene: Scene): Promise<WebXRAbstractMotionController> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                if (!this._ProfilesList) {\r\n                    return this.UpdateProfilesList();\r\n                } else {\r\n                    return this._ProfilesList;\r\n                }\r\n            })\r\n            .then((profilesList: { [profile: string]: string }) => {\r\n                // load the right profile\r\n                for (let i = 0; i < profileArray.length; ++i) {\r\n                    // defensive\r\n                    if (!profileArray[i]) {\r\n                        continue;\r\n                    }\r\n                    if (profilesList[profileArray[i]]) {\r\n                        return profileArray[i];\r\n                    }\r\n                }\r\n\r\n                throw new Error(`neither controller ${profileArray[0]} nor all fallbacks were found in the repository,`);\r\n            })\r\n            .then((profileToLoad: string) => {\r\n                // load the profile\r\n                if (!this._ProfileLoadingPromises[profileToLoad]) {\r\n                    this._ProfileLoadingPromises[profileToLoad] = Tools.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${profileToLoad}/profile.json`, false).then(\r\n                        (data) => <IMotionControllerProfile>JSON.parse(data as string)\r\n                    );\r\n                }\r\n                return this._ProfileLoadingPromises[profileToLoad];\r\n            })\r\n            .then((profile: IMotionControllerProfile) => {\r\n                return new WebXRProfiledMotionController(scene, xrInput, profile, this.BaseRepositoryUrl, this.DisableControllerCache ? undefined : controllerCache);\r\n            });\r\n    }\r\n\r\n    private static _LoadProfilesFromAvailableControllers(profileArray: string[], xrInput: XRInputSource, scene: Scene) {\r\n        // check fallbacks\r\n        for (let i = 0; i < profileArray.length; ++i) {\r\n            // defensive\r\n            if (!profileArray[i]) {\r\n                continue;\r\n            }\r\n            const fallbacks = this.FindFallbackWithProfileId(profileArray[i]);\r\n            for (let j = 0; j < fallbacks.length; ++j) {\r\n                const constructionFunction = this._AvailableControllers[fallbacks[j]];\r\n                if (constructionFunction) {\r\n                    return Promise.resolve(constructionFunction(xrInput, scene));\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error(`no controller requested was found in the available controllers list`);\r\n    }\r\n}\r\n\r\n// register the generic profile(s) here so we will at least have them\r\nWebXRMotionControllerManager.RegisterController(WebXRGenericTriggerMotionController.ProfileId, (xrInput: XRInputSource, scene: Scene) => {\r\n    return new WebXRGenericTriggerMotionController(scene, <any>xrInput.gamepad, xrInput.handedness);\r\n});\r\n\r\n// register fallbacks\r\nWebXRMotionControllerManager.DefaultFallbacks();\r\n","import type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { IMotionControllerProfile, IMotionControllerMeshMap } from \"./webXRAbstractMotionController\";\r\nimport { WebXRAbstractMotionController } from \"./webXRAbstractMotionController\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Axis, Space } from \"../../Maths/math.axis\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { WebXRControllerComponent } from \"./webXRControllerComponent\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\n/**\r\n * A profiled motion controller has its profile loaded from an online repository.\r\n * The class is responsible of loading the model, mapping the keys and enabling model-animations\r\n */\r\nexport class WebXRProfiledMotionController extends WebXRAbstractMotionController {\r\n    private _buttonMeshMapping: {\r\n        [buttonName: string]: {\r\n            mainMesh?: AbstractMesh;\r\n            states: {\r\n                [state: string]: IMotionControllerMeshMap;\r\n            };\r\n        };\r\n    } = {};\r\n    private _touchDots: { [visKey: string]: AbstractMesh } = {};\r\n\r\n    /**\r\n     * The profile ID of this controller. Will be populated when the controller initializes.\r\n     */\r\n    public profileId: string;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        xrInput: XRInputSource,\r\n        _profile: IMotionControllerProfile,\r\n        private _repositoryUrl: string,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        private controllerCache?: Array<{\r\n            filename: string;\r\n            path: string;\r\n            meshes: AbstractMesh[];\r\n        }>\r\n    ) {\r\n        super(scene, _profile.layouts[xrInput.handedness || \"none\"], xrInput.gamepad as any, xrInput.handedness, undefined, controllerCache);\r\n        this.profileId = _profile.profileId;\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        if (!this.controllerCache) {\r\n            Object.keys(this._touchDots).forEach((visResKey) => {\r\n                this._touchDots[visResKey].dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string } {\r\n        return {\r\n            filename: this.layout.assetPath,\r\n            path: `${this._repositoryUrl}/profiles/${this.profileId}/`,\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn(\"glTF / glb loader was not registered, using generic controller instead\");\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        this.getComponentIds().forEach((type) => {\r\n            const componentInLayout = this.layout.components[type];\r\n            this._buttonMeshMapping[type] = {\r\n                mainMesh: this._getChildByName(this.rootMesh!, componentInLayout.rootNodeName),\r\n                states: {},\r\n            };\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, visResponse.valueNodeName!),\r\n                        minMesh: this._getChildByName(this.rootMesh!, visResponse.minNodeName!),\r\n                        maxMesh: this._getChildByName(this.rootMesh!, visResponse.maxNodeName!),\r\n                    };\r\n                } else {\r\n                    // visibility, usually for touchpads\r\n                    const nameOfMesh =\r\n                        componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName\r\n                            ? componentInLayout.touchPointNodeName\r\n                            : visResponse.valueNodeName!;\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, nameOfMesh),\r\n                    };\r\n                    if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {\r\n                        const dot = CreateSphere(\r\n                            visualResponseKey + \"dot\",\r\n                            {\r\n                                diameter: 0.0015,\r\n                                segments: 8,\r\n                            },\r\n                            this.scene\r\n                        );\r\n                        dot.material = new StandardMaterial(visualResponseKey + \"mat\", this.scene);\r\n                        (<StandardMaterial>dot.material).diffuseColor = Color3.Red();\r\n                        dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh || null;\r\n                        dot.isVisible = false;\r\n                        this._touchDots[visualResponseKey] = dot;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \"-\" + this.handedness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n        if (!this.scene.useRightHandedSystem) {\r\n            this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);\r\n        }\r\n    }\r\n\r\n    protected _updateModel(_xrFrame: XRFrame): void {\r\n        if (this.disableAnimation) {\r\n            return;\r\n        }\r\n        this.getComponentIds().forEach((id) => {\r\n            const component = this.getComponent(id);\r\n            if (!component.hasChanges) {\r\n                return;\r\n            }\r\n            const meshes = this._buttonMeshMapping[id];\r\n            const componentInLayout = this.layout.components[id];\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                let value = component.value;\r\n                if (visResponse.componentProperty === \"xAxis\") {\r\n                    value = component.axes.x;\r\n                } else if (visResponse.componentProperty === \"yAxis\") {\r\n                    value = component.axes.y;\r\n                }\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== \"button\");\r\n                } else {\r\n                    // visibility\r\n                    const valueMesh = meshes.states[visualResponseKey].valueMesh;\r\n                    if (valueMesh) {\r\n                        valueMesh.isVisible = component.touched || component.pressed;\r\n                    }\r\n                    if (this._touchDots[visualResponseKey]) {\r\n                        this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * This will be triggered after the first XR Frame initialized the camera,\r\n     * including the right number of views and their rendering parameters\r\n     */\r\n    public onXRCameraInitializedObservable = new Observable<WebXRCamera>();\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(name: string, scene: Scene, private _xrSessionManager: WebXRSessionManager) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n        this._deferOnly = true;\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                if (this.onXRCameraInitializedObservable.hasObservers()) {\r\n                    this.onXRCameraInitializedObservable.notifyObservers(this);\r\n                    this.onXRCameraInitializedObservable.clear();\r\n                }\r\n\r\n                if (this._deferredUpdated) {\r\n                    this.position.copyFrom(this._deferredPositionUpdate);\r\n                    this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                }\r\n\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Set the target for the camera to look at.\r\n     * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras\r\n     * @param target the target to set the camera to look at\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        // only rotate around the y axis!\r\n        const tmpVector = TmpVectors.Vector3[1];\r\n        target.subtractToRef(this.position, tmpVector);\r\n        tmpVector.y = 0;\r\n        tmpVector.normalize();\r\n        const yRotation = Math.atan2(tmpVector.x, tmpVector.z);\r\n        this.rotationQuaternion.toEulerAnglesToRef(tmpVector);\r\n        Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        // check min/max Z and update if not the same as in cache\r\n        if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.maxZ || 10000,\r\n                depthNear: this.minZ,\r\n            };\r\n\r\n            this._xrSessionManager.updateRenderState(xrRenderState);\r\n            this._cache.minZ = this.minZ;\r\n            this._cache.maxZ = this.maxZ;\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n\r\n            // Replicate parent rig camera behavior\r\n            currentRig.layerMask = this.layerMask;\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x,\r\n                    y: this._referencedPosition.y,\r\n                    z: this._referencedPosition.z,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRState } from \"./webXRTypes\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { UniversalCamera } from \"../Cameras/universalCamera\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Options for setting up XR spectator camera.\r\n */\r\nexport interface WebXRSpectatorModeOption {\r\n    /**\r\n     * Expected refresh rate (frames per sec) for a spectator camera.\r\n     */\r\n    fps?: number;\r\n    /**\r\n     * The index of rigCameras array in a WebXR camera.\r\n     */\r\n    preferredCameraIndex?: number;\r\n}\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _attachedToElement: boolean = false;\r\n    private _spectatorCamera: Nullable<UniversalCamera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n    private _spectatorMode = false;\r\n    private _lastTimestamp = 0;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param _scene The scene the helper should be created in\r\n     */\r\n    private constructor(private _scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(_scene);\r\n        this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        _scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        const helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.exitXRAsync();\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        this._spectatorCamera?.dispose();\r\n        if (this._nonVRCamera) {\r\n            this._scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public async enterXRAsync(\r\n        sessionMode: XRSessionMode,\r\n        referenceSpaceType: XRReferenceSpaceType,\r\n        renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(),\r\n        sessionCreationOptions: XRSessionInit = {}\r\n    ): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        try {\r\n            await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\r\n            await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n            const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.camera.maxZ || 10000,\r\n                depthNear: this.camera.minZ,\r\n            };\r\n\r\n            // The layers feature will have already initialized the xr session's layers on session init.\r\n            if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\r\n                xrRenderState.baseLayer = baseLayer;\r\n            }\r\n\r\n            this.sessionManager.updateRenderState(xrRenderState);\r\n            // run the render loop\r\n            this.sessionManager.runXRRenderLoop();\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this._scene.autoClear;\r\n            this._nonVRCamera = this._scene.activeCamera;\r\n            this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\r\n            this._nonVRCamera?.detachControl();\r\n\r\n            this._scene.activeCamera = this.camera;\r\n            // do not compensate when AR session is used\r\n            if (sessionMode !== \"immersive-ar\") {\r\n                this._nonXRToXRCamera();\r\n            } else {\r\n                // Kept here, TODO - check if needed\r\n                this._scene.autoClear = false;\r\n                this.camera.compensateOnFirstFrame = false;\r\n                // reset the camera's position to the origin\r\n                this.camera.position.set(0, 0, 0);\r\n                this.camera.rotationQuaternion.set(0, 0, 0, 1);\r\n                this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n            }\r\n\r\n            this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\r\n                if (this.state !== WebXRState.EXITING_XR) {\r\n                    this._setState(WebXRState.EXITING_XR);\r\n                }\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this._scene.autoClear = this._originalSceneAutoClear;\r\n                this._scene.activeCamera = this._nonVRCamera;\r\n                if (this._attachedToElement && this._nonVRCamera) {\r\n                    this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\r\n                }\r\n                if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                    if ((<any>this._nonVRCamera).setPosition) {\r\n                        (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                    } else {\r\n                        this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                    }\r\n                }\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n\r\n            // Wait until the first frame arrives before setting state to in xr\r\n            this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                this._setState(WebXRState.IN_XR);\r\n            });\r\n            return this.sessionManager;\r\n        } catch (e) {\r\n            console.log(e);\r\n            console.log(e.message);\r\n            this._setState(WebXRState.NOT_IN_XR);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enable spectator mode for desktop VR experiences.\r\n     * When spectator mode is enabled a camera will be attached to the desktop canvas and will\r\n     * display the first rig camera's view on the desktop canvas.\r\n     * Please note that this will degrade performance, as it requires another camera render.\r\n     * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\r\n     * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\r\n     */\r\n    public enableSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        if (!this._spectatorMode) {\r\n            this._spectatorMode = true;\r\n            this._switchSpectatorMode(options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable spectator mode for desktop VR experiences.\r\n     */\r\n    public disableSpecatatorMode(): void {\r\n        if (this._spectatorMode) {\r\n            this._spectatorMode = false;\r\n            this._switchSpectatorMode();\r\n        }\r\n    }\r\n\r\n    private _switchSpectatorMode(options?: WebXRSpectatorModeOption): void {\r\n        const fps = options?.fps ? options.fps : 1000.0;\r\n        const refreshRate = (1.0 / fps) * 1000.0;\r\n        const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\r\n\r\n        const updateSpectatorCamera = () => {\r\n            if (this._spectatorCamera) {\r\n                const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\r\n                if (delta >= refreshRate) {\r\n                    this._lastTimestamp = this.sessionManager.currentTimestamp;\r\n                    this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\r\n                    this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\r\n                }\r\n            }\r\n        };\r\n        if (this._spectatorMode) {\r\n            if (cameraIndex >= this.camera.rigCameras.length) {\r\n                throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\r\n            }\r\n            const onStateChanged = () => {\r\n                if (this.state === WebXRState.IN_XR) {\r\n                    this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\r\n                    this._spectatorCamera.rotationQuaternion = new Quaternion();\r\n                    this._scene.activeCameras = [this.camera, this._spectatorCamera];\r\n                    this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\r\n                    this._scene.onAfterRenderCameraObservable.add((camera) => {\r\n                        if (camera === this.camera) {\r\n                            // reset the dimensions object for correct resizing\r\n                            this._scene.getEngine().framebufferDimensionsObject = null;\r\n                        }\r\n                    });\r\n                } else if (this.state === WebXRState.EXITING_XR) {\r\n                    this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n                    this._scene.activeCameras = null;\r\n                }\r\n            };\r\n            this.onStateChangedObservable.add(onStateChanged);\r\n            onStateChanged();\r\n        } else {\r\n            this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\r\n            this._scene.activeCameras = [this.camera];\r\n        }\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n","import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n    /**\r\n     * The name of the depth sensing feature\r\n     */\r\n    public static readonly DEPTH_SENSING = \"xr-depth-sensing\";\r\n    /**\r\n     * The name of the WebXR Space Warp feature\r\n     */\r\n    public static readonly SPACE_WARP = \"xr-space-warp\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IWebXRControllerOptions } from \"./webXRInputSource\";\r\nimport { WebXRInputSource } from \"./webXRInputSource\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\n\r\n/**\r\n * The schema for initialization options of the XR Input class\r\n */\r\nexport interface IWebXRInputOptions {\r\n    /**\r\n     * If set to true no model will be automatically loaded\r\n     */\r\n    doNotLoadControllerMeshes?: boolean;\r\n\r\n    /**\r\n     * If set, this profile will be used for all controllers loaded (for example \"microsoft-mixed-reality\")\r\n     * If not found, the xr input profile data will be used.\r\n     * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/\r\n     */\r\n    forceInputProfile?: string;\r\n\r\n    /**\r\n     * Do not send a request to the controller repository to load the profile.\r\n     *\r\n     * Instead, use the controllers available in babylon itself.\r\n     */\r\n    disableOnlineControllerRepository?: boolean;\r\n\r\n    /**\r\n     * A custom URL for the controllers repository\r\n     */\r\n    customControllersRepositoryURL?: string;\r\n\r\n    /**\r\n     * Should the controller model's components not move according to the user input\r\n     */\r\n    disableControllerAnimation?: boolean;\r\n\r\n    /**\r\n     * Optional options to pass to the controller. Will be overridden by the Input options where applicable\r\n     */\r\n    controllerOptions?: IWebXRControllerOptions;\r\n}\r\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\r\nexport class WebXRInput implements IDisposable {\r\n    /**\r\n     * XR controllers being tracked\r\n     */\r\n    public controllers: Array<WebXRInputSource> = [];\r\n    private _frameObserver: Nullable<Observer<any>>;\r\n    private _sessionEndedObserver: Nullable<Observer<any>>;\r\n    private _sessionInitObserver: Nullable<Observer<any>>;\r\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\r\n    public onControllerAddedObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\r\n    public onControllerRemovedObservable = new Observable<WebXRInputSource>();\r\n\r\n    /**\r\n     * Initializes the WebXRInput\r\n     * @param xrSessionManager the xr session manager for this session\r\n     * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n     * @param _options = initialization options for this xr input\r\n     */\r\n    public constructor(\r\n        /**\r\n         * the xr session manager for this session\r\n         */\r\n        public xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * the WebXR camera for this session. Mainly used for teleportation\r\n         */\r\n        public xrCamera: WebXRCamera,\r\n        private readonly _options: IWebXRInputOptions = {}\r\n    ) {\r\n        // Remove controllers when exiting XR\r\n        this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._addAndRemoveControllers(\r\n                [],\r\n                this.controllers.map((c) => {\r\n                    return c.inputSource;\r\n                })\r\n            );\r\n        });\r\n\r\n        this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {\r\n            session.addEventListener(\"inputsourceschange\", this._onInputSourcesChange);\r\n        });\r\n\r\n        this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {\r\n            // Update controller pose info\r\n            this.controllers.forEach((controller) => {\r\n                controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace, this.xrCamera);\r\n            });\r\n        });\r\n\r\n        if (this._options.customControllersRepositoryURL) {\r\n            WebXRMotionControllerManager.BaseRepositoryUrl = this._options.customControllersRepositoryURL;\r\n        }\r\n\r\n        WebXRMotionControllerManager.UseOnlineRepository = !this._options.disableOnlineControllerRepository;\r\n        if (WebXRMotionControllerManager.UseOnlineRepository) {\r\n            // pre-load the profiles list to load the controllers quicker afterwards\r\n            try {\r\n                WebXRMotionControllerManager.UpdateProfilesList().catch(() => {\r\n                    WebXRMotionControllerManager.UseOnlineRepository = false;\r\n                });\r\n            } catch (e) {\r\n                WebXRMotionControllerManager.UseOnlineRepository = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onInputSourcesChange = (event: XRInputSourceChangeEvent) => {\r\n        this._addAndRemoveControllers(event.added, event.removed);\r\n    };\r\n\r\n    private _addAndRemoveControllers(addInputs: readonly XRInputSource[], removeInputs: readonly XRInputSource[]) {\r\n        // Add controllers if they don't already exist\r\n        const sources = this.controllers.map((c) => {\r\n            return c.inputSource;\r\n        });\r\n        for (const input of addInputs) {\r\n            if (sources.indexOf(input) === -1) {\r\n                const controller = new WebXRInputSource(this.xrSessionManager.scene, input, {\r\n                    ...(this._options.controllerOptions || {}),\r\n                    forceControllerProfile: this._options.forceInputProfile,\r\n                    doNotLoadControllerMesh: this._options.doNotLoadControllerMeshes,\r\n                    disableMotionControllerAnimation: this._options.disableControllerAnimation,\r\n                });\r\n                this.controllers.push(controller);\r\n                this.onControllerAddedObservable.notifyObservers(controller);\r\n            }\r\n        }\r\n\r\n        // Remove and dispose of controllers to be disposed\r\n        const keepControllers: Array<WebXRInputSource> = [];\r\n        const removedControllers: Array<WebXRInputSource> = [];\r\n        this.controllers.forEach((c) => {\r\n            if (removeInputs.indexOf(c.inputSource) === -1) {\r\n                keepControllers.push(c);\r\n            } else {\r\n                removedControllers.push(c);\r\n            }\r\n        });\r\n        this.controllers = keepControllers;\r\n        removedControllers.forEach((c) => {\r\n            this.onControllerRemovedObservable.notifyObservers(c);\r\n            c.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this.controllers.forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\r\n        this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\r\n        this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\r\n        this.onControllerAddedObservable.clear();\r\n        this.onControllerRemovedObservable.clear();\r\n\r\n        // clear the controller cache\r\n        WebXRMotionControllerManager.ClearControllerCache();\r\n    }\r\n}\r\n","import { Observable } from \"../Misc/observable\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { WebXRAbstractMotionController } from \"./motionController/webXRAbstractMotionController\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRCamera } from \"./webXRCamera\";\r\n\r\nlet idCount = 0;\r\n\r\n/**\r\n * Configuration options for the WebXR controller creation\r\n */\r\nexport interface IWebXRControllerOptions {\r\n    /**\r\n     * Should the controller mesh be animated when a user interacts with it\r\n     * The pressed buttons / thumbstick and touchpad animations will be disabled\r\n     */\r\n    disableMotionControllerAnimation?: boolean;\r\n    /**\r\n     * Do not load the controller mesh, in case a different mesh needs to be loaded.\r\n     */\r\n    doNotLoadControllerMesh?: boolean;\r\n    /**\r\n     * Force a specific controller type for this controller.\r\n     * This can be used when creating your own profile or when testing different controllers\r\n     */\r\n    forceControllerProfile?: string;\r\n    /**\r\n     * Defines a rendering group ID for meshes that will be loaded.\r\n     * This is for the default controllers only.\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * Represents an XR controller\r\n */\r\nexport class WebXRInputSource {\r\n    private _tmpVector = new Vector3();\r\n    private _uniqueId: string;\r\n    private _disposed = false;\r\n\r\n    /**\r\n     * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if that's the case only the pointer from the head will be available\r\n     */\r\n    public grip?: AbstractMesh;\r\n    /**\r\n     * If available, this is the gamepad object related to this controller.\r\n     * Using this object it is possible to get click events and trackpad changes of the\r\n     * webxr controller that is currently being used.\r\n     */\r\n    public motionController?: WebXRAbstractMotionController;\r\n    /**\r\n     * Event that fires when the controller is removed/disposed.\r\n     * The object provided as event data is this controller, after associated assets were disposed.\r\n     * uniqueId is still available.\r\n     */\r\n    public onDisposeObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Will be triggered when the mesh associated with the motion controller is done loading.\r\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\r\n     * A shortened version of controller -> motion controller -> on mesh loaded.\r\n     */\r\n    public onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n    /**\r\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\r\n     */\r\n    public onMotionControllerInitObservable = new Observable<WebXRAbstractMotionController>();\r\n    /**\r\n     * Pointer which can be used to select objects or attach a visible laser to\r\n     */\r\n    public pointer: AbstractMesh;\r\n\r\n    /**\r\n     * The last XRPose the was calculated on the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRPose?: XRPose;\r\n\r\n    /**\r\n     * Creates the input source object\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport\r\n     * @param _scene the scene which the controller should be associated to\r\n     * @param inputSource the underlying input source for the controller\r\n     * @param _options options for this controller creation\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        /** The underlying input source for the controller  */\r\n        public inputSource: XRInputSource,\r\n        private _options: IWebXRControllerOptions = {}\r\n    ) {\r\n        this._uniqueId = `controller-${idCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;\r\n\r\n        this.pointer = new AbstractMesh(`${this._uniqueId}-pointer`, _scene);\r\n        this.pointer.rotationQuaternion = new Quaternion();\r\n\r\n        if (this.inputSource.gripSpace) {\r\n            this.grip = new AbstractMesh(`${this._uniqueId}-grip`, this._scene);\r\n            this.grip.rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n\r\n        // for now only load motion controllers if gamepad object available\r\n        if (this.inputSource.gamepad && this.inputSource.targetRayMode === \"tracked-pointer\") {\r\n            WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(\r\n                (motionController) => {\r\n                    this.motionController = motionController;\r\n                    this.onMotionControllerInitObservable.notifyObservers(motionController);\r\n                    // should the model be loaded?\r\n                    if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {\r\n                        this.motionController.loadModel().then((success) => {\r\n                            if (success && this.motionController && this.motionController.rootMesh) {\r\n                                if (this._options.renderingGroupId) {\r\n                                    // anything other than 0?\r\n                                    this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;\r\n                                    this.motionController.rootMesh.getChildMeshes(false).forEach((mesh) => (mesh.renderingGroupId = this._options.renderingGroupId!));\r\n                                }\r\n                                this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);\r\n                                this.motionController.rootMesh.parent = this.grip || this.pointer;\r\n                                this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;\r\n                            }\r\n                            // make sure to dispose is the controller is already disposed\r\n                            if (this._disposed) {\r\n                                this.motionController?.dispose();\r\n                            }\r\n                        });\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Warn(`Could not find a matching motion controller for the registered input source`);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get this controllers unique id\r\n     */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        if (this.grip) {\r\n            this.grip.dispose(true);\r\n        }\r\n        if (this.motionController) {\r\n            this.motionController.dispose();\r\n        }\r\n        this.pointer.dispose(true);\r\n        this.onMotionControllerInitObservable.clear();\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this._disposed = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a world space ray coming from the pointer or grip\r\n     * @param result the resulting ray\r\n     * @param gripIfAvailable use the grip mesh instead of the pointer, if available\r\n     */\r\n    public getWorldPointerRayToRef(result: Ray, gripIfAvailable: boolean = false) {\r\n        const object = gripIfAvailable && this.grip ? this.grip : this.pointer;\r\n        Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\r\n        result.direction.normalize();\r\n        result.origin.copyFrom(object.absolutePosition);\r\n        result.length = 1000;\r\n    }\r\n\r\n    /**\r\n     * Updates the controller pose based on the given XRFrame\r\n     * @param xrFrame xr frame to update the pose with\r\n     * @param referenceSpace reference space to use\r\n     * @param xrCamera the xr camera, used for parenting\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, xrCamera: WebXRCamera) {\r\n        const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);\r\n        this._lastXRPose = pose;\r\n\r\n        // Update the pointer mesh\r\n        if (pose) {\r\n            const pos = pose.transform.position;\r\n            this.pointer.position.set(pos.x, pos.y, pos.z);\r\n            const orientation = pose.transform.orientation;\r\n            this.pointer.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this.pointer.position.z *= -1;\r\n                this.pointer.rotationQuaternion!.z *= -1;\r\n                this.pointer.rotationQuaternion!.w *= -1;\r\n            }\r\n            this.pointer.parent = xrCamera.parent;\r\n        }\r\n\r\n        // Update the grip mesh if it exists\r\n        if (this.inputSource.gripSpace && this.grip) {\r\n            const pose = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\r\n            if (pose) {\r\n                const pos = pose.transform.position;\r\n                const orientation = pose.transform.orientation;\r\n                this.grip.position.set(pos.x, pos.y, pos.z);\r\n                this.grip.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n                if (!this._scene.useRightHandedSystem) {\r\n                    this.grip.position.z *= -1;\r\n                    this.grip.rotationQuaternion!.z *= -1;\r\n                    this.grip.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n            this.grip.parent = xrCamera.parent;\r\n        }\r\n        if (this.motionController) {\r\n            // either update buttons only or also position, if in gamepad mode\r\n            this.motionController.updateFromXRFrame(xrFrame);\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport type { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRCompositionLayer */\r\n// TODO (rgerd): Extend for all other subclasses of XRCompositionLayer.\r\nexport type WebXRCompositionLayerType = \"XRProjectionLayer\";\r\n\r\n/** Covers all supported subclasses of WebXR's XRLayer */\r\nexport type WebXRLayerType = \"XRWebGLLayer\" | WebXRCompositionLayerType;\r\n\r\n/**\r\n * Wrapper over subclasses of XRLayer.\r\n * @internal\r\n */\r\nexport class WebXRLayerWrapper {\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this.layerType == \"XRWebGLLayer\" && typeof (this.layer as XRWebGLLayer).fixedFoveation == \"number\";\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        if (this.isFixedFoveationSupported) {\r\n            return (this.layer as XRWebGLLayer).fixedFoveation!;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        if (this.isFixedFoveationSupported) {\r\n            const val = Math.max(0, Math.min(1, value || 0));\r\n            (this.layer as XRWebGLLayer).fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    protected constructor(\r\n        /** The width of the layer's framebuffer. */\r\n        public getWidth: () => number,\r\n        /** The height of the layer's framebuffer. */\r\n        public getHeight: () => number,\r\n        /** The XR layer that this WebXRLayerWrapper wraps. */\r\n        public readonly layer: XRLayer,\r\n        /** The type of XR layer that is being wrapped. */\r\n        public readonly layerType: WebXRLayerType,\r\n        /** Create a render target provider for the wrapped layer. */\r\n        public createRenderTargetTextureProvider: (xrSessionManager: WebXRSessionManager) => WebXRLayerRenderTargetTextureProvider\r\n    ) {}\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\n\r\n/**\r\n * Configuration object for WebXR output canvas\r\n */\r\nexport class WebXRManagedOutputCanvasOptions {\r\n    /**\r\n     * An optional canvas in case you wish to create it yourself and provide it here.\r\n     * If not provided, a new canvas will be created\r\n     */\r\n    public canvasElement?: HTMLCanvasElement;\r\n    /**\r\n     * Options for this XR Layer output\r\n     */\r\n    public canvasOptions?: XRWebGLLayerInit;\r\n    /**\r\n     * CSS styling for a newly created canvas (if not provided)\r\n     */\r\n    public newCanvasCssStyle?: string;\r\n\r\n    /**\r\n     * Get the default values of the configuration object\r\n     * @param engine defines the engine to use (can be null)\r\n     * @returns default values of this configuration object\r\n     */\r\n    public static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions {\r\n        const defaults = new WebXRManagedOutputCanvasOptions();\r\n        defaults.canvasOptions = {\r\n            antialias: true,\r\n            depth: true,\r\n            stencil: engine ? engine.isStencilEnable : true,\r\n            alpha: true,\r\n            framebufferScaleFactor: 1,\r\n        };\r\n\r\n        defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\r\n\r\n        return defaults;\r\n    }\r\n}\r\n/**\r\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\r\n */\r\nexport class WebXRManagedOutputCanvas implements WebXRRenderTarget {\r\n    private _canvas: Nullable<HTMLCanvasElement> = null;\r\n    private _engine: Nullable<ThinEngine> = null;\r\n    private _originalCanvasSize: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n\r\n    /**\r\n     * Rendering context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    public canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    public xrLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    private _xrLayerWrapper: Nullable<WebXRLayerWrapper> = null;\r\n\r\n    /**\r\n     * Observers registered here will be triggered when the xr layer was initialized\r\n     */\r\n    public onXRLayerInitObservable: Observable<XRWebGLLayer> = new Observable();\r\n\r\n    /**\r\n     * Initializes the canvas to be added/removed upon entering/exiting xr\r\n     * @param _xrSessionManager The XR Session manager\r\n     * @param _options optional configuration for this canvas output. defaults will be used if not provided\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: WebXRManagedOutputCanvasOptions = WebXRManagedOutputCanvasOptions.GetDefaults()) {\r\n        this._engine = _xrSessionManager.scene.getEngine();\r\n        this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n\r\n        if (!_options.canvasElement) {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\r\n            this._setManagedOutputCanvas(canvas);\r\n        } else {\r\n            this._setManagedOutputCanvas(_options.canvasElement);\r\n        }\r\n\r\n        _xrSessionManager.onXRSessionInit.add(() => {\r\n            this._addCanvas();\r\n        });\r\n\r\n        _xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._removeCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this._removeCanvas();\r\n        this._setManagedOutputCanvas(null);\r\n    }\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    public async initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer> {\r\n        const createLayer = () => {\r\n            this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\r\n            this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\r\n            this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\r\n            return this.xrLayer;\r\n        };\r\n\r\n        // support canvases without makeXRCompatible\r\n        if (!(this.canvasContext as any).makeXRCompatible) {\r\n            return Promise.resolve(createLayer());\r\n        }\r\n\r\n        return (this.canvasContext as any)\r\n            .makeXRCompatible()\r\n            .then(\r\n                // catch any error and continue. When using the emulator is throws this error for no apparent reason.\r\n                () => {},\r\n                () => {\r\n                    // log the error, continue nonetheless!\r\n                    Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\r\n                }\r\n            )\r\n            .then(() => {\r\n                return createLayer();\r\n            });\r\n    }\r\n\r\n    private _addCanvas() {\r\n        if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.appendChild(this._canvas);\r\n        }\r\n        if (this.xrLayer) {\r\n            this._setCanvasSize(true);\r\n        } else {\r\n            this.onXRLayerInitObservable.addOnce(() => {\r\n                this._setCanvasSize(true);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _removeCanvas() {\r\n        if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\r\n            document.body.removeChild(this._canvas);\r\n        }\r\n        this._setCanvasSize(false);\r\n    }\r\n\r\n    private _setCanvasSize(init: boolean = true, xrLayer = this._xrLayerWrapper) {\r\n        if (!this._canvas || !this._engine) {\r\n            return;\r\n        }\r\n        if (init) {\r\n            if (xrLayer) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = xrLayer.getWidth() + \"px\";\r\n                    this._canvas.style.height = xrLayer.getHeight() + \"px\";\r\n                } else {\r\n                    this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\r\n                }\r\n            }\r\n        } else {\r\n            if (this._originalCanvasSize) {\r\n                if (this._canvas !== this._engine.getRenderingCanvas()) {\r\n                    this._canvas.style.width = this._originalCanvasSize.width + \"px\";\r\n                    this._canvas.style.height = this._originalCanvasSize.height + \"px\";\r\n                } else {\r\n                    this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setManagedOutputCanvas(canvas: Nullable<HTMLCanvasElement>) {\r\n        this._removeCanvas();\r\n        if (!canvas) {\r\n            this._canvas = null;\r\n            (this.canvasContext as any) = null;\r\n        } else {\r\n            this._originalCanvasSize = {\r\n                width: canvas.offsetWidth,\r\n                height: canvas.offsetHeight,\r\n            };\r\n            this._canvas = canvas;\r\n            this.canvasContext = <any>this._canvas.getContext(\"webgl2\");\r\n            if (!this.canvasContext) {\r\n                this.canvasContext = <any>this._canvas.getContext(\"webgl\");\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { Engine } from \"../Engines/engine\";\r\nimport { WebGLHardwareTexture } from \"../Engines/WebGL/webGLHardwareTexture\";\r\nimport type { WebGLRenderTargetWrapper } from \"../Engines/WebGL/webGLRenderTargetWrapper\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiviewRenderTarget } from \"../Materials/Textures/MultiviewRenderTarget\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\n\r\n/**\r\n * An interface for objects that provide render target textures for XR rendering.\r\n */\r\nexport interface IWebXRRenderTargetTextureProvider extends IDisposable {\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRLayer.\r\n * @internal\r\n */\r\nexport abstract class WebXRLayerRenderTargetTextureProvider implements IWebXRRenderTargetTextureProvider {\r\n    public abstract trySetViewportForView(viewport: Viewport, view: XRView): boolean;\r\n    public abstract getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture>;\r\n    public abstract getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture>;\r\n\r\n    protected _renderTargetTextures = new Array<RenderTargetTexture>();\r\n    protected _framebufferDimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    private _engine: Engine;\r\n\r\n    constructor(private readonly _scene: Scene, public readonly layerWrapper: WebXRLayerWrapper) {\r\n        this._engine = _scene.getEngine();\r\n    }\r\n\r\n    private _createInternalTexture(textureSize: { width: number; height: number }, texture: WebGLTexture): InternalTexture {\r\n        const internalTexture = new InternalTexture(this._engine, InternalTextureSource.Unknown, true);\r\n        internalTexture.width = textureSize.width;\r\n        internalTexture.height = textureSize.height;\r\n        internalTexture._hardwareTexture = new WebGLHardwareTexture(texture, this._engine._gl);\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    protected _createRenderTargetTexture(\r\n        width: number,\r\n        height: number,\r\n        framebuffer: Nullable<WebGLFramebuffer>,\r\n        colorTexture?: WebGLTexture,\r\n        depthStencilTexture?: WebGLTexture,\r\n        multiview?: boolean\r\n    ): RenderTargetTexture {\r\n        if (!this._engine) {\r\n            throw new Error(\"Engine is disposed\");\r\n        }\r\n\r\n        const textureSize = { width, height };\r\n\r\n        // Create render target texture from the internal texture\r\n        const renderTargetTexture = multiview ? new MultiviewRenderTarget(this._scene, textureSize) : new RenderTargetTexture(\"XR renderTargetTexture\", textureSize, this._scene);\r\n        const renderTargetWrapper = renderTargetTexture.renderTarget as WebGLRenderTargetWrapper;\r\n        renderTargetWrapper._samples = renderTargetTexture.samples;\r\n        // Set the framebuffer, make sure it works in all scenarios - emulator, no layers and layers\r\n        if (framebuffer || !colorTexture) {\r\n            renderTargetWrapper._framebuffer = framebuffer;\r\n        }\r\n\r\n        // Create internal texture\r\n        if (colorTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._colorTextureArray = colorTexture;\r\n            } else {\r\n                const internalTexture = this._createInternalTexture(textureSize, colorTexture);\r\n                renderTargetWrapper.setTexture(internalTexture, 0);\r\n                renderTargetTexture._texture = internalTexture;\r\n            }\r\n        }\r\n\r\n        if (depthStencilTexture) {\r\n            if (multiview) {\r\n                renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\r\n            } else {\r\n                renderTargetWrapper._depthStencilTexture = this._createInternalTexture(textureSize, depthStencilTexture);\r\n            }\r\n        }\r\n\r\n        renderTargetTexture.disableRescaling();\r\n        // Firefox reality fails if skipInitialClear is set to true, so make sure only modern XR implementations set it.\r\n        if (typeof XRWebGLBinding !== \"undefined\") {\r\n            // WebXR pre-clears textures\r\n            renderTargetTexture.skipInitialClear = true;\r\n        }\r\n\r\n        this._renderTargetTextures.push(renderTargetTexture);\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    protected _destroyRenderTargetTexture(renderTargetTexture: RenderTargetTexture) {\r\n        this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(renderTargetTexture), 1);\r\n        renderTargetTexture.dispose();\r\n    }\r\n\r\n    public getFramebufferDimensions(): Nullable<{ framebufferWidth: number; framebufferHeight: number }> {\r\n        return this._framebufferDimensions;\r\n    }\r\n\r\n    public dispose() {\r\n        this._renderTargetTextures.forEach((rtt) => rtt.dispose());\r\n        this._renderTargetTextures.length = 0;\r\n    }\r\n}\r\n","import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IWebXRRenderTargetTextureProvider, WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget\";\r\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\r\n */\r\nexport class WebXRSessionManager implements IDisposable, IWebXRRenderTargetTextureProvider {\r\n    private _engine: Nullable<Engine>;\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _baseLayerWrapper: Nullable<WebXRLayerWrapper>;\r\n    private _baseLayerRTTProvider: Nullable<WebXRLayerRenderTargetTextureProvider>;\r\n    private _xrNavigator: any;\r\n    private _sessionMode: XRSessionMode;\r\n    private _onEngineDisposedObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Are we currently in the XR loop?\r\n     */\r\n    public inXRFrameLoop: boolean = false;\r\n    /**\r\n     * Are we in an XR session?\r\n     */\r\n    public inXRSession: boolean = false;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {\r\n        this._engine = scene.getEngine();\r\n        this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\r\n            this._engine = null;\r\n        });\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * The mode for the managed XR session\r\n     */\r\n    public get sessionMode(): XRSessionMode {\r\n        return this._sessionMode;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     * This should be called explicitly by the dev, if required.\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (this.inXRSession) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n        this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\r\n        this._engine = null;\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && this.inXRSession) {\r\n            this.inXRSession = false;\r\n            return this.session.end().catch(() => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\r\n     * In the event of a failure, the supplied viewport is not updated.\r\n     * @param viewport the viewport to which the view will be rendered\r\n     * @param view the view for which to set the viewport\r\n     * @returns whether the operation was successful\r\n     */\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye or null if not available\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this view\r\n     * @param view the view for which to get the render target\r\n     * @returns the render target for the specified view or null if not available\r\n     */\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return new NativeXRRenderTarget(this);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this._sessionMode = xrSessionMode;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this.inXRSession = true;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    this.inXRSession = false;\r\n\r\n                    // Notify frame observers\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n\r\n                    if (this._engine) {\r\n                        // make sure dimensions object is restored\r\n                        this._engine.framebufferDimensionsObject = null;\r\n\r\n                        // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                        this._engine.restoreDefaultFramebuffer();\r\n\r\n                        // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                        this._engine.customAnimationFrameRequester = null;\r\n                        this._engine._renderLoop();\r\n                    }\r\n\r\n                    // Dispose render target textures.\r\n                    // Only dispose on native because we can't destroy opaque textures on browser.\r\n                    if (this.isNative) {\r\n                        this._baseLayerRTTProvider?.dispose();\r\n                    }\r\n                    this._baseLayerRTTProvider = null;\r\n                    this._baseLayerWrapper = null;\r\n                },\r\n                { once: true }\r\n            );\r\n\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        if (!this.inXRSession || !this._engine) {\r\n            return;\r\n        }\r\n\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        this._engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (!this.inXRSession || !this._engine) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    this.inXRFrameLoop = true;\r\n                    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    this._engine._renderLoop();\r\n                    this._engine.framebufferDimensionsObject = null;\r\n                    this.inXRFrameLoop = false;\r\n                }\r\n            },\r\n        };\r\n\r\n        this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(this._engine._frameHandler);\r\n        }\r\n        this._engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session.\r\n     * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     * @deprecated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState): Promise<void> {\r\n        return Promise.resolve(this.session.updateRenderState(state));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setBaseLayerWrapper(baseLayerWrapper: Nullable<WebXRLayerWrapper>): void {\r\n        if (this.isNative) {\r\n            this._baseLayerRTTProvider?.dispose();\r\n        }\r\n        this._baseLayerWrapper = baseLayerWrapper;\r\n        this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getBaseLayerWrapper(): Nullable<WebXRLayerWrapper> {\r\n        return this._baseLayerWrapper;\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     */\r\n    public updateRenderState(state: XRRenderStateInit): void {\r\n        if (state.baseLayer) {\r\n            this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\r\n        }\r\n\r\n        this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\r\n     */\r\n    public get isNative(): boolean {\r\n        return this._xrNavigator.xr.native ?? false;\r\n    }\r\n\r\n    /**\r\n     * The current frame rate as reported by the device\r\n     */\r\n    public get currentFrameRate(): number | undefined {\r\n        return this.session?.frameRate;\r\n    }\r\n\r\n    /**\r\n     * A list of supported frame rates (only available in-session!\r\n     */\r\n    public get supportedFrameRates(): Float32Array | undefined {\r\n        return this.session?.supportedFrameRates;\r\n    }\r\n\r\n    /**\r\n     * Set the framerate of the session.\r\n     * @param rate the new framerate. This value needs to be in the supportedFrameRates array\r\n     * @returns a promise that resolves once the framerate has been set\r\n     */\r\n    public updateTargetFrameRate(rate: number): Promise<void> {\r\n        return this.session.updateTargetFrameRate(rate);\r\n    }\r\n\r\n    /**\r\n     * Run a callback in the xr render loop\r\n     * @param callback the callback to call when in XR Frame\r\n     * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\r\n     */\r\n    public runInXRFrame(callback: () => void, ignoreIfNotInSession = true): void {\r\n        if (this.inXRFrameLoop) {\r\n            callback();\r\n        } else if (this.inXRSession || !ignoreIfNotInSession) {\r\n            this.onXRFrameObservable.addOnce(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if fixed foveation is supported on this device\r\n     */\r\n    public get isFixedFoveationSupported(): boolean {\r\n        return this._baseLayerWrapper?.isFixedFoveationSupported || false;\r\n    }\r\n\r\n    /**\r\n     * Get the fixed foveation currently set, as specified by the webxr specs\r\n     * If this returns null, then fixed foveation is not supported\r\n     */\r\n    public get fixedFoveation(): Nullable<number> {\r\n        return this._baseLayerWrapper?.fixedFoveation || null;\r\n    }\r\n\r\n    /**\r\n     * Set the fixed foveation to the specified value, as specified by the webxr specs\r\n     * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\r\n     */\r\n    public set fixedFoveation(value: Nullable<number>) {\r\n        const val = Math.max(0, Math.min(1, value || 0));\r\n        if (this._baseLayerWrapper) {\r\n            this._baseLayerWrapper.fixedFoveation = val;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the features enabled on the current session\r\n     * This is only available in-session!\r\n     * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\r\n     */\r\n    public get enabledFeatures(): Nullable<string[]> {\r\n        return this.session?.enabledFeatures ?? null;\r\n    }\r\n}\r\n","import type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * States of the webXR experience\r\n */\r\nexport enum WebXRState {\r\n    /**\r\n     * Transitioning to being in XR mode\r\n     */\r\n    ENTERING_XR,\r\n    /**\r\n     * Transitioning to non XR mode\r\n     */\r\n    EXITING_XR,\r\n    /**\r\n     * In XR mode and presenting\r\n     */\r\n    IN_XR,\r\n    /**\r\n     * Not entered XR mode\r\n     */\r\n    NOT_IN_XR,\r\n}\r\n\r\n/**\r\n * The state of the XR camera's tracking\r\n */\r\nexport enum WebXRTrackingState {\r\n    /**\r\n     * No transformation received, device is not being tracked\r\n     */\r\n    NOT_TRACKING,\r\n    /**\r\n     * Tracking lost - using emulated position\r\n     */\r\n    TRACKING_LOST,\r\n    /**\r\n     * Transformation tracking works normally\r\n     */\r\n    TRACKING,\r\n}\r\n\r\n/**\r\n * Abstraction of the XR render target\r\n */\r\nexport interface WebXRRenderTarget extends IDisposable {\r\n    /**\r\n     * xrpresent context of the canvas which can be used to display/mirror xr content\r\n     */\r\n    canvasContext: WebGLRenderingContext;\r\n\r\n    /**\r\n     * xr layer for the canvas\r\n     */\r\n    xrLayer: Nullable<XRWebGLLayer>;\r\n\r\n    /**\r\n     * Initializes a XRWebGLLayer to be used as the session's baseLayer.\r\n     * @param xrSession xr session\r\n     * @returns a promise that will resolve once the XR Layer has been created\r\n     */\r\n    initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;\r\n}\r\n","import type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { WebXRLayerWrapper } from \"./webXRLayerWrapper\";\r\nimport { WebXRLayerRenderTargetTextureProvider } from \"./webXRRenderTargetTextureProvider\";\r\n\r\n/**\r\n * Wraps xr webgl layers.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerWrapper extends WebXRLayerWrapper {\r\n    /**\r\n     * @param layer is the layer to be wrapped.\r\n     * @returns a new WebXRLayerWrapper wrapping the provided XRWebGLLayer.\r\n     */\r\n    constructor(public readonly layer: XRWebGLLayer) {\r\n        super(\r\n            () => layer.framebufferWidth,\r\n            () => layer.framebufferHeight,\r\n            layer,\r\n            \"XRWebGLLayer\",\r\n            (sessionManager) => new WebXRWebGLLayerRenderTargetTextureProvider(sessionManager.scene, this)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Provides render target textures and other important rendering information for a given XRWebGLLayer.\r\n * @internal\r\n */\r\nexport class WebXRWebGLLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\r\n    // The dimensions will always be defined in this class.\r\n    protected _framebufferDimensions: { framebufferWidth: number; framebufferHeight: number };\r\n    private _rtt: Nullable<RenderTargetTexture>;\r\n    private _framebuffer: WebGLFramebuffer;\r\n    private _layer: XRWebGLLayer;\r\n\r\n    constructor(scene: Scene, public readonly layerWrapper: WebXRWebGLLayerWrapper) {\r\n        super(scene, layerWrapper);\r\n        this._layer = layerWrapper.layer;\r\n        this._framebufferDimensions = {\r\n            framebufferWidth: this._layer.framebufferWidth,\r\n            framebufferHeight: this._layer.framebufferHeight,\r\n        };\r\n    }\r\n\r\n    public trySetViewportForView(viewport: Viewport, view: XRView): boolean {\r\n        const xrViewport = this._layer.getViewport(view);\r\n        if (!xrViewport) {\r\n            return false;\r\n        }\r\n        const framebufferWidth = this._framebufferDimensions.framebufferWidth;\r\n        const framebufferHeight = this._framebufferDimensions.framebufferHeight;\r\n        viewport.x = xrViewport.x / framebufferWidth;\r\n        viewport.y = xrViewport.y / framebufferHeight;\r\n        viewport.width = xrViewport.width / framebufferWidth;\r\n        viewport.height = xrViewport.height / framebufferHeight;\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getRenderTargetTextureForEye(eye: XREye): Nullable<RenderTargetTexture> {\r\n        const layerWidth = this._layer.framebufferWidth;\r\n        const layerHeight = this._layer.framebufferHeight;\r\n        const framebuffer = this._layer.framebuffer;\r\n\r\n        if (\r\n            !this._rtt ||\r\n            layerWidth !== this._framebufferDimensions.framebufferWidth ||\r\n            layerHeight !== this._framebufferDimensions.framebufferHeight ||\r\n            framebuffer !== this._framebuffer\r\n        ) {\r\n            this._rtt = this._createRenderTargetTexture(layerWidth, layerHeight, framebuffer);\r\n            this._framebufferDimensions.framebufferWidth = layerWidth;\r\n            this._framebufferDimensions.framebufferHeight = layerHeight;\r\n            this._framebuffer = framebuffer;\r\n        }\r\n\r\n        return this._rtt;\r\n    }\r\n\r\n    public getRenderTargetTextureForView(view: XRView): Nullable<RenderTargetTexture> {\r\n        return this.getRenderTargetTextureForEye(view.eye);\r\n    }\r\n}\r\n"],"names":["Action","constructor","triggerOptions","condition","onBeforeExecuteObservable","parameter","this","trigger","_triggerParameter","_nextActiveAction","_condition","_prepare","getTriggerParameter","setTriggerParameter","value","_evaluateConditionForCurrentFrame","currentRenderId","_actionManager","getScene","getRenderId","_evaluationId","_currentResult","isValid","_executeCurrent","evt","notifyObservers","execute","skipToNextActiveAction","_child","then","action","_getProperty","propertyPath","_getEffectiveTarget","target","serialize","parent","_serialize","serializedAction","serializationObject","type","children","name","properties","serializedCondition","push","_SerializeValueAsString","toString","x","y","z","r","g","b","a","_GetTargetProperty","targetType","_isMesh","_isLight","_isCamera","_isMaterial","_isScene","ActionManager","scene","super","LastCreatedScene","_scene","actionManagers","dispose","sceneIndex","indexOf","i","actions","length","Triggers","splice","ownerMesh","meshes","find","m","actionManager","hasSpecificTriggers","triggers","index","hasSpecificTriggers2","triggerA","triggerB","hasSpecificTrigger","parameterPredicate","hasPointerTriggers","OnPickTrigger","OnPointerOutTrigger","hasPickTriggers","OnPickUpTrigger","registerAction","OnEveryFrameTrigger","Warn","_registeredActions","unregisterAction","processTrigger","OnKeyUpTrigger","OnKeyDownTrigger","sourceEvent","keyCode","toLowerCase","lowerCase","key","unicode","charCode","String","fromCharCode","split","root","Array","triggerObject","GetTriggerName","Node","DeepCopy","mesh","_meshId","id","Parse","parsedActions","object","parseParameter","floatValue","parseFloat","isNaN","effectiveTarget","values","FromArray","traverse","parsedAction","combineArray","detached","parameters","combine","j","NothingTrigger","getMaterialByName","getNodeByName","getSoundByName","param","newAction","params","internalClassType","instantiate","nothing","triggerParams","getMeshByName","getMeshById","OnLeftPickTrigger","OnRightPickTrigger","OnCenterPickTrigger","OnPickDownTrigger","OnDoublePickTrigger","OnPickOutTrigger","OnLongPressTrigger","OnPointerOverTrigger","OnIntersectionEnterTrigger","OnIntersectionExitTrigger","_staticOffsetValueQuaternion","Object","freeze","_staticOffsetValueVector3","Zero","_staticOffsetValueVector2","_staticOffsetValueSize","_staticOffsetValueColor3","Black","RuntimeAnimation","currentFrame","_currentFrame","weight","_weight","currentValue","_currentValue","targetPath","_targetPath","_currentActiveTarget","isAdditive","_host","animation","host","_events","_originalValue","_originalBlendValue","_offsetsCache","_highLimitsCache","_stopped","_blendingFactor","_directTarget","_absoluteFrameOffset","_previousElapsedTime","_previousAbsoluteFrame","_targetIsArray","_animation","_target","_activeTargets","_runtimeAnimations","_animationState","repeatCount","loopMode","_getCorrectLoopMode","dataType","ANIMATIONTYPE_MATRIX","workValue","_keys","getKeys","_minFrame","frame","_maxFrame","_minValue","_maxValue","newKey","_preparePath","_getOriginalValues","events","getEvents","forEach","e","_clone","_enableBlending","animationPropertiesOverride","enableBlending","targetIndex","targetPropertyPath","property","reset","restoreOriginal","undefined","_setValue","isDone","isStopped","runtimeAnimations","setValue","originalValue","getRestPose","clone","destination","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","_registerTargetForLateAnimationBinding","markAsDirty","targetProperty","goToFrame","keys","onlyOnce","_interpolate","_prepareForSpeedRatioChange","newSpeedRatio","newAbsoluteFrame","framePerSecond","animate","elapsedTimeSinceAnimationStart","from","to","loop","speedRatio","returnValue","frameRange","offsetValue","absoluteFrame","highLimitValue","ANIMATIONLOOPMODE_YOYO","position","Math","abs","sin","PI","_getKeyValue","ANIMATIONLOOPMODE_CYCLE","keyOffset","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","subtract","syncRoot","masterFrame","fromFrame","toFrame","_onLoop","event","SoundTrack","options","_isInitialized","soundCollection","_options","mainTrack","soundTracks","_initializeSoundTrackAudioGraph","audioEngine","canUseWebAudio","audioContext","_outputAudioNode","createGain","connect","masterGain","volume","gain","_connectedAnalyser","stopDebugCanvas","disconnect","addSound","sound","connectToSoundTrackAudioNode","soundTrackId","mainSoundTrack","removeSound","setVolume","newVolume","switchPanningModelToHRTF","switchPanningModelToEqualPower","connectToAnalyser","analyser","connectAudioNodes","PointerDragBehavior","currentDraggingPointerID","currentDraggingPointerId","enabled","_enabled","onEnabledObservable","_useAlternatePickedPointAboveMaxDragAngleDragSpeed","_activeDragButton","maxDragAngle","dragButtons","_useAlternatePickedPointAboveMaxDragAngle","dragging","dragDeltaRatio","updateDragPlane","_debugMode","_moving","onDragObservable","onDragStartObservable","onDragEndObservable","moveAttached","startAndReleaseDragOnPointerEvents","detachCameraControls","useObjectOrientationForDragging","validateDrag","targetPosition","_tmpVector","_alternatePickedPoint","_worldDragAxis","_targetPosition","_attachedToElement","_startDragRay","_lastPointerRay","_dragDelta","_pointA","_pointC","_localAxis","_lookAt","optionCount","dragAxis","dragPlaneNormal","init","attach","ownerNode","predicate","isNearGrabbable","attachedNode","_PlaneScene","getEngine","virtual","detachControl","onDisposeObservable","addOnce","_dragPlane","size","updatable","sideOrientation","DOUBLESIDE","lastDragPosition","pickPredicate","isDescendantOf","_pointerObserver","onPointerObservable","add","pointerInfo","POINTERDOWN","pickInfo","hit","pickedMesh","pickedPoint","ray","button","_activePointerInfo","_startDrag","pointerId","POINTERUP","releaseDrag","POINTERMOVE","_AnyMouseId","pointerType","hostInformation","isMobile","MouseEvent","origin","direction","_moveDrag","_beforeRenderObserver","onBeforeRenderObservable","needMatrixUpdate","_RemoveAndStorePivotPoint","subtractToRef","absolutePosition","scaleInPlace","getAbsolutePosition","addToRef","setAbsolutePosition","_RestorePivotPoint","computeWorldMatrix","dragPlanePoint","activeCamera","leftCamera","getClassName","arcRotateCamera","attachControl","inputs","noPreventDefault","_useCtrlForPanning","_panningMouseButton","startDrag","fromRay","startPickedPoint","lastRay","getWorldMatrix","getTranslationToRef","_updateDragPlanePosition","_pickWithRayOnDragPlane","attachedToElement","dragLength","TransformCoordinatesToRef","getRotationMatrix","Dot","scaleToRef","addInPlace","dragDistance","delta","forward","angle","acos","normalize","dot","pickResult","pickWithRay","dragPlanePosition","UpReadOnly","Right","CrossToRef","lookAt","detach","remove","StorageBuffer","engine","creationFlags","_engine","_storageBuffers","_create","_bufferSize","_creationFlags","_buffer","createStorageBuffer","_rebuild","getBuffer","update","data","byteOffset","byteLength","updateStorageBuffer","read","offset","buffer","readFromStorageBuffer","storageBuffers","pop","_releaseBuffer","ArcRotateCameraGamepadInput","gamepadRotationSensibility","gamepadMoveSensibility","_yAxisScale","invertYAxis","manager","camera","gamepadManager","_onGamepadConnectedObserver","onGamepadConnectedObservable","gamepad","POSE_ENABLED","XBOX","_onGamepadDisconnectedObserver","onGamepadDisconnectedObservable","getGamepadByType","checkInputs","rsValues","rightStick","normalizedRX","inertialAlphaOffset","normalizedRY","inertialBetaOffset","lsValues","leftStick","normalizedLY","inertialRadiusOffset","getSimpleName","FlyCameraKeyboardInput","keysForward","keysBackward","keysUp","keysDown","keysRight","keysLeft","BackCompatCameraNoPreventDefault","arguments","_onCanvasBlurObserver","onCanvasBlurObservable","_onKeyboardObserver","onKeyboardObservable","info","KEYDOWN","preventDefault","_onLostFocus","speed","_computeLocalCameraSpeed","_localDirection","copyFromFloats","useRightHandedSystem","getViewMatrix","invertToRef","_cameraTransformMatrix","TransformNormalToRef","_transformedDirection","cameraDirection","FlyCameraMouseInput","buttons","buttonsYaw","buttonsPitch","buttonsRoll","activeButton","angularSensibility","_previousPosition","_noPreventDefault","_observer","_inputManager","_addCameraPointerObserver","p","_pointerInput","_rollObserver","rollCorrect","restoreRoll","_removeCameraPointerObserver","isInVRExclusivePointerMode","touchEnabled","srcElement","setPointerCapture","clientX","clientY","_element","focus","isPointerLock","_onMouseMove","releasePointerCapture","offsetX","offsetY","_rotateCamera","movementX","movementY","_getWorldMatrixDeterminant","currentRotation","RotationYawPitchRoll","rotation","rotationChange","some","v","RotationAxis","X","multiplyInPlace","Y","limit","bankedTurnLimit","_trackRoll","bankedTurn","bankingDelta","bankedTurnMultiplier","Z","toEulerAnglesToRef","FollowCameraKeyboardMoveInput","keysHeightOffsetIncr","keysHeightOffsetDecr","keysHeightOffsetModifierAlt","keysHeightOffsetModifierCtrl","keysHeightOffsetModifierShift","keysRotationOffsetIncr","keysRotationOffsetDecr","keysRotationOffsetModifierAlt","keysRotationOffsetModifierCtrl","keysRotationOffsetModifierShift","keysRadiusIncr","keysRadiusDecr","keysRadiusModifierAlt","keysRadiusModifierCtrl","keysRadiusModifierShift","heightSensibility","rotationSensibility","radiusSensibility","metaKey","_ctrlPressed","ctrlKey","_altPressed","altKey","_shiftPressed","shiftKey","_modifierHeightOffset","heightOffset","_modifierRotationOffset","rotationOffset","_modifierRadius","radius","FollowCameraMouseWheelInput","axisControlRadius","axisControlHeight","axisControlRotation","wheelPrecision","wheelDeltaPercentage","_wheel","POINTERWHEEL","wheelDelta","max","min","deltaY","console","assert","FollowCameraPointersInput","angularSensibilityX","angularSensibilityY","pinchPrecision","pinchDeltaPercentage","axisXControlRadius","axisXControlHeight","axisXControlRotation","axisYControlRadius","axisYControlHeight","axisYControlRotation","axisPinchControlRadius","axisPinchControlHeight","axisPinchControlRotation","warningEnable","_warningCounter","onTouch","pointA","_warning","onMultiTouch","pointB","previousPinchSquaredDistance","pinchSquaredDistance","previousMultiTouchPanPosition","multiTouchPanPosition","pinchDelta","warn","FreeCameraGamepadInput","gamepadAngularSensibility","deadzoneDelta","_cameraTransform","Identity","_deltaTransform","_vector3","_vector2","gamepads","rotationQuaternion","toRotationMatrix","RotationYawPitchRollToRef","cameraRotation","setStereoscopicAnaglyphRigMode","_rigCameras","_rigPostProcess","setStereoscopicRigMode","isStereoscopicHoriz","cameraRigMode","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","isCrossEye","RIG_MODE_STEREOSCOPIC_INTERLACED","viewport","setVRRigMode","rigParams","metrics","vrCameraMetrics","GetDefault","_cameraRigParams","vrMetrics","vrWorkMatrix","vrHMatrix","leftHMatrix","vrPreViewMatrix","leftPreViewMatrix","getProjectionMatrix","_getVRProjectionMatrix","rightHMatrix","rightPreViewMatrix","multiviewEnabled","getCaps","multiview","_useMultiviewToSingleView","postProcessScaleFactor","compensateDistortion","setWebVRRigMode","vrDisplay","leftEye","getEyeParameters","rightEye","setCameraRigParameter","specs","frameData","parentCamera","_getWebVRProjectionMatrix","_getViewMatrix","_getWebVRViewMatrix","VRCameraMetrics","aspectRatio","hResolution","vResolution","aspectRatioFov","atan","vScreenSize","eyeToScreenDistance","h","hScreenSize","lensSeparationDistance","Translation","interpupillaryDistance","result","vScreenCenter","distortionK","chromaAbCorrection","lensCenterOffset","N","AddNodeConstructor","VRDeviceOrientationFreeCamera","_setRigMode","bind","setCameraRigMode","RIG_MODE_VR","WebVRFreeCamera","_webVROptions","_vrDevice","rawPose","_specsVersion","_attached","_descendants","_deviceRoomPosition","_deviceRoomRotationQuaternion","_standingMatrix","devicePosition","deviceRotationQuaternion","deviceScaleFactor","_deviceToWorld","_worldToDevice","controllers","onControllersAttachedObservable","onControllerMeshLoadedObservable","onPoseUpdatedFromDeviceObservable","_poseSet","rigParenting","_defaultHeight","_detachIfAttached","getVRDevice","isPresenting","_workingVector","_oneVector","One","_workingMatrix","_tmpMatrix","_cache","defaultHeight","minZ","trackPosition","controllerMeshes","defaultLightingOnControllers","positionScale","_onVREnabled","success","initControllers","onVRRequestPresentComplete","initWebVR","RIG_MODE_WEBVR","_frameData","enableVR","VRFrameData","useMultiview","onBeforeCameraRenderObservable","getDescendants","n","isController","controller","_mesh","isRigCamera","node","onAfterCameraRenderObservable","deviceDistanceToRoomGround","useStandingMatrix","callback","bool","initWebVRAsync","stageParameters","sittingToStandingTransform","FromFloat32ArrayToRefScaled","toggleModelMatrixHandInPlace","useStandingMatrixAsync","Promise","res","supported","removeCallback","_updateCacheWhenTrackingDisabledObserver","getControllerByName","gp","hand","leftController","_leftController","rightController","_rightController","getForwardRay","globalPosition","_checkInputs","getFrameData","updateFromDevice","pose","poseData","orientation","w","ForceAttachControlToAlwaysPreventDefault","hostWindow","getHostWindow","addEventListener","disableVR","window","removeEventListener","resetToCurrentRotation","resetPose","_updateRigCameras","camLeft","camRight","_correctPositionIfNotTrackPosition","matrix","isViewMatrix","TranslationToRef","invert","multiplyToRef","_updateCache","ignoreParentClass","equals","_updateCacheCalled","ComposeToRef","subtractInPlace","setTranslation","_computeDevicePosition","FromQuaternionToRef","FromRotationMatrixToRef","viewArray","leftViewMatrix","rightViewMatrix","FromArrayToRef","_webvrViewMatrix","getRotationMatrixToRef","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","_currentTarget","multiplyAtIndex","_globalPosition","_markSyncedWithParent","depthNear","depthFar","maxZ","projectionArray","leftProjectionMatrix","rightProjectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","webVrController","defaultModel","setEnabled","controllerIndex","_disableTrackPosition","initControllerMesh","loadedMesh","scaling","_lightOnControllers","activateLightOnSubMeshes","light","getChildren","includedOnlyMeshes","attachToPoseControlledCamera","firstViveWandDetected","controllerType","VIVE","DeviceOrientationCamera","_tmpDragQuaternion","_disablePointerInputWhenUsingDeviceOrientation","_dragFactor","_quaternionCache","addDeviceOrientation","_deviceOrientationInput","_onDeviceOrientationChangedObservable","_mouseInput","_allowCameraRotation","onPointerMovedObservable","_initialQuaternion","FromEulerAnglesToRef","disablePointerInputWhenUsingDeviceOrientation","enableHorizontalDragging","dragFactor","axis","axisName","FlyCameraInputsManager","addKeyboard","addMouse","FollowCameraInputsManager","addMouseWheel","addPointers","addVRDeviceOrientation","GamepadCamera","TouchCamera","touchAngularSensibility","touch","attached","touchMoveSensibility","addTouch","_setupInputs","mouse","allowMouse","UniversalCamera","addGamepad","_CreateDefaultParsedCamera","getLowestRoot","found","c","maxR","determinant","sqrtD","sqrt","r1","r2","temp","Collider","_collisionPoint","_planeIntersectionPoint","_tempVector","_tempVector2","_tempVector3","_tempVector4","_edge","_baseToVertex","_destinationPoint","_slidePlaneNormal","_displacementVector","_radius","_retry","_basePointWorld","_velocityWorld","_normalizedVelocity","_collisionMask","collisionMask","mask","slidePlaneNormal","_initialize","source","dir","_velocity","_velocitySquaredLength","lengthSquared","len","_x","_y","_z","_basePoint","_velocityWorldLength","_epsilon","collisionFound","_checkPointInTriangle","point","pa","pb","pc","d","_canDoCollision","sphereCenter","sphereRadius","vecMin","vecMax","distance","Distance","boxMin","boxMax","intersectBoxAASphere","_testTriangle","faceIndex","trianglePlaneArray","p1","p2","p3","hasMaterial","hostMesh","t0","embeddedInPlane","copyFromPoints","trianglePlane","isFrontFacingTo","signedDistToTrianglePlane","signedDistanceTo","normalDotVelocity","normal","DoubleSidedCheck","t1","t","lowestRoot","edgeSquaredLength","edgeDotVelocity","edgeDotBaseToVertex","f","distToCollisionSquared","_nearestDistanceSquared","collisionResponse","intersectionPoint","_nearestDistance","collidedMesh","_collide","pts","indices","indexStart","indexEnd","decal","invertTriangles","triangleStrip","indexA","indexB","indexC","_getResponse","pos","vel","SignedDistanceToPlaneFromPositionAndNormal","ComputeEffect","baseName","computeSource","defines","onCompiled","onError","uniqueId","onCompileObservable","onErrorObservable","onBindObservable","_wasPreviouslyReady","_isReady","_compilationError","_key","_computeSourceCodeOverride","_pipelineContext","_computeSourceCode","_rawComputeSourceCode","_shaderLanguage","WGSL","_UniqueIdSeed","_entryPoint","entryPoint","_shaderStore","GetShadersStore","_shaderRepository","GetShadersRepository","_includeShaderStore","GetIncludesShadersStore","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","indexParameters","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","_loadShader","computeCode","Initialize","PreProcess","migratedCommputeCode","processFinalCode","finalShaders","Finalize","_useFinalCode","vertexCode","spectorName","_prepareEffect","isReady","_isReadyInternal","getPipelineContext","getCompilationError","executeWhenCompiled","func","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","_processCompilationErrors","shader","optionalKey","HTMLElement","substr","atob","shaderUrl","_loadFile","computeSourceCode","_getComputeShaderCode","rawComputeSourceCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","clear","_deleteComputePipelineContext","_getShaderCodeAndErrorLine","code","error","regexp","errorLine","match","lineNumber","parseInt","lines","message","Error","LogShaderCodeOnCompilationError","lineErrorVertex","_releaseComputeEffect","RegisterShader","computeShader","ComputeShader","shaderPath","_shaderPath","_bindings","_samplers","_contextIsDirty","UniqueId","supportComputeShaders","bindingsMapping","_context","createComputeContext","setTexture","texture","bindSampler","current","Texture","TextureWithoutSampler","indexInGroupEntries","setStorageTexture","StorageTexture","setUniformBuffer","UniformBuffer","setStorageBuffer","setTextureSampler","sampler","compareSampler","Sampler","_effect","binding","shaderName","join","_cachedDefines","createComputeEffect","dispatch","_texture","setParameters","wrapU","wrapV","wrapR","anisotropicFilteringLevel","samplingMode","_comparisonFunction","ubo","computeDispatch","dispatchWhenReady","delay","resolve","check","Serialize","bindings","textures","serializedData","rootUrl","Octree","creationFunc","maxBlockCapacity","maxDepth","dynamicContent","_maxBlockCapacity","_selectionContent","_creationFunc","worldMin","worldMax","entries","_CreateBlocks","addMesh","entry","blocks","addEntry","removeMesh","removeEntry","select","frustumPlanes","allowDuplicate","concat","concatWithNoDuplicate","intersects","intersectsRay","CreationFuncForMeshes","block","boundingInfo","getBoundingInfo","isBlocked","boundingBox","intersectsMinMax","minPoint","maxPoint","CreationFuncForSubMeshes","OctreeBlock","capacity","depth","_boundingVectors","_capacity","_depth","_maxDepth","_minPoint","_maxPoint","createInnerBlocks","entryIndex","addEntries","selection","IsInFrustum","IntersectsSphere","intersectsBoxMinMax","currentDepth","blockSize","localMin","multiplyByFloats","localMax","PropertyTypeForEdition","editableInPropertyPage","displayName","propertyType","Boolean","groupName","propertyKey","propStore","_propStore","propertyName","ComputeBindingType","prototype","context","areAllComputeEffectsReady","releaseComputeEffects","pipelineContext","_rebuildComputeEffects","_debugPushGroup","targetObject","_debugPopGroup","_debugInsertMarker","text","_debugFlushPendingCommands","createDynamicTexture","width","height","generateMipMaps","Dynamic","baseWidth","baseHeight","needPOTTextures","GetExponentOfTwo","_caps","maxTextureSize","updateTextureSamplingMode","_internalTexturesCache","updateDynamicTexture","invertY","premulAlpha","format","forceBindTexture","allowGPUOptimization","gl","_gl","TEXTURE_2D","wasPreviouslyBound","_bindTextureDirectly","_unpackFlipY","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","textureType","_getWebGLTextureType","glformat","_getInternalFormat","internalFormat","_getRGBABufferInternalSizedFormat","texImage2D","generateMipmap","createExternalTexture","video","setExternalTexture","restoreSingleAttachment","bindAttachments","BACK","restoreSingleAttachmentForRenderTarget","COLOR_ATTACHMENT0","buildTextureLayout","textureStatus","NONE","attachments","drawBuffers","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","_currentRenderTarget","_attachments","count","_MSAAFramebuffer","bindFramebuffer","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","_framebuffer","webGLVersion","readBuffer","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","isCube","_bindUnboundFramebuffer","createMultipleRenderTarget","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","types","samplingModes","useSRGBBuffers","formats","targets","layerIndex","layers","_createHardwareRenderTargetWrapper","targetTypes","layerCounts","framebuffer","createFramebuffer","useStencilTexture","depthStencilBuffer","_setupFramebufferDepthAttachments","_depthStencilBuffer","_generateDepthBuffer","_generateStencilBuffer","useSRGBBuffer","layerCount","filters","_getSamplingParameters","supportSRGBBuffers","isWebGPU","isWebGL2","attachment","MultiRenderTarget","activeTexture","bindTexture","_hardwareTexture","underlyingResource","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","internalSizedFormat","webGLTextureType","TEXTURE_CUBE_MAP_POSITIVE_X","is2DArray","is3D","baseDepth","texImage3D","samples","_useSRGBBuffer","depthTextureExtension","depthTexture","Depth","depthTextureType","glDepthTextureInternalFormat","DEPTH_COMPONENT16","glDepthTextureFormat","DEPTH_COMPONENT","glDepthTextureType","UNSIGNED_SHORT","glDepthTextureAttachment","DEPTH_ATTACHMENT","FLOAT","DEPTH_COMPONENT32F","FLOAT_32_UNSIGNED_INT_24_8_REV","DEPTH32F_STENCIL8","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","UNSIGNED_INT","DEPTH_COMPONENT24","UNSIGNED_INT_24_8","DEPTH24_STENCIL8","TEXTURE0","framebufferTexture2D","FRAMEBUFFER","setTextures","setLayerAndFaceIndices","resetTextureCache","updateMultipleRenderTargetTextureSampleCount","maxMSAASamples","useDepthStencil","deleteRenderbuffer","deleteFramebuffer","renderbufferStorageMultisample","releaseMSAARenderBuffers","hardwareTexture","colorRenderbuffer","_createRenderBuffer","_getRGBAMultiSampleBufferFormat","addMSAARenderBuffer","createMultiviewUbo","addUniform","createMultiviewRenderTargetTexture","colorTexture","depthStencilTexture","internalTexture","Unknown","isMultiview","createTexture","TEXTURE_2D_ARRAY","texStorage3D","RGBA8","_colorTextureArray","_depthStencilTextureArray","_depthStencilTexture","bindMultiviewFramebuffer","_multiviewTexture","multiviewTexture","ext","oculusMultiview","framebufferTextureMultisampleMultiviewOVR","framebufferTextureMultiviewOVR","bindSpaceWarpFramebuffer","_spaceWarpTexture","spaceWarpTexture","_resizeOrCreateMultiviewTexture","getRenderWidth","getRenderHeight","currentCreateSceneUniformBuffer","createSceneUniformBuffer","_transformMatrixR","_multiviewSceneUbo","_createMultiviewUbo","_updateMultiviewUbo","viewR","projectionR","Matrix","GetRightPlaneToRef","_frustumPlanes","updateMatrix","getTransformMatrix","_viewMatrix","_renderMultiviewToSingleView","outputRenderTarget","_renderForCamera","_activeCamera","setViewport","postProcessManager","_prepareFrame","_finalizeFrame","isIntermediate","storageBuffer","transformTextureUrl","url","_excludedCompressedTextures","strRegExPattern","RegExp","lastDot","lastIndexOf","lastQuestionMark","querystring","substring","_textureFormatInUse","defineProperty","get","texturesSupported","astc","s3tc","pvrtc","etc2","etc1","enumerable","configurable","setCompressedTextureExclusions","skippedFiles","setTextureFormatToUse","formatsAvailable","len1","len2","_transformTextureUrl","updateVideoTexture","_isDisabled","_videoTextureSupported","getError","UNSIGNED_BYTE","_workingCanvas","createCanvas","getContext","_workingContext","clearRect","drawImage","videoWidth","videoHeight","ex","_vrExclusivePointerMode","_prepareVRComponent","_vrSupported","onVRDisplayChangedObservable","onVRRequestPresentStart","isVRDevicePresent","_vrDisplay","eventArgs","vrSupported","_webVRInitPromise","_onVrDisplayConnect","display","_onVrDisplayDisconnect","cancelAnimationFrame","_frameHandler","QueueNewFrame","_boundRenderFunction","_onVrDisplayPresentChange","_getVRDisplaysAsync","navigator","getVRDisplays","devices","onResolved","_onVRFullScreenTriggered","onRejected","presentationAttributes","highRefreshRate","vrPresentationAttributes","foveationLevel","requestPresent","getRenderingCanvas","attributes","catch","_oldSize","_oldHardwareScaleFactor","getHardwareScalingLevel","setHardwareScalingLevel","setSize","renderWidth","renderHeight","exitPresent","_onVRDisplayPointerRestricted","_onVRDisplayPointerUnrestricted","_connectVREvents","canvas","document","requestPointerLock","exitPointerLock","_submitVRFrame","submitFrame","isVRPresenting","_requestVRFrame","NativeDataStream","ArrayBuffer","DEFAULT_BUFFER_SIZE","_uint32s","Uint32Array","_int32s","Int32Array","_float32s","Float32Array","_length","_position","_nativeDataStream","_native","_flush","writeUint32","_flushIfNecessary","writeInt32","writeFloat32","writeUint32Array","set","writeInt32Array","writeFloat32Array","writeNativeData","handle","writeBoolean","required","writeBuffer","NativeHardwareTexture","_nativeTexture","existingTexture","setUsage","release","deleteTexture","NativePipelineContext","isParallelCompiled","compilationError","isCompiled","_getVertexShaderCode","_getFragmentShaderCode","_handlesSpectorRebuildCallback","_valueCache","_fillEffectInformation","uniformBuffersNames","uniformsNames","uniforms","samplerList","samplers","attributesNames","bindUniformBlock","getUniforms","uniform","_uniforms","getUniform","getAttributes","_cacheMatrix","uniformName","cache","flag","updateFlag","_cacheFloat2","changed","_cacheFloat3","_cacheFloat4","setInt","setInt2","setInt3","setInt4","setIntArray","array","setIntArray2","setIntArray3","setIntArray4","setUInt","setUInt2","setUInt3","setUInt4","setUIntArray","setUIntArray2","setUIntArray3","setUIntArray4","setFloatArray","setFloatArray2","setFloatArray3","setFloatArray4","setArray","setArray2","setArray3","setArray4","setMatrices","matrices","setMatrix","toArray","setMatrix3x3","setMatrix2x2","setFloat","setBool","setVector2","vector2","setFloat2","setVector3","vector3","setFloat3","setVector4","vector4","setFloat4","setQuaternion","quaternion","setColor3","color3","setColor4","alpha","setDirectColor4","color4","NativeRenderTargetWrapper","__framebuffer","_releaseFramebufferObjects","_framebufferDepthStencil","__framebufferDepthStencil","framebufferDepthStencil","isMulti","disposeOnlyFramebuffers","setAlphaMode","mode","noDepthWriteChange","_alphaMode","depthMask","depthCullingState","setDepthWrite","_cacheRenderPipeline","setDepthWriteEnabled","_alphaState","alphaBlend","setAlphaBlendFunctionParameters","ALPHA_DISABLE","setAlphaBlendEnabled","setAlphaBlendFactors","_blendFunctionParameters","_blendEquationParameters","setAlphaEquation","equation","call","WebGPUComputeContext","getBindGroups","computePipeline","_bindGroups","bindGroupEntriesExist","_bindGroupEntries","location","group","resource","_cacheSampler","getSampler","view","textureAdditionalUsages","StorageBinding","viewForWriting","dataBuffer","webgpuBuffer","_device","createBindGroup","layout","getBindGroupLayout","device","cacheSampler","_Counter","WebGPUComputePipelineContext","stage","sources","computeToken","_compiledComputeEffects","compiledEffect","_onAfterUnbindFrameBufferObservable","contextPipeline","computeContext","createComputePipeline","Auto","computePass","_renderTargetEncoder","beginComputePass","setPipeline","bindGroups","bindGroup","setBindGroup","dispatchWorkgroups","end","webGPUPipelineContextCompute","webGpuContext","dbgShowShaderCode","log","rawCompute","_createComputePipelineStageDescriptor","module","createShaderModule","_createDepthStencilCubeTexture","DepthStencil","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","_setupDepthStencilTexture","_textureHelper","createGPUTextureForInternalTexture","createCubeTexture","files","noMipmap","onLoad","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","createCubeTextureBase","imgs","imageBitmaps","_setCubeMapTextureParams","gpuTextureWrapper","updateCubeTextures","_generateMipmaps","_uploadEncoder","onLoadedObservable","loadMipmap","maxLevel","_cachedWrapU","_cachedWrapV","_maxLodLevel","enableGPUDebugMarkers","_renderEncoder","pushDebugGroup","_currentRenderPass","_pendingDebugCommands","popDebugGroup","insertDebugMarker","updateDynamicIndexBuffer","indexBuffer","gpuBuffer","is32Bits","Uint16Array","_bufferManager","setSubData","updateDynamicVertexBuffer","vertexBuffer","Uint8Array","updateTexture","WebGPUExternalTexture","_setInternalTexture","_currentMaterialContext","_mainRenderPassWrapper","renderPass","_endRenderTargetRenderPass","_mrtAttachments","setMRT","setMRTAttachments","_setDepthTextureFormat","_setColorFormat","createDepthStencilTexture","defaultAttachments","_defaultAttachments","incrementReferences","releaseMSAATexture","lastTextureIsDepthTexture","createMSAATexture","_convertRGBtoRGBATextureData","rgbData","rgbaData","val1","newIndex","getGPUFrameTimeCounter","_timestampQuery","gpuFrameTimeCounter","captureGPUFrameTime","enable","timerQuery","createQuery","_occlusionQuery","deleteQuery","query","isQueryResultAvailable","getQueryResult","beginOcclusionQuery","algorithmType","compatibilityMode","canBeginQuery","_getCurrentRenderPassIndex","_bundleList","_bundleListRenderTarget","addItem","endOcclusionQuery","createRawTexture","compression","Raw","_compression","_doNotHandleContextLost","_bufferView","updateRawTexture","bufferView","createRawCubeTexture","CubeRaw","_bufferViewArray","updateRawCubeTexture","needConversion","faceData","createRawCubeTextureFromUrl","mipmapGenerator","addPendingData","internalCallback","faceDataArrays","faces","mipData","level","mipSize","allFaces","mipFaceData","removePendingData","offlineProvider","request","exception","status","statusText","createRawTexture3D","Raw3D","updateRawTexture3D","createRawTexture2DArray","Raw2DArray","updateRawTexture2DArray","_readTexturePixels","flushRenderer","noDataConversion","flushFramebuffer","readPixels","_readTexturePixelsSync","WebGPURenderTargetWrapper","_renderTargetWrapperCache","createRenderTargetTexture","fullOptions","noColorAttachment","label","_createInternalTexture","RenderTarget","_samples","textureFloatLinearFiltering","createMipMaps","_createDepthStencilTexture","updateRenderTargetTextureSampleCount","createRenderTargetCubeTexture","setSampler","_createBuffer","createRawBuffer","MapRead","CopyDst","copyBufferToBuffer","reject","onEndFrameObservable","mapAsync","Read","copyArrayBuffer","getMappedRange","ctor","unmap","releaseBuffer","reason","_currentDrawContext","setBuffer","IsExternalTexture","copyVideoToTexture","createImageBitmap","bitmap","GenericController","vrGamepad","meshLoaded","ImportMesh","MODEL_BASE_URL","MODEL_FILENAME","newMeshes","_defaultModel","attachToMesh","_handleButtonChange","buttonIdx","state","_DefaultControllerFactory","gamepadInfo","PoseEnabledControllerType","PoseEnabledControllerHelper","InitiateController","factory","_ControllerFactories","canCreate","create","PoseEnabledController","fixedPosition","_trackPosition","_calculatedPosition","browserGamepad","isXR","_maxRotationDistFromHeadset","_draggedRoomRotation","_leftHandSystemQuaternion","_pointingPoseNode","_meshAttachedObservable","GENERIC","_calculatedRotation","_updatePoseAndMesh","Vector3","distanceAway","atan2","cos","rotationAmount","_poseControlledCamera","parents","obj","reverse","getTranslation","forwardWorld","TransformNormal","Normalize","POINTING_POSE","WebVRController","onButtonStateChange","_onButtonStateChange","onTriggerStateChangedObservable","onMainButtonStateChangedObservable","onSecondaryButtonStateChangedObservable","onPadStateChangedObservable","onPadValuesChangedObservable","pad","_changes","pressChanged","touchChanged","valueChanged","_buttons","_setButtonValue","newState","currentState","buttonIndex","pressed","touched","_checkChanges","GamepadManager","_babylonGamepads","_oneGamepadConnected","_isMonitoring","_gamepadEventSupported","_gamepadSupport","getGamepads","observer","_isConnected","notifyObserver","_onGamepadConnectedEvent","isConnected","newGamepad","_addNewGamepad","_startMonitoringGamepads","_onGamepadDisconnectedEvent","disconnectedGamepad","_updateGamepadObjects","_stopMonitoringGamepads","dualShock","search","xboxOne","_checkGamepadsStatus","_loggedErrors","TextureDome","newTexture","_useDirectMapping","CLAMP_ADDRESSMODE","_material","diffuseTexture","coordinatesMode","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","reflectionTexture","_changeTextureMode","_textureMode","fovMultiplier","textureMode","halfDome","_halfDome","_halfDomeMask","crossEye","_crossEye","material","textureUrlOrElement","MODE_MONOSCOPIC","_onBeforeCameraRenderObserver","onLoadErrorObservable","onLoadObservable","resolution","clickToPlay","autoPlay","useDirectMapping","faceForward","_setReady","segments","diameter","BACKSIDE","useEquirectangularFOV","opacityFresnel","_initTexture","slice","rotate","halfDomeMode","crossEyeMode","Forward","uScale","vScale","uOffset","vOffset","vAng","MODE_SIDEBYSIDE","rightOffset","leftOffset","isRightCamera","MODE_TOPBOTTOM","doNotRecurse","disposeMaterialAndTextures","_TimeToken","_timeElapsedQueryEnded","ShadersStore","EffectLayer","_effectLayerOptions","renderingGroupId","mainTexture","_mainTexture","setMaterialForRendering","isArray","currentMesh","_materialForRendering","getEffectIntensity","_effectIntensity","setEffectIntensity","intensity","_vertexBuffers","_maxSize","_mainTextureDesiredSize","_shouldRender","_postProcesses","_textures","_emissiveTextureAndColor","color","neutralColor","isEnabled","disableBoundingBoxesFromEffectLayer","onBeforeRenderMainTextureObservable","onBeforeComposeObservable","onBeforeRenderMeshToEffect","onAfterRenderMeshToEffect","onAfterComposeObservable","onSizeChangedObservable","_SceneComponentInitialization","effectLayers","_mergeDrawWrapper","_generateIndexBuffer","_generateVertexBuffer","_numInternalDraws","_init","mainTextureRatio","alphaBlendingMode","_setMainTextureSize","_createMainTexture","_createTextureAndPostProcesses","_indexBuffer","createIndexBuffer","vertices","PositionKind","mainTextureFixedSize","floor","mainTextureType","TRILINEAR_SAMPLINGMODE","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","renderList","ignoreCameraViewport","customIsReadyFunction","refreshRate","preWarm","subMeshes","subMesh","getMaterial","renderingMesh","getRenderingMesh","hardwareInstancedRendering","_getInstancesRenderList","_id","getReplacementMesh","hasThinInstances","_setEmissiveTextureAndColor","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","setColorWrite","_renderSubMesh","previousAlphaMode","getAlphaMode","onClearObservable","getBoundingBoxRenderer","boundingBoxRendererEnabled","onBeforeBindObservable","onAfterUnbindObservable","_addCustomEffectDefines","useInstances","emissiveTexture","getMesh","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","currentRenderPassId","isReadyForSubMesh","_useMeshMaterial","attribs","uv1","uv2","needAlphaTest","needAlphaTesting","getAlphaTestTexture","needAlphaBlendFromDiffuse","hasAlpha","useAlphaFromDiffuseTexture","_useAlphaFromAlbedoTexture","isVerticesDataPresent","UV2Kind","coordinatesIndex","UVKind","gammaSpace","opacityTexture","useVertexColors","ColorKind","hasVertexAlpha","transparencyMode","MATERIAL_OPAQUE","fallbacks","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","skeleton","isUsingTextureForMatrices","bones","addCPUSkinningFallback","morphTargetManager","morphInfluencers","numInfluencers","isUsingTextureForTargets","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","drawWrapper","_getDrawWrapper","cachedDefines","setEffect","createEffect","maxSimultaneousMorphTargets","render","numDraws","currentEffect","_createMergeEffect","enableEffect","setState","bindBuffers","_internalRender","getSize","_disposeTextureAndPostProcesses","hasMesh","shouldRender","_shouldRenderMesh","_canRenderMesh","needAlphaBlendingForMesh","_shouldRenderEmissiveTextureForMesh","enableAlphaMode","replacementMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","overrideMaterialSideOrientation","ClockWiseSideOrientation","CounterClockWiseSideOrientation","backFaceCulling","zOffset","cullBackFaces","zOffsetUnits","batch","mustReturn","_bind","fillMode","bindForSubMesh","textureMatrix","getTextureMatrix","boneTexture","getTransformMatrixTexture","getTransformMatrices","BindMorphTargetParameters","alphaMode","_processRendering","isInstance","world","resetRefreshCounter","vb","parsedEffectLayer","Instantiate","customType","_","getGlowLayerByName","getEffectName","GlowLayer","EffectName","blurKernelSize","effectiveKernel","_getEffectiveBlurKernelSize","_horizontalBlurPostprocess1","kernel","_verticalBlurPostprocess1","_horizontalBlurPostprocess2","_verticalBlurPostprocess2","_intensity","_includedOnlyMeshes","_excludedMeshes","_meshesUsingTheirOwnMaterials","DefaultTextureRatio","mainTextureSamples","ldrMerge","blurTextureWidth","blurTextureHeight","textureHalfFloatRender","_blurTexture1","blurTextureWidth2","blurTextureHeight2","_blurTexture2","externalTextureSamplerBinding","onApplyObservable","_postProcesses1","_postProcesses2","renderTarget","directRender","internalTexture2","unBindFramebuffer","map","pp","autoClear","needStencil","previousStencilBuffer","getStencilBuffer","setStencilBuffer","drawElementsType","TriangleFillMode","textureLevel","customEmissiveTextureSelector","customEmissiveColorSelector","emissiveColor","emissiveIntensity","addExcludedMesh","removeExcludedMesh","addIncludedOnlyMesh","removeIncludedOnlyMesh","referenceMeshToUseItsOwnMaterial","resetDrawCache","renderPassId","_disposeMesh","unReferenceMeshFromUsingItsOwnMaterial","includedMeshes","getMeshByUniqueId","excludedMeshes","parsedGlowLayer","DefaultBlurKernelSize","LensFlare","AddFlare","imgUrl","system","_system","_drawWrapper","lensFlares","LensFlareSystem","emitter","borderLimit","viewportBorder","layerMask","_isEnabled","_emitter","lensFlareSystems","meshesSelectionPredicate","isVisible","isBlocker","_createIndexBuffer","getEmitter","setEmitter","newEmitter","getEmitterPosition","computeEffectivePosition","globalViewport","Project","_positionX","_positionY","TransformCoordinates","rhs","_isVisible","toGlobal","awayX","awayY","away","Clamp","centerX","centerY","distX","distY","setDepthBuffer","flare","cw","ch","getAspectRatio","cx","cy","viewportMatrix","FromValues","rebuild","parsedLensFlareSystem","getLastEntryById","emitterId","lensFlareSystem","flares","parsedFlare","textureName","asArray","GetFilename","CurrentScreenBlock","VertexAndFragment","_samplerName","convertToGammaSpace","convertToLinearSpace","_isUnique","registerInput","AutoDetect","registerOutput","Color4","Neutral","Color3","Float","_inputs","addExcludedConnectionPointFromAllowedTypes","Vector2","Vector4","_prioritizeVertex","uv","rgba","_outputs","rgb","initialize","_excludeVariableName","sourceBlock","isInput","Fragment","prepareDefines","nodeMaterial","_linearDefineName","_gammaDefineName","isReadyOrNotBlocking","_injectVertexCode","uvInput","connectedPoint","ownerBlock","isAttribute","_emitUniformFromString","associatedVariableName","_mainUVName","_emitVaryingFromString","compilationString","o","isConnectedInVertexShader","_writeTextureRead","output","hasEndpoints","_writeOutput","vertexMode","_tempTextureRead","swizzle","_declareOutput","_buildBlock","_getFreeVariableName","sharedData","blockingBlocks","textureBlocks","blocksWithDefines","_emit2DSampler","isConnectedInFragmentShader","_getFreeDefineName","comments","_emitFunctionFromInclude","isRenderTarget","_deserialize","ImageSourceBlock","markAllMaterialsAsDirty","mat","hasTexture","samplerName","Output","Vertex","bindableBlocks","_dumpPropertiesCode","codeString","_codeVariableName","uAng","wAng","IgnoreTexturesAtLoadTime","ReflectionTextureBaseBlock","_OnGenerateOnlyFragmentCodeChanged","_propertyName","_onGenerateOnlyFragmentCodeChanged","_setTarget","_setInitialTarget","generateOnlyFragmentCode","_getTexture","autoConfigure","additionalFilteringInfo","positionInput","getInputBlockByPredicate","setAsAttribute","connectTo","worldInput","systemValue","World","setAsSystemValue","viewInput","View","_areTexturesDirty","_define3DName","_defineLocalCubicName","boundingBoxSize","_defineExplicitName","_defineSkyboxName","_defineCubicName","_defineSphericalName","_definePlanarName","_defineProjectionName","_defineEquirectangularName","_defineEquirectangularFixedName","_defineMirroredEquirectangularFixedName","_reflectionMatrixName","getReflectionTextureMatrix","_cubeSamplerName","_2DSamplerName","cubeTexture","_reflectionPositionName","boundingBoxPosition","_reflectionSizeName","handleVertexSide","_defineOppositeZ","_worldPositionNameInFragmentOnlyMode","worldPosVaryingName","worldPosition","_positionUVWName","_directionWName","handleFragmentSideInits","_samplerDeclaration","_emitFunction","replaceStrings","replace","_reflectionColorName","_reflectionVectorName","_reflectionCoordsName","handleFragmentSideCodeReflectionCoords","worldNormalVarName","worldPos","onlyReflectionVector","doNotEmitInvertZ","reflectionMatrix","positionUVW","vEyePosition","cameraPosition","handleFragmentSideCodeReflectionColor","lodVarName","swizzleLookupTexture","writeOutputs","varName","_prefiltered","notifiers","onValidation","TBNBlock","tangent","TBN","row0","row1","row2","isSystemValue","normalInput","tangentInput","normalAvailable","connectInputBlock","tangentAvailable","useTBNBlock","FragmentOutputBlock","useLogarithmicDepth","BindLogDepth","hints","needAlphaBlending","aValue","checks","notConnectedNonOptionalInputs","AnimatedInputBlockTypes","remapAttributeName","position2d","particle_uv","particle_color","particle_texturemask","particle_positionw","attributeInFragmentOnly","attributeAsUniform","InputBlock","_type","isUniform","_systemValue","WorldView","WorldViewProjection","ViewProjection","Projection","CameraPosition","FogColor","DeltaTime","MaterialAlpha","CameraParameters","_mode","Undefined","_animationType","None","isBoolean","matrixMode","isConstant","groupInInspector","onValueChangedObservable","setDefaultValue","validateBlockName","newName","attributeName","Attribute","_storedValue","Uniform","valueCallback","_valueCallback","_associatedVariableName","animationType","isUndefined","isVarying","Varying","Time","getAnimationRatio","RealTime","Now","startTime","_emitDefine","define","White","_emitConstant","_emitFloat","toGammaSpaceToRef","useExactSrgbConversions","toLinearSpaceToRef","_noContextSwitch","_emit","constants","_constantDeclaration","_uniformDeclaration","_getGLType","needWorldViewMatrix","needWorldViewProjectionMatrix","animatedInputs","_vertexState","_attributeDeclaration","_transmitWorld","worldView","worldViewProjection","variableName","_transmit","bindEyePosition","fogColor","deltaTime","hasOriginBottomLeft","Int","inputBlocks","codes","valueString","valueType","wellKnownValue","AnisotropyBlock","_tangentCorrectionFactorName","Input","worldTangent","roughness","anisotropy","_generateTBNSpace","worldPositionConnectionPoint","worldNormal","worldNormalConnectionPoint","_emitExtension","tangentReplaceString","getCode","generateTBNSpace","ClearCoatBlock","remapF0OnInterfaceChange","indexOfRefraction","normalMapColor","tintColor","tintAtDistance","tintThickness","clearcoat","intensityInput","_DefaultIndexOfRefraction","f0","pow","eta","mainPBRBlock","endpoints","perturbedNormalBlock","perturbedNormal","_mirroredCameraPosition","invertX","worldPositionVarName","GetCode","ccBlock","reflectionBlock","worldPosVarName","vTBNAvailable","normalShading","_vReflectionMicrosurfaceInfosName","_vReflectionInfosName","reflectionColor","IridescenceBlock","thickness","iridescence","indexOfRefractionInput","thicknessInput","iridescenceBlock","_DefaultMaximumThickness","ReflectionBlock","getInputByName","forceIrradianceInFragment","useSphericalHarmonics","cameraPositionConnectionPoint","viewConnectionPoint","reflection","environmentTexture","_defineLODReflectionAlpha","lodLevelInAlpha","_defineLinearSpecularReflection","linearSpecularLOD","invertZ","isRGBD","SKYBOX_MODE","maxVaryingVectors","lodGenerationScale","lodGenerationOffset","_vReflectionFilteringInfoName","Log2","materialDefines","polynomials","sphericalPolynomial","USESPHERICALFROMREFLECTIONMAP","SPHERICAL_HARMONICS","preScaledHarmonics","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","xx","zz","yy","xy","yz","zx","reflectionVectorName","_vEnvironmentIrradianceName","normalVarName","computeReflectionCoordsFunc","RefractionBlock","linkRefractionWithTransparency","invertRefractionY","useThicknessAsDepth","volumeIndexOfRefraction","refraction","refractionTexture","_defineLODRefractionAlpha","_defineLinearSpecularRefraction","_refractionMatrixName","getRefractionTextureMatrix","indexOfRefractionConnectionPoint","_vRefractionInfosName","_vRefractionMicrosurfaceInfosName","_vRefractionFilteringInfoName","SheenBlock","albedoScaling","linkSheenWithAlbedo","sheen","SubSurfaceBlock","translucencyIntensity","translucencyDiffusionDist","subsurface","translucencyEnabled","ssBlock","translucencyDiffusionDistance","refractionBlock","refractionTintAtDistance","refractionIntensity","refractionView","ParticleBlendMultiplyBlock","alphaTexture","alphaColor","blendColor","ParticleRampGradientBlock","rampColor","ParticleTextureBlock","MorphTargetsBlock","positionOutput","normalOutput","tangentOutput","uvOutput","markAsAttributesDirty","_areAttributesDirty","PrepareDefinesForMorphTargets","replaceRepeatableContent","vertexShaderState","fragmentShaderState","NUM_MORPH_INFLUENCERS","hasNormals","supportsNormals","hasTangents","supportsTangents","hasUVs","supportsUVs","injectionCode","_repeatableContentAnchor","NormalKind","TangentKind","repeatableContentBlocks","repeatKey","VertexOutputBlock","vector","_isLogarithmicDepthEnabled","nodeList","input","fragmentOutputNodes","ColorSplitterBlock","inputsAreExclusive","rgbIn","rgbOut","_inputRename","_outputRename","rgbOutput","rOutput","gOutput","bOutput","aOutput","MultiplyBlock","BasedOnInput","_typeConnectionSource","_linkConnectionTypes","acceptedConnectionPointTypes","left","right","RemapBlock","sourceRange","targetRange","sourceMin","sourceMax","targetMin","targetMax","_writeFloat","TransformBlock","complementW","complementZ","onConnectionObservable","other","otherAsInput","xyz","transform","transformName","nonUniformScaling","TriPlanarBlock","textureY","sourceY","textureZ","sourceZ","_getImageSourceBlock","connectionPoint","imageSourceBlock","samplerYName","samplerZName","hasImageSource","_convertToGammaSpace","_convertToLinearSpace","hideSourceZ","projectAsCube","disableLevelMultiplication","sharpness","toGamma","toLinear","_textureInfoName","_imageSource","_generateTextureLookup","uvx","uvy","uvz","_generateConversionCode","complement","TrigonometryBlockOperations","TrigonometryBlock","operation","Cos","Sin","Abs","Exp","Exp2","Round","Floor","Ceiling","Sqrt","Log","Tan","ArcTan","ArcCos","ArcSin","Fract","Sign","Radians","Degrees","VectorMergerBlock","xSwizzle","ySwizzle","zSwizzle","wSwizzle","xyzwIn","xyzIn","xyIn","zwIn","xyzw","xyzOut","xyOut","zwOut","_buildSwizzle","xInput","yInput","zInput","wInput","xyInput","zwInput","xyzInput","xyzwInput","v4Output","v3Output","v2Output","v2CompOutput","_writeVariable","ViewDirectionBlock","cameraPositionInput","NodeMaterialBlockConnectionPointMode","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","NodeMaterialModes","NodeMaterialSystemValues","NodeMaterialBlock","isUnique","isFinalMerger","_isFinalMerger","_isInput","isTeleportOut","_isTeleportOut","isTeleportIn","_isTeleportIn","buildId","_buildId","outputs","filter","getOutputByName","visibleInInspector","visibleOnFrame","_originalTargetIsNeutral","currentPoint","stringVersion","isOptional","getFirstAvailableInput","forOutput","getFirstAvailableOutput","forBlock","getSiblingOutput","isAnAncestorOf","endpoint","notFound","canConnectTo","updateUniformsAndSamples","uniformBuffers","provideFallbacks","initializeDefines","willBeGeneratedIntoVertexShaderFromFragmentShader","isDirectlyConnectedToVertexOutput","inputIndex0","inputIndex1","looseCoupling","_acceptedConnectionPointType","_linkedConnectionSource","_processBuild","activeBlocks","build","localBlockIsFragment","otherBlockWasGeneratedInVertexShader","_buildTarget","_enforceAssociatedVariableName","reservedNames","reservedName","_customBuildStep","verbose","emitVertex","emitFragment","emitComments","_dumpCode","uniqueNames","alreadyDumped","nameAsVariableName","connectedBlock","_dumpCodeForOutputConnections","connectedOutput","blockType","_deserializePortDisplayNamesAndExposedOnFrame","serializedInputs","serializedOutputs","port","isExposedOnFrame","exposedPortPosition","NodeMaterialConnectionPointCompatibilityStates","NodeMaterialConnectionPointDirection","NodeMaterialConnectionPoint","AreEquivalentTypes","type1","type2","_direction","_ownerBlock","_connectedPoint","innerType","_defaultConnectionPointType","isConnectedToInputBlock","connectedBlocks","_endpoints","createCustomInputBlock","needDualDirectionValidation","excludedConnectionPointTypes","checkCompatibilityState","Compatible","otherBlock","TargetIncompatible","TypeIncompatible","targetBlock","HierarchyIssue","ignoreConstraints","disconnectFrom","bitmask","All","inputName","targetBlockId","targetConnectionName","NodeMaterialBuildState","supportUniformBuffers","functions","extensions","prePassOutput","counters","_varyingTransfer","_injectAtEnd","_repeatableContentAnchorIndex","_builtCompilationString","finalize","isFragmentMode","functionCode","functionName","varyingDeclaration","extensionName","extension","prefix","variableNames","defineNames","_emit2DArraySampler","_emitCodeFromInclude","includeName","substitutionVars","IncludesShadersStore","replaceString","storeKey","removeAttributes","removeUniforms","removeVaryings","removeIfDef","_registerTempVariable","temps","notDefine","varyings","startsWith","toFixed","NodeMaterialBuildStateSharedData","forcedBindableBlocks","blocksWithFallbacks","dynamicUniformBlocks","allowEmptyVertexProgram","emitErrors","errorMessage","notConnectedInput","NodeMaterialConnectionPointCustomObject","_blockType","_blockName","PBRBaseSimpleMaterial","doubleSided","_twoSidedLighting","_markAllSubMeshesAsTexturesDirty","maxSimultaneousLights","disableLighting","invertNormalMapX","invertNormalMapY","occlusionStrength","useLightmapAsShadowmap","_useAmbientInGrayScale","HDRFiltering","_lodGenerationOffset","_lodGenerationScale","quality","hdrScale","_createRenderTarget","textureFloatRender","updateTextureWrappingMode","_prefilterInternal","mipmapsCount","ILog2","_effectWrapper","outputTexture","_effectRenderer","saveStates","intTexture","getInternalTexture","applyEffectWrapper","directions","face","lod","draw","restoreStates","restoreDefaultFramebuffer","_releaseTexture","_swapAndDie","_createEffect","vertexShader","fragmentShader","samplerNames","uniformNames","useShaderStore","prefilter","onFinished","_features","allowTexturePrefiltering","MultiviewRenderTarget","_renderTarget","_getEngine","maxSamples","_bindFrameBuffer","getViewCount","TexturePackerFrame","scale","ProceduralTexture","fragment","fallbackTexture","onGeneratedObservable","onBeforeGenerationObservable","nodeMaterialSource","_currentRefreshId","_frameId","_refreshRate","_floats","_ints","_floatsArrays","_colors3","_colors4","_vectors2","_vectors3","_matrices","_fallbackTextureUsed","_contentUpdateId","_rtWrapper","component","_getComponent","NAME_PROCEDURALTEXTURE","_addComponent","proceduralTextures","_fullEngine","_size","_textureType","_generateMipMaps","setFragment","_fallbackTexture","_createRtWrapper","getEffect","_setEffect","getContent","_contentData","REFRESHRATE_RENDER_ONCE","_getDefines","shaders","_fragment","fragmentElement","vertex","getRenderSize","resize","_checkUniform","setFloats","useCameraPostProcess","viewPort","currentViewport","clearColor","generateMipMapsForCubemap","onGenerated","textureSize","ProceduralTextureSceneComponent","register","_beforeClearStage","registerStep","STEP_BEFORECLEAR_PROCEDURALTEXTURE","_beforeClear","proceduralTexturesEnabled","StartPerformanceCounter","proceduralIndex","proceduralTexture","EndPerformanceCounter","DynamicTexture","_canvas","canRescale","_recreate","releaseInternalTexture","ratio","scaleTo","fillRect","_format","drawText","font","fillStyle","textSize","measureText","fontSize","fillText","_IsCanvasElement","base64String","toDataURL","_invertY","HDRCubeTexture","isBlocking","_isBlocking","rotationY","_rotationY","setReflectionTextureMatrix","RotationY","_boundingBoxSize","sceneOrEngine","generateHarmonics","prefilterOnLoad","supersample","_generateHarmonics","_onError","_coordinatesMode","CUBIC_MODE","_textureMatrix","_prefilterOnLoad","_onLoad","_noMipmap","_supersample","_getFromCache","SetImmediate","useDelayedTextureLoading","delayLoadState","_loadTexture","caps","textureFloat","textureHalfFloat","textureHalfFloatLinearFiltering","previousOnLoad","hdrFiltering","GetCubeMapTextureData","ConvertCubeMapToSphericalPolynomial","results","byteArray","shortArray","dataFace","_FacesMapping","delayLoad","isIdentity","parsedTexture","useInGammaSpace","isSupported","drawBuffersExtension","_count","wrap","textureNames","doNotChangeAspectRatio","drawOnlyOnFirstAttachmentByDefault","_textureNames","_initTypes","_multiRenderTargetOptions","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","defaultType","_createInternaTextureIndexMapping","mapMainInternalTexture2Index","mapInternalTexture2MainIndex","internalTextures","mainIndex","forceFullRebuild","releaseInternalTextures","_releaseTextures","useMipMaps","setSamples","setInternalTexture","disposePrevious","setLayerAndFaceIndex","layerIndices","faceIndices","_processSizeParameter","updateCount","_unbindFrameBuffer","onAfterRenderObservable","doNotDisposeInternalTextures","removeSource","firstChild","removeChild","srcObject","src","removeAttribute","VideoTexture","onUserActionRequestedObservable","_onUserActionRequestedObservable","_processError","_errorFound","_handlePlay","play","hasObservers","muted","otherReason","settings","_stillImageCaptured","_displayingPosterTexture","_currentSrc","_resizeInternalTexture","IsExponentOfTwo","WRAP_ADDRESSMODE","_updateInternalTexture","autoplay","_settings","poster","independentVideoSource","oldHandler","onplaying","oldMuted","pause","_reset","readyState","HAVE_CURRENT_DATA","frameId","getFrameId","_externalTexture","autoUpdateTexture","_initialSamplingMode","_getName","_getVideo","setAttribute","_createInternalTextureOnEvent","videoHasEnoughData","HTMLVideoElement","currentSrc","isNative","SetCorsBehavior","createElement","appendChild","paused","updateURL","CreateFromStreamAsync","stream","constraints","createVideoElement","_badOS","body","style","opacity","bottom","mozSrcObject","URL","createObjectURL","onPlaying","videoTexture","CreateFromWebCamAsync","audioConstaints","mediaDevices","getUserMedia","audio","getTracks","track","stop","CreateFromWebCam","onReady","err","GreasedLineSimpleMaterial","_color","_colorsDistributionType","COLOR_DISTRIBUTION_TYPE_SEGMENT","DEFAULT_COLOR","visibility","useDash","dashRatio","dashOffset","dashCount","sizeAttenuation","DEFAULT_WIDTH_ATTENUATED","DEFAULT_WIDTH","useColors","colorsDistributionType","colorDistributionType","colorsSampling","NEAREST_NEAREST","colorMode","COLOR_MODE_SET","_colors","colors","setColors","_EmptyColorsTexture","_BooleanToNumber","_Color3toRGBAUint8","colorTable","_createColorsTexture","colorsArray","_colorsTexture","TEXTUREFORMAT_RGBA","_colorsSampling","_setColorModeAndColorDistributionType","_colorMode","updateLazy","lazy","forceNewTexture","origColorsCount","colorArray","_width","_useColors","_visibility","_useDash","_dashOffset","_dashRatio","_dashCount","_dashArray","_sizeAttenuation","setColor","_resolution","greasedLineMaterialOptions","parse","_rootUrl","_PrepareEmptyColorsTexture","_decalMap","_uniformBufferLayoutBuilt","UniformBufferEffectCommonAccessor","_isUbo","uboOrEffect","updateMatrix3x3","updateMatrix2x2","updateFloat","updateFloat2","updateFloat3","updateFloat4","updateFloatArray","updateArray","updateIntArray","updateMatrices","updateVector3","updateVector4","updateColor3","updateColor4","updateDirectColor4","updateInt","updateInt2","updateInt3","updateInt4","BoxBlock","evaluateContext","Geometry","subdivisions","subdivisionsX","subdivisionsY","subdivisionsZ","geometry","sizeInput","widthInput","heightInput","depthInput","getConnectedValue","widthSegments","heightSegments","depthSegments","_storedFunction","GeometryInputBlock","isContextual","_contextualSource","contextualValue","Positions","Normals","Colors","Tangents","UV","UV2","UV3","UV4","UV5","UV6","VertexID","GeometryID","CollectionID","FaceID","LoopID","getContextualValue","GeometryOutputBlock","currentVertexData","_vertexData","vertexData","NodeGeometryBlockConnectionPointTypes","NodeGeometryContextualSources","NodeGeometryBlock","buildExecutionTime","_buildExecutionTime","isAnAncestorOfType","getDescendantOfPredicate","descendant","onBuildObservable","valueMin","valueMax","defaultValue","now","_saveMeshData","NodeGeometryBuildState","_rotationMatrix","_scalingMatrix","_positionMatrix","_scalingRotationMatrix","_transformMatrix","noContextualData","geometryContext","executionContext","getExecutionIndex","getOverridePositionsContextualValue","positions","getOverrideNormalsContextualValue","normals","tangents","uvs","uvs2","uvs3","uvs4","uvs5","uvs6","getExecutionFaceIndex","getExecutionLoopIndex","metadata","collectionId","adapt","adaptInput","_instantiate","currentPosition","additionalVertexData","ScalingToRef","clonePositionIndex","fromArray","_instantiateWithMatrix","decalMap","_projectOnTrianglesToRef","step","checkStopper","ref","proj","tmp","indexCount","p0","tmpDist","ProjectOnTriangleToRef","_projectOnUnIndexedTrianglesToRef","verticesStart","verticesCount","projectToRef","_unIndexed","HDRTools","_Ldexp","mantissa","exponent","_Rgbe2float","float32array","red","green","blue","_ReadStringLine","uint8array","startIndex","line","character","RGBE_ReadHeader","endOfHeader","findFormat","lineIndex","exec","dataPosition","hdrInfo","RGBE_ReadPixels","ConvertPanoramaToCubemap","_RGBEReadPixelsRLE","num_scanlines","scanline_width","dataIndex","endIndex","scanLineArrayBuffer","scanLineArray","resultBuffer","resultArray","_RGBEReadPixelsNOTRLE","PanoramaToCubeMapTools","float32Array","inputWidth","inputHeight","front","CreateCubemapTexture","FACE_FRONT","back","FACE_BACK","FACE_LEFT","FACE_RIGHT","up","FACE_UP","down","FACE_DOWN","texSize","textureArray","round","sampleFactor","sampleFactorSqr","rotDX1","rotDX2","dy","fy","sy","xv1","xv2","sx","CalcProjectionSpherical","vDir","theta","phi","dx","px","py","inputY","DynamicFloat32Array","itemCapacity","_view","_itemLength","itemLength","at","NaN","subarray","start","item","_growArray","newCapacity","InitialArraySize","TimestampColHeader","NumPointsColHeader","CarriageReturnRegex","PerformanceViewerCollector","SliceDataOffset","NumberOfPointsOffset","_enabledStrategyCallbacks","_collectDataAtFrame","timestamp","_startingTimestamp","numPoints","datasets","ids","numberOfIndices","startingIndices","startingIndex","previousStartingIndex","strategy","_strategies","getData","datasetObservable","Map","_datasetMeta","_eventRestoreSet","Set","_customEventObservable","metadataObservable","addCollectionStrategies","registerEvent","forceUpdate","category","has","delete","strategyCallback","counter","afterRenderObserver","stringObserver","eventVal","sendEvent","_restoreStringEvents","observers","strategyCallbacks","hidden","_getHexColorFromId","hash","charCodeAt","hex","getCurrentSlice","updateMetadata","prop","meta","preserveStringEventsRestore","_hasLoadedData","hasLoadedData","loadFromFileData","keepDatasetMeta","s","numPointsIndex","parsedDatasets","firstLine","dataLines","idCategoryMap","val","exportDataToCsv","csvContent","diff","fileName","Date","toISOString","Download","Blob","shouldPreserve","_isStarted","isStarted","getPerfCollector","_perfCollector","P","DDSD_MIPMAPCOUNT","DDPF_LUMINANCE","FourCCToInt32","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","DDSTools","GetDDSInfo","header","extendedHeader","headerLengthInt","mipmapCount","fourCC","dxgiFormat","isFourCC","isRGB","isLuminance","isCompressed","_GetHalfFloatAsFloatRGBAArrayBuffer","dataOffset","dataLength","arrayBuffer","destArray","srcData","srcPos","StoreLODInAlphaChannel","_GetHalfFloatRGBAArrayBuffer","_GetFloatRGBAArrayBuffer","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetFloatAsUIntRGBAArrayBuffer","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetRGBAArrayBuffer","rOffset","gOffset","bOffset","aOffset","_ExtractLongWordOrder","_GetRGBArrayBuffer","_GetLuminanceArrayBuffer","UploadDDSLevels","loadMipmaps","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","mip","internalCompressedFormat","blockBytes","bpp","computeFormats","startFace","floatArray","_badDesktopOS","floatAvailable","halfFloatAvailable","destType","dataGetter","dataGetterPolynomial","_uploadDataToTextureDirectly","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","_uploadCompressedDataToTextureDirectly","createPrefilteredCubeTexture","loadData","_sphericalPolynomial","_source","CubePrefiltered","textureLOD","minLODIndex","maxLODIndex","mipmapIndex","glTextureFromLod","Temp","TEXTURE_CUBE_MAP","LINEAR","isDDS","lodTexture","_isCube","_lodTextureHigh","_lodTextureMid","_lodTextureLow","ColorGradient","gradient","color1","color2","getColorToRef","random","Color3Gradient","FactorGradient","factor1","factor2","getFactor","GradientHelper","GetCurrentGradient","gradients","updateFunc","gradientIndex","currentGradient","nextGradient","lastIndex","GreasedLineTools","OmitZeroLengthPredicate","MeshesToLines","points","meshIndex","getVerticesData","getIndices","ii","vi1","vi2","vi3","pointsFromPredicate","ToVector3Array","ToNumberArray","flatMap","GetPointsCountInfo","counts","total","GetLineLength","point1","SegmentizeSegmentByCount","point2","segmentCount","dividedLinePoints","divisor","setAll","segmentVector","divideToRef","nextPoint","SegmentizeLineBySegmentLength","what","segmentLength","subLines","GetLineSegments","ceil","seg","SegmentizeLineBySegmentCount","GetMinMaxSegmentLength","sorted","sort","GetPositionOnLineByVisibility","lineSegments","lineLength","visbility","localSpace","lengthVisibilityRatio","sumSegmentLengths","segmentIndex","lineSegmentsLength","GetCircleLinePoints","radiusX","radiusY","segmentAngle","GetBezierLinePoints","CreateQuadraticBezier","getPoints","GetArrowCap","widthUp","widthDown","widthStartUp","widthStartDown","widths","GetPointsFromText","fontData","includeInner","allPoints","shapePaths","sp","paths","points2d","p2d","holes","KhronosTextureContainer","facesExpected","isInvalid","IsValid","dataSize","BYTES_PER_ELEMENT","headerDataView","DataView","littleEndian","getUint32","glType","glTypeSize","glFormat","glInternalFormat","glBaseInternalFormat","pixelWidth","pixelHeight","pixelDepth","numberOfArrayElements","numberOfFaces","numberOfMipmapLevels","bytesOfKeyValueData","loadType","COMPRESSED_2D","uploadLevels","_upload2DCompressedLevels","TEX_2D","COMPRESSED_3D","TEX_3D","HEADER_LEN","imageSize","identifier","runCoroutineAsync","coroutine","_coroutineScheduler","schedulerAndDispose","observable","coroutines","onSteps","onErrors","shift","scheduler","onStep","CreateObservableScheduler","_coroutineSchedulerDispose","cancelAllCoroutines","PivotTools","_PivotCached","getPivotPointToRef","_OldPivotPoint","_PivotPostMultiplyPivotMatrix","_postMultiplyPivotMatrix","equalsToFloats","setPivotMatrix","IdentityReadOnly","getPivotPoint","_PivotTranslation","_PivotTmpVector","setPivotPoint","serializedGeometries","SerializeGeometry","serializationGeometries","doNotSerialize","serializeVerticeData","SerializeMesh","serializationScene","_geometry","getGeometryById","geometries","SceneSerializer","ClearCache","_Serialize","checkSyncReadSupported","supportSyncTextureRead","ForceSerializeBuffers","ambientColor","gravity","collisionsEnabled","fogMode","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","morphTargetManagers","abstractMesh","lights","cameras","activeCameraID","AppendSerializedAnimations","animationGroups","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","materials","multiMaterials","multiMaterial","_files","environmentTextureRotationY","environmentIntensity","skeletons","transformNodes","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","getGeometries","particleSystems","postProcesses","_serializableComponents","SerializeAsync","promises","_CollectPromises","all","hasOwnProperty","toSerialize","withParents","withChildren","serializeMaterial","submaterial","subMaterials","defaultMaterial","transformNode","FinalizeSingleNode","JoystickAxis","VirtualJoystick","_GetDefaultOptions","puckSize","containerSize","puckImage","containerImage","alwaysVisible","limitToContainer","leftJoystick","customizations","_released","_leftJoystick","_GlobalJoystickIndex","_axisTargetedByLeftAndRight","_axisTargetedByUpAndDown","reverseLeftRight","reverseUpDown","_touches","deltaPosition","_joystickSensibility","_inversedSensibility","_onResize","_VJCanvasWidth","innerWidth","_VJCanvasHeight","innerHeight","Canvas","_HalfWidth","backgroundColor","top","zIndex","touchAction","_VJCanvasContext","strokeStyle","lineWidth","_joystickColor","setPosition","setPuckImage","setContainerImage","_AlwaysVisibleSticks","_joystickPointerId","_joystickPointerPos","_joystickPreviousPointerPos","_joystickPointerStartPos","_deltaJoystickVector","_onPointerDownHandlerRef","_onPointerDown","_onPointerMoveHandlerRef","_onPointerMove","_onPointerUpHandlerRef","_onPointerUp","requestAnimationFrame","_drawVirtualJoystick","setJoystickSensibility","newJoystickSensibility","positionOnScreenCondition","_joystickPosition","_action","prevX","prevY","deltaJoystickX","deltaJoystickY","_clearPreviousDraw","setJoystickColor","newColor","newSize","_joystickContainerSize","_clearContainerSize","_clearContainerSizeOffset","_joystickPuckSize","_clearPuckSize","_clearPuckSizeOffset","clearPosition","_alwaysVisible","setActionOnTouch","setAxisForLeftRight","setAxisForUpDown","jp","urlPath","image","Image","onload","_containerImage","_puckImage","_drawContainer","beginPath","arc","stroke","closePath","_drawPuck","releaseCanvas","BoxParticleEmitter","direction1","direction2","minEmitBox","maxEmitBox","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","randX","RandomRange","randY","randZ","TransformNormalFromFloatsToRef","startPositionFunction","positionToUpdate","TransformCoordinatesFromFloatsToRef","newOne","applyToShader","buildUniformLayout","getEffectDefines","ConeParticleEmitter","_buildHeight","_angle","_height","tan","directionRandomizer","radiusRange","heightRange","emitFromSpawnPointOnly","_localPosition","CustomParticleEmitter","particlePositionGenerator","particleDestinationGenerator","tmpVector","diffVector","lifeTime","CylinderParticleEmitter","inverseWorldMatrix","yPos","radiusDistribution","positionRadius","xPos","zPos","CylinderDirectedParticleEmitter","HemisphericParticleEmitter","randRadius","MeshParticleEmitter","_indices","_positions","_normals","_storedNormal","useMeshNormalsForDirection","randomFaceIndex","bu","bv","bw","faceIndexA","faceIndexB","faceIndexC","vertexA","vertexB","vertexC","randomVertex","meshId","getLastMeshById","PointParticleEmitter","SphereParticleEmitter","SphereDirectedParticleEmitter","BaseParticleSystem","noiseTexture","_noiseTexture","isAnimationSheetEnabled","_isAnimationSheetEnabled","_useLogarithmicDepth","fragmentDepthSupported","_hasTargetStopDurationDependantGradient","_startSizeGradients","_emitRateGradients","_lifeTimeGradients","getDragGradients","_dragGradients","getLimitVelocityGradients","_limitVelocityGradients","getColorGradients","_colorGradients","getSizeGradients","_sizeGradients","getColorRemapGradients","_colorRemapGradients","getAlphaRemapGradients","_alphaRemapGradients","getLifeTimeGradients","getAngularSpeedGradients","_angularSpeedGradients","getVelocityGradients","_velocityGradients","getStartSizeGradients","getEmitRateGradients","particleEmitterType","billboardMode","_billboardMode","isBillboardBased","_isBillboardBased","imageProcessingConfiguration","_imageProcessingConfiguration","_attachImageProcessingConfiguration","configuration","_removeGradientAndTexture","valueGradient","animations","emitRate","manualEmitCount","updateSpeed","targetStopDuration","disposeOnStop","minEmitPower","maxEmitPower","minLifeTime","maxLifeTime","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minInitialRotation","maxInitialRotation","minAngularSpeed","maxAngularSpeed","customShader","preventAutoStart","_wasDispatched","noiseStrength","onAnimationEnd","blendMode","BLENDMODE_ONEONE","forceDepthWrite","preWarmCycles","preWarmStepOffset","spriteCellChangeSpeed","startSpriteCellID","endSpriteCellID","spriteCellWidth","spriteCellHeight","spriteCellLoop","spriteRandomStartCell","translationPivot","beginAnimationOnStart","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","worldOffset","_rampGradients","startDelay","limitVelocityDamping","colorDead","textureMask","_isSubEmitter","_imageProcessingConfigurationDefines","createPointEmitter","particleEmitter","createHemisphericEmitter","createSphereEmitter","createDirectedSphereEmitter","createCylinderEmitter","createDirectedCylinderEmitter","createConeEmitter","createBoxEmitter","BLENDMODE_STANDARD","BLENDMODE_ADD","BLENDMODE_MULTIPLY","BLENDMODE_MULTIPLYADD","GPUParticleSystem","IsSupported","LastCreatedEngine","supportTransformFeedbacks","_linesIndexBufferUseInstancing","getCapacity","maxActiveParticleCount","_maxActiveParticleCount","activeParticleCount","particleTexture","_getWrapper","_platform","isUpdateBufferCreated","isUpdateBufferReady","_recreateUpdateEffect","_started","isStopping","getActiveCount","_currentActiveCount","_preWarmDone","beginAnimation","_releaseBuffers","releaseVertexBuffers","_targetIndex","getCustomEffect","_customWrappers","_getCustomDrawWrapper","setCustomEffect","onBeforeDrawParticlesObservable","_onBeforeDrawParticlesObservable","vertexShaderName","vertexBuffers","_renderVertexBuffers","addColorGradient","colorGradient","_refreshColorGradient","reorder","_colorGradientsTexture","forceRefreshGradients","_refreshFactorGradient","removeColorGradient","_drawWrappers","drawContext","_addFactorGradient","factorGradients","factor","addSizeGradient","removeSizeGradient","_sizeGradientsTexture","that","addAngularSpeedGradient","removeAngularSpeedGradient","_angularSpeedGradientsTexture","addVelocityGradient","removeVelocityGradient","_velocityGradientsTexture","addLimitVelocityGradient","removeLimitVelocityGradient","_limitVelocityGradientsTexture","addDragGradient","removeDragGradient","_dragGradientsTexture","addEmitRateGradient","removeEmitRateGradient","addStartSizeGradient","removeStartSizeGradient","addColorRemapGradient","removeColorRemapGradient","addAlphaRemapGradient","removeAlphaRemapGradient","addRampGradient","removeRampGradient","getRampGradients","useRampGradients","addLifeTimeGradient","removeLifeTimeGradient","customEffect","_accumulatedCount","_currentRenderId","_currentRenderingCameraUniqueId","_timeDelta","updateInAnimate","_actualFrame","_rawTextureWidth","onStoppedObservable","isGPU","defaultProjectionMatrix","PerspectiveFovLH","getUniqueId","useInstancing","randomTextureSize","optionsAsNumber","isFinite","_randomTexture","_randomTexture2","_randomTextureSize","_createVertexBuffers","updateBuffer","renderBuffer","spriteSource","renderVertexBuffers","createVertexBuffer","_attributesStrideSize","BILLBOARDMODE_STRETCHED","alignDataInBuffer","createVertexBuffers","force","_buffer0","usingCustomEmitter","particleIndex","numDummies","spriteData","bufferData1","createParticleBuffer","bufferData2","_buffer1","_spriteBuffer","_sourceBuffer","_targetBuffer","_createColorGradientTexture","_createSizeGradientTexture","_createAngularSpeedGradientTexture","_createVelocityGradientTexture","_createLimitVelocityGradientTexture","_createDragGradientTexture","_cachedUpdateDefines","_updateBuffer","createUpdateBuffer","customWrapper","fillDefines","fillUniformsAttributesAndSamplerNames","_GetAttributeNamesOrOptions","hasColorGradients","isBillboardStretched","attributeNamesOrOptions","_GetEffectCreationOptions","effectCreationOption","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","PrepareUniforms","PrepareSamplers","_update","_createFactorGradientTexture","CreateRTexture","tmpColor","CreateRGBATexture","_render","emitterWM","viewMatrix","baseSize","getBaseSize","invView","applyByPostProcess","bindDrawBuffers","forceWireframe","drawArraysType","unbindInstanceAttributes","emitterPosition","preUpdateParticleBuffer","updateParticleBuffer","tmpBuffer","forceUpdateOnly","intPart","outparticles","checkUpdateEffect","contextLost","releaseBuffers","disposeTexture","rvb","cloneTexture","custom","program","createEffectForParticles","shaderOptions","serialization","serializeTexture","parsedParticleSystem","doNotStart","particleSystem","_Parse","Particle","colorStep","age","angularSpeed","cellIndex","_attachedSubEmitters","_currentColor1","_currentColor2","_currentSize1","_currentSize2","_currentAngularSpeed1","_currentAngularSpeed2","_currentVelocity1","_currentVelocity2","_currentLimitVelocity1","_currentLimitVelocity2","_currentDrag1","_currentDrag2","_Count","_updateCellInfoFromSystem","updateCellIndex","offsetAge","changeSpeed","_randomCellOffset","dist","_initialEndSpriteCellID","_initialStartSpriteCellID","_initialSpriteCellLoop","_inheritParticleInfoToSubEmitter","subEmitter","emitterMesh","inheritDirection","normalizeToRef","setDirection","inheritedVelocityAmount","_inheritedVelocityOffset","_inheritParticleInfoToSubEmitters","_currentColorGradient","_currentSizeGradient","_currentAngularSpeedGradient","_currentVelocityGradient","_currentLimitVelocityGradient","_currentDragGradient","copyTo","_initialDirection","remapData","_randomNoiseCoordinates1","_randomNoiseCoordinates2","ParticleSystem","onDispose","_onDisposeObserver","_useRampGradients","_resetEffect","particles","_particles","isAlive","_useInstancing","epsilon","_emitterInverseWorldMatrix","_stockParticles","_newPartsExcess","_scaledColorStep","_colorDiff","_scaledDirection","_scaledGravity","_currentEmitRate1","_currentEmitRate2","_currentStartSize1","_currentStartSize2","_disposeEmitterOnDispose","recycleParticle","lastParticle","_createParticle","_subEmitters","subEmitters","ATTACHED","_emitFromParticle","templateIndex","END","subSystem","_rootParticleSystem","activeSubSystems","vertexArrayObject","_vertexArrayObject","instancedArrays","noiseTextureData","updateFunction","noiseTextureSize","sameParticleArray","scaledUpdateSpeed","_scaledUpdateSpeed","previousAge","directionScale","limitVelocity","drag","_emitterWorldMatrix","fetchedColorR","_fetchR","fetchedColorG","fetchedColorB","scaledForce","newGradient","_removeFactorGradient","factorGradient","_createRampGradientTexture","_rampGradientsTexture","_syncRampGradientTexture","rampGradient","drawWrappers","u","pixels","_vertexBuffer","releaseVertexArrayObject","_vertexBufferSize","BILLBOARDMODE_STRETCHED_LOCAL","vertexSize","cellIndexBuffer","directionBuffer","rampDataBuffer","offsets","indicesWireframe","_linesIndexBuffer","_alive","_prepareSubEmitterInternalArray","_currentEmitRateGradient","_currentStartSizeGradient","noiseTextureAsProcedural","stopSubEmitters","_stopSubEmitters","_appendParticleVertex","initialDirection","_removeFromRoot","newParticles","factorGradient1","factorGradient2","lifeTime1","lifeTime2","emitPower","supportRenderPasses","attributesNamesOrOptions","preWarmOnly","rate","_toBeDisposed","_appendParticleVertices","updateDirectly","defaultViewMatrix","recordVertexArrayObject","bindVertexArrayObject","_activeParticleSystems","subs","cell","sub","colorGradients","serializedGradient","rampGradients","colorRemapGradients","colorRemapGradient","alphaRemapGradients","alphaRemapGradient","sizeGradients","sizeGradient","angularSpeedGradients","angularSpeedGradient","velocityGradients","velocityGradient","dragGradients","dragGradient","emitRateGradients","emitRateGradient","startSizeGradients","startSizeGradient","lifeTimeGradients","lifeTimeGradient","limitVelocityGradients","limitVelocityGradient","internalClass","animationIndex","parsedAnimation","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","emitterType","cellArray","_ParseParticleSystem","AddParser","NAME_PARTICLESYSTEM","parsedData","container","individualParser","GetIndividualParser","AddIndividualParser","fragmentName","allSamplers","getEmittedParticleSystems","getHierarchyEmittedParticleSystems","descendants","ParticleSystemSet","_emitterNodeIsOwned","systems","emitterNode","_emitterNode","setEmitterAsSphere","_emitterCreationOptions","kind","gpu","BaseAssetsUrl","SubEmitterType","SubEmitter","CannonJSPlugin","_useDeltaForWorldStep","iterations","cannonInjection","CANNON","_physicsMaterials","_fixedTimeStep","_physicsBodiesToRemoveAfterStep","_firstFrame","_tmpQuaternion","_minus90X","_plus90X","_tmpPosition","_tmpDeltaPosition","_tmpUnityRotation","BJSCANNON","_extendNamespace","broadphase","NaiveBroadphase","solver","_cannonRaycastResult","RaycastResult","_raycastResult","getPluginVersion","setGravity","vec","setTimeStep","timeStep","getTimeStep","executeStep","impostors","impostor","HeightmapImpostor","PlaneImpostor","beforeStep","_removeMarkedPhysicsBodiesFromWorld","physicsBody","removeBody","applyImpulse","contactPoint","worldPoint","Vec3","impulse","applyForce","generatePhysicsBody","removePhysicsBody","isBodyInitRequired","shape","_createShape","oldBody","_addMaterial","getParam","bodyCreationObject","mass","nativeOptions","Body","onCollide","afterStep","addShape","addBody","_processChildMeshes","_updatePhysicsBodyTransformation","mainImpostor","meshChildren","getChildMeshes","mainRotation","conjugateToRef","processMesh","childImpostor","getPhysicsImpostor","pPosition","q","multiply","resetUpdateFlags","Quaternion","physicsImpostor","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","constraint","jointData","joint","constraintData","pivotA","mainPivot","pivotB","connectedPivot","axisA","mainAxis","axisB","connectedAxis","maxForce","nativeParams","collideConnected","collision","HingeJoint","Hinge2Joint","HingeConstraint","DistanceJoint","DistanceConstraint","maxDistance","SpringJoint","springData","Spring","restLength","stiffness","damping","localAnchorA","localAnchorB","LockJoint","LockConstraint","PointToPointJoint","BallAndSocketJoint","PointToPointConstraint","physicsJoint","addConstraint","forceApplicationCallback","registerAfterPhysicsStep","removeJoint","removeConstraint","unregisterAfterPhysicsStep","friction","restitution","currentMat","Material","_checkWithEpsilon","impostorExtents","getObjectExtents","SphereImpostor","radiusZ","Sphere","CylinderImpostor","radiusTop","radiusBottom","numSegments","Cylinder","quat","setFromAxisAngle","translation","transformAllPoints","BoxImpostor","box","Box","Plane","MeshImpostor","rawVerts","rawFaces","oldPosition","oldRotation","oldQuaternion","getParentsRotation","conjugateInPlace","transformedVertices","Trimesh","oldPosition2","oldRotation2","oldQuaternion2","_createHeightmap","ParticleImpostor","NoImpostor","pointDepth","arraySize","dim","extendSizeWorld","minY","elementSize","loc","newValue","Heightfield","center","getObjectCenter","getAbsolutePivotPoint","divideInPlace","setDeltaRotation","oldPivot","getPivotMatrix","setPreTransformMatrix","centerWorld","negate","setDeltaPosition","setTransformationFromPhysicsBody","setPhysicsBodyTransformation","newPosition","newRotation","setLinearVelocity","velocity","setAngularVelocity","angularVelocity","getLinearVelocity","getAngularVelocity","setBodyMass","updateMassProperties","getBodyMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","sleepBody","sleep","wakeUpBody","wakeUp","updateDistanceJoint","setMotor","motorIndex","enableMotor","setMotorSpeed","setLimit","minForce","motorEquation","syncMeshWithImpostor","getRadius","shapes","boundingSphereRadius","getBoxSizeToRef","halfExtents","step_tmp1","dt","timeSinceLastCalled","maxSubSteps","internalStep","time","internalSteps","performance","h_div_dt","interpvelo","bodies","STATIC","sleepState","SLEEPING","vsub","previousPosition","vadd","interpolatedPosition","interpolatedQuaternion","raycast","raycastToRef","raycastClosest","hasHit","setHitData","hitNormalWorld","hitPointWorld","setHitDistance","DefaultPluginFactory","OimoJSPlugin","oimoInjection","OIMO","_tmpImpostorsArray","_tmpPositionVector","BJSOIMO","contact","contacts","touching","body1","sleeping","body2","next","collidingImpostor","invScale","bodyConfig","config","posShape","rot","rotShape","move","density","checkWithEpsilon","globalQuaternion","toEulerAngles","radToDeg","localPosition","sizeX","sizeY","sizeZ","resetQuaternion","updatePosition","removeRigidBody","nativeJointData","axe1","axe2","pos1","pos2","spring","PrismaticJoint","SliderJoint","WheelJoint","getPosition","getQuaternion","syncShapes","awake","linearVelocity","staticBody","setupMass","minDistance","limitMotor","upperLimit","lowerLimit","motor","rotationalLimitMotor2","rotationalLimitMotor1","rotationalLimitMotor","halfWidth","halfHeight","halfDepth","PostProcessRenderEffect","getPostProcesses","singleInstance","_singleInstance","_getPostProcesses","_cameras","_indicesForCamera","pps","ppIndex","_attachCameras","cameraKey","cams","MakeArray","cameraName","postProcess","attachPostProcess","_detachCameras","detachPostProcess","_enable","_disable","PostProcessRenderPipeline","_renderEffects","_renderEffectsForIsolatedPass","renderEffectName","addEffect","renderEffect","_enableEffect","renderEffects","_disableEffect","unique","indicesToDelete","_enableMSAAOnFirstPostProcess","sampleCount","supportMSAA","effectKeys","setPrePassRenderer","prePassRenderer","PostProcessRenderPipelineManager","_renderPipelines","supportedPipelines","renderPipelineName","pipeline","addPipeline","renderPipeline","removePipeline","attachCamerasToRenderPipeline","detachCamerasFromRenderPipeline","enableEffectInPipeline","disableEffectInPipeline","AnaglyphPostProcess","rigCameras","reusable","_passedProcess","setTextureFromPostProcess","BloomEffect","threshold","_downscale","_merge","_blurX","_bloomScale","_blurY","bloomWeight","bloomKernel","pipelineTextureType","blockCompilation","_effects","alwaysForcePOT","disposeEffects","effectIndex","_updateEffects","updateEffect","BloomMergePostProcess","originalFromInput","blurred","setTextureFromPostProcessOutput","ChromaticAberrationPostProcess","screenWidth","screenHeight","aberrationAmount","radialIntensity","centerPosition","parsedPostProcess","targetCamera","renderTargetSamplingMode","CircleOfConfusionPostProcess","lensSize","fStop","focusDistance","focalLength","_depthTexture","cocPrecalculation","DepthOfFieldBlurPostProcess","circleOfConfusion","imageToBlur","DepthOfFieldEffectBlurLevel","DepthOfFieldEffect","_circleOfConfusion","blurLevel","Low","circleOfConfusionTextureFormat","_depthOfFieldBlurY","_depthOfFieldBlurX","blurCount","kernelSize","High","Medium","adjustedKernelSize","blurY","blurX","_dofMerge","DepthOfFieldMergePostProcess","_blurSteps","ExtractHighlightsPostProcess","_exposure","_inputPostProcess","FxaaPostProcess","texelSize","glInfo","getGlInfo","renderer","GrainPostProcess","animated","ImageProcessingPostProcess","doNotBuild","_imageProcessingObserver","onUpdateParameters","getCamera","scenes","_updateParameters","colorCurves","colorCurvesEnabled","colorGradingTexture","colorGradingEnabled","exposure","toneMappingEnabled","toneMappingType","contrast","vignetteStretch","vignetteCentreX","vignetteCenterX","vignetteCentreY","vignetteCenterY","vignetteWeight","vignetteColor","vignetteCameraFov","vignetteBlendMode","vignetteEnabled","ditheringIntensity","ditheringEnabled","fromLinearSpace","_fromLinearSpace","_defines","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","FROMLINEARSPACE","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","EXPOSURE","SKIPFINALCOLORCLAMP","onApply","MotionBlurConfiguration","texturesRequired","MotionBlurPostProcess","motionBlurSamples","_motionBlurSamples","_updateEffect","isObjectBased","_isObjectBased","_applyMode","_geometryBufferRenderer","_forceGeometryBuffer","geometryBufferRenderer","_prePassRenderer","motionStrength","_invViewProjection","_previousViewProjection","forceGeometryBuffer","enableGeometryBufferRenderer","enableVelocity","enablePrePassRenderer","_prePassEffectConfiguration","excludeSkinnedMesh","skinnedMesh","list","excludedSkinnedMeshesFromVelocity","excludedSkinnedMesh","removeExcludedSkinnedMesh","_previousTransformationMatrices","_previousBonesTransformationMatrices","_onApplyObjectBased","_onApplyScreenBased","velocityIndex","getTextureIndex","VELOCITY_TEXTURE_TYPE","getGBuffer","getIndex","getRenderTarget","viewProjection","depthIndex","DEPTH_TEXTURE_TYPE","ScreenSpaceReflectionsConfiguration","ScreenSpaceReflectionPostProcess","strength","reflectionSpecularFalloffExponent","roughnessFactor","_enableSmoothReflections","_reflectionSamples","_smoothSteps","enablePosition","enableReflectivity","_updateEffectDefines","positionIndex","POSITION_TEXTURE_TYPE","roughnessIndex","REFLECTIVITY_TEXTURE_TYPE","normalIndex","projectionMatrix","_isSceneRightHanded","enableSmoothReflections","reflectionSamples","smoothSteps","steps","SharpenPostProcess","colorAmount","edgeAmount","VRDistortionCorrectionPostProcess","isRightEye","_isRightEye","_distortionFactors","_postProcessScaleFactor","_lensCenterOffset","adaptScaleToCurrentViewport","_scaleIn","_scaleFactor","_lensCenter","VRMultiviewToSingleviewPostProcess","scaleFactor","cam","isLeftCamera","removeReflectionProbe","toRemove","addReflectionProbe","newReflectionProbe","ReflectionProbe","useFloat","linearSpace","_add","_invertYAxis","_parentContainer","_sceneUBOs","_renderTargetTexture","currentApplyByPostProcess","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","_attachedMesh","lookAtFunction","LookAtRHToRef","LookAtLHToRef","perspectiveFunction","PerspectiveFovRH","Up","setTransformMatrix","rigParent","_forcedViewPosition","_currentSceneUBO","updateTransformMatrix","setRenderingAutoClearDepthStencil","autoClearDepthStencil","fullDetails","ret","isReflectionProbe","parsedReflectionProbe","rp","renderTargetSize","_waitingRenderList","DepthPeelingEffectConfiguration","DepthPeelingRenderer","passCount","_passCount","_createRenderPassIds","useRenderPasses","_useRenderPasses","usePasses","_thinTextures","_currentPingPongState","_layoutCacheFormat","_layoutCache","_candidateSubMeshes","_excludedSubMeshes","_colorCache","_DEPTH_CLEAR_VALUE","_MIN_DEPTH","_MAX_DEPTH","_renderPassIds","_createEffects","_releaseRenderPassIds","createRenderPassId","releaseRenderPassId","_depthMrts","_colorMrts","_blendBackMrt","_outputRT","optionsArray","frontColorTexture","backColorTexture","_disposeTextures","_updateTextures","_updateTextureReferences","textureIndex","prePassTexture","defaultRT","_blendBackTexture","_shareDepth","_blendBackEffectWrapper","_blendBackEffectWrapperPingPong","_finalEffectWrapper","addEffectConfiguration","_renderSubMeshes","mapMaterialContext","previousShaderHotSwapping","previousBFC","firstDraw","allowShaderHotSwapping","materialContext","newMaterialContext","createMaterialContext","_finalCompose","writeId","setCustomOutput","applyStates","_getRenderingFillMode","TriangleFanDrawMode","TriangleStripDrawMode","depthTest","resetCachedMaterial","readId","blendBackEffectWrapper","FluidRenderingDepthTextureCopy","depthRTWrapper","_depthRTWrapper","_copyTextureToTexture","copy","FluidRenderingObject","particleSize","_particleSize","onParticleSizeChanged","useVelocity","_useVelocity","use","_hasVelocity","_effectsAreDirty","priority","particleThicknessAlpha","_depthEffectWrapper","_thicknessEffectWrapper","attributeNames","depthEffect","thicknessEffect","renderDepthTexture","numParticles","depthDrawWrapper","renderThicknessTexture","thicknessDrawWrapper","renderDiffuseTexture","FluidRenderingObjectCustomParticles","buffers","_numParticles","_diffuseEffectWrapper","addBuffers","stride","instanced","setNumParticles","num","diffuseDrawWrapper","diffuseEffect","FluidRenderingObjectParticleSystem","_particleSystem","useTrueRenderingForDiffuseTexture","_useTrueRenderingForDiffuseTexture","_blendMode","_onBeforeDrawParticleObserver","ps","_originalRender","_updateInAnimate","FluidRenderingTextures","blurNumIterations","_blurNumIterations","numIterations","_blurPostProcesses","_rt","renderTargetBlur","_rtBlur","textureBlur","_textureBlurred","blurTextureSizeX","blurTextureSizeY","enableBlur","blurSizeDivisor","blurFilterSize","blurMaxFilterSize","blurDepthScale","_camera","_blurTextureSizeX","_blurTextureSizeY","_textureFormat","textureFormat","_blurTextureType","blurTextureType","_blurTextureFormat","blurTextureFormat","_useStandardBlur","useStandardBlur","_postProcessRunningIndex","rtBlur","textureBlurred","blurPostProcesses","_createBlurPostProcesses","applyBlurPostProcesses","renderTexture","textureBlurSource","debugName","targetSize","useBilinearFiltering","kernelBlurXPostprocess","_bindTexture","inputTexture","rt","_fixReusablePostProcess","kernelBlurYPostprocess","blurList","_getProjectedParticleConstant","_getDepthThreshold","isReusable","onActivateObservable","_currentRenderTextureInd","fov","GeometryBufferRenderer","_linkPrePassRenderer","_linkedWithPrePass","_multiRenderTarget","_unlinkPrePassRenderer","_createRenderTargets","_resetLayout","_enablePosition","_enableReflectivity","_enableVelocity","_attachmentsFromPrePass","_forceTextureType","geometryBufferType","_positionIndex","_velocityIndex","_reflectivityIndex","_depthIndex","NORMAL_TEXTURE_TYPE","_normalIndex","_setAttachments","_linkInternalTexture","needsPreviousWorldMatrices","_ratio","depthFormat","renderTransparentMeshes","_resizeObserver","_clearColor","_clearDepthColor","useSpecificClearForDepthTexture","_useUbo","_depthFormat","disableDepthWrite","needUv","bumpTexture","BumpTextureEnabled","metallicWorkflow","metallicRoughnessTexture","metallic","baseTexture","baseColor","specularGlossinessTexture","specularColor","glossiness","metallicTexture","albedoTexture","albedoColor","reflectivityTexture","reflectivityColor","microSurface","specularTexture","numMorphInfluencers","buffersCount","onResizeObservable","_assignRenderTargetIndices","layoutAttachmentsAll","layoutAttachmentsAllButDepth","layoutAttachmentsDepthOnly","attachmentsAll","attachmentsAllButDepth","attachmentsDepthOnly","renderSubMesh","bonesTransformations","_copyBonesTransformationMatrices","visibleInstances","BindSceneUniformBuffer","finalizeSceneUbo","instanceDataStorage","_instanceDataStorage","isFrozen","mainDeterminant","_preBind","standardDerivatives","parallaxScaleBias","PrePassRenderTarget","renderTargetTexture","_beforeCompositionPostProcesses","_internalTextureDirty","_createCompositionEffect","imageProcessingPostProcess","_checkSize","requiredWidth","requiredHeight","_resetPostProcessChain","renderTargets","_prePassRenderTarget","_outputPostProcess","restoreDefaultInputTexture","PrePassRenderer","_textureIndices","_useSpecificClearForDepthTexture","_isDirty","_setRenderTarget","prePassRenderTarget","currentRTisSceneRT","_refreshGeometryBufferRendererLink","doNotUseGeometryRendererFallback","_geometryBuffer","disableGeometryBufferRenderer","excludedMaterials","mrtCount","_mrtTypes","_mrtFormats","_mrtLayout","_mrtNames","_effectConfigurations","_needsCompositionForThisPass","disableGammaTransform","TextureFormats","isStencilEnable","bindAttachmentsForEffect","isPrePassCapable","excluded","_multiTarget","_multiRenderAttachments","_reinitializeAttachments","multiRenderLayout","clearLayout","clearDepthLayout","defaultLayout","_clearAttachments","_clearDepthAttachments","purpose","_updateGeometryBufferLayout","texturesActivated","matches","prePassConstant","geometryBufferConstant","restoreAttachments","_beforeDraw","layer","_setupOutputForThisPass","useCameraPostProcesses","_postProcessesSourceForThisPass","firstPP","_renderPostProcesses","postProcessChain","_afterDraw","_clear","_setEnabled","_setRenderTargetEnabled","_unlinkInternalTexture","cfg","getEffectConfiguration","previousMrtCount","_enableTextures","createPostProcess","_getPostProcessesSource","secondaryCamera","activeCameras","cameraHasImageProcessing","_hasImageProcessing","_needsImageProcessing","firstCameraPP","_getFirstPostProcess","firstPrePassPP","needsImageProcessing","isIPPAlreadyPresent","enablePrePass","_depthPeelingRenderer","useOrderIndependentTransparency","_markAllMaterialsAsPrePassDirty","PrePassDirtyFlag","ScreenSpaceReflections2Configuration","SSAO2Configuration","SubSurfaceScatteringPostProcess","subSurfaceConfiguration","metersPerUnit","ssDiffusionS","ssDiffusionD","ssFilterRadii","SubSurfaceConfiguration","_ssDiffusionS","_ssDiffusionD","_ssFilterRadii","NAME_SUBSURFACE","ssDiffusionProfileColors","addDiffusionProfile","getDiffusionProfileParameters","clearAllDiffusionProfiles","maxScatteringDistance","_sampleBurleyDiffusionProfile","rcpS","UtilityLayerRenderer","getRenderCamera","getRigParentIfPossible","_renderCamera","activeCam","originalScene","setRenderCamera","_getSharedGizmoLight","_sharedGizmoLight","utilityLayerScene","groundColor","Gray","DefaultUtilityLayer","_DefaultUtilityLayer","_CreateDefaultUtilityLayerFromScene","DefaultKeepDepthUtilityLayer","_DefaultKeepDepthUtilityLayer","autoClearDepthAndStencil","handleEvents","_pointerCaptures","_lastPointerEvents","pickUtilitySceneFirst","onlyCheckPointerDownEvents","processAllEvents","pickingEnabled","onPointerOutObservable","_allowPostProcessClearColor","postProcessesEnabled","_originalPointerObserver","onPrePointerObservable","prePointerInfo","POINTERDOUBLETAP","pointerX","pointerY","pointerEvent","isPointerCaptured","getNearPickDataForScene","scenePick","nearInteractionPickingInfo","originalPickingInfo","previousActiveCamera","pick","utilityScenePick","skipOnPointerObservable","originalScenePick","mainSceneTrackerPredicate","_notifyObservers","makeObserverTopPriority","_afterRenderObserver","onAfterRenderCameraObservable","_sceneDisposeObserver","_updateCamera","oldScene","rightCamera","cameraToUseForPointers","ShadersStoreWGSL","ThinSprite","animationStarted","_animationStarted","fromIndex","_fromIndex","toIndex","_toIndex","loopAnimation","_loopAnimation","_delay","invertU","invertV","_time","_onBaseAnimationEnd","playAnimation","stopAnimation","_animate","Sprite","_manager","isPickable","useAlphaForPicking","_onAnimationEnd","_endAnimation","disposeWhenFinishedAnimating","sprites","cellRef","parsedSprite","sprite","SpriteRenderer","pixelPerfect","_pixelPerfect","autoResetAlpha","fogEnabled","_useVAO","supportSpriteInstancing","disableVertexArrayObjects","_buildIndexBuffer","inverts","cellInfo","_drawWrapperBase","_drawWrapperFog","_drawWrapperDepth","_drawWrapperFogDepth","customSpriteUpdate","drawWrapperDepth","shouldRenderFog","noSprite","_appendSpriteVertex","culling","cull","depthFunc","arrayOffset","rowSize","cellWidth","_xOffset","_yOffset","cellHeight","_xSize","_ySize","_internalPickSprites","fastCheck","pickingInfo","spriteManagers","spriteIndex","spriteManager","_internalMultiPickSprites","pickingInfos","multiIntersects","pickSprite","_tempSpritePickingRay","createPickingRayInCameraSpaceToRef","createPickingRayInCameraSpace","pickSpriteWithRay","TransformToRef","multiPickSprite","multiPickSpriteWithRay","setPointerOverSprite","_pointerOverSprite","getPointerOverSprite","SpriteSceneComponent","NAME_SPRITE","onBeforeSpritesRenderingObservable","onAfterSpritesRenderingObservable","_spritePredicate","_pointerMoveStage","STEP_POINTERMOVE_SPRITE","_pointerMove","_pointerDownStage","STEP_POINTERDOWN_SPRITE","_pointerDown","_pointerUpStage","STEP_POINTERUP_SPRITE","_pointerUp","_pickSpriteButKeepRay","originalPointerInfo","unTranslatedPointerX","unTranslatedPointerY","isMeshPicked","element","pickedSprite","doNotHandleCursors","hoverCursor","cursor","_pickedDownSprite","doubleClick","spritePickResult","_isPointerSwiping","WebXRAbstractFeature","_xrSessionManager","_removeOnDetach","isDisposed","disableAutoAttach","xrNativeFeatureName","_addNewAttachObserver","onXRFrameObservable","_onXRFrame","isCompatible","WebXRControllerPointerSelection","_attachController","xrController","_controllers","laserPointer","selectionMesh","_generateNewMeshPair","pointer","meshUnderPointer","tmpRay","disabledByNearInteraction","_IdCounter","_attachedController","enablePointerSelectionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachTrackedPointerRayMode","_attachGazeMode","_attachScreenRayMode","_tmpVectorForPickCompare","disablePointerLighting","disableSelectionMeshLighting","displayLaserPointer","displaySelectionMesh","laserPointerPickedColor","laserPointerDefaultColor","selectionMeshDefaultColor","selectionMeshPickedColor","_identityMatrix","_screenCoordinatesRef","_viewportRef","xrInput","onControllerAddedObservable","onControllerRemovedObservable","_detachController","constantlyUpdateMeshUnderPointer","gazeCamera","webXRCamera","controllerId","getMeshUnderPointer","getXRControllerByPointerId","_getPointerSelectionDisabledByPointerId","_setPointerSelectionDisabledByPointerId","_xrFrame","controllerData","controllerGlobalPosition","getWorldPointerRayToRef","getForwardRayToRef","maxPointerDistance","disableScenePointerVectorUpdate","xrCamera","toGlobalToRef","ProjectToRef","screenCoordinates","_utilityLayerScene","pointerMovePredicate","raySelectionPredicate","aimTransform","gripTransform","grip","_updatePointerDistance","pickNormal","_convertNormalToDirectionOfRay","getNormal","deltaFighting","axis1","Cross","axis2","RotationFromAxisToRef","customUtilityLayerScene","timeToSelect","sceneToRenderTo","useUtilityLayer","oldPick","discMesh","tessellation","timer","downTriggered","pointerEventInit","onFrameObserver","_augmentPointerInit","_pickingMoved","disablePointerUpOnTouchOut","simulatePointerUp","getDeltaTime","simulatePointerDown","simulatePointerMove","finalPointerUpTriggered","pointerDownTriggered","runInXRFrame","forceGazeMode","motionController","overrideButtonId","selectionComponent","getComponent","getMainComponent","onButtonChangedObserver","onButtonStateChangedObservable","changes","disableSwitchOnClick","onMotionControllerInitObservable","selectStartListener","selectEndListener","eventListeners","selectend","selectstart","session","xrControllerUniqueId","eventName","meshParent","customLasterPointerMeshGenerator","diameterTop","diameterBottom","laserPointerMaterial","customSelectionMeshGenerator","bakeCurrentTransformIntoVertices","targetMat","newPick","gazeModePointerMovedFactor","_laserPointer","screenX","screenY","lasterPointerDefaultColor","Name","POINTER_SELECTION","Version","AddWebXRFeature","xrSessionManager","WebXRMotionControllerTeleportation","rotationEnabled","_rotationEnabled","teleportationTargetMesh","_snappedToPoint","_cachedColor4White","_tmpRay","skipNextTeleportation","backwardsMovementEnabled","backwardsTeleportationDistance","parabolicCheckRadius","parabolicRayEnabled","straightRayEnabled","rotationAngle","onTargetMeshPositionUpdatedObservable","teleportationEnabled","forceHandedness","teleportationState","backwards","rotating","baseRotation","blocked","initMotionController","movementController","getComponentOfType","THUMBSTICK_TYPE","TOUCHPAD_TYPE","useMainComponentOnly","mainComponent","teleportationComponent","_currentTeleportationControllerId","timeToTeleport","timeout","contextObservable","breakCondition","onEnded","_teleportForward","onAxisChangedObserver","onAxisValueChangedObservable","axesData","snapPointsOnly","FromEulerVectorToRef","rotateByQuaternionToRef","realWorldHeight","_floorMeshes","FromEulerAngles","_setTargetMeshVisibility","_createDefaultTargetMesh","floorMeshes","_snapToPositions","snapPositions","_blockedRayColor","blockedRayColor","snapToPoints","addFloorMesh","addBlockerMesh","pickBlockerMeshes","addSnapPoint","newSnapPoint","removeFloorMesh","removeBlockerMesh","removeFloorMeshByName","removeSnapPoint","snapPointToRemove","setSelectionFeature","selectionFeature","_selectionFeature","targetMesh","hitPossible","_showParabolicPath","_setTargetMeshPosition","xRotation","compensation","_disposeBezierCurve","defaultTargetMeshOptions","teleportationTarget","teleportationCircleMaterial","dynamicTexture","teleportationFillColor","fill","teleportationBorderColor","torus","disableAnimation","animationInnerCircle","setKeys","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","setEasingFunction","cone","torusArrowMaterial","torusConeMaterial","diffuseColor","_teleportationRingMaterial","_findClosestSnapPointWithRadius","realPosition","snapToPositionRadius","closestPoint","closestDistance","Number","MAX_VALUE","radiusSquared","DistanceSquared","snapPosition","visible","_quadraticBezierCurve","quadraticBezierVectors","generateRayPathMesh","instance","onBeforeCameraTeleport","onAfterCameraTeleport","TELEPORTATION","WebXRAbstractMotionController","gamepadObject","_doNotLoadControllerMesh","_controllerCache","_initComponent","componentDef","components","gamepadIndices","axes","xAxis","yAxis","_modelReady","onModelLoadedObservable","getComponentIds","rootMesh","getAllComponentsOfType","selectComponentId","loadModel","useGeneric","_getModelLoadingConstraints","loadingParams","_getGenericFilenameAndPath","_getFilenameAndPath","meshesLoaded","_getGenericParentMesh","_setRootMesh","_processLoadedModel","filename","path","profileId","updateFromXRFrame","xrFrame","updateModel","handness","pulse","duration","hapticActuatorIndex","hapticActuators","_getChildByName","_getImmediateChildByName","_lerpTransform","axisMap","axisValue","fixValueCoordinates","minMesh","maxMesh","valueMesh","lerpValue","SlerpToRef","_updateModel","setParent","WebXRControllerComponent","_buttonIndex","_axesIndices","_axes","_hasChanges","_pressed","_touched","hasChanges","isAxes","isButton","nativeController","buttonUpdated","axesUpdate","previous","BUTTON_TYPE","SQUEEZE_TYPE","TRIGGER_TYPE","WebXRGenericTriggerMotionController","GenericTriggerLayout","ProfileId","rootNodeName","visualResponses","gamepadMapping","assetPath","none","controllerCache","WebXRMotionControllerManager","ClearProfilesCache","_ProfilesList","_ProfileLoadingPromises","DefaultFallbacks","RegisterFallbacksForProfileId","FindFallbackWithProfileId","returnArray","_Fallbacks","unshift","GetMotionControllerWithXRInput","forceProfile","profileArray","profiles","windowsMRIdx","UseOnlineRepository","firstFunction","PrioritizeOnlineRepository","_LoadProfileFromRepository","_LoadProfilesFromAvailableControllers","secondFunction","RegisterController","constructFunction","_AvailableControllers","UpdateProfilesList","LoadFileAsync","BaseRepositoryUrl","JSON","ClearControllerCache","cacheItem","profilesList","profileToLoad","profile","DisableControllerCache","constructionFunction","WebXRProfiledMotionController","_profile","_repositoryUrl","layouts","_buttonMeshMapping","_touchDots","visResKey","glbLoaded","IsPluginForExtensionAvailable","_meshes","componentInLayout","mainMesh","states","visualResponseKey","visResponse","valueNodeProperty","valueNodeName","minNodeName","maxNodeName","nameOfMesh","touchPointNodeName","Red","WORLD","componentProperty","WebXRCamera","_referenceQuaternion","_referencedPosition","_trackingState","NOT_TRACKING","onXRCameraInitializedObservable","onTrackingStateChanged","compensateOnFirstFrame","_rotate180","RIG_MODE_CUSTOM","updateUpVectorFromRotation","_updateNumberOfRigCameras","freezeProjectionMatrix","_deferOnly","onXRSessionInit","_updateFromXRSession","_deferredUpdated","_deferredPositionUpdate","_deferredRotationQuaternionUpdate","_updateReferenceSpace","trackingState","_setTrackingState","basePose","getViewerPose","baseReferenceSpace","_updateForDualEyeDebugging","setTransformationFromNonVRCamera","otherCamera","resetToBaseReferenceSpace","decompose","resetReferenceSpace","setTarget","yRotation","_lastXRViewerPose","referenceSpace","emulatedPosition","TRACKING_LOST","TRACKING","xrRenderState","updateRenderState","views","currentRig","eye","_isRightCamera","_isLeftCamera","getRenderTargetTextureForView","_renderingMultiview","trySetViewportForView","viewCount","newCamera","removedCamera","referencedMat","poseMat","transformMat","_ScaleReadOnly","XRRigidTransform","getOffsetReferenceSpace","WebXRExperienceHelper","_nonVRCamera","_spectatorCamera","_originalSceneAutoClear","_supported","_spectatorMode","_lastTimestamp","onInitialXRPoseSetObservable","onStateChangedObservable","NOT_IN_XR","sessionManager","featuresManager","CreateAsync","helper","initializeAsync","_setState","exitXRAsync","enterXRAsync","sessionMode","referenceSpaceType","getWebXRRenderTarget","sessionCreationOptions","ENTERING_XR","optionalFeatures","_extendXRSessionInitObject","initializeSessionAsync","setReferenceSpaceTypeAsync","baseLayer","initializeXRLayerAsync","getEnabledFeature","LAYERS","runXRRenderLoop","_nonXRToXRCamera","onXRSessionEnded","EXITING_XR","IN_XR","enableSpectatorMode","_switchSpectatorMode","disableSpecatatorMode","fps","cameraIndex","preferredCameraIndex","updateSpectatorCamera","currentTimestamp","absoluteRotation","onStateChanged","framebufferDimensionsObject","WebXRFeatureName","ANCHOR_SYSTEM","BACKGROUND_REMOVER","HIT_TEST","MESH_DETECTION","PHYSICS_CONTROLLERS","PLANE_DETECTION","FEATURE_POINTS","HAND_TRACKING","IMAGE_TRACKING","NEAR_INTERACTION","DOM_OVERLAY","MOVEMENT","LIGHT_ESTIMATION","EYE_TRACKING","WALKING_LOCOMOTION","DEPTH_SENSING","SPACE_WARP","WebXRFeaturesManager","getEnabledFeatures","featureName","feature","featureImplementation","attachFeature","detachFeature","constructorFunction","stable","_AvailableFeatures","latest","ConstructFeature","GetAvailableFeatures","GetAvailableVersions","GetLatestVersionOfFeature","GetStableVersionOfFeature","disableFeature","enableFeature","moduleOptions","attachIfPossible","versionToLoad","conflictingFeature","_ConflictingFeatures","constructed","dependsOn","dependentsFound","every","xrSessionInit","enabledFeatures","nativeName","requiredFeatures","getXRSessionInitExtension","extended","WebXRInput","_onInputSourcesChange","_addAndRemoveControllers","added","removed","_sessionEndedObserver","_sessionInitObserver","_frameObserver","customControllersRepositoryURL","disableOnlineControllerRepository","addInputs","removeInputs","controllerOptions","forceControllerProfile","forceInputProfile","doNotLoadControllerMesh","doNotLoadControllerMeshes","disableMotionControllerAnimation","disableControllerAnimation","keepControllers","removedControllers","idCount","WebXRInputSource","_disposed","onMeshLoadedObservable","_uniqueId","gripSpace","gripIfAvailable","getPose","targetRaySpace","_lastXRPose","WebXRLayerWrapper","isFixedFoveationSupported","layerType","fixedFoveation","getWidth","getHeight","createRenderTargetTextureProvider","WebXRManagedOutputCanvasOptions","GetDefaults","defaults","canvasOptions","antialias","stencil","framebufferScaleFactor","newCanvasCssStyle","WebXRManagedOutputCanvas","xrLayer","_xrLayerWrapper","onXRLayerInitObservable","canvasElement","_setManagedOutputCanvas","cssText","_addCanvas","_removeCanvas","xrSession","createLayer","XRWebGLLayer","canvasContext","makeXRCompatible","_setCanvasSize","contains","_originalCanvasSize","offsetWidth","offsetHeight","WebXRLayerRenderTargetTextureProvider","layerWrapper","_renderTargetTextures","_createRenderTargetTexture","renderTargetWrapper","disableRescaling","XRWebGLBinding","skipInitialClear","_destroyRenderTargetTexture","getFramebufferDimensions","_framebufferDimensions","rtt","WebXRSessionManager","defaultHeightCompensation","onXRReferenceSpaceChanged","inXRFrameLoop","inXRSession","_onEngineDisposedObserver","_referenceSpace","newReferenceSpace","_sessionMode","_baseLayerRTTProvider","getRenderTargetTextureForEye","_xrNavigator","xr","native","xrSessionMode","requestSession","customAnimationFrameRequester","_renderLoop","_baseLayerWrapper","once","isSessionSupportedAsync","IsSessionSupportedAsync","renderFunction","requestReferenceSpace","rejectionReason","heightCompensation","viewerReferenceSpace","updateRenderStateAsync","_setBaseLayerWrapper","baseLayerWrapper","_getBaseLayerWrapper","functionToUse","isSessionSupported","supportsSession","currentFrameRate","frameRate","supportedFrameRates","updateTargetFrameRate","ignoreIfNotInSession","WebXRState","WebXRTrackingState","WebXRWebGLLayerWrapper","framebufferWidth","framebufferHeight","WebXRWebGLLayerRenderTargetTextureProvider","_layer","xrViewport","getViewport","layerWidth","layerHeight","_rtt"],"sourceRoot":""}