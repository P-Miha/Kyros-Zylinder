{"version":3,"file":"js/835.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/externals/havok.ts","webpack://babylonjs-typescript-webpack-template/./src/scenes/exampleScenes/physicsWithHavok.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/hemisphericLight.ts"],"sourcesContent":["import HavokPlugin from \"@babylonjs/havok\";\r\n\r\nexport const havokModule = HavokPlugin();\r\n","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { CreateSphere } from \"@babylonjs/core/Meshes/Builders/sphereBuilder\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\r\n\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\nimport \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../../createScene\";\r\nimport { havokModule } from \"../../externals/havok\";\r\nimport { PhysicsShapeBox, PhysicsShapeSphere } from \"@babylonjs/core/Physics/v2/physicsShape\";\r\nimport { PhysicsBody } from \"@babylonjs/core/Physics/v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"@babylonjs/core/Physics/v2/IPhysicsEnginePlugin\";\r\nimport { HavokPlugin } from \"@babylonjs/core/Physics/v2/Plugins/havokPlugin\";\r\n\r\nclass PhysicsSceneWithAmmo implements CreateSceneClass {\r\n    preTasks = [havokModule];\r\n\r\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        \r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\r\n\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        // Our built-in 'sphere' shape.\r\n        const sphere = CreateSphere(\"sphere\", { diameter: 2, segments: 32 }, scene);\r\n\r\n        // Move the sphere upward at 4 units\r\n        sphere.position.y = 4;\r\n        \r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\"ground\", { width: 10, height: 10 }, scene);\r\n        \r\n        // PHYSICS!\r\n        scene.enablePhysics(null, new HavokPlugin(true, await havokModule));\r\n        // Create a sphere shape\r\n        const sphereShape = new PhysicsShapeSphere(new Vector3(0, 0, 0)\r\n            , 1\r\n            , scene);\r\n\r\n        // Sphere body\r\n        const sphereBody = new PhysicsBody(sphere, PhysicsMotionType.DYNAMIC, false, scene);\r\n\r\n        // Set shape material properties\r\n        sphereShape.material = { friction: 0.2, restitution: 0.6 };\r\n\r\n        // Associate shape and body\r\n        sphereBody.shape = sphereShape;\r\n\r\n        // And body mass\r\n        sphereBody.setMassProperties({ mass: 1 });\r\n\r\n        // Create a static box shape\r\n        const groundShape = new PhysicsShapeBox(new Vector3(0, 0, 0)\r\n            , Quaternion.Identity()\r\n            , new Vector3(10, 0.1, 10)\r\n            , scene);\r\n\r\n        // Create a body and attach it to the ground. Set it as Static.\r\n        const groundBody = new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n\r\n        // Set material properties\r\n        groundShape.material = { friction: 0.2, restitution: 0.8 };\r\n\r\n        // Associate the body and the shape\r\n        groundBody.shape = groundShape;\r\n\r\n        // Set the mass to 0\r\n        groundBody.setMassProperties({ mass: 0 });\r\n\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new PhysicsSceneWithAmmo();\r\n","import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"],"names":["havokModule","preTasks","createScene","async","engine","canvas","scene","camera","Math","PI","setTarget","Zero","attachControl","intensity","sphere","diameter","segments","position","y","ground","width","height","enablePhysics","sphereShape","sphereBody","DYNAMIC","material","friction","restitution","shape","setMassProperties","mass","groundShape","Identity","groundBody","STATIC","N","AddNodeConstructor","name","HemisphericLight","constructor","direction","super","groundColor","this","Up","_buildUniformLayout","_uniformBuffer","addUniform","create","getClassName","setDirectionToTarget","target","Normalize","subtract","getShadowGenerator","transferToEffect","_effect","lightIndex","normalizeDirection","updateFloat4","x","z","updateColor3","scale","transferToNodeMaterialEffect","effect","lightDataUniformName","setFloat3","computeWorldMatrix","_worldMatrix","getTypeID","LIGHTTYPEID_HEMISPHERICLIGHT","prepareLightSpecificDefines","defines"],"sourceRoot":""}