"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[488],{3488:(e,t,n)=>{n.r(t),n.d(t,{NavigationMeshRecast:()=>b,default:()=>f});var o=n(4147),a=n(972),i=n(3242),s=n(3852),r=n(156),c=n(2758),l=n(9859),h=n(9823),g=n(4482),d=n(3632),p=n(8680),m=n.n(p),u=n(147);n(6521);const w=[];class b{constructor(){this.createScene=async(e,t)=>{const n=await m()(),p=new o.x(e),b=new s.P(n);b.setWorkerURL("./navMeshWorker.js");const f=new r.c("camera1",new a.P(-6,4,-8),p);f.setTarget(a.P.Zero()),f.attachControl(t,!0),new c.e("light1",new a.P(0,1,0),p).intensity=.7;const k=function(e){const t=h.V.CreateGround("ground1",{width:6,height:6,subdivisions:2},e),n=new i.K("mat1",e);n.diffuseColor=new l.Wo(1,1,1);const o=h.V.CreateSphere("sphere1",{diameter:2,segments:16},e);o.material=n,o.position.y=1;const s=h.V.CreateBox("cube",{size:1,height:3},e);s.position=new a.P(1,1.5,0);const r=d.Kj.MergeMeshes([o,s,t]);if(!r)throw new Error("Could not merge meshes");return r}(p);return b.createNavMesh([k],{cs:.2,ch:.2,walkableSlopeAngle:90,walkableHeight:1,walkableClimb:1,walkableRadius:1,maxEdgeLen:12,maxSimplificationError:1.3,minRegionArea:8,mergeRegionArea:20,maxVertsPerPoly:6,detailSampleDist:6,detailSampleMaxError:1},(e=>{console.log("got worker data",e),b.buildFromNavmeshData(e);const t=b.createDebugNavMesh(p);t.position=new a.P(0,.01,0);const n=new i.K("matdebug",p);n.diffuseColor=new l.Wo(.1,.2,1),n.alpha=.2,t.material=n;const o=b.createCrowd(10,.1,p);let s;const r={radius:.1,height:.2,maxAcceleration:4,maxSpeed:1,collisionQueryRange:.5,pathOptimizationRange:0,separationWeight:1};for(s=0;s<1;s++){const e=.2,t=h.V.CreateBox("cube",{size:e,height:e},p),n=h.V.CreateBox("cube",{size:.1,height:.1},p),s=new i.K("mat2",p),c=Math.random();s.diffuseColor=new l.Wo(.4+.6*c,.3,1-.3*c),t.material=s;const d=b.getRandomPointAround(new a.P(-2,.1,-1.8),.5),m=new g.Y("transform"),u=o.addAgent(d,r,m);w.push({idx:u,trf:m,mesh:t,target:n})}let c,d,m;p.onPointerObservable.add((e=>{e.type===u.kD.POINTERDOWN&&e?.pickInfo?.pickedMesh&&(console.log("pointer down",e.pickInfo.pickedMesh.name),function(e){if(d=e,c=function(){const e=p.pick(p.pointerX,p.pointerY);return e?.hit?e.pickedPoint:null}(),c){setTimeout((function(){f.detachControl()}),0);const e=o.getAgents();let t;for(t=0;t<e.length;t++)o.agentGoto(e[t],b.getClosestPoint(c));const n=b.computePath(o.getAgentPosition(e[0]),b.getClosestPoint(c));m=h.V.CreateDashedLines("ribbon",{points:n,updatable:!0,instance:m},p)}}(e.pickInfo.pickedMesh))})),p.onBeforeRenderObservable.add((()=>{const e=w.length;for(let t=0;t<e;t++){const e=w[t];e.mesh.position=o.getAgentPosition(e.idx);const n=o.getAgentVelocity(e.idx);if(o.getAgentNextTargetPathToRef(e.idx,e.target.position),n.length()>.2){n.normalize();const t=Math.atan2(n.x,n.z);e.mesh.rotation.y=e.mesh.rotation.y+.05*(t-e.mesh.rotation.y)}}}))})),p}}}const f=new b}}]);
//# sourceMappingURL=488.babylonBundle.js.map