"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[778],{63778:(s,t,e)=>{e.d(t,{j:()=>d});var r=e(96786),i=e(90972),o=e(37959),n=e(84684),a=e(96721),h=e(9827),c=e(89859),f=e(43092),u=e(22059),_=e(80569),l=e(40078),p=e(28981);const m={effect:null,subMesh:null};class d extends _.a{constructor(s,t,e,r={},o=!0){super(s,t,o),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new i.y3,this._cachedWorldViewProjectionMatrix=new i.y3,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=e,this._options=Object.assign({needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1},r)}get shaderPath(){return this._shaderPath}set shaderPath(s){this._shaderPath=s}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(s){-1===this._options.uniforms.indexOf(s)&&this._options.uniforms.push(s)}setTexture(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._textures[s]=t,this}setTextureArray(s,t){return-1===this._options.samplers.indexOf(s)&&this._options.samplers.push(s),this._checkUniform(s),this._textureArrays[s]=t,this}setExternalTexture(s,t){return-1===this._options.externalTextures.indexOf(s)&&this._options.externalTextures.push(s),this._externalTextures[s]=t,this}setFloat(s,t){return this._checkUniform(s),this._floats[s]=t,this}setInt(s,t){return this._checkUniform(s),this._ints[s]=t,this}setUInt(s,t){return this._checkUniform(s),this._uints[s]=t,this}setFloats(s,t){return this._checkUniform(s),this._floatsArrays[s]=t,this}setColor3(s,t){return this._checkUniform(s),this._colors3[s]=t,this}setColor3Array(s,t){return this._checkUniform(s),this._colors3Arrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setColor4(s,t){return this._checkUniform(s),this._colors4[s]=t,this}setColor4Array(s,t){return this._checkUniform(s),this._colors4Arrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setVector2(s,t){return this._checkUniform(s),this._vectors2[s]=t,this}setVector3(s,t){return this._checkUniform(s),this._vectors3[s]=t,this}setVector4(s,t){return this._checkUniform(s),this._vectors4[s]=t,this}setQuaternion(s,t){return this._checkUniform(s),this._quaternions[s]=t,this}setQuaternionArray(s,t){return this._checkUniform(s),this._quaternionsArrays[s]=t.reduce(((s,t)=>(t.toArray(s,s.length),s)),[]),this}setMatrix(s,t){return this._checkUniform(s),this._matrices[s]=t,this}setMatrices(s,t){this._checkUniform(s);const e=new Float32Array(16*t.length);for(let s=0;s<t.length;s++)t[s].copyToArray(e,16*s);return this._matrixArrays[s]=e,this}setMatrix3x3(s,t){return this._checkUniform(s),this._matrices3x3[s]=t,this}setMatrix2x2(s,t){return this._checkUniform(s),this._matrices2x2[s]=t,this}setArray2(s,t){return this._checkUniform(s),this._vectors2Arrays[s]=t,this}setArray3(s,t){return this._checkUniform(s),this._vectors3Arrays[s]=t,this}setArray4(s,t){return this._checkUniform(s),this._vectors4Arrays[s]=t,this}setUniformBuffer(s,t){return-1===this._options.uniformBuffers.indexOf(s)&&this._options.uniformBuffers.push(s),this._uniformBuffers[s]=t,this}setTextureSampler(s,t){return-1===this._options.samplerObjects.indexOf(s)&&this._options.samplerObjects.push(s),this._textureSamplers[s]=t,this}setStorageBuffer(s,t){return-1===this._options.storageBuffers.indexOf(s)&&this._options.storageBuffers.push(s),this._storageBuffers[s]=t,this}setDefine(s,t){const e=s.trimEnd()+" ",r=this.options.defines.findIndex((t=>t===s||t.startsWith(e)));return r>=0&&this.options.defines.splice(r,1),("boolean"!=typeof t||t)&&this.options.defines.push(e+t),this}isReadyForSubMesh(s,t,e){return this.isReady(s,e,t)}isReady(s,t,e){var r,i,n,h;const c=e&&this._storeEffectOnSubMeshes;if(this.isFrozen)if(c){if(e.effect&&e.effect._wasPreviouslyReady)return!0}else{const s=this._drawWrapper.effect;if(s&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===t)return!0}const u=this.getScene(),_=u.getEngine(),l=[],d=[],x=new f.L;let A=this._shaderPath,y=this._options.uniforms,v=this._options.uniformBuffers,g=this._options.samplers;_.getCaps().multiview&&u.activeCamera&&u.activeCamera.outputRenderTarget&&u.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,l.push("#define MULTIVIEW"),-1!==this._options.uniforms.indexOf("viewProjection")&&-1===this._options.uniforms.indexOf("viewProjectionR")&&this._options.uniforms.push("viewProjectionR"));for(let s=0;s<this._options.defines.length;s++){const t=0===this._options.defines[s].indexOf("#define")?this._options.defines[s]:`#define ${this._options.defines[s]}`;l.push(t)}for(let s=0;s<this._options.attributes.length;s++)d.push(this._options.attributes[s]);if(s&&s.isVerticesDataPresent(o.o.ColorKind)&&(d.push(o.o.ColorKind),l.push("#define VERTEXCOLOR")),t&&(l.push("#define INSTANCES"),a.G.PushAttributesForInstances(d,this._materialHelperNeedsPreviousMatrices),(null==s?void 0:s.hasThinInstances)&&(l.push("#define THIN_INSTANCES"),s&&s.isVerticesDataPresent(o.o.ColorInstanceKind)&&(d.push(o.o.ColorInstanceKind),l.push("#define INSTANCESCOLOR")))),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton){d.push(o.o.MatricesIndicesKind),d.push(o.o.MatricesWeightsKind),s.numBoneInfluencers>4&&(d.push(o.o.MatricesIndicesExtraKind),d.push(o.o.MatricesWeightsExtraKind));const t=s.skeleton;l.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers),x.addCPUSkinningFallback(0,s),t.isUsingTextureForMatrices?(l.push("#define BONETEXTURE"),-1===this._options.uniforms.indexOf("boneTextureWidth")&&this._options.uniforms.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(l.push("#define BonesPerMesh "+(t.bones.length+1)),-1===this._options.uniforms.indexOf("mBones")&&this._options.uniforms.push("mBones"))}else l.push("#define NUM_BONE_INFLUENCERS 0");let T=0;const M=s?s.morphTargetManager:null;if(M){const s=M.supportsUVs&&-1!==l.indexOf("#define UV1"),t=M.supportsTangents&&-1!==l.indexOf("#define TANGENT"),e=M.supportsNormals&&-1!==l.indexOf("#define NORMAL");T=M.numInfluencers,s&&l.push("#define MORPHTARGETS_UV"),t&&l.push("#define MORPHTARGETS_TANGENT"),e&&l.push("#define MORPHTARGETS_NORMAL"),T>0&&l.push("#define MORPHTARGETS"),M.isUsingTextureForTargets&&(l.push("#define MORPHTARGETS_TEXTURE"),-1===this._options.uniforms.indexOf("morphTargetTextureIndices")&&this._options.uniforms.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),l.push("#define NUM_MORPH_INFLUENCERS "+T);for(let r=0;r<T;r++)d.push(o.o.PositionKind+r),e&&d.push(o.o.NormalKind+r),t&&d.push(o.o.TangentKind+r),s&&d.push(o.o.UVKind+"_"+r);T>0&&(y=y.slice(),y.push("morphTargetInfluences"),y.push("morphTargetTextureInfo"),y.push("morphTargetTextureIndices"))}else l.push("#define NUM_MORPH_INFLUENCERS 0");if(s){const t=s.bakedVertexAnimationManager;t&&t.isEnabled&&(l.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===this._options.uniforms.indexOf("bakedVertexAnimationSettings")&&this._options.uniforms.push("bakedVertexAnimationSettings"),-1===this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted")&&this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted"),-1===this._options.uniforms.indexOf("bakedVertexAnimationTime")&&this._options.uniforms.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),a.G.PrepareAttributesForBakedVertexAnimation(d,s,l)}for(const s in this._textures)if(!this._textures[s].isReady())return!1;s&&this._shouldTurnAlphaTestOn(s)&&l.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,p.qx)(y),(0,p.lK)(this,u,l)),this.customShaderNameResolve&&(y=y.slice(),v=v.slice(),g=g.slice(),A=this.customShaderNameResolve(A,y,v,g,l,d));const S=c?e._getDrawWrapper():this._drawWrapper,b=null!==(r=null==S?void 0:S.effect)&&void 0!==r?r:null,O=null!==(i=null==S?void 0:S.defines)&&void 0!==i?i:null,P=l.join("\n");let E=b;return O!==P&&(E=_.createEffect(A,{attributes:d,uniformsNames:y,uniformBuffersNames:v,samplers:g,defines:P,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:T},shaderLanguage:this._options.shaderLanguage},_),c?e.setEffect(E,P,this._materialContext):S&&S.setEffect(E,P),this._onEffectCreatedObservable&&(m.effect=E,m.subMesh=null!==(n=null!=e?e:null==s?void 0:s.subMeshes[0])&&void 0!==n?n:null,this._onEffectCreatedObservable.notifyObservers(m))),E._wasPreviouslyUsingInstances=!!t,null!==(h=!(null==E?void 0:E.isReady()))&&void 0!==h&&!h&&(b!==E&&u.resetCachedMaterial(),E._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(s,t){const e=this.getScene(),r=null!=t?t:this.getEffect();r&&(-1!==this._options.uniforms.indexOf("world")&&r.setMatrix("world",s),-1!==this._options.uniforms.indexOf("worldView")&&(s.multiplyToRef(e.getViewMatrix(),this._cachedWorldViewMatrix),r.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==this._options.uniforms.indexOf("worldViewProjection")&&(s.multiplyToRef(e.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),r.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)))}bindForSubMesh(s,t,e){var r;this.bind(s,t,null===(r=e._drawWrapperOverride)||void 0===r?void 0:r.effect,e)}bind(s,t,e,r){var i;const o=r&&this._storeEffectOnSubMeshes,n=null!=e?e:o?r.effect:this.getEffect();if(!n)return;this._activeEffect=n,this.bindOnlyWorldMatrix(s,e);const h=this._options.uniformBuffers;let c=!1;if(n&&h&&h.length>0&&this.getScene().getEngine().supportsUniformBuffers)for(let e=0;e<h.length;++e)switch(h[e]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(n,"Mesh"),t.transferToEffect(s));break;case"Scene":a.G.BindSceneUniformBuffer(n,this.getScene().getSceneUniformBuffer()),this.getScene().finalizeSceneUbo(),c=!0}const f=t&&o?this._mustRebind(this.getScene(),n,t.visibility):this.getScene().getCachedMaterial()!==this;if(n&&f){let s;for(s in c||-1===this._options.uniforms.indexOf("view")||n.setMatrix("view",this.getScene().getViewMatrix()),c||-1===this._options.uniforms.indexOf("projection")||n.setMatrix("projection",this.getScene().getProjectionMatrix()),c||-1===this._options.uniforms.indexOf("viewProjection")||(n.setMatrix("viewProjection",this.getScene().getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",this.getScene()._transformMatrixR)),this.getScene().activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&n.setVector3("cameraPosition",this.getScene().activeCamera.globalPosition),a.G.BindBonesParameters(t,n),(0,p.an)(n,this,this.getScene()),this._textures)n.setTexture(s,this._textures[s]);for(s in this._textureArrays)n.setTextureArray(s,this._textureArrays[s]);for(s in this._externalTextures)n.setExternalTexture(s,this._externalTextures[s]);for(s in this._ints)n.setInt(s,this._ints[s]);for(s in this._uints)n.setUInt(s,this._uints[s]);for(s in this._floats)n.setFloat(s,this._floats[s]);for(s in this._floatsArrays)n.setArray(s,this._floatsArrays[s]);for(s in this._colors3)n.setColor3(s,this._colors3[s]);for(s in this._colors3Arrays)n.setArray3(s,this._colors3Arrays[s]);for(s in this._colors4){const t=this._colors4[s];n.setFloat4(s,t.r,t.g,t.b,t.a)}for(s in this._colors4Arrays)n.setArray4(s,this._colors4Arrays[s]);for(s in this._vectors2)n.setVector2(s,this._vectors2[s]);for(s in this._vectors3)n.setVector3(s,this._vectors3[s]);for(s in this._vectors4)n.setVector4(s,this._vectors4[s]);for(s in this._quaternions)n.setQuaternion(s,this._quaternions[s]);for(s in this._matrices)n.setMatrix(s,this._matrices[s]);for(s in this._matrixArrays)n.setMatrices(s,this._matrixArrays[s]);for(s in this._matrices3x3)n.setMatrix3x3(s,this._matrices3x3[s]);for(s in this._matrices2x2)n.setMatrix2x2(s,this._matrices2x2[s]);for(s in this._vectors2Arrays)n.setArray2(s,this._vectors2Arrays[s]);for(s in this._vectors3Arrays)n.setArray3(s,this._vectors3Arrays[s]);for(s in this._vectors4Arrays)n.setArray4(s,this._vectors4Arrays[s]);for(s in this._quaternionsArrays)n.setArray4(s,this._quaternionsArrays[s]);for(s in this._uniformBuffers){const t=this._uniformBuffers[s].getBuffer();t&&n.bindUniformBuffer(t,s)}for(s in this._textureSamplers)n.setTextureSampler(s,this._textureSamplers[s]);for(s in this._storageBuffers)n.setStorageBuffer(s,this._storageBuffers[s])}if(n&&t&&(f||!this.isFrozen)){const s=t.morphTargetManager;s&&s.numInfluencers>0&&a.G.BindMorphTargetParameters(t,n);const e=t.bakedVertexAnimationManager;e&&e.isEnabled&&(null===(i=t.bakedVertexAnimationManager)||void 0===i||i.bind(n,!!n._wasPreviouslyUsingInstances))}this._afterBind(t,n)}getActiveTextures(){const s=super.getActiveTextures();for(const t in this._textures)s.push(this._textures[t]);for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)s.push(e[t])}return s}hasTexture(s){if(super.hasTexture(s))return!0;for(const t in this._textures)if(this._textures[t]===s)return!0;for(const t in this._textureArrays){const e=this._textureArrays[t];for(let t=0;t<e.length;t++)if(e[t]===s)return!0}return!1}clone(s){const t=r.p4.Clone((()=>new d(s,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);t.name=s,t.id=s,"object"==typeof t._shaderPath&&(t._shaderPath=Object.assign({},t._shaderPath)),this._options=Object.assign({},this._options),Object.keys(this._options).forEach((s=>{const t=this._options[s];Array.isArray(t)&&(this._options[s]=t.slice(0))})),this.stencil.copyTo(t.stencil);for(const s in this._textures)t.setTexture(s,this._textures[s]);for(const s in this._textureArrays)t.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)t.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)t.setInt(s,this._ints[s]);for(const s in this._uints)t.setUInt(s,this._uints[s]);for(const s in this._floats)t.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)t.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)t.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)t._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)t.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)t._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)t.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)t.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)t.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)t.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)t._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)t.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)t._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)t.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)t.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)t.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)t.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)t.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)t.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)t.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)t.setStorageBuffer(s,this._storageBuffers[s]);return t}dispose(s,t,e){if(t){let s;for(s in this._textures)this._textures[s].dispose();for(s in this._textureArrays){const t=this._textureArrays[s];for(let s=0;s<t.length;s++)t[s].dispose()}}this._textures={},super.dispose(s,t,e)}serialize(){const s=r.p4.Serialize(this);let t;for(t in s.customType="BABYLON.ShaderMaterial",s.uniqueId=this.uniqueId,s.options=this._options,s.shaderPath=this._shaderPath,s.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,s.stencil=this.stencil.serialize(),s.textures={},this._textures)s.textures[t]=this._textures[t].serialize();for(t in s.textureArrays={},this._textureArrays){s.textureArrays[t]=[];const e=this._textureArrays[t];for(let r=0;r<e.length;r++)s.textureArrays[t].push(e[r].serialize())}for(t in s.ints={},this._ints)s.ints[t]=this._ints[t];for(t in s.uints={},this._uints)s.uints[t]=this._uints[t];for(t in s.floats={},this._floats)s.floats[t]=this._floats[t];for(t in s.FloatArrays={},this._floatsArrays)s.FloatArrays[t]=this._floatsArrays[t];for(t in s.colors3={},this._colors3)s.colors3[t]=this._colors3[t].asArray();for(t in s.colors3Arrays={},this._colors3Arrays)s.colors3Arrays[t]=this._colors3Arrays[t];for(t in s.colors4={},this._colors4)s.colors4[t]=this._colors4[t].asArray();for(t in s.colors4Arrays={},this._colors4Arrays)s.colors4Arrays[t]=this._colors4Arrays[t];for(t in s.vectors2={},this._vectors2)s.vectors2[t]=this._vectors2[t].asArray();for(t in s.vectors3={},this._vectors3)s.vectors3[t]=this._vectors3[t].asArray();for(t in s.vectors4={},this._vectors4)s.vectors4[t]=this._vectors4[t].asArray();for(t in s.quaternions={},this._quaternions)s.quaternions[t]=this._quaternions[t].asArray();for(t in s.matrices={},this._matrices)s.matrices[t]=this._matrices[t].asArray();for(t in s.matrixArray={},this._matrixArrays)s.matrixArray[t]=this._matrixArrays[t];for(t in s.matrices3x3={},this._matrices3x3)s.matrices3x3[t]=this._matrices3x3[t];for(t in s.matrices2x2={},this._matrices2x2)s.matrices2x2[t]=this._matrices2x2[t];for(t in s.vectors2Arrays={},this._vectors2Arrays)s.vectors2Arrays[t]=this._vectors2Arrays[t];for(t in s.vectors3Arrays={},this._vectors3Arrays)s.vectors3Arrays[t]=this._vectors3Arrays[t];for(t in s.vectors4Arrays={},this._vectors4Arrays)s.vectors4Arrays[t]=this._vectors4Arrays[t];for(t in s.quaternionsArrays={},this._quaternionsArrays)s.quaternionsArrays[t]=this._quaternionsArrays[t];return s}static Parse(s,t,e){const o=r.p4.Parse((()=>new d(s.name,t,s.shaderPath,s.options,s.storeEffectOnSubMeshes)),s,t,e);let a;for(a in s.stencil&&o.stencil.parse(s.stencil,t,e),s.textures)o.setTexture(a,n.x.Parse(s.textures[a],t,e));for(a in s.textureArrays){const r=s.textureArrays[a],i=new Array;for(let s=0;s<r.length;s++)i.push(n.x.Parse(r[s],t,e));o.setTextureArray(a,i)}for(a in s.ints)o.setInt(a,s.ints[a]);for(a in s.uints)o.setUInt(a,s.uints[a]);for(a in s.floats)o.setFloat(a,s.floats[a]);for(a in s.floatsArrays)o.setFloats(a,s.floatsArrays[a]);for(a in s.colors3)o.setColor3(a,c.Wo.FromArray(s.colors3[a]));for(a in s.colors3Arrays){const t=s.colors3Arrays[a].reduce(((s,t,e)=>(e%3==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>c.Wo.FromArray(s)));o.setColor3Array(a,t)}for(a in s.colors4)o.setColor4(a,c.HE.FromArray(s.colors4[a]));for(a in s.colors4Arrays){const t=s.colors4Arrays[a].reduce(((s,t,e)=>(e%4==0?s.push([t]):s[s.length-1].push(t),s)),[]).map((s=>c.HE.FromArray(s)));o.setColor4Array(a,t)}for(a in s.vectors2)o.setVector2(a,i.FM.FromArray(s.vectors2[a]));for(a in s.vectors3)o.setVector3(a,i.P.FromArray(s.vectors3[a]));for(a in s.vectors4)o.setVector4(a,i.Lt.FromArray(s.vectors4[a]));for(a in s.quaternions)o.setQuaternion(a,i._f.FromArray(s.quaternions[a]));for(a in s.matrices)o.setMatrix(a,i.y3.FromArray(s.matrices[a]));for(a in s.matrixArray)o._matrixArrays[a]=new Float32Array(s.matrixArray[a]);for(a in s.matrices3x3)o.setMatrix3x3(a,s.matrices3x3[a]);for(a in s.matrices2x2)o.setMatrix2x2(a,s.matrices2x2[a]);for(a in s.vectors2Arrays)o.setArray2(a,s.vectors2Arrays[a]);for(a in s.vectors3Arrays)o.setArray3(a,s.vectors3Arrays[a]);for(a in s.vectors4Arrays)o.setArray4(a,s.vectors4Arrays[a]);for(a in s.quaternionsArrays)o.setArray4(a,s.quaternionsArrays[a]);return o}static ParseFromFileAsync(s,t,e,r=""){return new Promise(((i,o)=>{const n=new u.g;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const t=JSON.parse(n.responseText),o=this.Parse(t,e||l.l.LastCreatedScene,r);s&&(o.name=s),i(o)}else o("Unable to load the ShaderMaterial")})),n.open("GET",t),n.send()}))}static ParseFromSnippetAsync(s,t,e=""){return new Promise(((r,i)=>{const o=new u.g;o.addEventListener("readystatechange",(()=>{if(4==o.readyState)if(200==o.status){const i=JSON.parse(JSON.parse(o.responseText).jsonPayload),n=JSON.parse(i.shaderMaterial),a=this.Parse(n,t||l.l.LastCreatedScene,e);a.snippetId=s,r(a)}else i("Unable to load the snippet "+s)})),o.open("GET",this.SnippetUrl+"/"+s.replace(/#/g,"/")),o.send()}))}}d.SnippetUrl="https://snippet.babylonjs.com",d.CreateFromSnippetAsync=d.ParseFromSnippetAsync,(0,h.H)("BABYLON.ShaderMaterial",d)}}]);
//# sourceMappingURL=778.babylonBundle.js.map