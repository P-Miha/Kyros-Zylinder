{"version":3,"file":"js/962.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/linesMesh.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/Plugins/ammoJSPlugin.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/physicsImpostor.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/color.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/color.vertex.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name\r\n     * @param newParent\r\n     * @param doNotCloneChildren\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n","import { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { IPhysicsEnabledObject } from \"../physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { VertexData } from \"../../../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../../Meshes/mesh\";\r\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder\";\r\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder\";\r\nimport type { LinesMesh } from \"../../../Meshes/linesMesh\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n    private _tmpContactNormal = new Vector3();\r\n    private _tmpContactDistance: number;\r\n    private _tmpContactImpulse: number;\r\n    private _tmpVec3 = new Vector3();\r\n\r\n    private static readonly _DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly _KINEMATIC_FLAG = 2;\r\n    private static readonly _DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            const worldNormal = contactPoint.m_normalWorldOnB;\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactNormal.x = worldNormal.x();\r\n            this._tmpContactNormal.y = worldNormal.y();\r\n            this._tmpContactNormal.z = worldNormal.z();\r\n            this._tmpContactImpulse = contactPoint.getAppliedImpulse();\r\n            this._tmpContactDistance = contactPoint.getDistance();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom mesh impostor handler function to support building custom mesh impostor vertex data\r\n     */\r\n    public onCreateCustomMeshImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    /**\r\n     * The create custom convex hull impostor handler function to support building custom convex hull impostor vertex data\r\n     */\r\n    public onCreateCustomConvexHullImpostor: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (const impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (const mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            } else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (const otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({\r\n                                        body: otherImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                    otherImpostor.onCollide({\r\n                                        body: mainImpostor.physicsBody,\r\n                                        point: this._tmpContactPoint,\r\n                                        distance: this._tmpContactDistance,\r\n                                        impulse: this._tmpContactImpulse,\r\n                                        normal: this._tmpContactNormal,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        } else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        const nbVertices = bodyVertices.size();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        const path: Array<Vector3> = new Array();\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        const object = impostor.object;\r\n        const shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        } else {\r\n            impostor.object = ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\r\n        const object = impostor.object;\r\n        let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        const nbVertices = vertexPositions.length / 3;\r\n        const bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        let node: any;\r\n        let nodePositions: any;\r\n        let x, y, z: number;\r\n        let nx, ny, nz: number;\r\n        for (let n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            const nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        const vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            const worldPoint = this._tmpAmmoVectorA;\r\n            const impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                const localTranslation = impostor.object.getWorldMatrix().getTranslation();\r\n                worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\r\n            } else {\r\n                worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            }\r\n\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        } else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const colShape = this._createShape(impostor);\r\n            const mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            } else {\r\n                const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                const startTransform = new this.bjsAMMO.btTransform();\r\n                impostor.object.computeWorldMatrix(true);\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(\r\n                    impostor.object.rotationQuaternion!.x,\r\n                    impostor.object.rotationQuaternion!.y,\r\n                    impostor.object.rotationQuaternion!.z,\r\n                    impostor.object.rotationQuaternion!.w\r\n                );\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                const body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                // compute delta position: compensate the difference between shape center and mesh origin\r\n                if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\r\n                    const boundingInfo = impostor.object.getBoundingInfo();\r\n                    this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\r\n                    this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\r\n                    this._tmpVec3.x /= impostor.object.scaling.x;\r\n                    this._tmpVec3.y /= impostor.object.scaling.y;\r\n                    this._tmpVec3.z /= impostor.object.scaling.z;\r\n                    impostor.setDeltaPosition(this._tmpVec3);\r\n                }\r\n\r\n                const group = impostor.getParam(\"group\");\r\n                const mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        const jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        let joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint: {\r\n                const distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.HingeJoint: {\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z),\r\n                    mainAxis,\r\n                    connectedAxis\r\n                );\r\n                break;\r\n            }\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(\r\n                    mainBody,\r\n                    connectedBody,\r\n                    new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z),\r\n                    new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z)\r\n                );\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n\r\n            let localMatrix;\r\n\r\n            if (topLevelObject && topLevelObject !== object) {\r\n                // top level matrix used for shape transform doesn't take scale into account.\r\n                // Moreover, every children vertex position must be in that space.\r\n                // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\r\n                let topLevelQuaternion;\r\n                if (topLevelObject.rotationQuaternion) {\r\n                    topLevelQuaternion = topLevelObject.rotationQuaternion;\r\n                } else if (topLevelObject.rotation) {\r\n                    topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\r\n                } else {\r\n                    topLevelQuaternion = Quaternion.Identity();\r\n                }\r\n                const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\r\n                topLevelMatrix.invertToRef(this._tmpMatrix);\r\n                const wm = object.computeWorldMatrix(false);\r\n                localMatrix = wm.multiply(this._tmpMatrix);\r\n            } else {\r\n                // current top level is same as object level -> only use local scaling\r\n                Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                localMatrix = this._tmpMatrix;\r\n            }\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    v = Vector3.TransformCoordinates(v, localMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const newPoints = [];\r\n            const newNorms = [];\r\n            for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            const vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const triPoints = [];\r\n                const triNorms = [];\r\n                for (let i = 0; i < vertexPositions.length; i += 3) {\r\n                    const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\r\n\r\n                const nbVertices = vertexPositions.length / 3;\r\n                const bodyVertices = softBody.get_m_nodes();\r\n                let node: any;\r\n                let nodeNormals: any;\r\n                for (let i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            const vertex_data = this._softVertexData(impostor);\r\n            const vertexPositions = vertex_data.positions;\r\n            const vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            } else {\r\n                const len = vertexPositions.length;\r\n                const segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                const segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        let len: number;\r\n        let segments: number;\r\n        const vertex_data = this._softVertexData(impostor);\r\n        const vertexPositions = vertex_data.positions;\r\n        const vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        const vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        const reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        const reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) {\r\n            // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        } else {\r\n            //extruded mesh\r\n            impostor._isFromLine = false;\r\n            const pathVectors = impostor.getParam(\"path\");\r\n            const shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        let fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\r\n\r\n        const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        let triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            let indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            const faceCount = indices.length / 3;\r\n            for (let i = 0; i < faceCount; i++) {\r\n                const triPoints = [];\r\n                for (let point = 0; point < 3; point++) {\r\n                    let v = new Vector3(\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 0],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 1],\r\n                        vertexPositions[indices[i * 3 + point] * 3 + 2]\r\n                    );\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    let vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue: any;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n\r\n        if (!ignoreChildren) {\r\n            const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            let childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                const childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    const shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    const parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    const s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(\r\n                        childMesh.rotationQuaternion!.x,\r\n                        childMesh.rotationQuaternion!.y,\r\n                        childMesh.rotationQuaternion!.z,\r\n                        childMesh.rotationQuaternion!.w\r\n                    );\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    const shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsilon or with a Math function\r\n                if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    const radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                {\r\n                    // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\r\n                    // Height is just the height between the center of each 'sphere' of the capsule caps\r\n                    const capRadius = impostorExtents.x / 2;\r\n                    returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape if the impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    if (this.onCreateCustomMeshImpostor) {\r\n                        returnValue = this.onCreateCustomMeshImpostor(impostor);\r\n                    } else {\r\n                        const triMesh = new this.bjsAMMO.btTriangleMesh();\r\n                        impostor._pluginData.toDispose.push(triMesh);\r\n                        const triangleCount = this._addMeshVerts(triMesh, object, object);\r\n                        if (triangleCount == 0) {\r\n                            returnValue = new this.bjsAMMO.btCompoundShape();\r\n                        } else {\r\n                            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // Otherwise create convexHullImpostor\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsImpostor.ConvexHullImpostor: {\r\n                if (this.onCreateCustomConvexHullImpostor) {\r\n                    returnValue = this.onCreateCustomConvexHullImpostor(impostor);\r\n                } else {\r\n                    const convexHull = new this.bjsAMMO.btConvexHullShape();\r\n                    const triangleCount = this._addHullVerts(convexHull, object, object);\r\n                    if (triangleCount == 0) {\r\n                        // Cleanup Unused Convex Hull Shape\r\n                        impostor._pluginData.toDispose.push(convexHull);\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = convexHull;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh body position/rotation from the babylon impostor\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(\r\n                    this._tmpAmmoTransform.getRotation().x(),\r\n                    this._tmpAmmoTransform.getRotation().y(),\r\n                    this._tmpAmmoTransform.getRotation().z(),\r\n                    this._tmpAmmoTransform.getRotation().w()\r\n                );\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(\r\n                this._tmpAmmoTransform.getRotation().x(),\r\n                this._tmpAmmoTransform.getRotation().y(),\r\n                this._tmpAmmoTransform.getRotation().z(),\r\n                this._tmpAmmoTransform.getRotation().w()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                const motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        } else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.linearVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        let v: any;\r\n        if (impostor.soft) {\r\n            v = impostor.physicsBody.angularVelocity();\r\n        } else {\r\n            v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        const result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        } else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        } else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets restitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            } else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        } else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        } else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        } else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append an anchor to a cloth object\r\n     * @param impostor is the cloth impostor to add anchor to\r\n     * @param otherImpostor is the rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendAnchor(\r\n        impostor: PhysicsImpostor,\r\n        otherImpostor: PhysicsImpostor,\r\n        width: number,\r\n        height: number,\r\n        influence: number = 1,\r\n        noCollisionBetweenLinkedBodies: boolean = false\r\n    ) {\r\n        const segs = impostor.segments;\r\n        const nbAcross = Math.round((segs - 1) * width);\r\n        const nbUp = Math.round((segs - 1) * height);\r\n        const nbDown = segs - 1 - nbUp;\r\n        const node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        const node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.forceActivationState(0);\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     */\r\n    public updateDistanceJoint() {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     */\r\n    public setLimit() {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const extents = impostor.getObjectExtents();\r\n        return extents.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const extents = impostor.getObjectExtents();\r\n        result.x = extents.x;\r\n        result.y = extents.y;\r\n        result.z = extents.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of temp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from where should the ray start?\r\n     * @param to where should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        result.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            result.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            result.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n    }\r\n}\r\n","import type { Nullable, IndicesArray } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { ArrayTools } from \"../../Misc/arrayTools\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Bone } from \"../../Bones/bone\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { PhysicsEngine as PhysicsEngineV1 } from \"./physicsEngine\";\r\n\r\nimport type { PhysicsJointData } from \"./physicsJoint\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * The interface for the physics imposter parameters\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface PhysicsImpostorParameters {\r\n    /**\r\n     * The mass of the physics imposter\r\n     */\r\n    mass: number;\r\n    /**\r\n     * The friction of the physics imposter\r\n     */\r\n    friction?: number;\r\n    /**\r\n     * The coefficient of restitution of the physics imposter\r\n     */\r\n    restitution?: number;\r\n    /**\r\n     * The native options of the physics imposter\r\n     */\r\n    nativeOptions?: any;\r\n    /**\r\n     * Specifies if the parent should be ignored\r\n     */\r\n    ignoreParent?: boolean;\r\n    /**\r\n     * Specifies if bi-directional transformations should be disabled\r\n     */\r\n    disableBidirectionalTransformation?: boolean;\r\n    /**\r\n     * The pressure inside the physics imposter, soft object only\r\n     */\r\n    pressure?: number;\r\n    /**\r\n     * The stiffness the physics imposter, soft object only\r\n     */\r\n    stiffness?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex velocities, soft object only\r\n     */\r\n    velocityIterations?: number;\r\n    /**\r\n     * The number of iterations used in maintaining consistent vertex positions, soft object only\r\n     */\r\n    positionIterations?: number;\r\n    /**\r\n     * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only\r\n     * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right\r\n     * Add to fix multiple points\r\n     */\r\n    fixedPoints?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    margin?: number;\r\n    /**\r\n     * The collision margin around a soft object\r\n     */\r\n    damping?: number;\r\n    /**\r\n     * The path for a rope based on an extrusion\r\n     */\r\n    path?: any;\r\n    /**\r\n     * The shape of an extrusion used for a rope based on an extrusion\r\n     */\r\n    shape?: any;\r\n}\r\n\r\n/**\r\n * Interface for a physics-enabled object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport interface IPhysicsEnabledObject {\r\n    /**\r\n     * The position of the physics-enabled object\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scale of the physics-enabled object\r\n     */\r\n    scaling: Vector3;\r\n    /**\r\n     * The rotation of the physics-enabled object\r\n     */\r\n    rotation?: Vector3;\r\n    /**\r\n     * The parent of the physics-enabled object\r\n     */\r\n    parent?: any;\r\n    /**\r\n     * The bounding info of the physics-enabled object\r\n     * @returns The bounding info of the physics-enabled object\r\n     */\r\n    getBoundingInfo(): BoundingInfo;\r\n    /**\r\n     * Computes the world matrix\r\n     * @param force Specifies if the world matrix should be computed by force\r\n     * @returns A world matrix\r\n     */\r\n    computeWorldMatrix(force: boolean): Matrix;\r\n    /**\r\n     * Gets the world matrix\r\n     * @returns A world matrix\r\n     */\r\n    getWorldMatrix?(): Matrix;\r\n    /**\r\n     * Gets the child meshes\r\n     * @param directDescendantsOnly Specifies if only direct-descendants should be obtained\r\n     * @returns An array of abstract meshes\r\n     */\r\n    getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;\r\n    /**\r\n     * Gets the vertex data\r\n     * @param kind The type of vertex data\r\n     * @returns A nullable array of numbers, or a float32 array\r\n     */\r\n    getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;\r\n    /**\r\n     * Gets the indices from the mesh\r\n     * @returns A nullable array of index arrays\r\n     */\r\n    getIndices?(): Nullable<IndicesArray>;\r\n    /**\r\n     * Gets the scene from the mesh\r\n     * @returns the indices array or null\r\n     */\r\n    getScene?(): Scene;\r\n    /**\r\n     * Gets the absolute position from the mesh\r\n     * @returns the absolute position\r\n     */\r\n    getAbsolutePosition(): Vector3;\r\n    /**\r\n     * Gets the absolute pivot point from the mesh\r\n     * @returns the absolute pivot point\r\n     */\r\n    getAbsolutePivotPoint(): Vector3;\r\n    /**\r\n     * Rotates the mesh\r\n     * @param axis The axis of rotation\r\n     * @param amount The amount of rotation\r\n     * @param space The space of the rotation\r\n     * @returns The rotation transform node\r\n     */\r\n    rotate(axis: Vector3, amount: number, space?: Space): TransformNode;\r\n    /**\r\n     * Translates the mesh\r\n     * @param axis The axis of translation\r\n     * @param distance The distance of translation\r\n     * @param space The space of the translation\r\n     * @returns The transform node\r\n     */\r\n    translate(axis: Vector3, distance: number, space?: Space): TransformNode;\r\n    /**\r\n     * Sets the absolute position of the mesh\r\n     * @param absolutePosition The absolute position of the mesh\r\n     * @returns The transform node\r\n     */\r\n    setAbsolutePosition(absolutePosition: Vector3): TransformNode;\r\n    /**\r\n     * Gets the class name of the mesh\r\n     * @returns The class name\r\n     */\r\n    getClassName(): string;\r\n}\r\n\r\nMesh._PhysicsImpostorParser = function (scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n    return new PhysicsImpostor(\r\n        physicObject,\r\n        jsonObject.physicsImpostor,\r\n        {\r\n            mass: jsonObject.physicsMass,\r\n            friction: jsonObject.physicsFriction,\r\n            restitution: jsonObject.physicsRestitution,\r\n        },\r\n        scene\r\n    );\r\n};\r\n\r\n/**\r\n * Represents a physics imposter\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsImpostor {\r\n    /**\r\n     * The default object size of the imposter\r\n     */\r\n    public static DEFAULT_OBJECT_SIZE: Vector3 = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * The identity quaternion of the imposter\r\n     */\r\n    public static IDENTITY_QUATERNION = Quaternion.Identity();\r\n\r\n    /** @internal */\r\n    public _pluginData: any = {};\r\n\r\n    private _physicsEngine: Nullable<PhysicsEngineV1>;\r\n    //The native cannon/oimo/energy physics body object.\r\n    private _physicsBody: any;\r\n    private _bodyUpdateRequired: boolean = false;\r\n\r\n    private _onBeforePhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    private _onAfterPhysicsStepCallbacks = new Array<(impostor: PhysicsImpostor) => void>();\r\n    /** @internal */\r\n    public _onPhysicsCollideCallbacks: Array<{\r\n        callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>, distance: number, impulse: number, normal: Nullable<Vector3>) => void;\r\n        otherImpostors: Array<PhysicsImpostor>;\r\n    }> = [];\r\n\r\n    private _deltaPosition: Vector3 = Vector3.Zero();\r\n    private _deltaRotation: Quaternion;\r\n    private _deltaRotationConjugated: Quaternion;\r\n\r\n    /** @internal */\r\n    public _isFromLine: boolean;\r\n\r\n    //If set, this is this impostor's parent\r\n    private _parent: Nullable<PhysicsImpostor>;\r\n\r\n    private _isDisposed = false;\r\n\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private static _TmpQuat: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Specifies if the physics imposter is disposed\r\n     */\r\n    get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics imposter\r\n     */\r\n    get mass(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\r\n    }\r\n\r\n    set mass(value: number) {\r\n        this.setMass(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of friction\r\n     */\r\n    get friction(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of friction\r\n     */\r\n    set friction(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the coefficient of restitution\r\n     */\r\n    get restitution(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coefficient of restitution\r\n     */\r\n    set restitution(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get pressure(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPressure!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set pressure(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPressure) {\r\n            return;\r\n        }\r\n        plugin.setBodyPressure!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get stiffness(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyStiffness) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyStiffness!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set stiffness(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyStiffness) {\r\n            return;\r\n        }\r\n        plugin.setBodyStiffness!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get velocityIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyVelocityIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyVelocityIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set velocityIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyVelocityIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyVelocityIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    get positionIterations(): number {\r\n        if (!this._physicsEngine) {\r\n            return 0;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.getBodyPositionIterations) {\r\n            return 0;\r\n        }\r\n        return plugin.getBodyPositionIterations!(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\r\n     */\r\n    set positionIterations(value: number) {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.setBodyPositionIterations) {\r\n            return;\r\n        }\r\n        plugin.setBodyPositionIterations!(this, value);\r\n    }\r\n\r\n    /**\r\n     * The unique id of the physics imposter\r\n     * set by the physics engine when adding this impostor to the array\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public soft: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public segments: number = 0;\r\n\r\n    private _joints: Array<{\r\n        joint: PhysicsJoint;\r\n        otherImpostor: PhysicsImpostor;\r\n    }>;\r\n\r\n    /**\r\n     * Initializes the physics imposter\r\n     * @param object The physics-enabled object used as the physics imposter\r\n     * @param type The type of the physics imposter. Types are available as static members of this class.\r\n     * @param _options The options for the physics imposter\r\n     * @param _scene The Babylon scene\r\n     */\r\n    constructor(\r\n        /**\r\n         * The physics-enabled object used as the physics imposter\r\n         */\r\n        public object: IPhysicsEnabledObject,\r\n        /**\r\n         * The type of the physics imposter\r\n         */\r\n        public type: number,\r\n        private _options: PhysicsImpostorParameters = { mass: 0 },\r\n        private _scene?: Scene\r\n    ) {\r\n        //sanity check!\r\n        if (!this.object) {\r\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\r\n            return;\r\n        }\r\n        if (this.object.parent && _options.mass !== 0) {\r\n            Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\r\n        }\r\n\r\n        // Legacy support for old syntax.\r\n        if (!this._scene && object.getScene) {\r\n            this._scene = object.getScene();\r\n        }\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.type > 100) {\r\n            this.soft = true;\r\n        }\r\n\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as any;\r\n        if (!this._physicsEngine) {\r\n            Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\r\n        } else {\r\n            //set the object's quaternion, if not set\r\n            if (!this.object.rotationQuaternion) {\r\n                if (this.object.rotation) {\r\n                    this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\r\n                } else {\r\n                    this.object.rotationQuaternion = new Quaternion();\r\n                }\r\n            }\r\n            //default options params\r\n            this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\r\n            this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\r\n            this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\r\n            if (this.soft) {\r\n                //softbody mass must be above 0;\r\n                this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\r\n                this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\r\n                this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\r\n                this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\r\n                this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\r\n                this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\r\n                this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\r\n                this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\r\n                this._options.path = _options.path === void 0 ? null : _options.path;\r\n                this._options.shape = _options.shape === void 0 ? null : _options.shape;\r\n            }\r\n            this._joints = [];\r\n            //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\r\n            if (!this.object.parent || this._options.ignoreParent) {\r\n                this._init();\r\n            } else if (this.object.parent.physicsImpostor) {\r\n                Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will completely initialize this impostor.\r\n     * It will create a new body - but only if this mesh has no parent.\r\n     * If it has, this impostor will not be used other than to define the impostor\r\n     * of the child mesh.\r\n     * @internal\r\n     */\r\n    public _init() {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._physicsEngine.removeImpostor(this);\r\n        this.physicsBody = null;\r\n        this._parent = this._parent || this._getPhysicsParent();\r\n        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\r\n            this._physicsEngine.addImpostor(this);\r\n        }\r\n    }\r\n\r\n    private _getPhysicsParent(): Nullable<PhysicsImpostor> {\r\n        if (this.object.parent instanceof AbstractMesh) {\r\n            const parentMesh: AbstractMesh = <AbstractMesh>this.object.parent;\r\n            return parentMesh.physicsImpostor;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Should a new body be generated.\r\n     * @returns boolean specifying if body initialization is required\r\n     */\r\n    public isBodyInitRequired(): boolean {\r\n        return this._bodyUpdateRequired || (!this._physicsBody && (!this._parent || !!this._options.ignoreParent));\r\n    }\r\n\r\n    /**\r\n     * Sets the updated scaling\r\n     */\r\n    public setScalingUpdated() {\r\n        this.forceUpdate();\r\n    }\r\n\r\n    /**\r\n     * Force a regeneration of this or the parent's impostor's body.\r\n     * Use with caution - This will remove all previously-instantiated joints.\r\n     */\r\n    public forceUpdate() {\r\n        this._init();\r\n        if (this.parent && !this._options.ignoreParent) {\r\n            this.parent.forceUpdate();\r\n        }\r\n    }\r\n\r\n    /*public get mesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }*/\r\n\r\n    /**\r\n     * Gets the body that holds this impostor. Either its own, or its parent.\r\n     */\r\n    public get physicsBody(): any {\r\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\r\n    }\r\n\r\n    /**\r\n     * Get the parent of the physics imposter\r\n     * @returns Physics imposter or null\r\n     */\r\n    public get parent(): Nullable<PhysicsImpostor> {\r\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent of the physics imposter\r\n     */\r\n    public set parent(value: Nullable<PhysicsImpostor>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    /**\r\n     * Set the physics body. Used mainly by the physics engine/plugin\r\n     */\r\n    public set physicsBody(physicsBody: any) {\r\n        if (this._physicsBody && this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\r\n        }\r\n        this._physicsBody = physicsBody;\r\n        this.resetUpdateFlags();\r\n    }\r\n\r\n    /**\r\n     * Resets the update flags\r\n     */\r\n    public resetUpdateFlags() {\r\n        this._bodyUpdateRequired = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the object extents\r\n     * @returns the object extents\r\n     */\r\n    public getObjectExtents(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const q = this.object.rotationQuaternion;\r\n            const scaling = this.object.scaling.clone();\r\n            //reset rotation\r\n            this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\r\n            //calculate the world matrix with no rotation\r\n            const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            if (worldMatrix) {\r\n                worldMatrix.decompose(scaling, undefined, undefined);\r\n            }\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            // get the global scaling of the object\r\n            const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\r\n            size.x = Math.abs(size.x);\r\n            size.y = Math.abs(size.y);\r\n            size.z = Math.abs(size.z);\r\n            //bring back the rotation\r\n            this.object.rotationQuaternion = q;\r\n            //calculate the world matrix with the new rotation\r\n            this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\r\n            return size;\r\n        } else {\r\n            return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the object center\r\n     * @returns The object center\r\n     */\r\n    public getObjectCenter(): Vector3 {\r\n        if (this.object.getBoundingInfo) {\r\n            const boundingInfo = this.object.getBoundingInfo();\r\n            return boundingInfo.boundingBox.centerWorld;\r\n        } else {\r\n            return this.object.position;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a specific parameter from the options parameters\r\n     * @param paramName The object parameter name\r\n     * @returns The object parameter\r\n     */\r\n    public getParam(paramName: string): any {\r\n        return (<any>this._options)[paramName];\r\n    }\r\n\r\n    /**\r\n     * Sets a specific parameter in the options given to the physics plugin\r\n     * @param paramName The parameter name\r\n     * @param value The value of the parameter\r\n     */\r\n    public setParam(paramName: string, value: number) {\r\n        (<any>this._options)[paramName] = value;\r\n        this._bodyUpdateRequired = true;\r\n    }\r\n\r\n    /**\r\n     * Specifically change the body's mass. Won't recreate the physics body object\r\n     * @param mass The mass of the physics imposter\r\n     */\r\n    public setMass(mass: number) {\r\n        if (this.getParam(\"mass\") !== mass) {\r\n            this.setParam(\"mass\", mass);\r\n        }\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity\r\n     * @returns  linear velocity or null\r\n     */\r\n    public getLinearVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity\r\n     * @param velocity  linear velocity or null\r\n     */\r\n    public setLinearVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity\r\n     * @returns angular velocity or null\r\n     */\r\n    public getAngularVelocity(): Nullable<Vector3> {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity\r\n     * @param velocity The velocity or null\r\n     */\r\n    public setAngularVelocity(velocity: Nullable<Vector3>) {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a function with the physics plugin native code\r\n     * Provide a function the will have two variables - the world object and the physics body object\r\n     * @param func The function to execute with the physics plugin native code\r\n     */\r\n    public executeNativeFunction(func: (world: any, physicsBody: any) => void) {\r\n        if (this._physicsEngine) {\r\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onBeforePhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregister a function that will be executed before the physics world is stepping forward\r\n     * @param func The function to execute before the physics world is stepped forward\r\n     */\r\n    public unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onBeforePhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        this._onAfterPhysicsStepCallbacks.push(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function that will be executed after the physics step\r\n     * @param func The function to execute after physics step\r\n     */\r\n    public unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void {\r\n        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\r\n\r\n        if (index > -1) {\r\n            this._onAfterPhysicsStepCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * register a function that will be executed when this impostor collides against a different body\r\n     * @param collideAgainst Physics imposter, or array of physics imposters to collide against\r\n     * @param func Callback that is executed on collision\r\n     */\r\n    public registerOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\r\n    }\r\n\r\n    /**\r\n     * Unregisters the physics imposter's collision callback\r\n     * @param collideAgainst The physics object to collide against\r\n     * @param func Callback to execute on collision\r\n     */\r\n    public unregisterOnPhysicsCollide(\r\n        collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>,\r\n        func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>, point: Nullable<Vector3>) => void\r\n    ): void {\r\n        const collidedAgainstList: Array<PhysicsImpostor> = collideAgainst instanceof Array ? <Array<PhysicsImpostor>>collideAgainst : [<PhysicsImpostor>collideAgainst];\r\n        let index = -1;\r\n        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\r\n            if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\r\n                // chcek the arrays match\r\n                const sameList = cbDef.otherImpostors.every((impostor) => {\r\n                    return collidedAgainstList.indexOf(impostor) > -1;\r\n                });\r\n                if (sameList) {\r\n                    index = idx;\r\n                }\r\n                return sameList;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (found) {\r\n            this._onPhysicsCollideCallbacks.splice(index, 1);\r\n        } else {\r\n            Logger.Warn(\"Function to remove was not found\");\r\n        }\r\n    }\r\n\r\n    //temp variables for parent rotation calculations\r\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _tmpQuat2: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Get the parent rotation\r\n     * @returns The parent rotation\r\n     */\r\n    public getParentsRotation(): Quaternion {\r\n        let parent = this.object.parent;\r\n        this._tmpQuat.copyFromFloats(0, 0, 0, 1);\r\n        while (parent) {\r\n            if (parent.rotationQuaternion) {\r\n                this._tmpQuat2.copyFrom(parent.rotationQuaternion);\r\n            } else {\r\n                Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\r\n            }\r\n            this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\r\n            parent = parent.parent;\r\n        }\r\n        return this._tmpQuat;\r\n    }\r\n\r\n    /**\r\n     * this function is executed by the physics engine.\r\n     */\r\n    public beforeStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this.object.translate(this._deltaPosition, -1);\r\n        this._deltaRotationConjugated &&\r\n            this.object.rotationQuaternion &&\r\n            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\r\n        this.object.computeWorldMatrix(false);\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\r\n        } else {\r\n            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\r\n        }\r\n        if (!this._options.disableBidirectionalTransformation) {\r\n            this.object.rotationQuaternion &&\r\n                this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/ this.object.getAbsolutePosition(), this._tmpQuat);\r\n        }\r\n\r\n        this._onBeforePhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * this function is executed by the physics engine\r\n     */\r\n    public afterStep = () => {\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._onAfterPhysicsStepCallbacks.forEach((func) => {\r\n            func(this);\r\n        });\r\n\r\n        this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\r\n        // object has now its world rotation. needs to be converted to local.\r\n        if (this.object.parent && this.object.rotationQuaternion) {\r\n            this.getParentsRotation();\r\n            this._tmpQuat.conjugateInPlace();\r\n            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\r\n        }\r\n        // take the position set and make it the absolute position of this object.\r\n        this.object.setAbsolutePosition(this.object.position);\r\n        if (this._deltaRotation) {\r\n            this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\r\n            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\r\n            this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\r\n        } else {\r\n            this.object.translate(this._deltaPosition, 1);\r\n        }\r\n        this.object.computeWorldMatrix(true);\r\n    };\r\n\r\n    /**\r\n     * Legacy collision detection event support\r\n     */\r\n    public onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void> = null;\r\n\r\n    /**\r\n     *\r\n     * @param e\r\n     * @returns\r\n     */\r\n    public onCollide = (e: { body: any; point: Nullable<Vector3>; distance: number; impulse: number; normal: Nullable<Vector3> }) => {\r\n        if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\r\n            return;\r\n        }\r\n\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n        const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\r\n        if (otherImpostor) {\r\n            // Legacy collision detection event support\r\n            if (this.onCollideEvent) {\r\n                this.onCollideEvent(this, otherImpostor);\r\n            }\r\n            this._onPhysicsCollideCallbacks\r\n                .filter((obj) => {\r\n                    return obj.otherImpostors.indexOf(<PhysicsImpostor>otherImpostor) !== -1;\r\n                })\r\n                .forEach((obj) => {\r\n                    obj.callback(this, <PhysicsImpostor>otherImpostor, e.point, e.distance, e.impulse, e.normal);\r\n                });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply a force\r\n     * @param force The force to apply\r\n     * @param contactPoint The contact point for the force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply an impulse\r\n     * @param force The impulse force\r\n     * @param contactPoint The contact point for the impulse force\r\n     * @returns The physics imposter\r\n     */\r\n    public applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * A help function to create a joint\r\n     * @param otherImpostor A physics imposter used to create a joint\r\n     * @param jointType The type of joint\r\n     * @param jointData The data for the joint\r\n     * @returns The physics imposter\r\n     */\r\n    public createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor {\r\n        const joint = new PhysicsJoint(jointType, jointData);\r\n        this.addJoint(otherImpostor, joint);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a joint to this impostor with a different impostor\r\n     * @param otherImpostor A physics imposter used to add a joint\r\n     * @param joint The joint to add\r\n     * @returns The physics imposter\r\n     */\r\n    public addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor {\r\n        this._joints.push({\r\n            otherImpostor: otherImpostor,\r\n            joint: joint,\r\n        });\r\n\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add an anchor to a cloth impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param width ratio across width from 0 to 1\r\n     * @param height ratio up height from 0 to 1\r\n     * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\r\n     * @returns impostor the soft imposter\r\n     */\r\n    public addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendAnchor!(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a hook to a rope impostor\r\n     * @param otherImpostor rigid impostor to anchor to\r\n     * @param length ratio across rope from 0 to 1\r\n     * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     * @returns impostor the rope imposter\r\n     */\r\n    public addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor {\r\n        if (!this._physicsEngine) {\r\n            return this;\r\n        }\r\n        const plugin = this._physicsEngine.getPhysicsPlugin();\r\n        if (!plugin.appendAnchor) {\r\n            return this;\r\n        }\r\n        if (this._physicsEngine) {\r\n            plugin.appendHook!(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will keep this body still, in a sleep mode.\r\n     * @returns the physics imposter\r\n     */\r\n    public sleep(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Wake the body up.\r\n     * @returns The physics imposter\r\n     */\r\n    public wakeUp(): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the physics imposter\r\n     * @param newObject The physics imposter clones to this physics-enabled object\r\n     * @returns A nullable physics imposter\r\n     */\r\n    public clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        if (!newObject) {\r\n            return null;\r\n        }\r\n        return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\r\n    }\r\n\r\n    /**\r\n     * Disposes the physics imposter\r\n     */\r\n    public dispose(/*disposeChildren: boolean = true*/) {\r\n        //no dispose if no physics engine is available.\r\n        if (!this._physicsEngine) {\r\n            return;\r\n        }\r\n\r\n        this._joints.forEach((j) => {\r\n            if (this._physicsEngine) {\r\n                this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\r\n            }\r\n        });\r\n        //dispose the physics body\r\n        this._physicsEngine.removeImpostor(this);\r\n        if (this.parent) {\r\n            this.parent.forceUpdate();\r\n        } else {\r\n            /*this._object.getChildMeshes().forEach(function(mesh) {\r\n                if (mesh.physicsImpostor) {\r\n                    if (disposeChildren) {\r\n                        mesh.physicsImpostor.dispose();\r\n                        mesh.physicsImpostor = null;\r\n                    }\r\n                }\r\n            })*/\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the delta position\r\n     * @param position The delta position amount\r\n     */\r\n    public setDeltaPosition(position: Vector3) {\r\n        this._deltaPosition.copyFrom(position);\r\n    }\r\n\r\n    /**\r\n     * Sets the delta rotation\r\n     * @param rotation The delta rotation amount\r\n     */\r\n    public setDeltaRotation(rotation: Quaternion) {\r\n        if (!this._deltaRotation) {\r\n            this._deltaRotation = new Quaternion();\r\n        }\r\n        this._deltaRotation.copyFrom(rotation);\r\n        this._deltaRotationConjugated = this._deltaRotation.conjugate();\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the physics imposter and stores the result in the input parameter\r\n     * @param result Stores the box size\r\n     * @returns The physics imposter\r\n     */\r\n    public getBoxSizeToRef(result: Vector3): PhysicsImpostor {\r\n        if (this._physicsEngine) {\r\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the physics imposter\r\n     * @returns Radius of the physics imposter\r\n     */\r\n    public getRadius(): number {\r\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\r\n    }\r\n\r\n    /**\r\n     * Sync a bone with this impostor\r\n     * @param bone The bone to sync to the impostor.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     */\r\n    public syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion) {\r\n        const tempVec = PhysicsImpostor._TmpVecs[0];\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\r\n                bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\r\n            } else {\r\n                bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\r\n            }\r\n        }\r\n\r\n        tempVec.x = 0;\r\n        tempVec.y = 0;\r\n        tempVec.z = 0;\r\n\r\n        if (jointPivot) {\r\n            tempVec.x = jointPivot.x;\r\n            tempVec.y = jointPivot.y;\r\n            tempVec.z = jointPivot.z;\r\n\r\n            bone.getDirectionToRef(tempVec, boneMesh, tempVec);\r\n\r\n            if (distToJoint === undefined || distToJoint === null) {\r\n                distToJoint = jointPivot.length();\r\n            }\r\n\r\n            tempVec.x *= distToJoint;\r\n            tempVec.y *= distToJoint;\r\n            tempVec.z *= distToJoint;\r\n        }\r\n\r\n        if (bone.getParent()) {\r\n            tempVec.addInPlace(mesh.getAbsolutePosition());\r\n            bone.setAbsolutePosition(tempVec, boneMesh);\r\n        } else {\r\n            boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\r\n            boneMesh.position.x -= tempVec.x;\r\n            boneMesh.position.y -= tempVec.y;\r\n            boneMesh.position.z -= tempVec.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync impostor to a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = <AbstractMesh>this.object;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = PhysicsImpostor._TmpQuat;\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = PhysicsImpostor._TmpVecs[0];\r\n        const boneDir = PhysicsImpostor._TmpVecs[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = PhysicsImpostor._TmpVecs[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    //Impostor types\r\n    /**\r\n     * No-Imposter type\r\n     */\r\n    public static NoImpostor = 0;\r\n    /**\r\n     * Sphere-Imposter type\r\n     */\r\n    public static SphereImpostor = 1;\r\n    /**\r\n     * Box-Imposter type\r\n     */\r\n    public static BoxImpostor = 2;\r\n    /**\r\n     * Plane-Imposter type\r\n     */\r\n    public static PlaneImpostor = 3;\r\n    /**\r\n     * Mesh-imposter type (Only available to objects with vertices data)\r\n     */\r\n    public static MeshImpostor = 4;\r\n    /**\r\n     * Capsule-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static CapsuleImpostor = 6;\r\n    /**\r\n     * Cylinder-Imposter type\r\n     */\r\n    public static CylinderImpostor = 7;\r\n    /**\r\n     * Particle-Imposter type\r\n     */\r\n    public static ParticleImpostor = 8;\r\n    /**\r\n     * Heightmap-Imposter type\r\n     */\r\n    public static HeightmapImpostor = 9;\r\n    /**\r\n     * ConvexHull-Impostor type (Ammo.js plugin only)\r\n     */\r\n    public static ConvexHullImpostor = 10;\r\n    /**\r\n     * Custom-Imposter type (Ammo.js plugin only)\r\n     */\r\n    public static CustomImpostor = 100;\r\n    /**\r\n     * Rope-Imposter type\r\n     */\r\n    public static RopeImpostor = 101;\r\n    /**\r\n     * Cloth-Imposter type\r\n     */\r\n    public static ClothImpostor = 102;\r\n    /**\r\n     * Softbody-Imposter type\r\n     */\r\n    public static SoftbodyImpostor = 103;\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n"],"names":["_LinesMeshParser","parsedMesh","scene","LinesMesh","Parse","_isShaderMaterial","shader","getClassName","constructor","name","parent","source","doNotCloneChildren","useVertexColor","useVertexAlpha","material","super","color","alpha","this","clone","intersectionThreshold","options","attributes","PositionKind","uniforms","needAlphaBlending","defines","useClipPlane","push","ColorKind","_color4","getScene","doNotSerialize","isReady","_lineMaterial","_userInstancedBuffersStorage","value","fillMode","LineListDrawMode","checkCollisions","_bind","_subMesh","colorEffect","_geometry","indexToBind","isUnIndexed","getIndexBuffer","vertexBuffers","vertexArrayObjects","r","g","b","set","setColor4","_draw","subMesh","instancesCount","getVertexBuffers","_unIndexed","engine","getEngine","drawArraysType","verticesStart","verticesCount","drawElementsType","indexStart","indexCount","dispose","doNotRecurse","disposeMaterialAndTextures","doNotDisposeMaterial","newParent","createInstance","instance","InstancedLinesMesh","instancedBuffers","key","serialize","serializationObject","asArray","result","FromArray","AmmoJSPlugin","_useDeltaForWorldStep","ammoInjection","Ammo","overlappingPairCache","bjsAMMO","_timeStep","_fixedTimeStep","_maxSteps","_tmpQuaternion","_tmpContactCallbackResult","_tmpContactPoint","_tmpContactNormal","_tmpVec3","_tmpMatrix","isSupported","_collisionConfiguration","btSoftBodyRigidBodyCollisionConfiguration","_dispatcher","btCollisionDispatcher","_overlappingPairCache","btDbvtBroadphase","_solver","btSequentialImpulseConstraintSolver","_softBodySolver","btDefaultSoftBodySolver","world","btSoftRigidDynamicsWorld","_tmpAmmoConcreteContactResultCallback","ConcreteContactResultCallback","addSingleResult","contactPoint","worldPoint","wrapPointer","btManifoldPoint","getPositionWorldOnA","worldNormal","m_normalWorldOnB","x","y","z","_tmpContactImpulse","getAppliedImpulse","_tmpContactDistance","getDistance","_raycastResult","_tmpAmmoTransform","btTransform","setIdentity","_tmpAmmoQuaternion","btQuaternion","_tmpAmmoVectorA","btVector3","_tmpAmmoVectorB","_tmpAmmoVectorC","_tmpAmmoVectorD","Error","getPluginVersion","setGravity","gravity","setValue","getWorldInfo","set_m_gravity","setTimeStep","timeStep","setFixedTimeStep","fixedTimeStep","setMaxSteps","maxSteps","getTimeStep","_isImpostorInContact","impostor","contactTest","physicsBody","_isImpostorPairInContact","impostorA","impostorB","contactPairTest","_stepSimulation","stepSimulation","executeStep","delta","impostors","soft","beforeStep","mainImpostor","_afterSoftStep","afterStep","_onPhysicsCollideCallbacks","length","collideCallback","otherImpostor","otherImpostors","isActive","onCollide","body","point","distance","impulse","normal","type","RopeImpostor","_ropeStep","_softbodyOrClothStep","bodyVertices","get_m_nodes","nbVertices","size","node","nodePositions","path","Array","n","at","get_m_x","object","shape","getParam","_isFromLine","points","normalDirection","ClothImpostor","vertexPositions","getVerticesData","vertexNormals","NormalKind","nx","ny","nz","nodeNormals","get_m_n","vertex_data","positions","normals","uvs","UVKind","colors","getIndices","indices","applyToMesh","applyImpulse","force","Warn","activate","getWorldMatrix","subtractInPlace","getTranslation","applyForce","localTranslation","generatePhysicsBody","_pluginData","toDispose","removePhysicsBody","forceUpdate","isBodyInitRequired","colShape","_createShape","mass","get_m_cfg","set_collisions","set_kDP","castObject","btCollisionObject","getCollisionShape","setMargin","setActivationState","_DISABLE_DEACTIVATION_FLAG","addSoftBody","setBodyPressure","SoftbodyImpostor","setBodyStiffness","setBodyVelocityIterations","setBodyPositionIterations","localInertia","startTransform","computeWorldMatrix","calculateLocalInertia","position","rotationQuaternion","w","setOrigin","setRotation","myMotionState","btDefaultMotionState","rbInfo","btRigidBodyConstructionInfo","btRigidBody","setCollisionFlags","getCollisionFlags","_KINEMATIC_FLAG","NoImpostor","getChildShape","_DISABLE_COLLISION_FLAG","MeshImpostor","boundingInfo","getBoundingInfo","copyFrom","getAbsolutePosition","boundingBox","centerWorld","scaling","setDeltaPosition","group","mask","addRigidBody","concat","setBodyRestitution","setBodyFriction","removeSoftBody","removeRigidBody","forEach","d","destroy","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","mainPivot","connectedPivot","DistanceJoint","maxDistance","btPoint2PointConstraint","HingeJoint","mainAxis","connectedAxis","btHingeConstraint","BallAndSocketJoint","addConstraint","collision","physicsJoint","removeJoint","removeConstraint","_addMeshVerts","btTriangleMesh","topLevelObject","triangleCount","getChildMeshes","localMatrix","topLevelQuaternion","rotation","FromEulerAngles","Identity","Compose","One","invertToRef","multiply","ScalingToRef","faceCount","i","triPoints","vec","v","TransformCoordinates","addTriangle","m","_softVertexData","newPoints","newNorms","TransformNormal","Zero","ExtractFromMesh","_createSoftbody","btCompoundShape","triNorms","softBody","btSoftBodyHelpers","CreateFromTriMesh","setX","setY","setZ","_createCloth","len","segments","Math","sqrt","segs","CreatePatch","_createRope","map","reduce","accumulator","currentValue","pathVectors","fixedPoints","ropeBody","CreateRope","_createCustom","returnValue","onCreateCustomShape","_addHullVerts","btConvexHullShape","addPoint","ignoreChildren","impostorExtents","getObjectExtents","meshChildren","childrenAdded","childMesh","childImpostor","getPhysicsImpostor","parentMat","s","decompose","getOrigin","addChildShape","SphereImpostor","WithinEpsilon","btSphereShape","radii","btMultiSphereShape","setLocalScaling","CapsuleImpostor","capRadius","btCapsuleShape","CylinderImpostor","btCylinderShape","PlaneImpostor","BoxImpostor","btBoxShape","onCreateCustomMeshImpostor","triMesh","btBvhTriangleMeshShape","ConvexHullImpostor","onCreateCustomConvexHullImpostor","convexHull","CustomImpostor","setTransformationFromPhysicsBody","getMotionState","getWorldTransform","getRotation","toEulerAnglesToRef","setPhysicsBodyTransformation","newPosition","newRotation","trans","abs","setWorldTransform","motionState","undefined","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","getAngularVelocity","setBodyMass","setTotalMass","setMassProps","getBodyMass","getBodyFriction","friction","set_kDF","setFriction","getBodyRestitution","restitution","setRestitution","getBodyPressure","pressure","set_kPR","getBodyStiffness","stiffness","get_m_materials","set_m_kLST","getBodyVelocityIterations","velocityIterations","set_viterations","getBodyPositionIterations","positionIterations","set_piterations","appendAnchor","width","height","influence","noCollisionBetweenLinkedBodies","round","appendHook","sleepBody","forceActivationState","wakeUpBody","updateDistanceJoint","setMotor","speed","maxForce","enableAngularMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","getBoxSizeToRef","extents","raycast","from","to","raycastToRef","_tmpAmmoVectorRCA","_tmpAmmoVectorRCB","rayCallback","ClosestRayResultCallback","rayTest","reset","hasHit","setHitData","get_m_hitNormalWorld","get_m_hitPointWorld","calculateHitDistance","_PhysicsImpostorParser","physicObject","jsonObject","PhysicsImpostor","physicsImpostor","physicsMass","physicsFriction","physicsRestitution","isDisposed","_isDisposed","_physicsEngine","getPhysicsPlugin","setMass","plugin","_options","_scene","_bodyUpdateRequired","_onBeforePhysicsStepCallbacks","_onAfterPhysicsStepCallbacks","_deltaPosition","_tmpQuat","_tmpQuat2","translate","_deltaRotationConjugated","multiplyToRef","getParentsRotation","disableBidirectionalTransformation","func","conjugateInPlace","setAbsolutePosition","_deltaRotation","applyRotationQuaternionToRef","_TmpVecs","onCollideEvent","e","getImpostorWithPhysicsBody","filter","obj","indexOf","callback","getPhysicsEngine","RotationYawPitchRoll","margin","damping","_joints","ignoreParent","_init","removeImpostor","_parent","_getPhysicsParent","addImpostor","_physicsBody","setScalingUpdated","resetUpdateFlags","q","IDENTITY_QUATERNION","worldMatrix","extendSize","scale","multiplyInPlace","DEFAULT_OBJECT_SIZE","getObjectCenter","paramName","setParam","executeNativeFunction","registerBeforePhysicsStep","unregisterBeforePhysicsStep","index","splice","registerAfterPhysicsStep","unregisterAfterPhysicsStep","registerOnPhysicsCollide","collideAgainst","collidedAgainstList","unregisterOnPhysicsCollide","some","cbDef","idx","sameList","every","copyFromFloats","RotationYawPitchRollToRef","createJoint","jointType","addJoint","addAnchor","addHook","sleep","wakeUp","newObject","j","setDeltaRotation","conjugate","syncBoneWithImpostor","bone","boneMesh","jointPivot","distToJoint","adjustRotation","tempVec","tempQuat","_TmpQuat","setRotationQuaternion","WORLD","getDirectionToRef","getParent","addInPlace","syncImpostorWithBone","boneAxis","getRotationQuaternionToRef","pos","boneDir","getAbsolutePositionToRef","BuildArray","ParticleImpostor","HeightmapImpostor","ShadersStore"],"sourceRoot":""}