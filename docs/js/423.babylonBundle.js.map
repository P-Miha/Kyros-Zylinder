{"version":3,"file":"js/423.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/hemisphericLight.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/linesBuilder.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/ribbonBuilder.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/shapeBuilder.ts"],"sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n","import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {\r\n                // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            } else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.pathArray\r\n * @param options.closeArray\r\n * @param options.closePath\r\n * @param options.offset\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.uvs\r\n * @param options.colors\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\nMesh.CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scale\r\n * @param options.rotation\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        options.firstNormal || null,\r\n        options.adjustFrame ? true : false\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.path\r\n * @param options.scaleFunction\r\n * @param options.rotationFunction\r\n * @param options.ribbonCloseArray\r\n * @param options.ribbonClosePath\r\n * @param options.closeShape\r\n * @param options.closePath\r\n * @param options.cap\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param options.firstNormal\r\n * @param options.adjustFrame\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const firstNormal = options.firstNormal || null;\r\n    const adjustFrame = options.adjustFrame || false;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        firstNormal,\r\n        adjustFrame\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>,\r\n    firstNormal: Nullable<Vector3>,\r\n    adjustFrame: boolean\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean,\r\n        adjustFrame: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n        if (adjustFrame) {\r\n            /* fix tangents,normals, binormals */\r\n            for (let i = 0; i < tangents.length; i++) {\r\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\r\n                    tangents[i].copyFrom(tangents[i - 1]);\r\n                }\r\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\r\n                    normals[i].copyFrom(normals[i - 1]);\r\n                }\r\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\r\n                    binormals[i].copyFrom(binormals[i - 1]);\r\n                }\r\n                if (i > 0) {\r\n                    let v = tangents[i - 1];\r\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\r\n                        tangents[i].scaleInPlace(-1);\r\n                    }\r\n                    v = normals[i - 1];\r\n                    if (Vector3.Dot(v, normals[i]) < 0) {\r\n                        normals[i].scaleInPlace(-1);\r\n                    }\r\n                    v = binormals[i - 1];\r\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\r\n                        binormals[i].scaleInPlace(-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath = new Array<Vector3>();\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\nMesh.ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n"],"names":["N","AddNodeConstructor","name","scene","HemisphericLight","Zero","constructor","direction","super","groundColor","this","Up","_buildUniformLayout","_uniformBuffer","addUniform","create","getClassName","setDirectionToTarget","target","Normalize","subtract","getShadowGenerator","transferToEffect","_effect","lightIndex","normalizeDirection","updateFloat4","x","y","z","updateColor3","scale","intensity","transferToNodeMaterialEffect","effect","lightDataUniformName","setFloat3","computeWorldMatrix","_worldMatrix","Identity","getTypeID","LIGHTTYPEID_HEMISPHERICLIGHT","prepareLightSpecificDefines","defines","CreateLineSystemVertexData","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","color","r","g","b","a","vertexData","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","Array","curvect","lg","nb","shft","dashshft","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLineSystem","instance","getVerticesData","PositionKind","vertexColor","lineColors","ColorKind","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","material","applyToMesh","updatable","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","Warn","updateMeshPositions","dashedLines","LinesBuilder","CreateRibbonVertexData","pathArray","closeArray","closePath","invertUV","defaultOffset","offset","sideOrientation","DEFAULTSIDE","customUV","uvs","customColors","normals","us","vs","uTotalDistance","vTotalDistance","minlg","ar1","ar2","idc","closePathCorr","path","vectlg","dist","path1","path2","u","v","vertex1","vertex2","UseOpenGLOrientationForUV","pi","l1","l2","min","path1nb","ComputeNormals","indexFirst","indexLast","_ComputeSides","frontUVs","backUVs","Float32Array","positions32","normals32","uvs32","set","_idx","CreateRibbon","_GetDefaultSideOrientation","minimum","Vector3","setAll","Number","MAX_VALUE","maximum","mesh","ns","_originalBuilderSideOrientation","DOUBLESIDE","si","pathPoint","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","hasBoundingInfo","getBoundingInfo","reConstruct","buildBoundingInfo","colorIndex","UVKind","areNormalsFrozen","isFacetDataEnabled","getIndices","NormalKind","params","getFacetDataParameters","ribbon","RibbonBuilder","ExtrudeShape","shape","rotation","cap","NO_CAP","closeShape","_ExtrudeShapeGeneric","firstNormal","adjustFrame","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","curve","rotateFunction","rbCA","rbCP","custom","updtbl","side","extrusionPathArray","path3D","shapePaths","tangents","getTangents","getNormals","binormals","getBinormals","distances","getDistances","copyFrom","Dot","scaleInPlace","angle","rotate","scl","CAP_END","rotationMatrix","Matrix","shapePath","angleStep","scaleRatio","RotationAxisToRef","planed","add","rotated","TransformCoordinatesToRef","addInPlace","capPath","pointCap","barycenter","CAP_START","CAP_ALL","storage","update","extrudedGeneric","ShapeBuilder"],"sourceRoot":""}