{"version":3,"file":"js/522.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/joinedPhysicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v2/physicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/physicsRaycastResult.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/physicsEngine.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v1/physicsEngineComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Physics/v2/physicsEngine.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"./v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine\";\r\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine\";\r\n\r\ndeclare module \"../scene\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @internal */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @returns a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @returns a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        if (!plugin || plugin?.getPluginVersion() === 1) {\r\n            this._physicsEngine = new PhysicsEngineV1(gravity, plugin as IPhysicsEnginePluginV1);\r\n        } else if (plugin?.getPluginVersion() === 2) {\r\n            this._physicsEngine = new PhysicsEngineV2(gravity, plugin as IPhysicsEnginePluginV2);\r\n        } else {\r\n            throw new Error(\"Unsupported Physics plugin version.\");\r\n        }\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\nimport \"../joinedPhysicsEngineComponent\";\r\n\r\ndeclare module \"../../Meshes/transformNode\" {\r\n    /**\r\n     *\r\n     */\r\n    /** @internal */\r\n    export interface TransformNode {\r\n        /** @internal */\r\n        _physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         * @see\r\n         */\r\n        physicsBody: Nullable<PhysicsBody>;\r\n\r\n        /**\r\n         *\r\n         */\r\n        getPhysicsBody(): Nullable<PhysicsBody>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): TransformNode;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(TransformNode.prototype, \"physicsBody\", {\r\n    get: function (this: TransformNode) {\r\n        return this._physicsBody;\r\n    },\r\n    set: function (this: TransformNode, value: Nullable<PhysicsBody>) {\r\n        if (this._physicsBody === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsBody = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsBody) {\r\n                    this.physicsBody.dispose(/*!doNotRecurse*/);\r\n                    this.physicsBody = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics body\r\n * @returns a physics body or null\r\n */\r\nTransformNode.prototype.getPhysicsBody = function (): Nullable<PhysicsBody> {\r\n    return this.physicsBody;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nTransformNode.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): TransformNode {\r\n    if (!this.physicsBody) {\r\n        throw new Error(\"No Physics Body for TransformNode\");\r\n    }\r\n    this.physicsBody.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n","import { Vector3 } from \"../Maths/math.vector\";\r\nimport type { PhysicsBody } from \"./v2/physicsBody\";\r\n\r\n/**\r\n * Interface for query parameters in the raycast function.\r\n * @see the \"Collision Filtering\" section in https://github.com/eoineoineoin/glTF/tree/MSFT_RigidBodies/extensions/2.0/Vendor/MSFT_collision_primitives\r\n */\r\nexport interface IRaycastQuery {\r\n    /** Membership mask */\r\n    membership?: number;\r\n    /** CollideWith mask */\r\n    collideWith?: number;\r\n}\r\n\r\n/**\r\n * Holds the data for the raycast result\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsRaycastResult {\r\n    private _hasHit: boolean = false;\r\n\r\n    private _hitDistance: number = 0;\r\n    private _hitNormalWorld: Vector3 = Vector3.Zero();\r\n    private _hitPointWorld: Vector3 = Vector3.Zero();\r\n    private _rayFromWorld: Vector3 = Vector3.Zero();\r\n    private _rayToWorld: Vector3 = Vector3.Zero();\r\n    private _triangleIndex: number = -1;\r\n\r\n    /**\r\n     * The Physics body that the ray hit\r\n     */\r\n    public body?: PhysicsBody;\r\n    /**\r\n     * The body Index in case the Physics body is using instances\r\n     */\r\n    public bodyIndex?: number;\r\n\r\n    /**\r\n     * Gets if there was a hit\r\n     */\r\n    get hasHit(): boolean {\r\n        return this._hasHit;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance from the hit\r\n     */\r\n    get hitDistance(): number {\r\n        return this._hitDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit normal/direction in the world\r\n     */\r\n    get hitNormalWorld(): Vector3 {\r\n        return this._hitNormalWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the hit point in the world\r\n     */\r\n    get hitPointWorld(): Vector3 {\r\n        return this._hitPointWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"start point\" of the ray in the world\r\n     */\r\n    get rayFromWorld(): Vector3 {\r\n        return this._rayFromWorld;\r\n    }\r\n\r\n    /**\r\n     * Gets the ray \"end point\" of the ray in the world\r\n     */\r\n    get rayToWorld(): Vector3 {\r\n        return this._rayToWorld;\r\n    }\r\n\r\n    /*\r\n     * The index of the original triangle which was hit. Will be -1 if contact point is not on a mesh shape\r\n     */\r\n    get triangleIndex(): number {\r\n        return this._triangleIndex;\r\n    }\r\n\r\n    /**\r\n     * Sets the hit data (normal & point in world space)\r\n     * @param hitNormalWorld defines the normal in world space\r\n     * @param hitPointWorld defines the point in world space\r\n     */\r\n    public setHitData(hitNormalWorld: IXYZ, hitPointWorld: IXYZ, triangleIndex?: number) {\r\n        this._hasHit = true;\r\n        this._hitNormalWorld.set(hitNormalWorld.x, hitNormalWorld.y, hitNormalWorld.z);\r\n        this._hitPointWorld.set(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z);\r\n        this._triangleIndex = triangleIndex ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Sets the distance from the start point to the hit point\r\n     * @param distance\r\n     */\r\n    public setHitDistance(distance: number) {\r\n        this._hitDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance manually\r\n     */\r\n    public calculateHitDistance() {\r\n        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPointWorld);\r\n    }\r\n\r\n    /**\r\n     * Resets all the values to default\r\n     * @param from The from point on world space\r\n     * @param to The to point on world space\r\n     */\r\n    public reset(from: Vector3 = Vector3.Zero(), to: Vector3 = Vector3.Zero()) {\r\n        this._rayFromWorld.copyFrom(from);\r\n        this._rayToWorld.copyFrom(to);\r\n\r\n        this._hasHit = false;\r\n        this._hitDistance = 0;\r\n\r\n        this._hitNormalWorld.setAll(0);\r\n        this._hitPointWorld.setAll(0);\r\n        this._triangleIndex = -1;\r\n\r\n        this.body = undefined;\r\n        this.bodyIndex = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for the size containing width and height\r\n */\r\ninterface IXYZ {\r\n    /**\r\n     * X\r\n     */\r\n    x: number;\r\n\r\n    /**\r\n     * Y\r\n     */\r\n    y: number;\r\n\r\n    /**\r\n     * Z\r\n     */\r\n    z: number;\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PhysicsImpostorJoint, IPhysicsEnginePlugin } from \"./IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport type { PhysicsJoint } from \"./physicsJoint\";\r\nimport type { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /**\r\n     * Global value used to control the smallest number supported by the simulation\r\n     */\r\n    private _impostors: Array<PhysicsImpostor> = [];\r\n    private _joints: Array<PhysicsImpostorJoint> = [];\r\n    private _subTimeStep: number = 0;\r\n    private _uniqueIdCounter = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePlugin {\r\n        throw _WarnImport(\"CannonJSPlugin\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePlugin = PhysicsEngine.DefaultPluginFactory()) {\r\n        if (!this._physicsPlugin.isSupported()) {\r\n            throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\r\n        }\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._impostors.forEach(function (impostor) {\r\n            impostor.dispose();\r\n        });\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    public addImpostor(impostor: PhysicsImpostor) {\r\n        this._impostors.push(impostor);\r\n        impostor.uniqueId = this._uniqueIdCounter++;\r\n        //if no parent, generate the body\r\n        if (!impostor.parent) {\r\n            this._physicsPlugin.generatePhysicsBody(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    public removeImpostor(impostor: PhysicsImpostor) {\r\n        const index = this._impostors.indexOf(impostor);\r\n        if (index > -1) {\r\n            const removed = this._impostors.splice(index, 1);\r\n            //Is it needed?\r\n            if (removed.length) {\r\n                this.getPhysicsPlugin().removePhysicsBody(impostor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    public addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const impostorJoint = {\r\n            mainImpostor: mainImpostor,\r\n            connectedImpostor: connectedImpostor,\r\n            joint: joint,\r\n        };\r\n        joint.physicsPlugin = this._physicsPlugin;\r\n        this._joints.push(impostorJoint);\r\n        this._physicsPlugin.generateJoint(impostorJoint);\r\n    }\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    public removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const matchingJoints = this._joints.filter(function (impostorJoint) {\r\n            return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\r\n        });\r\n        if (matchingJoints.length) {\r\n            this._physicsPlugin.removeJoint(matchingJoints[0]);\r\n            //TODO remove it from the list as well\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        //check if any mesh has no body / requires an update\r\n        this._impostors.forEach((impostor) => {\r\n            if (impostor.isBodyInitRequired()) {\r\n                this._physicsPlugin.generatePhysicsBody(impostor);\r\n            }\r\n        });\r\n\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._impostors);\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePlugin {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    public getImpostors(): Array<PhysicsImpostor> {\r\n        return this._impostors;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].object === object) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].physicsBody === body) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        return this._physicsPlugin.raycast(from, to);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult) {\r\n        return this._physicsPlugin.raycastToRef(from, to, result);\r\n    }\r\n}\r\n","import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function (this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function (): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options,\r\n    });\r\n    return this;\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./IPhysicsEnginePlugin\";\r\nimport type { IRaycastQuery } from \"../physicsRaycastResult\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /** @internal */\r\n    private _physicsBodies: Array<PhysicsBody> = [];\r\n    private _subTimeStep: number = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns physics plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePluginV2 {\r\n        throw _WarnImport(\"\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePluginV2 = PhysicsEngine.DefaultPluginFactory()) {\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._physicsBodies);\r\n    }\r\n\r\n    /**\r\n     * Add a body as an active component of this engine\r\n     * @param body\r\n     */\r\n    public addBody(physicsBody: PhysicsBody): void {\r\n        this._physicsBodies.push(physicsBody);\r\n    }\r\n    /**\r\n     * Removes a particular body from this engine\r\n     */\r\n    public removeBody(physicsBody: PhysicsBody): void {\r\n        const index = this._physicsBodies.indexOf(physicsBody);\r\n        if (index > -1) {\r\n            /*const removed =*/ this._physicsBodies.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of bodies added to this engine\r\n\r\n     */\r\n    public getBodies(): Array<PhysicsBody> {\r\n        return this._physicsBodies;\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePluginV2 {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult, query?: IRaycastQuery): void {\r\n        this._physicsPlugin.raycast(from, to, result, query);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3, query?: IRaycastQuery): PhysicsRaycastResult {\r\n        const result = new PhysicsRaycastResult();\r\n        this._physicsPlugin.raycast(from, to, result, query);\r\n        return result;\r\n    }\r\n}\r\n"],"names":["prototype","getPhysicsEngine","this","_physicsEngine","enablePhysics","gravity","plugin","component","_getComponent","NAME_PHYSICSENGINE","PhysicsEngineSceneComponent","_addComponent","getPluginVersion","Error","_physicsTimeAccumulator","e","message","disablePhysicsEngine","dispose","isPhysicsEnabled","undefined","deleteCompoundImpostor","compound","mesh","parts","physicsImpostor","_advancePhysicsEngineStep","step","subTime","getSubTimeStep","onBeforePhysicsObservable","notifyObservers","_step","onAfterPhysicsObservable","constructor","scene","name","getDeterministicFrameTime","getTimeStep","register","rebuild","clear","Object","defineProperty","get","_physicsBody","set","value","_disposePhysicsObserver","onDisposeObservable","remove","add","physicsBody","enumerable","configurable","getPhysicsBody","applyImpulse","force","contactPoint","PhysicsRaycastResult","_hasHit","_hitDistance","_hitNormalWorld","Zero","_hitPointWorld","_rayFromWorld","_rayToWorld","_triangleIndex","hasHit","hitDistance","hitNormalWorld","hitPointWorld","rayFromWorld","rayToWorld","triangleIndex","setHitData","x","y","z","setHitDistance","distance","calculateHitDistance","Distance","reset","from","to","copyFrom","setAll","body","bodyIndex","PhysicsEngine","_physicsPlugin","DefaultPluginFactory","_impostors","_joints","_subTimeStep","_uniqueIdCounter","isSupported","setGravity","setTimeStep","newTimeStep","setSubTimeStep","subTimeStep","forEach","impostor","getPhysicsPluginName","addImpostor","push","uniqueId","parent","generatePhysicsBody","removeImpostor","index","indexOf","splice","length","getPhysicsPlugin","removePhysicsBody","addJoint","mainImpostor","connectedImpostor","joint","impostorJoint","physicsPlugin","generateJoint","removeJoint","matchingJoints","filter","delta","isBodyInitRequired","executeStep","getImpostors","getImpostorForPhysicsObject","object","i","getImpostorWithPhysicsBody","raycast","raycastToRef","result","_physicsImpostor","getPhysicsImpostor","setPhysicsLinkWith","otherMesh","pivot1","pivot2","options","createJoint","HingeJoint","mainPivot","connectedPivot","nativeParams","_physicsBodies","addBody","removeBody","getBodies","query"],"sourceRoot":""}