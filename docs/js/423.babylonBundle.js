"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[423],{32758:(t,e,a)=>{a.d(e,{e:()=>c});var n=a(13555),o=a(96786),r=a(90972),i=a(89859),s=a(62528),l=a(85046);s.N.AddNodeConstructor("Light_Type_3",((t,e)=>()=>new c(t,r.P.Zero(),e)));class c extends l._{constructor(t,e,a){super(t,a),this.groundColor=new i.Wo(0,0,0),this.direction=e||r.P.Up()}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightGround",3),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}getClassName(){return"HemisphericLight"}setDirectionToTarget(t){return this.direction=r.P.Normalize(t.subtract(r.P.Zero())),this.direction}getShadowGenerator(){return null}transferToEffect(t,e){const a=r.P.Normalize(this.direction);return this._uniformBuffer.updateFloat4("vLightData",a.x,a.y,a.z,0,e),this._uniformBuffer.updateColor3("vLightGround",this.groundColor.scale(this.intensity),e),this}transferToNodeMaterialEffect(t,e){const a=r.P.Normalize(this.direction);return t.setFloat3(e,a.x,a.y,a.z),this}computeWorldMatrix(){return this._worldMatrix||(this._worldMatrix=r.y3.Identity()),this._worldMatrix}getTypeID(){return l._.LIGHTTYPEID_HEMISPHERICLIGHT}prepareLightSpecificDefines(t,e){t["HEMILIGHT"+e]=!0}}(0,n.gn)([(0,o.n9)()],c.prototype,"groundColor",void 0),(0,n.gn)([(0,o.hd)()],c.prototype,"direction",void 0)},71528:(t,e,a)=>{a.d(e,{BH:()=>u,Gz:()=>p,RN:()=>f,eW:()=>c,nL:()=>d,xW:()=>h});var n=a(90972),o=a(33632),r=a(74517),i=a(22078),s=a(37959),l=a(59288);function c(t){const e=[],a=[],n=t.lines,o=t.colors,i=[];let s=0;for(let t=0;t<n.length;t++){const r=n[t];for(let n=0;n<r.length;n++){if(a.push(r[n].x,r[n].y,r[n].z),o){const e=o[t];i.push(e[n].r,e[n].g,e[n].b,e[n].a)}n>0&&(e.push(s-1),e.push(s)),s++}}const l=new r.x;return l.indices=e,l.positions=a,o&&(l.colors=i),l}function u(t){const e=t.dashSize||3,a=t.gapSize||1,o=t.dashNb||200,i=t.points,s=new Array,l=new Array,c=n.P.Zero();let u=0,h=0,d=0,p=0,f=0,g=0,y=0;for(y=0;y<i.length-1;y++)i[y+1].subtractToRef(i[y],c),u+=c.length();for(d=u/o,p=e*d/(e+a),y=0;y<i.length-1;y++){i[y+1].subtractToRef(i[y],c),h=Math.floor(c.length()/d),c.normalize();for(let t=0;t<h;t++)f=d*t,s.push(i[y].x+f*c.x,i[y].y+f*c.y,i[y].z+f*c.z),s.push(i[y].x+(f+p)*c.x,i[y].y+(f+p)*c.y,i[y].z+(f+p)*c.z),l.push(g,g+1),g+=2}const b=new r.x;return b.positions=s,b.indices=l,b}function h(t,e,a=null){const n=e.instance,o=e.lines,r=e.colors;if(n){const t=n.getVerticesData(s.o.PositionKind);let e,a;r&&(e=n.getVerticesData(s.o.ColorKind));let i=0,l=0;for(let n=0;n<o.length;n++){const s=o[n];for(let o=0;o<s.length;o++)t[i]=s[o].x,t[i+1]=s[o].y,t[i+2]=s[o].z,r&&e&&(a=r[n],e[l]=a[o].r,e[l+1]=a[o].g,e[l+2]=a[o].b,e[l+3]=a[o].a,l+=4),i+=3}return n.updateVerticesData(s.o.PositionKind,t,!1,!1),r&&e&&n.updateVerticesData(s.o.ColorKind,e,!1,!1),n}const l=!!r,u=new i._(t,a,null,void 0,void 0,l,e.useVertexAlpha,e.material);return c(e).applyToMesh(u,e.updatable),u}function d(t,e,a=null){const n=e.colors?[e.colors]:null;return h(t,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:n,useVertexAlpha:e.useVertexAlpha,material:e.material},a)}function p(t,e,a=null){const r=e.points,s=e.instance,c=e.gapSize||1,h=e.dashSize||3;if(s){const t=t=>{const e=n.P.Zero(),a=t.length/6;let o=0,i=0,l=0,c=0,u=0,h=0,d=0,p=0;for(d=0;d<r.length-1;d++)r[d+1].subtractToRef(r[d],e),o+=e.length();l=o/a;const f=s._creationDataStorage.dashSize;for(c=f*l/(f+s._creationDataStorage.gapSize),d=0;d<r.length-1;d++)for(r[d+1].subtractToRef(r[d],e),i=Math.floor(e.length()/l),e.normalize(),p=0;p<i&&h<t.length;)u=l*p,t[h]=r[d].x+u*e.x,t[h+1]=r[d].y+u*e.y,t[h+2]=r[d].z+u*e.z,t[h+3]=r[d].x+(u+c)*e.x,t[h+4]=r[d].y+(u+c)*e.y,t[h+5]=r[d].z+(u+c)*e.z,h+=6,p++;for(;h<t.length;)t[h]=r[d].x,t[h+1]=r[d].y,t[h+2]=r[d].z,h+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&l.Y.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),s.updateMeshPositions(t,!1),s}const d=new i._(t,a,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return u(e).applyToMesh(d,e.updatable),d._creationDataStorage=new o.gW,d._creationDataStorage.dashSize=h,d._creationDataStorage.gapSize=c,d}const f={CreateDashedLines:p,CreateLineSystem:h,CreateLines:d};r.x.CreateLineSystem=c,r.x.CreateDashedLines=u,o.Kj.CreateLines=(t,e,a=null,n=!1,o=null)=>d(t,{points:e,updatable:n,instance:o},a),o.Kj.CreateDashedLines=(t,e,a,n,o,r=null,i,s)=>p(t,{points:e,dashSize:a,gapSize:n,dashNb:o,updatable:i,instance:s},r)},27079:(t,e,a)=>{a.d(e,{LY:()=>c,Ub:()=>u,jM:()=>l});var n=a(90972),o=a(33632),r=a(37959),i=a(74517),s=a(53027);function l(t){let e=t.pathArray;const a=t.closeArray||!1,n=t.closePath||!1,o=t.invertUV||!1,l=Math.floor(e[0].length/2);let c=t.offset||l;c=c>l?l:Math.floor(c);const u=0===t.sideOrientation?0:t.sideOrientation||i.x.DEFAULTSIDE,h=t.uvs,d=t.colors,p=[],f=[],g=[],y=[],b=[],_=[],m=[],D=[];let x;const P=[],S=[];let A,C,z;if(e.length<2){const t=[],a=[];for(C=0;C<e[0].length-c;C++)t.push(e[0][C]),a.push(e[0][C+c]);e=[t,a]}let V=0;const w=n?1:0;let K,L,U,v,N,O;for(x=e[0].length,A=0;A<e.length;A++){for(m[A]=0,b[A]=[0],K=e[A],L=K.length,x=x<L?x:L,z=0;z<L;)p.push(K[z].x,K[z].y,K[z].z),z>0&&(U=K[z].subtract(K[z-1]).length(),v=U+m[A],b[A].push(v),m[A]=v),z++;n&&(z--,p.push(K[0].x,K[0].y,K[0].z),U=K[z].subtract(K[0]).length(),v=U+m[A],b[A].push(v),m[A]=v),P[A]=L+w,S[A]=V,V+=L+w}let j,F,I=null,T=null;for(C=0;C<x+w;C++){for(D[C]=0,_[C]=[0],A=0;A<e.length-1;A++)N=e[A],O=e[A+1],C===x?(I=N[0],T=O[0]):(I=N[C],T=O[C]),U=T.subtract(I).length(),v=U+D[C],_[C].push(v),D[C]=v;a&&T&&I&&(N=e[A],O=e[0],C===x&&(T=O[0]),U=T.subtract(I).length(),v=U+D[C],D[C]=v)}if(h)for(A=0;A<h.length;A++)y.push(h[A].x,s.e.UseOpenGLOrientationForUV?1-h[A].y:h[A].y);else for(A=0;A<e.length;A++)for(C=0;C<x+w;C++)j=0!=m[A]?b[A][C]/m[A]:0,F=0!=D[C]?_[C][A]/D[C]:0,o?y.push(F,j):y.push(j,s.e.UseOpenGLOrientationForUV?1-F:F);A=0;let M=0,E=P[A]-1,B=P[A+1]-1,G=E<B?E:B,k=S[1]-S[0];const R=a?P.length:P.length-1;for(;M<=G&&A<R;)f.push(M,M+k,M+1),f.push(M+k+1,M+1,M+k),M+=1,M===G&&(A++,A===P.length-1?(k=S[0]-S[A],E=P[A]-1,B=P[0]-1):(k=S[A+1]-S[A],E=P[A]-1,B=P[A+1]-1),M=S[A],G=E<B?E+M:B+M);if(i.x.ComputeNormals(p,f,g),n){let t=0,a=0;for(A=0;A<e.length;A++)t=3*S[A],a=A+1<e.length?3*(S[A+1]-1):g.length-3,g[t]=.5*(g[t]+g[a]),g[t+1]=.5*(g[t+1]+g[a+1]),g[t+2]=.5*(g[t+2]+g[a+2]),g[a]=g[t],g[a+1]=g[t+1],g[a+2]=g[t+2]}i.x._ComputeSides(u,p,f,g,y,t.frontUVs,t.backUVs);let H=null;if(d){H=new Float32Array(4*d.length);for(let t=0;t<d.length;t++)H[4*t]=d[t].r,H[4*t+1]=d[t].g,H[4*t+2]=d[t].b,H[4*t+3]=d[t].a}const W=new i.x,Y=new Float32Array(p),Z=new Float32Array(g),X=new Float32Array(y);return W.indices=f,W.positions=Y,W.normals=Z,W.uvs=X,H&&W.set(H,r.o.ColorKind),n&&(W._idx=S),W}function c(t,e,a=null){const c=e.pathArray,u=e.closeArray,h=e.closePath,d=o.Kj._GetDefaultSideOrientation(e.sideOrientation),p=e.instance,f=e.updatable;if(p){const t=n.jp.Vector3[0].setAll(Number.MAX_VALUE),a=n.jp.Vector3[1].setAll(-Number.MAX_VALUE),l=e=>{let n=c[0].length;const r=p;let i=0;const s=r._originalBuilderSideOrientation===o.Kj.DOUBLESIDE?2:1;for(let o=1;o<=s;++o)for(let o=0;o<c.length;++o){const s=c[o],l=s.length;n=n<l?n:l;for(let o=0;o<n;++o){const n=s[o];e[i]=n.x,e[i+1]=n.y,e[i+2]=n.z,t.minimizeInPlaceFromFloats(n.x,n.y,n.z),a.maximizeInPlaceFromFloats(n.x,n.y,n.z),i+=3}if(r._creationDataStorage&&r._creationDataStorage.closePath){const t=s[0];e[i]=t.x,e[i+1]=t.y,e[i+2]=t.z,i+=3}}},u=p.getVerticesData(r.o.PositionKind);if(l(u),p.hasBoundingInfo?p.getBoundingInfo().reConstruct(t,a,p._worldMatrix):p.buildBoundingInfo(t,a,p._worldMatrix),p.updateVerticesData(r.o.PositionKind,u,!1,!1),e.colors){const t=p.getVerticesData(r.o.ColorKind);for(let a=0,n=0;a<e.colors.length;a++,n+=4){const o=e.colors[a];t[n]=o.r,t[n+1]=o.g,t[n+2]=o.b,t[n+3]=o.a}p.updateVerticesData(r.o.ColorKind,t,!1,!1)}if(e.uvs){const t=p.getVerticesData(r.o.UVKind);for(let a=0;a<e.uvs.length;a++)t[2*a]=e.uvs[a].x,t[2*a+1]=s.e.UseOpenGLOrientationForUV?1-e.uvs[a].y:e.uvs[a].y;p.updateVerticesData(r.o.UVKind,t,!1,!1)}if(!p.areNormalsFrozen||p.isFacetDataEnabled){const t=p.getIndices(),e=p.getVerticesData(r.o.NormalKind),a=p.isFacetDataEnabled?p.getFacetDataParameters():null;if(i.x.ComputeNormals(u,t,e,a),p._creationDataStorage&&p._creationDataStorage.closePath){let t=0,a=0;for(let n=0;n<c.length;n++)t=3*p._creationDataStorage.idx[n],a=n+1<c.length?3*(p._creationDataStorage.idx[n+1]-1):e.length-3,e[t]=.5*(e[t]+e[a]),e[t+1]=.5*(e[t+1]+e[a+1]),e[t+2]=.5*(e[t+2]+e[a+2]),e[a]=e[t],e[a+1]=e[t+1],e[a+2]=e[t+2]}p.areNormalsFrozen||p.updateVerticesData(r.o.NormalKind,e,!1,!1)}return p}{const n=new o.Kj(t,a);n._originalBuilderSideOrientation=d,n._creationDataStorage=new o.gW;const r=l(e);return h&&(n._creationDataStorage.idx=r._idx),n._creationDataStorage.closePath=h,n._creationDataStorage.closeArray=u,r.applyToMesh(n,f),n}}const u={CreateRibbon:c};i.x.CreateRibbon=l,o.Kj.CreateRibbon=(t,e,a=!1,n,o,r,i=!1,s,l)=>c(t,{pathArray:e,closeArray:a,closePath:n,offset:o,updatable:i,sideOrientation:s,instance:l},r)},69590:(t,e,a)=>{a.d(e,{Gc:()=>s,Oy:()=>u,bC:()=>l});var n=a(90972),o=a(33632),r=a(27079),i=a(41021);function s(t,e,a=null){const n=e.path,r=e.shape,i=e.scale||1,s=e.rotation||0,l=0===e.cap?0:e.cap||o.Kj.NO_CAP,u=e.updatable,h=o.Kj._GetDefaultSideOrientation(e.sideOrientation),d=e.instance||null,p=e.invertUV||!1,f=e.closeShape||!1;return c(t,r,n,i,s,null,null,e.closePath||!1,f,l,!1,a,!!u,h,d,p,e.frontUVs||null,e.backUVs||null,e.firstNormal||null,!!e.adjustFrame)}function l(t,e,a=null){const n=e.path,r=e.shape,i=e.scaleFunction||(()=>1),s=e.rotationFunction||(()=>0),l=e.closePath||e.ribbonCloseArray||!1,u=e.closeShape||e.ribbonClosePath||!1,h=0===e.cap?0:e.cap||o.Kj.NO_CAP,d=e.updatable,p=e.firstNormal||null,f=e.adjustFrame||!1;return c(t,r,n,null,null,i,s,l,u,h,!0,a,!!d,o.Kj._GetDefaultSideOrientation(e.sideOrientation),e.instance||null,e.invertUV||!1,e.frontUVs||null,e.backUVs||null,p,f)}function c(t,e,a,s,l,c,u,h,d,p,f,g,y,b,_,m,D,x,P,S){const A=(t,e,a,r,i,s,l,c,u,h,d)=>{const p=a.getTangents(),f=a.getNormals(),g=a.getBinormals(),y=a.getDistances();if(d)for(let t=0;t<p.length;t++)if(0==p[t].x&&0==p[t].y&&0==p[t].z&&p[t].copyFrom(p[t-1]),0==f[t].x&&0==f[t].y&&0==f[t].z&&f[t].copyFrom(f[t-1]),0==g[t].x&&0==g[t].y&&0==g[t].z&&g[t].copyFrom(g[t-1]),t>0){let e=p[t-1];n.P.Dot(e,p[t])<0&&p[t].scaleInPlace(-1),e=f[t-1],n.P.Dot(e,f[t])<0&&f[t].scaleInPlace(-1),e=g[t-1],n.P.Dot(e,g[t])<0&&g[t].scaleInPlace(-1)}let b=0;const _=h&&c?c:()=>null!==s?s:0,m=h&&l?l:()=>null!==i?i:1;let D=u===o.Kj.NO_CAP||u===o.Kj.CAP_END?0:2;const x=n.jp.Matrix[0];for(let a=0;a<e.length;a++){const o=new Array,i=_(a,y[a]),s=m(a,y[a]);n.y3.RotationAxisToRef(p[a],b,x);for(let r=0;r<t.length;r++){const i=p[a].scale(t[r].z).add(f[a].scale(t[r].x)).add(g[a].scale(t[r].y)),l=n.P.Zero();n.P.TransformCoordinatesToRef(i,x,l),l.scaleInPlace(s).addInPlace(e[a]),o[r]=l}r[D]=o,b+=i,D++}const P=t=>{const e=Array(),a=n.P.Zero();let o;for(o=0;o<t.length;o++)a.addInPlace(t[o]);for(a.scaleInPlace(1/t.length),o=0;o<t.length;o++)e.push(a);return e};switch(u){case o.Kj.NO_CAP:break;case o.Kj.CAP_START:r[0]=P(r[2]),r[1]=r[2];break;case o.Kj.CAP_END:r[D]=r[D-1],r[D+1]=P(r[D-1]);break;case o.Kj.CAP_ALL:r[0]=P(r[2]),r[1]=r[2],r[D]=r[D-1],r[D+1]=P(r[D-1])}return r};let C,z;if(_){const t=_._creationDataStorage;return C=P?t.path3D.update(a,P):t.path3D.update(a),z=A(e,a,t.path3D,t.pathArray,s,l,c,u,t.cap,f,S),(0,r.LY)("",{pathArray:z,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:_},g||void 0)}C=P?new i.$B(a,P):new i.$B(a),z=A(e,a,C,new Array,s,l,c,u,p=p<0||p>3?0:p,f,S);const V=(0,r.LY)(t,{pathArray:z,closeArray:h,closePath:d,updatable:y,sideOrientation:b,invertUV:m,frontUVs:D||void 0,backUVs:x||void 0},g);return V._creationDataStorage.pathArray=z,V._creationDataStorage.path3D=C,V._creationDataStorage.cap=p,V}const u={ExtrudeShape:s,ExtrudeShapeCustom:l};o.Kj.ExtrudeShape=(t,e,a,n,r,i,l=null,c,u,h)=>s(t,{shape:e,path:a,scale:n,rotation:r,cap:0===i?0:i||o.Kj.NO_CAP,sideOrientation:u,instance:h,updatable:c},l),o.Kj.ExtrudeShapeCustom=(t,e,a,n,r,i,s,c,u,h,d,p)=>l(t,{shape:e,path:a,scaleFunction:n,rotationFunction:r,ribbonCloseArray:i,ribbonClosePath:s,cap:0===c?0:c||o.Kj.NO_CAP,sideOrientation:d,instance:p,updatable:h},u)}}]);
//# sourceMappingURL=423.babylonBundle.js.map