"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[419],{1419:(t,s,i)=>{i.d(s,{b:()=>d});var o=i(972),e=i(9288),n=i(3262),r=i(7582),a=i(7959),h=i(4517),c=i(9590),p=i(1528),l=i(5388),m=i(1865),y=i(7786);class d{constructor(t=!0,s=Ammo,i=null){this._useDeltaForWorldStep=t,this.bjsAMMO={},this.name="AmmoJSPlugin",this._timeStep=1/60,this._fixedTimeStep=1/60,this._maxSteps=5,this._tmpQuaternion=new o._f,this._tmpContactCallbackResult=!1,this._tmpContactPoint=new o.P,this._tmpContactNormal=new o.P,this._tmpVec3=new o.P,this._tmpMatrix=new o.y3,"function"!=typeof s?(this.bjsAMMO=s,this.isSupported()?(this._collisionConfiguration=new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration,this._dispatcher=new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration),this._overlappingPairCache=i||new this.bjsAMMO.btDbvtBroadphase,this._solver=new this.bjsAMMO.btSequentialImpulseConstraintSolver,this._softBodySolver=new this.bjsAMMO.btDefaultSoftBodySolver,this.world=new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher,this._overlappingPairCache,this._solver,this._collisionConfiguration,this._softBodySolver),this._tmpAmmoConcreteContactResultCallback=new this.bjsAMMO.ConcreteContactResultCallback,this._tmpAmmoConcreteContactResultCallback.addSingleResult=t=>{const s=(t=this.bjsAMMO.wrapPointer(t,this.bjsAMMO.btManifoldPoint)).getPositionWorldOnA(),i=t.m_normalWorldOnB;this._tmpContactPoint.x=s.x(),this._tmpContactPoint.y=s.y(),this._tmpContactPoint.z=s.z(),this._tmpContactNormal.x=i.x(),this._tmpContactNormal.y=i.y(),this._tmpContactNormal.z=i.z(),this._tmpContactImpulse=t.getAppliedImpulse(),this._tmpContactDistance=t.getDistance(),this._tmpContactCallbackResult=!0},this._raycastResult=new l.d,this._tmpAmmoTransform=new this.bjsAMMO.btTransform,this._tmpAmmoTransform.setIdentity(),this._tmpAmmoQuaternion=new this.bjsAMMO.btQuaternion(0,0,0,1),this._tmpAmmoVectorA=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorB=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorC=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorD=new this.bjsAMMO.btVector3(0,0,0)):e.Y.Error("AmmoJS is not available. Please make sure you included the js file.")):e.Y.Error("AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.")}getPluginVersion(){return 1}setGravity(t){this._tmpAmmoVectorA.setValue(t.x,t.y,t.z),this.world.setGravity(this._tmpAmmoVectorA),this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA)}setTimeStep(t){this._timeStep=t}setFixedTimeStep(t){this._fixedTimeStep=t}setMaxSteps(t){this._maxSteps=t}getTimeStep(){return this._timeStep}_isImpostorInContact(t){return this._tmpContactCallbackResult=!1,this.world.contactTest(t.physicsBody,this._tmpAmmoConcreteContactResultCallback),this._tmpContactCallbackResult}_isImpostorPairInContact(t,s){return this._tmpContactCallbackResult=!1,this.world.contactPairTest(t.physicsBody,s.physicsBody,this._tmpAmmoConcreteContactResultCallback),this._tmpContactCallbackResult}_stepSimulation(t=1/60,s=10,i=1/60){if(0==s)this.world.stepSimulation(t,0);else for(;s>0&&t>0;)t-i<i?(this.world.stepSimulation(t,0),t=0):(t-=i,this.world.stepSimulation(i,0)),s--}executeStep(t,s){for(const t of s)t.soft||t.beforeStep();this._stepSimulation(this._useDeltaForWorldStep?t:this._timeStep,this._maxSteps,this._fixedTimeStep);for(const t of s)if(t.soft?this._afterSoftStep(t):t.afterStep(),t._onPhysicsCollideCallbacks.length>0&&this._isImpostorInContact(t))for(const s of t._onPhysicsCollideCallbacks)for(const i of s.otherImpostors)(t.physicsBody.isActive()||i.physicsBody.isActive())&&this._isImpostorPairInContact(t,i)&&(t.onCollide({body:i.physicsBody,point:this._tmpContactPoint,distance:this._tmpContactDistance,impulse:this._tmpContactImpulse,normal:this._tmpContactNormal}),i.onCollide({body:t.physicsBody,point:this._tmpContactPoint,distance:this._tmpContactDistance,impulse:this._tmpContactImpulse,normal:this._tmpContactNormal}))}_afterSoftStep(t){t.type===n.Q.RopeImpostor?this._ropeStep(t):this._softbodyOrClothStep(t)}_ropeStep(t){const s=t.physicsBody.get_m_nodes(),i=s.size();let e,n,r,a,h;const l=new Array;for(let t=0;t<i;t++)e=s.at(t),n=e.get_m_x(),r=n.x(),a=n.y(),h=n.z(),l.push(new o.P(r,a,h));const m=t.object,y=t.getParam("shape");t._isFromLine?t.object=(0,p.nL)("lines",{points:l,instance:m}):t.object=(0,c.Gc)("ext",{shape:y,path:l,instance:m})}_softbodyOrClothStep(t){const s=t.type===n.Q.ClothImpostor?1:-1,i=t.object;let o=i.getVerticesData(a.o.PositionKind);o||(o=[]);let e=i.getVerticesData(a.o.NormalKind);e||(e=[]);const r=o.length/3,c=t.physicsBody.get_m_nodes();let p,l,m,y,d,_,u,g;for(let t=0;t<r;t++){p=c.at(t),l=p.get_m_x(),m=l.x(),y=l.y(),d=l.z()*s;const i=p.get_m_n();_=i.x(),u=i.y(),g=i.z()*s,o[3*t]=m,o[3*t+1]=y,o[3*t+2]=d,e[3*t]=_,e[3*t+1]=u,e[3*t+2]=g}const b=new h.x;b.positions=o,b.normals=e,b.uvs=i.getVerticesData(a.o.UVKind),b.colors=i.getVerticesData(a.o.ColorKind),i&&i.getIndices&&(b.indices=i.getIndices()),b.applyToMesh(i)}applyImpulse(t,s,i){if(t.soft)e.Y.Warn("Cannot be applied to a soft body");else{t.physicsBody.activate();const o=this._tmpAmmoVectorA,e=this._tmpAmmoVectorB;t.object&&t.object.getWorldMatrix&&i.subtractInPlace(t.object.getWorldMatrix().getTranslation()),o.setValue(i.x,i.y,i.z),e.setValue(s.x,s.y,s.z),t.physicsBody.applyImpulse(e,o)}}applyForce(t,s,i){if(t.soft)e.Y.Warn("Cannot be applied to a soft body");else{t.physicsBody.activate();const o=this._tmpAmmoVectorA,e=this._tmpAmmoVectorB;if(t.object&&t.object.getWorldMatrix){const s=t.object.getWorldMatrix().getTranslation();o.setValue(i.x-s.x,i.y-s.y,i.z-s.z)}else o.setValue(i.x,i.y,i.z);e.setValue(s.x,s.y,s.z),t.physicsBody.applyForce(e,o)}}generatePhysicsBody(t){if(t._pluginData.toDispose=[],t.parent)t.physicsBody&&(this.removePhysicsBody(t),t.forceUpdate());else if(t.isBodyInitRequired()){const s=this._createShape(t),i=t.getParam("mass");if(t._pluginData.mass=i,t.soft)s.get_m_cfg().set_collisions(17),s.get_m_cfg().set_kDP(t.getParam("damping")),this.bjsAMMO.castObject(s,this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(t.getParam("margin")),s.setActivationState(d._DISABLE_DEACTIVATION_FLAG),this.world.addSoftBody(s,1,-1),t.physicsBody=s,t._pluginData.toDispose.push(s),this.setBodyPressure(t,0),t.type===n.Q.SoftbodyImpostor&&this.setBodyPressure(t,t.getParam("pressure")),this.setBodyStiffness(t,t.getParam("stiffness")),this.setBodyVelocityIterations(t,t.getParam("velocityIterations")),this.setBodyPositionIterations(t,t.getParam("positionIterations"));else{const o=new this.bjsAMMO.btVector3(0,0,0),e=new this.bjsAMMO.btTransform;t.object.computeWorldMatrix(!0),e.setIdentity(),0!==i&&s.calculateLocalInertia(i,o),this._tmpAmmoVectorA.setValue(t.object.position.x,t.object.position.y,t.object.position.z),this._tmpAmmoQuaternion.setValue(t.object.rotationQuaternion.x,t.object.rotationQuaternion.y,t.object.rotationQuaternion.z,t.object.rotationQuaternion.w),e.setOrigin(this._tmpAmmoVectorA),e.setRotation(this._tmpAmmoQuaternion);const r=new this.bjsAMMO.btDefaultMotionState(e),a=new this.bjsAMMO.btRigidBodyConstructionInfo(i,r,s,o),h=new this.bjsAMMO.btRigidBody(a);if(0===i&&(h.setCollisionFlags(h.getCollisionFlags()|d._KINEMATIC_FLAG),h.setActivationState(d._DISABLE_DEACTIVATION_FLAG)),t.type!=n.Q.NoImpostor||s.getChildShape||h.setCollisionFlags(h.getCollisionFlags()|d._DISABLE_COLLISION_FLAG),t.type!==n.Q.MeshImpostor&&t.type!==n.Q.NoImpostor){const s=t.object.getBoundingInfo();this._tmpVec3.copyFrom(t.object.getAbsolutePosition()),this._tmpVec3.subtractInPlace(s.boundingBox.centerWorld),this._tmpVec3.x/=t.object.scaling.x,this._tmpVec3.y/=t.object.scaling.y,this._tmpVec3.z/=t.object.scaling.z,t.setDeltaPosition(this._tmpVec3)}const c=t.getParam("group"),p=t.getParam("mask");c&&p?this.world.addRigidBody(h,c,p):this.world.addRigidBody(h),t.physicsBody=h,t._pluginData.toDispose=t._pluginData.toDispose.concat([h,a,r,e,o,s])}this.setBodyRestitution(t,t.getParam("restitution")),this.setBodyFriction(t,t.getParam("friction"))}}removePhysicsBody(t){this.world&&(t.soft?this.world.removeSoftBody(t.physicsBody):this.world.removeRigidBody(t.physicsBody),t._pluginData&&(t._pluginData.toDispose.forEach((t=>{this.bjsAMMO.destroy(t)})),t._pluginData.toDispose=[]))}generateJoint(t){const s=t.mainImpostor.physicsBody,i=t.connectedImpostor.physicsBody;if(!s||!i)return;const n=t.joint.jointData;let a;switch(n.mainPivot||(n.mainPivot=new o.P(0,0,0)),n.connectedPivot||(n.connectedPivot=new o.P(0,0,0)),t.joint.type){case r.q7.DistanceJoint:{const t=n.maxDistance;t&&(n.mainPivot=new o.P(0,-t/2,0),n.connectedPivot=new o.P(0,t/2,0)),a=new this.bjsAMMO.btPoint2PointConstraint(s,i,new this.bjsAMMO.btVector3(n.mainPivot.x,n.mainPivot.y,n.mainPivot.z),new this.bjsAMMO.btVector3(n.connectedPivot.x,n.connectedPivot.y,n.connectedPivot.z));break}case r.q7.HingeJoint:{n.mainAxis||(n.mainAxis=new o.P(0,0,0)),n.connectedAxis||(n.connectedAxis=new o.P(0,0,0));const t=new this.bjsAMMO.btVector3(n.mainAxis.x,n.mainAxis.y,n.mainAxis.z),e=new this.bjsAMMO.btVector3(n.connectedAxis.x,n.connectedAxis.y,n.connectedAxis.z);a=new this.bjsAMMO.btHingeConstraint(s,i,new this.bjsAMMO.btVector3(n.mainPivot.x,n.mainPivot.y,n.mainPivot.z),new this.bjsAMMO.btVector3(n.connectedPivot.x,n.connectedPivot.y,n.connectedPivot.z),t,e);break}case r.q7.BallAndSocketJoint:a=new this.bjsAMMO.btPoint2PointConstraint(s,i,new this.bjsAMMO.btVector3(n.mainPivot.x,n.mainPivot.y,n.mainPivot.z),new this.bjsAMMO.btVector3(n.connectedPivot.x,n.connectedPivot.y,n.connectedPivot.z));break;default:e.Y.Warn("JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint"),a=new this.bjsAMMO.btPoint2PointConstraint(s,i,new this.bjsAMMO.btVector3(n.mainPivot.x,n.mainPivot.y,n.mainPivot.z),new this.bjsAMMO.btVector3(n.connectedPivot.x,n.connectedPivot.y,n.connectedPivot.z))}this.world.addConstraint(a,!t.joint.jointData.collision),t.joint.physicsJoint=a}removeJoint(t){this.world&&this.world.removeConstraint(t.joint.physicsJoint)}_addMeshVerts(t,s,i){let e=0;if(i&&i.getIndices&&i.getWorldMatrix&&i.getChildMeshes){let n=i.getIndices();n||(n=[]);let r,h=i.getVerticesData(a.o.PositionKind);if(h||(h=[]),s&&s!==i){let t;t=s.rotationQuaternion?s.rotationQuaternion:s.rotation?o._f.FromEulerAngles(s.rotation.x,s.rotation.y,s.rotation.z):o._f.Identity(),o.y3.Compose(o.P.One(),t,s.position).invertToRef(this._tmpMatrix),r=i.computeWorldMatrix(!1).multiply(this._tmpMatrix)}else o.y3.ScalingToRef(i.scaling.x,i.scaling.y,i.scaling.z,this._tmpMatrix),r=this._tmpMatrix;const c=n.length/3;for(let s=0;s<c;s++){const i=[];for(let t=0;t<3;t++){let e,a=new o.P(h[3*n[3*s+t]+0],h[3*n[3*s+t]+1],h[3*n[3*s+t]+2]);a=o.P.TransformCoordinates(a,r),e=0==t?this._tmpAmmoVectorA:1==t?this._tmpAmmoVectorB:this._tmpAmmoVectorC,e.setValue(a.x,a.y,a.z),i.push(e)}t.addTriangle(i[0],i[1],i[2]),e++}i.getChildMeshes().forEach((i=>{e+=this._addMeshVerts(t,s,i)}))}return e}_softVertexData(t){const s=t.object;if(s&&s.getIndices&&s.getWorldMatrix&&s.getChildMeshes){let t=s.getIndices();t||(t=[]);let i=s.getVerticesData(a.o.PositionKind);i||(i=[]);let e=s.getVerticesData(a.o.NormalKind);e||(e=[]),s.computeWorldMatrix(!1);const n=[],r=[];for(let t=0;t<i.length;t+=3){let a=new o.P(i[t],i[t+1],i[t+2]),h=new o.P(e[t],e[t+1],e[t+2]);a=o.P.TransformCoordinates(a,s.getWorldMatrix()),h=o.P.TransformNormal(h,s.getWorldMatrix()),n.push(a.x,a.y,a.z),r.push(h.x,h.y,h.z)}const c=new h.x;return c.positions=n,c.normals=r,c.uvs=s.getVerticesData(a.o.UVKind),c.colors=s.getVerticesData(a.o.ColorKind),s&&s.getIndices&&(c.indices=s.getIndices()),c.applyToMesh(s),s.position=o.P.Zero(),s.rotationQuaternion=null,s.rotation=o.P.Zero(),s.computeWorldMatrix(!0),c}return h.x.ExtractFromMesh(s)}_createSoftbody(t){const s=t.object;if(s&&s.getIndices){let i=s.getIndices();i||(i=[]);const e=this._softVertexData(t),n=e.positions,r=e.normals;if(null===n||null===r)return new this.bjsAMMO.btCompoundShape;{const t=[],e=[];for(let s=0;s<n.length;s+=3){const i=new o.P(n[s],n[s+1],n[s+2]),a=new o.P(r[s],r[s+1],r[s+2]);t.push(i.x,i.y,-i.z),e.push(a.x,a.y,-a.z)}const a=(new this.bjsAMMO.btSoftBodyHelpers).CreateFromTriMesh(this.world.getWorldInfo(),t,s.getIndices(),i.length/3,!0),h=n.length/3,c=a.get_m_nodes();let p,l;for(let t=0;t<h;t++)p=c.at(t),l=p.get_m_n(),l.setX(e[3*t]),l.setY(e[3*t+1]),l.setZ(e[3*t+2]);return a}}}_createCloth(t){const s=t.object;if(s&&s.getIndices){let i=s.getIndices();i||(i=[]);const o=this._softVertexData(t),e=o.positions,n=o.normals;if(null===e||null===n)return new this.bjsAMMO.btCompoundShape;{const s=e.length,i=Math.sqrt(s/3);t.segments=i;const o=i-1;return this._tmpAmmoVectorA.setValue(e[0],e[1],e[2]),this._tmpAmmoVectorB.setValue(e[3*o],e[3*o+1],e[3*o+2]),this._tmpAmmoVectorD.setValue(e[s-3],e[s-2],e[s-1]),this._tmpAmmoVectorC.setValue(e[s-3-3*o],e[s-2-3*o],e[s-1-3*o]),(new this.bjsAMMO.btSoftBodyHelpers).CreatePatch(this.world.getWorldInfo(),this._tmpAmmoVectorA,this._tmpAmmoVectorB,this._tmpAmmoVectorC,this._tmpAmmoVectorD,i,i,t.getParam("fixedPoints"),!0)}}}_createRope(t){let s,i;const o=this._softVertexData(t),n=o.positions,r=o.normals;if(null===n||null===r)return new this.bjsAMMO.btCompoundShape;if(o.applyToMesh(t.object,!0),t._isFromLine=!0,0===r.map((t=>t*t)).reduce(((t,s)=>t+s)))s=n.length,i=s/3-1,this._tmpAmmoVectorA.setValue(n[0],n[1],n[2]),this._tmpAmmoVectorB.setValue(n[s-3],n[s-2],n[s-1]);else{t._isFromLine=!1;const o=t.getParam("path");if(null===t.getParam("shape"))return e.Y.Warn("No shape available for extruded mesh"),new this.bjsAMMO.btCompoundShape;s=o.length,i=s-1,this._tmpAmmoVectorA.setValue(o[0].x,o[0].y,o[0].z),this._tmpAmmoVectorB.setValue(o[s-1].x,o[s-1].y,o[s-1].z)}t.segments=i;let a=t.getParam("fixedPoints");a=a>3?3:a;const h=(new this.bjsAMMO.btSoftBodyHelpers).CreateRope(this.world.getWorldInfo(),this._tmpAmmoVectorA,this._tmpAmmoVectorB,i-1,a);return h.get_m_cfg().set_collisions(17),h}_createCustom(t){let s=null;return this.onCreateCustomShape&&(s=this.onCreateCustomShape(t)),null==s&&(s=new this.bjsAMMO.btCompoundShape),s}_addHullVerts(t,s,i){let e=0;if(i&&i.getIndices&&i.getWorldMatrix&&i.getChildMeshes){let n=i.getIndices();n||(n=[]);let r=i.getVerticesData(a.o.PositionKind);r||(r=[]),i.computeWorldMatrix(!1);const h=n.length/3;for(let s=0;s<h;s++){const a=[];for(let t=0;t<3;t++){let e,h=new o.P(r[3*n[3*s+t]+0],r[3*n[3*s+t]+1],r[3*n[3*s+t]+2]);o.y3.ScalingToRef(i.scaling.x,i.scaling.y,i.scaling.z,this._tmpMatrix),h=o.P.TransformCoordinates(h,this._tmpMatrix),e=0==t?this._tmpAmmoVectorA:1==t?this._tmpAmmoVectorB:this._tmpAmmoVectorC,e.setValue(h.x,h.y,h.z),a.push(e)}t.addPoint(a[0],!0),t.addPoint(a[1],!0),t.addPoint(a[2],!0),e++}i.getChildMeshes().forEach((i=>{e+=this._addHullVerts(t,s,i)}))}return e}_createShape(t,s=!1){const i=t.object;let r;const a=t.getObjectExtents();if(!s){const s=t.object.getChildMeshes?t.object.getChildMeshes(!0):[];r=new this.bjsAMMO.btCompoundShape;let i=0;if(s.forEach((t=>{const s=t.getPhysicsImpostor();if(s){if(s.type==n.Q.MeshImpostor)throw"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)";const e=this._createShape(s),a=t.parent.getWorldMatrix().clone(),h=new o.P;a.decompose(h),this._tmpAmmoTransform.getOrigin().setValue(t.position.x*h.x,t.position.y*h.y,t.position.z*h.z),this._tmpAmmoQuaternion.setValue(t.rotationQuaternion.x,t.rotationQuaternion.y,t.rotationQuaternion.z,t.rotationQuaternion.w),this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion),r.addChildShape(this._tmpAmmoTransform,e),s.dispose(),i++}})),i>0){if(t.type!=n.Q.NoImpostor){const s=this._createShape(t,!0);s&&(this._tmpAmmoTransform.getOrigin().setValue(0,0,0),this._tmpAmmoQuaternion.setValue(0,0,0,1),this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion),r.addChildShape(this._tmpAmmoTransform,s))}return r}this.bjsAMMO.destroy(r),r=null}switch(t.type){case n.Q.SphereImpostor:if(m.R.WithinEpsilon(a.x,a.y,1e-4)&&m.R.WithinEpsilon(a.x,a.z,1e-4))r=new this.bjsAMMO.btSphereShape(a.x/2);else{const t=[new this.bjsAMMO.btVector3(0,0,0)],s=[1];r=new this.bjsAMMO.btMultiSphereShape(t,s,1),r.setLocalScaling(new this.bjsAMMO.btVector3(a.x/2,a.y/2,a.z/2))}break;case n.Q.CapsuleImpostor:{const t=a.x/2;r=new this.bjsAMMO.btCapsuleShape(t,a.y-2*t)}break;case n.Q.CylinderImpostor:this._tmpAmmoVectorA.setValue(a.x/2,a.y/2,a.z/2),r=new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);break;case n.Q.PlaneImpostor:case n.Q.BoxImpostor:this._tmpAmmoVectorA.setValue(a.x/2,a.y/2,a.z/2),r=new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);break;case n.Q.MeshImpostor:if(0==t.getParam("mass")){if(this.onCreateCustomMeshImpostor)r=this.onCreateCustomMeshImpostor(t);else{const s=new this.bjsAMMO.btTriangleMesh;t._pluginData.toDispose.push(s);const o=this._addMeshVerts(s,i,i);r=0==o?new this.bjsAMMO.btCompoundShape:new this.bjsAMMO.btBvhTriangleMeshShape(s)}break}case n.Q.ConvexHullImpostor:if(this.onCreateCustomConvexHullImpostor)r=this.onCreateCustomConvexHullImpostor(t);else{const s=new this.bjsAMMO.btConvexHullShape;0==this._addHullVerts(s,i,i)?(t._pluginData.toDispose.push(s),r=new this.bjsAMMO.btCompoundShape):r=s}break;case n.Q.NoImpostor:r=new this.bjsAMMO.btSphereShape(a.x/2);break;case n.Q.CustomImpostor:r=this._createCustom(t);break;case n.Q.SoftbodyImpostor:r=this._createSoftbody(t);break;case n.Q.ClothImpostor:r=this._createCloth(t);break;case n.Q.RopeImpostor:r=this._createRope(t);break;default:e.Y.Warn("The impostor type is not currently supported by the ammo plugin.")}return r}setTransformationFromPhysicsBody(t){t.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform),t.object.position.set(this._tmpAmmoTransform.getOrigin().x(),this._tmpAmmoTransform.getOrigin().y(),this._tmpAmmoTransform.getOrigin().z()),t.object.rotationQuaternion?t.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(),this._tmpAmmoTransform.getRotation().y(),this._tmpAmmoTransform.getRotation().z(),this._tmpAmmoTransform.getRotation().w()):t.object.rotation&&(this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(),this._tmpAmmoTransform.getRotation().y(),this._tmpAmmoTransform.getRotation().z(),this._tmpAmmoTransform.getRotation().w()),this._tmpQuaternion.toEulerAnglesToRef(t.object.rotation))}setPhysicsBodyTransformation(t,s,i){const o=t.physicsBody.getWorldTransform();if(Math.abs(o.getOrigin().x()-s.x)>y.kn||Math.abs(o.getOrigin().y()-s.y)>y.kn||Math.abs(o.getOrigin().z()-s.z)>y.kn||Math.abs(o.getRotation().x()-i.x)>y.kn||Math.abs(o.getRotation().y()-i.y)>y.kn||Math.abs(o.getRotation().z()-i.z)>y.kn||Math.abs(o.getRotation().w()-i.w)>y.kn)if(this._tmpAmmoVectorA.setValue(s.x,s.y,s.z),o.setOrigin(this._tmpAmmoVectorA),this._tmpAmmoQuaternion.setValue(i.x,i.y,i.z,i.w),o.setRotation(this._tmpAmmoQuaternion),t.physicsBody.setWorldTransform(o),0==t.mass){const s=t.physicsBody.getMotionState();s&&s.setWorldTransform(o)}else t.physicsBody.activate()}isSupported(){return void 0!==this.bjsAMMO}setLinearVelocity(t,s){this._tmpAmmoVectorA.setValue(s.x,s.y,s.z),t.soft?t.physicsBody.linearVelocity(this._tmpAmmoVectorA):t.physicsBody.setLinearVelocity(this._tmpAmmoVectorA)}setAngularVelocity(t,s){this._tmpAmmoVectorA.setValue(s.x,s.y,s.z),t.soft?t.physicsBody.angularVelocity(this._tmpAmmoVectorA):t.physicsBody.setAngularVelocity(this._tmpAmmoVectorA)}getLinearVelocity(t){let s;if(s=t.soft?t.physicsBody.linearVelocity():t.physicsBody.getLinearVelocity(),!s)return null;const i=new o.P(s.x(),s.y(),s.z());return this.bjsAMMO.destroy(s),i}getAngularVelocity(t){let s;if(s=t.soft?t.physicsBody.angularVelocity():t.physicsBody.getAngularVelocity(),!s)return null;const i=new o.P(s.x(),s.y(),s.z());return this.bjsAMMO.destroy(s),i}setBodyMass(t,s){t.soft?t.physicsBody.setTotalMass(s,!1):t.physicsBody.setMassProps(s),t._pluginData.mass=s}getBodyMass(t){return t._pluginData.mass||0}getBodyFriction(t){return t._pluginData.friction||0}setBodyFriction(t,s){t.soft?t.physicsBody.get_m_cfg().set_kDF(s):t.physicsBody.setFriction(s),t._pluginData.friction=s}getBodyRestitution(t){return t._pluginData.restitution||0}setBodyRestitution(t,s){t.physicsBody.setRestitution(s),t._pluginData.restitution=s}getBodyPressure(t){return t.soft?t._pluginData.pressure||0:(e.Y.Warn("Pressure is not a property of a rigid body"),0)}setBodyPressure(t,s){t.soft?t.type===n.Q.SoftbodyImpostor?(t.physicsBody.get_m_cfg().set_kPR(s),t._pluginData.pressure=s):(t.physicsBody.get_m_cfg().set_kPR(0),t._pluginData.pressure=0):e.Y.Warn("Pressure can only be applied to a softbody")}getBodyStiffness(t){return t.soft?t._pluginData.stiffness||0:(e.Y.Warn("Stiffness is not a property of a rigid body"),0)}setBodyStiffness(t,s){t.soft?(s=(s=s<0?0:s)>1?1:s,t.physicsBody.get_m_materials().at(0).set_m_kLST(s),t._pluginData.stiffness=s):e.Y.Warn("Stiffness cannot be applied to a rigid body")}getBodyVelocityIterations(t){return t.soft?t._pluginData.velocityIterations||0:(e.Y.Warn("Velocity iterations is not a property of a rigid body"),0)}setBodyVelocityIterations(t,s){t.soft?(s=s<0?0:s,t.physicsBody.get_m_cfg().set_viterations(s),t._pluginData.velocityIterations=s):e.Y.Warn("Velocity iterations cannot be applied to a rigid body")}getBodyPositionIterations(t){return t.soft?t._pluginData.positionIterations||0:(e.Y.Warn("Position iterations is not a property of a rigid body"),0)}setBodyPositionIterations(t,s){t.soft?(s=s<0?0:s,t.physicsBody.get_m_cfg().set_piterations(s),t._pluginData.positionIterations=s):e.Y.Warn("Position iterations cannot be applied to a rigid body")}appendAnchor(t,s,i,o,e=1,n=!1){const r=t.segments,a=Math.round((r-1)*i)+r*(r-1-Math.round((r-1)*o));t.physicsBody.appendAnchor(a,s.physicsBody,n,e)}appendHook(t,s,i,o=1,e=!1){const n=Math.round(t.segments*i);t.physicsBody.appendAnchor(n,s.physicsBody,e,o)}sleepBody(t){t.physicsBody.forceActivationState(0)}wakeUpBody(t){t.physicsBody.activate()}updateDistanceJoint(){e.Y.Warn("updateDistanceJoint is not currently supported by the Ammo physics plugin")}setMotor(t,s,i){t.physicsJoint.enableAngularMotor(!0,s,i)}setLimit(){e.Y.Warn("setLimit is not currently supported by the Ammo physics plugin")}syncMeshWithImpostor(t,s){s.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform),t.position.x=this._tmpAmmoTransform.getOrigin().x(),t.position.y=this._tmpAmmoTransform.getOrigin().y(),t.position.z=this._tmpAmmoTransform.getOrigin().z(),t.rotationQuaternion&&(t.rotationQuaternion.x=this._tmpAmmoTransform.getRotation().x(),t.rotationQuaternion.y=this._tmpAmmoTransform.getRotation().y(),t.rotationQuaternion.z=this._tmpAmmoTransform.getRotation().z(),t.rotationQuaternion.w=this._tmpAmmoTransform.getRotation().w())}getRadius(t){return t.getObjectExtents().x/2}getBoxSizeToRef(t,s){const i=t.getObjectExtents();s.x=i.x,s.y=i.y,s.z=i.z}dispose(){this.bjsAMMO.destroy(this.world),this.bjsAMMO.destroy(this._solver),this.bjsAMMO.destroy(this._overlappingPairCache),this.bjsAMMO.destroy(this._dispatcher),this.bjsAMMO.destroy(this._collisionConfiguration),this.bjsAMMO.destroy(this._tmpAmmoVectorA),this.bjsAMMO.destroy(this._tmpAmmoVectorB),this.bjsAMMO.destroy(this._tmpAmmoVectorC),this.bjsAMMO.destroy(this._tmpAmmoTransform),this.bjsAMMO.destroy(this._tmpAmmoQuaternion),this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback),this.world=null}raycast(t,s){return this.raycastToRef(t,s,this._raycastResult),this._raycastResult}raycastToRef(t,s,i){this._tmpAmmoVectorRCA=new this.bjsAMMO.btVector3(t.x,t.y,t.z),this._tmpAmmoVectorRCB=new this.bjsAMMO.btVector3(s.x,s.y,s.z);const o=new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA,this._tmpAmmoVectorRCB);this.world.rayTest(this._tmpAmmoVectorRCA,this._tmpAmmoVectorRCB,o),i.reset(t,s),o.hasHit()&&(i.setHitData({x:o.get_m_hitNormalWorld().x(),y:o.get_m_hitNormalWorld().y(),z:o.get_m_hitNormalWorld().z()},{x:o.get_m_hitPointWorld().x(),y:o.get_m_hitPointWorld().y(),z:o.get_m_hitPointWorld().z()}),i.calculateHitDistance()),this.bjsAMMO.destroy(o),this.bjsAMMO.destroy(this._tmpAmmoVectorRCA),this.bjsAMMO.destroy(this._tmpAmmoVectorRCB)}}d._DISABLE_COLLISION_FLAG=4,d._KINEMATIC_FLAG=2,d._DISABLE_DEACTIVATION_FLAG=4},3262:(t,s,i)=>{i.d(s,{Q:()=>p});var o=i(9288),e=i(2085),n=i(972),r=i(7257),a=i(3632),h=i(7582),c=i(730);a.Kj._PhysicsImpostorParser=function(t,s,i){return new p(s,i.physicsImpostor,{mass:i.physicsMass,friction:i.physicsFriction,restitution:i.physicsRestitution},t)};class p{get isDisposed(){return this._isDisposed}get mass(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyMass(this):0}set mass(t){this.setMass(t)}get friction(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyFriction(this):0}set friction(t){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyFriction(this,t)}get restitution(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this):0}set restitution(t){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this,t)}get pressure(){if(!this._physicsEngine)return 0;const t=this._physicsEngine.getPhysicsPlugin();return t.setBodyPressure?t.getBodyPressure(this):0}set pressure(t){if(!this._physicsEngine)return;const s=this._physicsEngine.getPhysicsPlugin();s.setBodyPressure&&s.setBodyPressure(this,t)}get stiffness(){if(!this._physicsEngine)return 0;const t=this._physicsEngine.getPhysicsPlugin();return t.getBodyStiffness?t.getBodyStiffness(this):0}set stiffness(t){if(!this._physicsEngine)return;const s=this._physicsEngine.getPhysicsPlugin();s.setBodyStiffness&&s.setBodyStiffness(this,t)}get velocityIterations(){if(!this._physicsEngine)return 0;const t=this._physicsEngine.getPhysicsPlugin();return t.getBodyVelocityIterations?t.getBodyVelocityIterations(this):0}set velocityIterations(t){if(!this._physicsEngine)return;const s=this._physicsEngine.getPhysicsPlugin();s.setBodyVelocityIterations&&s.setBodyVelocityIterations(this,t)}get positionIterations(){if(!this._physicsEngine)return 0;const t=this._physicsEngine.getPhysicsPlugin();return t.getBodyPositionIterations?t.getBodyPositionIterations(this):0}set positionIterations(t){if(!this._physicsEngine)return;const s=this._physicsEngine.getPhysicsPlugin();s.setBodyPositionIterations&&s.setBodyPositionIterations(this,t)}constructor(t,s,i={mass:0},e){this.object=t,this.type=s,this._options=i,this._scene=e,this._pluginData={},this._bodyUpdateRequired=!1,this._onBeforePhysicsStepCallbacks=new Array,this._onAfterPhysicsStepCallbacks=new Array,this._onPhysicsCollideCallbacks=[],this._deltaPosition=n.P.Zero(),this._isDisposed=!1,this.soft=!1,this.segments=0,this._tmpQuat=new n._f,this._tmpQuat2=new n._f,this.beforeStep=()=>{this._physicsEngine&&(this.object.translate(this._deltaPosition,-1),this._deltaRotationConjugated&&this.object.rotationQuaternion&&this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated,this.object.rotationQuaternion),this.object.computeWorldMatrix(!1),this.object.parent&&this.object.rotationQuaternion?(this.getParentsRotation(),this._tmpQuat.multiplyToRef(this.object.rotationQuaternion,this._tmpQuat)):this._tmpQuat.copyFrom(this.object.rotationQuaternion||new n._f),this._options.disableBidirectionalTransformation||this.object.rotationQuaternion&&this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this,this.object.getAbsolutePosition(),this._tmpQuat),this._onBeforePhysicsStepCallbacks.forEach((t=>{t(this)})))},this.afterStep=()=>{this._physicsEngine&&(this._onAfterPhysicsStepCallbacks.forEach((t=>{t(this)})),this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this),this.object.parent&&this.object.rotationQuaternion&&(this.getParentsRotation(),this._tmpQuat.conjugateInPlace(),this._tmpQuat.multiplyToRef(this.object.rotationQuaternion,this.object.rotationQuaternion)),this.object.setAbsolutePosition(this.object.position),this._deltaRotation?(this.object.rotationQuaternion&&this.object.rotationQuaternion.multiplyToRef(this._deltaRotation,this.object.rotationQuaternion),this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation,p._TmpVecs[0]),this.object.translate(p._TmpVecs[0],1)):this.object.translate(this._deltaPosition,1),this.object.computeWorldMatrix(!0))},this.onCollideEvent=null,this.onCollide=t=>{if(!this._onPhysicsCollideCallbacks.length&&!this.onCollideEvent)return;if(!this._physicsEngine)return;const s=this._physicsEngine.getImpostorWithPhysicsBody(t.body);s&&(this.onCollideEvent&&this.onCollideEvent(this,s),this._onPhysicsCollideCallbacks.filter((t=>-1!==t.otherImpostors.indexOf(s))).forEach((i=>{i.callback(this,s,t.point,t.distance,t.impulse,t.normal)})))},this.object?(this.object.parent&&0!==i.mass&&o.Y.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur."),!this._scene&&t.getScene&&(this._scene=t.getScene()),this._scene&&(this.type>100&&(this.soft=!0),this._physicsEngine=this._scene.getPhysicsEngine(),this._physicsEngine?(this.object.rotationQuaternion||(this.object.rotation?this.object.rotationQuaternion=n._f.RotationYawPitchRoll(this.object.rotation.y,this.object.rotation.x,this.object.rotation.z):this.object.rotationQuaternion=new n._f),this._options.mass=void 0===i.mass?0:i.mass,this._options.friction=void 0===i.friction?.2:i.friction,this._options.restitution=void 0===i.restitution?.2:i.restitution,this.soft&&(this._options.mass=this._options.mass>0?this._options.mass:1,this._options.pressure=void 0===i.pressure?200:i.pressure,this._options.stiffness=void 0===i.stiffness?1:i.stiffness,this._options.velocityIterations=void 0===i.velocityIterations?20:i.velocityIterations,this._options.positionIterations=void 0===i.positionIterations?20:i.positionIterations,this._options.fixedPoints=void 0===i.fixedPoints?0:i.fixedPoints,this._options.margin=void 0===i.margin?0:i.margin,this._options.damping=void 0===i.damping?0:i.damping,this._options.path=void 0===i.path?null:i.path,this._options.shape=void 0===i.shape?null:i.shape),this._joints=[],!this.object.parent||this._options.ignoreParent?this._init():this.object.parent.physicsImpostor&&o.Y.Warn("You must affect impostors to children before affecting impostor to parent.")):o.Y.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors."))):o.Y.Error("No object was provided. A physics object is obligatory")}_init(){this._physicsEngine&&(this._physicsEngine.removeImpostor(this),this.physicsBody=null,this._parent=this._parent||this._getPhysicsParent(),this._isDisposed||this.parent&&!this._options.ignoreParent||this._physicsEngine.addImpostor(this))}_getPhysicsParent(){return this.object.parent instanceof r.x?this.object.parent.physicsImpostor:null}isBodyInitRequired(){return this._bodyUpdateRequired||!this._physicsBody&&(!this._parent||!!this._options.ignoreParent)}setScalingUpdated(){this.forceUpdate()}forceUpdate(){this._init(),this.parent&&!this._options.ignoreParent&&this.parent.forceUpdate()}get physicsBody(){return this._parent&&!this._options.ignoreParent?this._parent.physicsBody:this._physicsBody}get parent(){return!this._options.ignoreParent&&this._parent?this._parent:null}set parent(t){this._parent=t}set physicsBody(t){this._physicsBody&&this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this),this._physicsBody=t,this.resetUpdateFlags()}resetUpdateFlags(){this._bodyUpdateRequired=!1}getObjectExtents(){if(this.object.getBoundingInfo){const t=this.object.rotationQuaternion,s=this.object.scaling.clone();this.object.rotationQuaternion=p.IDENTITY_QUATERNION;const i=this.object.computeWorldMatrix&&this.object.computeWorldMatrix(!0);i&&i.decompose(s,void 0,void 0);const o=this.object.getBoundingInfo().boundingBox.extendSize.scale(2).multiplyInPlace(s);return o.x=Math.abs(o.x),o.y=Math.abs(o.y),o.z=Math.abs(o.z),this.object.rotationQuaternion=t,this.object.computeWorldMatrix&&this.object.computeWorldMatrix(!0),o}return p.DEFAULT_OBJECT_SIZE}getObjectCenter(){return this.object.getBoundingInfo?this.object.getBoundingInfo().boundingBox.centerWorld:this.object.position}getParam(t){return this._options[t]}setParam(t,s){this._options[t]=s,this._bodyUpdateRequired=!0}setMass(t){this.getParam("mass")!==t&&this.setParam("mass",t),this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyMass(this,t)}getLinearVelocity(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this):n.P.Zero()}setLinearVelocity(t){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this,t)}getAngularVelocity(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this):n.P.Zero()}setAngularVelocity(t){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this,t)}executeNativeFunction(t){this._physicsEngine&&t(this._physicsEngine.getPhysicsPlugin().world,this.physicsBody)}registerBeforePhysicsStep(t){this._onBeforePhysicsStepCallbacks.push(t)}unregisterBeforePhysicsStep(t){const s=this._onBeforePhysicsStepCallbacks.indexOf(t);s>-1?this._onBeforePhysicsStepCallbacks.splice(s,1):o.Y.Warn("Function to remove was not found")}registerAfterPhysicsStep(t){this._onAfterPhysicsStepCallbacks.push(t)}unregisterAfterPhysicsStep(t){const s=this._onAfterPhysicsStepCallbacks.indexOf(t);s>-1?this._onAfterPhysicsStepCallbacks.splice(s,1):o.Y.Warn("Function to remove was not found")}registerOnPhysicsCollide(t,s){const i=t instanceof Array?t:[t];this._onPhysicsCollideCallbacks.push({callback:s,otherImpostors:i})}unregisterOnPhysicsCollide(t,s){const i=t instanceof Array?t:[t];let e=-1;this._onPhysicsCollideCallbacks.some(((t,o)=>{if(t.callback===s&&t.otherImpostors.length===i.length){const s=t.otherImpostors.every((t=>i.indexOf(t)>-1));return s&&(e=o),s}return!1}))?this._onPhysicsCollideCallbacks.splice(e,1):o.Y.Warn("Function to remove was not found")}getParentsRotation(){let t=this.object.parent;for(this._tmpQuat.copyFromFloats(0,0,0,1);t;)t.rotationQuaternion?this._tmpQuat2.copyFrom(t.rotationQuaternion):n._f.RotationYawPitchRollToRef(t.rotation.y,t.rotation.x,t.rotation.z,this._tmpQuat2),this._tmpQuat.multiplyToRef(this._tmpQuat2,this._tmpQuat),t=t.parent;return this._tmpQuat}applyForce(t,s){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().applyForce(this,t,s),this}applyImpulse(t,s){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().applyImpulse(this,t,s),this}createJoint(t,s,i){const o=new h.q7(s,i);return this.addJoint(t,o),this}addJoint(t,s){return this._joints.push({otherImpostor:t,joint:s}),this._physicsEngine&&this._physicsEngine.addJoint(this,t,s),this}addAnchor(t,s,i,o,e){if(!this._physicsEngine)return this;const n=this._physicsEngine.getPhysicsPlugin();return n.appendAnchor?(this._physicsEngine&&n.appendAnchor(this,t,s,i,o,e),this):this}addHook(t,s,i,o){if(!this._physicsEngine)return this;const e=this._physicsEngine.getPhysicsPlugin();return e.appendAnchor?(this._physicsEngine&&e.appendHook(this,t,s,i,o),this):this}sleep(){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().sleepBody(this),this}wakeUp(){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().wakeUpBody(this),this}clone(t){return t?new p(t,this.type,this._options,this._scene):null}dispose(){this._physicsEngine&&(this._joints.forEach((t=>{this._physicsEngine&&this._physicsEngine.removeJoint(this,t.otherImpostor,t.joint)})),this._physicsEngine.removeImpostor(this),this.parent&&this.parent.forceUpdate(),this._isDisposed=!0)}setDeltaPosition(t){this._deltaPosition.copyFrom(t)}setDeltaRotation(t){this._deltaRotation||(this._deltaRotation=new n._f),this._deltaRotation.copyFrom(t),this._deltaRotationConjugated=this._deltaRotation.conjugate()}getBoxSizeToRef(t){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this,t),this}getRadius(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getRadius(this):0}syncBoneWithImpostor(t,s,i,o,e){const n=p._TmpVecs[0],r=this.object;if(r.rotationQuaternion)if(e){const i=p._TmpQuat;r.rotationQuaternion.multiplyToRef(e,i),t.setRotationQuaternion(i,c.T.WORLD,s)}else t.setRotationQuaternion(r.rotationQuaternion,c.T.WORLD,s);n.x=0,n.y=0,n.z=0,i&&(n.x=i.x,n.y=i.y,n.z=i.z,t.getDirectionToRef(n,s,n),null==o&&(o=i.length()),n.x*=o,n.y*=o,n.z*=o),t.getParent()?(n.addInPlace(r.getAbsolutePosition()),t.setAbsolutePosition(n,s)):(s.setAbsolutePosition(r.getAbsolutePosition()),s.position.x-=n.x,s.position.y-=n.y,s.position.z-=n.z)}syncImpostorWithBone(t,s,i,o,e,n){const r=this.object;if(r.rotationQuaternion)if(e){const i=p._TmpQuat;t.getRotationQuaternionToRef(c.T.WORLD,s,i),i.multiplyToRef(e,r.rotationQuaternion)}else t.getRotationQuaternionToRef(c.T.WORLD,s,r.rotationQuaternion);const a=p._TmpVecs[0],h=p._TmpVecs[1];n||((n=p._TmpVecs[2]).x=0,n.y=1,n.z=0),t.getDirectionToRef(n,s,h),t.getAbsolutePositionToRef(s,a),null==o&&i&&(o=i.length()),null!=o&&(a.x+=h.x*o,a.y+=h.y*o,a.z+=h.z*o),r.setAbsolutePosition(a)}}p.DEFAULT_OBJECT_SIZE=new n.P(1,1,1),p.IDENTITY_QUATERNION=n._f.Identity(),p._TmpVecs=e.B.BuildArray(3,n.P.Zero),p._TmpQuat=n._f.Identity(),p.NoImpostor=0,p.SphereImpostor=1,p.BoxImpostor=2,p.PlaneImpostor=3,p.MeshImpostor=4,p.CapsuleImpostor=6,p.CylinderImpostor=7,p.ParticleImpostor=8,p.HeightmapImpostor=9,p.ConvexHullImpostor=10,p.CustomImpostor=100,p.RopeImpostor=101,p.ClothImpostor=102,p.SoftbodyImpostor=103}}]);
//# sourceMappingURL=419.babylonBundle.js.map