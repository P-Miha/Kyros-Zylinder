{"version":3,"file":"js/460.babylonBundle.js","mappings":"6JAaA,IAAYA,EAgBAC,EAwCAC,EAyCAC,EAYAC,EAsLAC,E,+DAnSZ,SAAYL,GAIR,mBAIA,yBAIA,sBACH,CAbD,CAAYA,IAAAA,EAA8B,KAgB1C,SAAYC,GAKR,2BAKA,2BAKA,2BAKA,6BAKA,6BAKA,6BAMA,wCACH,CArCD,CAAYA,IAAAA,EAAqB,KAwCjC,SAAYC,GAKR,yCAKA,2BAKA,qBAMA,uBAKA,mBAKA,6BAMA,wBACH,CAtCD,CAAYA,IAAAA,EAAqB,KAyCjC,SAAYC,GACR,uBACA,yBACA,2BACA,iBACA,iCACA,6BACA,mBACA,gCACH,CATD,CAAYA,IAAAA,EAAgB,KAY5B,SAAYC,GACR,mBACA,2BACA,0BACH,CAJD,CAAYA,IAAAA,EAA0B,KAsLtC,SAAYC,GACR,uBACA,2BACA,wBACH,CAJD,CAAYA,IAAAA,EAAiB,I,8HCrR7B,MAAMC,EASF,YAAmBC,EAAYC,EAAyBC,GAkHhD,KAAAC,UAAuB,GACvB,KAAAC,SAAqB,GAlHzB,MAAMC,EAAgBL,EAAKM,oBAAmB,GACxCC,EAAY,IAAI,IAChBC,EAAkB,IAAI,KACtBC,EAAkB,IAAI,IAC5BJ,EAAcK,UAAUH,EAAWC,EAAiBC,GAEpDE,KAAKC,eAAiB,aAAe,UAAeZ,EAAKa,mBAAqBb,EAAKa,mBAAqB,gBAAuBb,EAAKc,UACpIH,KAAKC,eAAiBD,KAAKC,eAAeG,SAC1CJ,KAAKK,eAAiBd,EAAMe,qBAC5BN,KAAKO,gBAAkBjB,CAC3B,CAeOkB,QAAQnB,EAAYoB,GACvB,MAAMC,EAAcV,KAAKR,UAAUmB,OAE7BC,EADiBvB,EAAKM,oBAAmB,GACVkB,SAASb,KAAKC,gBAE7Ca,EAAazB,EAAK0B,gBAAgB,mBAA8B,GAChEC,EAAWF,EAAWH,OAAS,EACrC,IAAK,IAAIM,EAAI,EAAGA,EAAID,EAAUC,IAAK,CAC/B,MAAMC,EAAM,IAAI,IAAQJ,EAAe,EAAJG,EAAQ,GAAIH,EAAe,EAAJG,EAAQ,GAAIH,EAAe,EAAJG,EAAQ,IACzFjB,KAAKR,UAAU2B,KAAK,yBAA6BD,EAAKN,G,CAG1D,GAAIZ,KAAKO,gBAAiB,CACtB,MAAMa,EAAc/B,EAAKgC,aACzB,GAAID,EACA,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAYT,OAAQW,GAAK,EAErCtB,KAAKK,gBACLL,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,GACxCV,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,GACxCV,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,KAExCV,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,GACxCV,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,GACxCV,KAAKP,SAAS0B,KAAKC,EAAYE,EAAI,GAAKZ,G,CAMpDD,GACiBpB,EAAKkC,gBAAe,GAI5BC,QAAQC,IAAYA,EAAEC,cAAaC,SAASF,GAAWzB,KAAKQ,QAAQiB,EAAGhB,IAExF,CAUOmB,YAAYC,GACf,MAAMC,EAAkC,EAAxB9B,KAAKR,UAAUmB,OAEzBoB,EADgB,EACPD,EACTE,EAAcH,EAAOI,QAAQF,GAE7BG,EAAM,IAAIC,aAAaN,EAAOO,OAAOC,OAAQL,EAAaF,GAChE,IAAK,IAAIR,EAAI,EAAGA,EAAItB,KAAKR,UAAUmB,OAAQW,IACvCY,EAAQ,EAAJZ,EAAQ,GAAKtB,KAAKR,UAAU8B,GAAGgB,EACnCJ,EAAQ,EAAJZ,EAAQ,GAAKtB,KAAKR,UAAU8B,GAAGiB,EACnCL,EAAQ,EAAJZ,EAAQ,GAAKtB,KAAKR,UAAU8B,GAAGkB,EAGvC,OAAON,CACX,CAEOO,WAAWZ,EAAaa,GAC3Bb,EAAOc,MAAMD,EAAIE,WACrB,CASOC,aAAahB,GAChB,MACME,EADc,EACL/B,KAAKP,SAASkB,OACvBqB,EAAcH,EAAOI,QAAQF,GAC7BG,EAAM,IAAIY,WAAWjB,EAAOO,OAAOC,OAAQL,EAAahC,KAAKP,SAASkB,QAC5E,IAAK,IAAIW,EAAI,EAAGA,EAAItB,KAAKP,SAASkB,OAAQW,IACtCY,EAAIZ,GAAKtB,KAAKP,SAAS6B,GAG3B,OAAOY,CACX,EASJ,MAAMa,EACF,YAAmBC,GACfhD,KAAKiD,SAAWD,EAChBhD,KAAKkD,cAAgB,CAAEC,kBAAcC,EAAWC,UAAMD,EAAWE,aAASF,EAAWG,wBAAoBH,EAC7G,EAiBJ,MAAMI,EAAN,cACW,KAAAR,OAAiBS,OAAO,GAGxB,KAAAtD,SAAoB,IAAI,IACxB,KAAAuD,OAAkB,IAAI,GAEjC,EAEA,MAAMC,EAAN,cAEW,KAAAC,WAA2B,IAAIJ,EAC/B,KAAAK,WAA2B,IAAIL,EAC/B,KAAAM,eAAyB,CAepC,CAbIC,iBAAiB1B,EAAa2B,EAAgBC,GAC1C,MAAMC,EAAS,IAAIpB,WAAWT,EAAQ2B,GAChCG,EAAW,IAAIhC,aAAaE,EAAQ2B,GAE1CC,EAASL,WAAWZ,OAASS,OAAOS,EADvB,IAEbD,EAASL,WAAWzD,SAASiE,IAAID,EAASE,IAAWF,EAASE,IAAWF,EAASE,KAClFJ,EAASL,WAAWF,OAAOU,IAAID,EAASE,IAAYF,EAASE,IAAYF,EAASE,KAElFJ,EAASJ,WAAWb,OAASS,OAAOS,EAAOI,KAC3CL,EAASJ,WAAW1D,SAASiE,IAAID,EAASG,IAAWH,EAASG,IAAWH,EAASG,KAClFL,EAASJ,WAAWH,OAAOU,IAAID,EAASG,IAAYH,EAASG,IAAYH,EAASG,KAClFL,EAASH,eAAiBK,EAASG,GACvC,EAMG,MAAMC,EA4BT,YAA2BC,GAAiC,EAAMC,EAAmBC,IAA1D,KAAAF,sBAAAA,EAxBpB,KAAAG,MAAa,CAAC,EAQd,KAAAC,KAAe,cAKd,KAAAC,eAAyB,EAAI,GAC7B,KAAAC,UAAoB,EAAI,GACxB,KAAAC,SAAW,eAAsB,EAAG,UACpC,KAAAC,QAAU,IAAIC,IAEd,KAAAC,yBAA2B,IAAID,IAIhC,KAAAE,sBAAwB,IAAI,KAGJ,mBAAhBV,GAIPzE,KAAK2E,MAAQF,EAGZzE,KAAKoF,eAIVpF,KAAKqF,MAAQrF,KAAK2E,MAAMW,kBAAkB,GAC1CtF,KAAKuF,gBAAkBvF,KAAK2E,MAAMa,yBAAyB,GAAG,IAJ1D,UAAa,uEAPb,UAAa,+EAYrB,CAKOJ,cACH,YAAsBhC,IAAfpD,KAAK2E,KAChB,CAQOc,WAAWC,GACd1F,KAAK2E,MAAMgB,oBAAoB3F,KAAKqF,MAAOrF,KAAK4F,UAAUF,GAC9D,CAQOG,YAAYC,GACf9F,KAAK6E,eAAiBiB,CAC1B,CAQOC,cACH,OAAO/F,KAAK6E,cAChB,CAaOmB,YAAYC,EAAeC,GAC9B,IAAK,MAAMxE,KAAewE,EAClBxE,EAAYyE,gBAGhBnG,KAAKoG,6BAA6B1E,EAAaA,EAAY2E,eAG/DrG,KAAK2E,MAAM2B,cAActG,KAAKqF,MAAOrF,KAAKwE,sBAAwByB,EAAQjG,KAAK8E,WAE/E9E,KAAKuG,YAAcvG,KAAK2E,MAAM6B,uBAAuBxG,KAAKqF,OAAO,GACjE,IAAK,MAAM3D,KAAewE,EACtBlG,KAAKyG,KAAK/E,GAGd1B,KAAK0G,mBACT,CASOC,mBACH,OAAO,CACX,CAaOC,SAASC,EAAmBC,EAA+B3G,EAAmB4G,GACjFF,EAAKG,YAAc,IAAIjE,EAAe/C,KAAK2E,MAAMsC,iBAAiB,IAElEjH,KAAKkH,uBAAuBL,EAAKG,YAAaF,GAC9C,MAAMK,EAAY,CAACnH,KAAK4F,UAAUzF,GAAWH,KAAKoH,WAAWL,IAC7D/G,KAAK2E,MAAM0C,sBAAsBR,EAAKG,YAAY/D,SAAUkE,GAE5DnH,KAAK2E,MAAM2C,iBAAiBtH,KAAKqF,MAAOwB,EAAKG,YAAY/D,SAAU4D,EAAKU,aACxEvH,KAAKgF,QAAQZ,IAAIyC,EAAKG,YAAY/D,SAAS,GAAI,CAAE4D,KAAMA,EAAMW,MAAO,GACxE,CAOOC,WAAWZ,GACd,GAAIA,EAAKa,sBAAwBb,EAAKa,qBAAqB/G,OAAS,EAChE,IAAK,MAAMgH,KAAYd,EAAKa,qBACxB1H,KAAKkF,yBAAyB0C,OAAOD,EAAS1E,SAAS,IACvDjD,KAAK2E,MAAMkD,oBAAoB7H,KAAKqF,MAAOsC,EAAS1E,UAGxD4D,EAAKG,cACLhH,KAAKkF,yBAAyB0C,OAAOf,EAAKG,YAAY/D,SAAS,IAC/DjD,KAAK2E,MAAMkD,oBAAoB7H,KAAKqF,MAAOwB,EAAKG,YAAY/D,UAEpE,CAeO6E,kBAAkBjB,EAAmBC,EAA+BzH,G,QACvE,MAAM0I,EAA8D,QAA7C,EAA6B,QAA7B,EAAA1I,EAAK2I,gCAAwB,eAAED,sBAAc,QAAI,EAClEE,EAAa5I,EAAK2I,yBAAyBC,WAC5CA,IAGLjI,KAAKkI,6BAA6BrB,EAAMC,EAAYmB,EAAY,EAAGF,GAAgB,GACnFlB,EAAKa,qBAAqB/F,SAAQ,CAACqB,EAAQwE,KACvCxH,KAAKgF,QAAQZ,IAAIpB,EAAOC,SAAS,GAAI,CAAE4D,KAAMA,EAAMW,MAAOA,GAAQ,IAE1E,CAEQU,6BAA6BrB,EAAmBC,EAA+BmB,EAA0BE,EAAoBC,EAAkBC,GACnJ,MAAMC,EAAW,mBACXC,EAAiB,gBACvB,IAAK,IAAIjH,EAAI6G,EAAY7G,EAAI8G,EAAU9G,IAAK,CACxC,MAAMnB,EAAW,CAAC8H,EAAe,GAAJ3G,EAAS,IAAK2G,EAAe,GAAJ3G,EAAS,IAAK2G,EAAe,GAAJ3G,EAAS,KACxF,IAAIkH,EAIAA,EAHCH,EAGQxB,EAAKa,qBAAqBpG,GAAG2B,SAF7BjD,KAAK2E,MAAMsC,iBAAiB,GAIzCsB,EAAeE,iBAAiB,EAAGR,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,GAAI,GAC3GiH,EAAeE,iBAAiB,EAAGR,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,GAAI,GAC3GiH,EAAeE,iBAAiB,EAAGR,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,GAAI2G,EAAe,GAAJ3G,EAAS,IAAK,GAC5G,6BAAmCiH,EAAgBD,GACnD,MAAMnB,EAAY,CAAChH,EAAU,CAACmI,EAAShG,EAAGgG,EAAS/F,EAAG+F,EAAS9F,EAAG8F,EAASI,IAE3E,GADA1I,KAAK2E,MAAM0C,sBAAsBmB,EAAQrB,IACpCkB,EAAQ,CACT,MAAMM,EAAa,IAAI5F,EAAeyF,GAClC3B,EAAKa,qBAAqB/G,SAE1BgI,EAAWzF,cAAgB2D,EAAKa,qBAAqB,GAAGxE,eAE5DlD,KAAKkH,uBAAuByB,EAAY7B,GACxC9G,KAAK4I,8BAA8BD,GACnC9B,EAAKa,qBAAqBvG,KAAKwH,GAC/B3I,KAAK2E,MAAM2C,iBAAiBtH,KAAKqF,MAAOmD,EAAQ3B,EAAKU,aACrDoB,EAAWE,qBAAuB7I,KAAK2E,MAAMmE,gCAAgCN,GAAQ,E,EAGjG,CAOOO,oBAAoBlC,EAAmBxH,G,QAC1C,MAAM0I,EAA8D,QAA7C,EAA6B,QAA7B,EAAA1I,EAAK2I,gCAAwB,eAAED,sBAAc,QAAI,EAClEE,EAAa5I,EAAK2I,yBAAyBC,WACjD,IAAKA,EACD,OAEJ,MAAMe,EAAuBnC,EAAKa,qBAAqB/G,OACjDmG,EAAa9G,KAAKiJ,cAAcpC,GAEtC,GAAIkB,EAAiBiB,EAAsB,CACvChJ,KAAKkI,6BAA6BrB,EAAMC,EAAYmB,EAAYe,EAAsBjB,GAAgB,GACtG,MAAMmB,EAAiBlJ,KAAK2E,MAAMwE,iBAAiBtC,EAAKa,qBAAqB,GAAGzE,UAAU,GAC1F,IAAK,IAAI3B,EAAI0H,EAAsB1H,EAAIyG,EAAgBzG,IACnDtB,KAAK2E,MAAMyE,iBAAiBvC,EAAKa,qBAAqBpG,GAAG2B,SAAUiG,GACnElJ,KAAK4I,8BAA8B/B,EAAKa,qBAAqBpG,IAC7DtB,KAAKgF,QAAQZ,IAAIyC,EAAKa,qBAAqBpG,GAAG2B,SAAS,GAAI,CAAE4D,KAAMA,EAAMW,MAAOlG,G,MAEjF,GAAIyG,EAAiBiB,EAAsB,CAC9C,MAAMK,EAAoBL,EAAuBjB,EACjD,IAAK,IAAIzG,EAAI,EAAGA,EAAI+H,EAAmB/H,IAAK,CACxC,MAAMkH,EAAS3B,EAAKa,qBAAqB4B,MACzCtJ,KAAKgF,QAAQ4C,OAAOY,EAAOvF,SAAS,IACpCjD,KAAK2E,MAAMkD,oBAAoB7H,KAAKqF,MAAOmD,EAAOvF,UAClDjD,KAAK2E,MAAM4E,gBAAgBf,EAAOvF,S,CAEtCjD,KAAKkI,6BAA6BrB,EAAMC,EAAYmB,EAAY,EAAGF,GAAgB,E,CAE3F,CASAtB,KAAKI,GACD7G,KAAKwJ,cAAc3C,EAAMA,EAAKR,cAClC,CAgBAmD,cAAc3C,EAAmBR,GAC7B,GAAIQ,EAAKa,qBAAqB/G,OAAQ,CAElC,MAAMc,EAAI4E,EACJ4B,EAAaxG,EAAEuG,yBAAyBC,WAC9C,IAAKA,EACD,OAEJ,MAAMF,EAAiBlB,EAAKa,qBAAqB/G,OACjD,IAAK,IAAIW,EAAI,EAAGA,EAAIyG,EAAgBzG,IAAK,CACrC,MAAMmI,EAAY5C,EAAKa,qBAAqBpG,GAAGuH,qBACzCa,EAAkB,IAAIvH,aAAanC,KAAK2E,MAAMvC,OAAOC,OAAQrC,KAAKuG,YAAckD,EAAW,IAC3FjC,EAAY,GAAJlG,EAEd,IAAK,IAAIqI,EAAK,EAAGA,EAAK,GAAIA,IACN,IAAN,EAALA,KACD1B,EAAWT,EAAQmC,GAAMD,EAAgBC,IAGjD1B,EAAWT,EAAQ,IAAM,C,CAE7B/F,EAAEmI,0BAA0B,S,MAE5B,IAEI,MAAMC,EAAgB7J,KAAK2E,MAAMmF,sBAAsBjD,EAAKG,YAAY/D,UAAU,GAC5E8G,EAAkBF,EAAc,GAChCG,EAAkBH,EAAc,GAChCI,EAAO,mBAEbA,EAAK7F,IAAI4F,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,IAErF,MAAME,EAAS7D,EAAc6D,OAE7B,GAAIA,GAAUA,EAAOC,2BAA4B,CAC7C,oBAA0BJ,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,IAClFG,EAAOC,2BAA2BC,eAAe,oBACjDH,EAAKI,gBAAgB,oBACrB,8BAAoCH,EAAOI,iBAAkB,iBAC7D,MAAMC,EAAgB,gBACtB,wCAA8C,mBAA0BA,GACxElE,EAAclG,SAASiE,IAAImG,EAAcjI,EAAGiI,EAAchI,EAAGgI,EAAc/H,E,MAE3E6D,EAAclG,SAASiE,IAAI2F,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,IAGnF1D,EAAcnG,mBACdmG,EAAcnG,mBAAmBsK,SAASP,GAE1CA,EAAKQ,mBAAmBpE,EAAciC,S,CAE5C,MAAOoC,GACLC,QAAQC,IAAI,qCAAqCvE,EAAczB,SAAS8F,EAAEG,a,CAGtF,CAaOC,SAASjE,EAAmBkE,G,UAC/B,MAAMC,EAAcD,GAASA,EAAM/D,YAAc+D,EAAM/D,YAAcvD,OAAO,GAC5E,KAAMoD,EAAKR,yBAAyB,OAAqD,QAA3C,EAAAQ,EAAKR,cAAc2B,gCAAwB,eAAEC,aAGvF,OAFAjI,KAAK2E,MAAMyE,iBAAiBvC,EAAKG,YAAY/D,SAAU+H,QACvDhL,KAAK4I,8BAA8B/B,EAAKG,aAG5C,MACMe,EAA2D,QAA1C,EAA0B,QAA1B,EADblB,EAAKR,cACU2B,gCAAwB,eAAED,sBAAc,QAAI,EACrE,IAAK,IAAIzG,EAAI,EAAGA,EAAIyG,EAAgBzG,IAChCtB,KAAK2E,MAAMyE,iBAAiBvC,EAAKa,qBAAqBpG,GAAG2B,SAAU+H,GACnEhL,KAAK4I,8BAA8B/B,EAAKa,qBAAqBpG,GAErE,CAQQ2J,oBAAoBpE,EAAmBqE,G,MAC3C,OAAgC,QAAzB,EAAArE,EAAKa,4BAAoB,eAAE/G,QAASkG,EAAKa,qBAAqBwD,QAAAA,EAAiB,GAAKrE,EAAKG,WACpG,CASOmE,SAAStE,GACZ,MAAMuE,EAAYpL,KAAKiL,oBAAoBpE,GACrCwE,EAAkBrL,KAAK2E,MAAMwE,iBAAiBiC,EAAUnI,UAAU,GACxE,GAAuB,GAAnBoI,EAAsB,CACtB,MAAM9L,EAAQsH,EAAKR,cAAciF,WACjC,OAAO,IAAI,KAAa,CAAE3C,WAAY0C,GAAmB9L,E,CAE7D,OAAO,IACX,CAQOgM,aAAaR,GAChB,OAAIA,EAAMS,KACCT,EAAMS,KAGNxL,KAAK2E,MAAM8G,iBAAiBV,EAAM/D,YAEjD,CASO0E,aAAa7E,EAAmB8E,EAAmBT,GACtDlL,KAAK4L,wBACD/E,GACCgF,IACG7L,KAAK2E,MAAMmH,qBAAqBD,EAAe5I,SAAU0I,EAAU,GAEvET,EAER,CASOa,aAAalF,EAAmBqE,GACnC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GACjD,OAAOlL,KAAK2E,MAAMqH,qBAAqBZ,GAAW,EACtD,CAEQa,yBAAyBC,GAC7B,MAAO,CACH/I,aAAc,cAAkB+I,EAAe,IAC/C7I,KAAM6I,EAAe,GACrB5I,QAAS,cAAkB4I,EAAe,IAC1C3I,mBAAoB,eAAqB2I,EAAe,IAEhE,CAEQtD,8BAA8BD,GAElC,MAAMwD,EAAWnM,KAAKoM,+BAA+BzD,GAC/C0D,EAAY1D,EAAWzF,cAGzBmJ,EAAUlJ,eACVgJ,EAAS,GAAKE,EAAUlJ,aAAamJ,WAEnBlJ,MAAlBiJ,EAAUhJ,OACV8I,EAAS,GAAKE,EAAUhJ,MAExBgJ,EAAU/I,UACV6I,EAAS,GAAKE,EAAU/I,QAAQgJ,WAEhCD,EAAU9I,qBACV4I,EAAS,GAAKE,EAAU9I,mBAAmB+I,WAE/CtM,KAAK2E,MAAM4H,0BAA0B5D,EAAW1F,SAAUkJ,EAC9D,CAEOjF,uBAAuByB,EAA4B7B,GACtD,OAAQA,GACJ,KAAK,YACD9G,KAAK2E,MAAM6H,sBAAsB7D,EAAW1F,SAAUjD,KAAK2E,MAAM8H,WAAWC,QAC5E,MACJ,KAAK,cACD1M,KAAK2E,MAAM6H,sBAAsB7D,EAAW1F,SAAUjD,KAAK2E,MAAM8H,WAAWE,WAC5E,MACJ,KAAK,aACD3M,KAAK2E,MAAM6H,sBAAsB7D,EAAW1F,SAAUjD,KAAK2E,MAAM8H,WAAWG,SAGxF,CAEOC,cAAchG,EAAmBC,EAA+BoE,GACnElL,KAAK4L,wBACD/E,GACC8B,IACG3I,KAAKkH,uBAAuByB,EAAY7B,EAAW,GAEvDoE,EAER,CAEOjC,cAAcpC,EAAmBqE,GACpC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GAC3CM,EAAOxL,KAAK2E,MAAMmI,sBAAsB1B,EAAUnI,UAAU,GAClE,OAAQuI,GACJ,KAAKxL,KAAK2E,MAAM8H,WAAWC,OACvB,OAAO,YACX,KAAK1M,KAAK2E,MAAM8H,WAAWE,UACvB,OAAO,cACX,KAAK3M,KAAK2E,MAAM8H,WAAWG,QACvB,OAAO,aAEf,MAAM,IAAIG,MAAM,wBAA0BvB,EAC9C,CAEQY,+BAA+BzD,GACnC,MAAMqE,EAAWhN,KAAK2E,MAAMwE,iBAAiBR,EAAW1F,UACxD,GAAI+J,EAAS,IAAMhN,KAAK2E,MAAMsI,OAAOC,UAAW,CAC5C,MAAMC,EAAYnN,KAAK2E,MAAMyI,6BAA6BJ,EAAS,IACnE,GAAIG,EAAU,IAAMnN,KAAK2E,MAAMsI,OAAOC,UAClC,OAAOC,EAAU,E,CAKzB,MAAO,CAAC,CAAC,EAAG,EAAG,GAAI,EAAG,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,EAAG,GAC/C,CAOOE,sBAAsBxG,EAAmBqE,GAC5C,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GAC3CoC,EAAWtN,KAAKoM,+BAA+BhB,GACrD,OAAOpL,KAAKiM,yBAAyBqB,EACzC,CAaOC,kBAAkB1G,EAAmBwF,EAAkCnB,GAC1ElL,KAAK4L,wBACD/E,GACC8B,IACGA,EAAWzF,cAAgBmJ,EAC3BrM,KAAK4I,8BAA8BD,EAAW,GAElDuC,EAER,CAIOsC,kBAAkB3G,EAAmBqE,GACxC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GAC3CgB,EAAiBlM,KAAK2E,MAAM8I,0BAA0BrC,EAAUnI,UAAU,GAChF,OAAOjD,KAAKiM,yBAAyBC,EACzC,CAWOwB,iBAAiB7G,EAAmB8G,EAAiBzC,GACxDlL,KAAK4L,wBACD/E,GACC8B,IACG3I,KAAK2E,MAAMiJ,yBAAyBjF,EAAW1F,SAAU0K,EAAQ,GAErEzC,EAER,CAWO2C,iBAAiBhH,EAAmBqE,GACvC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GACjD,OAAOlL,KAAK2E,MAAMmJ,yBAAyB1C,EAAUnI,UAAU,EACnE,CAUO8K,kBAAkBlH,EAAmB8G,EAAiBzC,GACzDlL,KAAK4L,wBACD/E,GACC8B,IACG3I,KAAK2E,MAAMqJ,0BAA0BrF,EAAW1F,SAAU0K,EAAQ,GAEtEzC,EAER,CAUO+C,kBAAkBpH,EAAmBqE,GACxC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GACjD,OAAOlL,KAAK2E,MAAMuJ,0BAA0B9C,EAAUnI,UAAU,EACpE,CAUOkL,kBAAkBtH,EAAmBuH,EAAiBlD,GACzDlL,KAAK4L,wBACD/E,GACC8B,IACG3I,KAAK2E,MAAM0J,0BAA0B1F,EAAW1F,SAAUjD,KAAK4F,UAAUwI,GAAQ,GAErFlD,EAER,CAWOoD,uBAAuBzH,EAAmBuH,EAAiBlD,GAC9D,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GAC3CqD,EAAKvO,KAAK2E,MAAM6J,0BAA0BpD,EAAUnI,UAAU,GACpEjD,KAAKyO,aAAaF,EAAIH,EAC1B,CAKQxC,wBAAwB/E,EAAmB6H,EAAqCxD,G,MACpF,IAA6B,QAAzB,EAAArE,EAAKa,4BAAoB,eAAE/G,QAAS,QAAuByC,IAAlB8H,EACzC,IAAK,IAAI5J,EAAI,EAAGA,EAAIuF,EAAKa,qBAAqB/G,OAAQW,IAClDoN,EAAU7H,EAAKa,qBAAqBpG,SAGxCoN,EAAU1O,KAAKiL,oBAAoBpE,EAAMqE,GAEjD,CAYOyD,aAAa9H,EAAmB+H,EAAkBC,EAAmB3D,GACxElL,KAAK4L,wBACD/E,GACCuE,IACGpL,KAAK2E,MAAMmK,qBAAqB1D,EAAUnI,SAAUjD,KAAK4F,UAAUiJ,GAAW7O,KAAK4F,UAAUgJ,GAAS,GAE1G1D,EAER,CAYO6D,WAAWlI,EAAmBmI,EAAgBH,EAAmB3D,GACpE8D,EAAMC,WAAWjP,KAAK+F,cAAe/F,KAAK+E,SAAS,IACnD/E,KAAK2O,aAAa9H,EAAM7G,KAAK+E,SAAS,GAAI8J,EAAU3D,EACxD,CAWOgE,mBAAmBrI,EAAmBsI,EAAiBjE,GAC1DlL,KAAK4L,wBACD/E,GACCuE,IACGpL,KAAK2E,MAAMyK,2BAA2BhE,EAAUnI,SAAUjD,KAAK4F,UAAUuJ,GAAQ,GAErFjE,EAER,CAYOmE,wBAAwBxI,EAAmBsI,EAAiBjE,GAC/D,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GAC3CoE,EAAKtP,KAAK2E,MAAM4K,2BAA2BnE,EAAUnI,UAAU,GACrEjD,KAAKyO,aAAaa,EAAIH,EAC1B,CAcO/I,6BAA6BS,EAAmB2I,GACnD,MAAMnJ,EAAgBQ,EAAKR,cAC3B,GAAIQ,EAAK4I,aAAe,EAAG,CAEvB,MACMxH,EADI5B,EACW2B,yBAAyBC,WAC9C,IAAKA,EACD,OAEJ,MAAMF,EAAiBlB,EAAK4I,aAC5BzP,KAAKkI,6BAA6BrB,EAAMA,EAAKoC,gBAAiBhB,EAAY,EAAGF,GAAgB,E,MAG7F/H,KAAK2E,MAAM0C,sBAAsBR,EAAKG,YAAY/D,SAAUjD,KAAK0P,mBAAmBF,GAE5F,CAQOG,iBAAiB9I,EAAmB+I,EAAgB1E,GACvDlL,KAAK4L,wBACD/E,GACCuE,IACGpL,KAAK2E,MAAMkL,yBAAyBzE,EAAUnI,SAAU2M,EAAO,GAEnE1E,EAER,CAQO4E,iBAAiBjJ,EAAmBqE,GACvC,MAAME,EAAYpL,KAAKiL,oBAAoBpE,EAAMqE,GACjD,OAAOlL,KAAK2E,MAAMoL,yBAAyB3E,EAAUnI,UAAU,EACnE,CAUO+M,YAAYnJ,GACf,GAAIA,EAAKa,sBAAwBb,EAAKa,qBAAqB/G,OAAS,EAChE,IAAK,MAAMgH,KAAYd,EAAKa,qBACxB1H,KAAK2E,MAAM4E,gBAAgB5B,EAAS1E,UACpC0E,EAAS1E,cAAWG,EAGxByD,EAAKG,cACLhH,KAAK2E,MAAM4E,gBAAgB1C,EAAKG,YAAY/D,UAC5C4D,EAAKG,YAAY/D,cAAWG,EAEpC,CAaO6M,UAAUlF,EAAqBS,EAAwB0E,GAC1D,OAAQ1E,GACJ,KAAK,YACD,CACI,MAAM2E,EAASD,EAAQC,QAAU,EAC3BC,EAASF,EAAQE,OAASpQ,KAAK4F,UAAUsK,EAAQE,QAAU,CAAC,EAAG,EAAG,GACxErF,EAAM/D,YAAchH,KAAK2E,MAAM0L,sBAAsBD,EAAQD,GAAQ,E,CAEzE,MACJ,KAAK,SACD,CACI,MAAM7H,EAAW4H,EAAQ5H,SAAWtI,KAAKoH,WAAW8I,EAAQ5H,UAAY,CAAC,EAAG,EAAG,EAAG,GAC5EgI,EAASJ,EAAQK,QAAUvQ,KAAK4F,UAAUsK,EAAQK,SAAW,CAAC,EAAG,EAAG,GACpEH,EAASF,EAAQE,OAASpQ,KAAK4F,UAAUsK,EAAQE,QAAU,CAAC,EAAG,EAAG,GACxErF,EAAM/D,YAAchH,KAAK2E,MAAM6L,mBAAmBJ,EAAQ9H,EAAUgI,GAAQ,E,CAEhF,MACJ,KAAK,aACD,CACI,MAAMG,EAASP,EAAQO,OAASzQ,KAAK4F,UAAUsK,EAAQO,QAAU,CAAC,EAAG,EAAG,GAClEC,EAASR,EAAQQ,OAAS1Q,KAAK4F,UAAUsK,EAAQQ,QAAU,CAAC,EAAG,EAAG,GAClEP,EAASD,EAAQC,QAAU,EACjCpF,EAAM/D,YAAchH,KAAK2E,MAAMgM,uBAAuBF,EAAQC,EAAQP,GAAQ,E,CAElF,MACJ,KAAK,eAEGpF,EAAM/D,YAAchH,KAAK2E,MAAMiM,2BAA2B,GAE9D,MACJ,KAAK,cACD,CACI,MAAMH,EAASP,EAAQO,OAASzQ,KAAK4F,UAAUsK,EAAQO,QAAU,CAAC,EAAG,EAAG,GAClEC,EAASR,EAAQQ,OAAS1Q,KAAK4F,UAAUsK,EAAQQ,QAAU,CAAC,EAAG,EAAG,GAClEP,EAASD,EAAQC,QAAU,EACjCpF,EAAM/D,YAAchH,KAAK2E,MAAMkM,wBAAwBJ,EAAQC,EAAQP,GAAQ,E,CAEnF,MACJ,KAAK,iBACL,KAAK,UACD,CACI,MAAM9Q,EAAO6Q,EAAQ7Q,KACrB,IAAIA,EAmBA,MAAM,IAAI0N,MAAM,6CAnBV,CACN,MAAM+D,IAAuBZ,EAAQY,mBAC/BC,EAAcvF,GAAQ,iBACtBwF,EAAQ,IAAI5R,EAAgBC,EAAM0R,EAAa1R,aAAI,EAAJA,EAAMiM,YAC3D0F,EAAMxQ,QAAQnB,EAAMyR,GAEpB,MAAMG,EAAYD,EAAMpP,YAAY5B,KAAK2E,OACnCuM,EAAWD,EAAUtQ,OAAS,EAEpC,GAAI6K,GAAQ,iBACRT,EAAM/D,YAAchH,KAAK2E,MAAMwM,0BAA0BF,EAAUrO,WAAYsO,GAAU,OACtF,CACH,MAAME,EAAYJ,EAAMnO,aAAa7C,KAAK2E,OACpC0M,EAAeD,EAAUzQ,OAAS,EACxCoK,EAAM/D,YAAchH,KAAK2E,MAAM2M,oBAAoBL,EAAUrO,WAAYsO,EAAUE,EAAUxO,WAAYyO,GAAc,GACvHL,EAAMvO,WAAWzC,KAAK2E,MAAOyM,E,CAEjCJ,EAAMvO,WAAWzC,KAAK2E,MAAOsM,E,EAKrC,MACJ,QACI,MAAM,IAAIlE,MAAM,2BAG5B,CAEOwE,6BAA6BxG,EAAqByG,GACrD,MAAMC,EAAczR,KAAK2E,MAAM+M,uBAAuB3G,EAAM/D,aAAa,GAAG,GAC5EhH,KAAK2E,MAAMgN,uBAAuB5G,EAAM/D,YAAa,CAACwK,EAAgBC,GAC1E,CAEOG,6BAA6B7G,GAChC,OAAO/K,KAAK2E,MAAM+M,uBAAuB3G,EAAM/D,aAAa,GAAG,EACnE,CAEO6K,0BAA0B9G,EAAqB+G,GAClD,MAAMC,EAAa/R,KAAK2E,MAAM+M,uBAAuB3G,EAAM/D,aAAa,GAAG,GAC3EhH,KAAK2E,MAAMgN,uBAAuB5G,EAAM/D,YAAa,CAAC+K,EAAYD,GACtE,CAEOE,0BAA0BjH,GAC7B,OAAO/K,KAAK2E,MAAM+M,uBAAuB3G,EAAM/D,aAAa,GAAG,EACnE,CAQOiL,YAAYlH,EAAqBmH,G,cACpC,MAAMC,EAAmC,QAAjB,EAAAD,EAASE,gBAAQ,QAAI,GACvCC,EAAwC,QAAvB,EAAAH,EAASG,sBAAc,QAAIF,EAC5CG,EAAkC,QAApB,EAAAJ,EAASI,mBAAW,QAAI,EACtCC,EAA0C,QAAxB,EAAAL,EAASK,uBAAe,QAAI,YAC9CC,EAAgD,QAA3B,EAAAN,EAASM,0BAAkB,QAAI,YAEpDC,EAAa,CAACJ,EAAgBF,EAAiBG,EAAatS,KAAK0S,yBAAyBH,GAAkBvS,KAAK0S,yBAAyBF,IAChJxS,KAAK2E,MAAMgO,qBAAqB5H,EAAM/D,YAAayL,EACvD,CAQOG,WAAW7H,EAAqB8H,GACnC7S,KAAK2E,MAAMmO,oBAAoB/H,EAAM/D,YAAa6L,EACtD,CASOE,WAAWhI,GACd,OAAO/K,KAAK2E,MAAMqO,oBAAoBjI,EAAM/D,aAAa,EAC7D,CAUQ0I,mBAAmBF,GACvB,GAAIA,EAAKtF,OAEL,OADAsF,EAAK7P,qBACE,CAACK,KAAK4F,UAAU4J,EAAKlF,kBAAmBtK,KAAKoH,WAAWoI,EAAKrF,6BAGxE,IAAIpD,EAAc,mBAClB,GAAIyI,EAAKtP,mBACL6G,EAAcyI,EAAKtP,uBAChB,CACH,MAAM+S,EAAIzD,EAAKlH,SACf,0BAAgC2K,EAAE3Q,EAAG2Q,EAAE1Q,EAAG0Q,EAAEzQ,EAAGuE,E,CAGnD,MADkB,CAAC/G,KAAK4F,UAAU4J,EAAKrP,UAAWH,KAAKoH,WAAWL,GAEtE,CASOmM,SAASnI,EAAqBoI,EAAwBC,EAAuB9K,EAAuB+K,GACvG,MAAMC,EAAkB,CACpBF,EAAcpT,KAAK4F,UAAUwN,GAAe,CAAC,EAAG,EAAG,GACnD9K,EAAWtI,KAAKoH,WAAWkB,GAAY,CAAC,EAAG,EAAG,EAAG,GACjD+K,EAAQrT,KAAK4F,UAAUyN,GAAS,CAAC,EAAG,EAAG,IAE3CrT,KAAK2E,MAAM4O,kBAAkBxI,EAAM/D,YAAamM,EAASnM,YAAasM,EAC1E,CAQOE,YAAYzI,EAAqB0I,GACpCzT,KAAK2E,MAAM+O,qBAAqB3I,EAAM/D,YAAayM,EACvD,CASOE,eAAe5I,GAClB,OAAO/K,KAAK2E,MAAMiP,wBAAwB7I,EAAM/D,aAAa,EACjE,CAYO6M,eAAe9I,GAClB,MAAO,CAAC,CACZ,CASO+I,gBAAgBjN,G,MACnB,MAAMkN,GAAoC,QAAzB,EAAAlN,EAAKa,4BAAoB,eAAE/G,QAAS,EAAIkG,EAAKa,qBAAqB,GAAKb,EAAKG,YACvF+D,EAAQ/K,KAAK2E,MAAMwE,iBAAiB4K,EAAS9Q,UAAU,GACvD+Q,EAAchU,KAAK2E,MAAMsP,oCAAoClJ,GAEnE,GAAIiJ,EAAY,IAAMhU,KAAK2E,MAAMsI,OAAOC,UACpC,MAAO,CAAE+D,UAAW,GAAIiD,QAAS,IAGrC,MAAMC,EAAenU,KAAK2E,MAAMyP,yBAAyBJ,EAAY,IAAI,GACnEK,EAAoB,IAAIlS,aAAanC,KAAK2E,MAAMvC,OAAOC,OAAQ8R,EAAa,GAAsB,EAAlBA,EAAa,IAC7FG,EAAkB,IAAIC,YAAYvU,KAAK2E,MAAMvC,OAAOC,OAAQ8R,EAAa,GAAsB,EAAlBA,EAAa,IAI1FlD,EAAYoD,EAAkBG,MAAM,GACpCN,EAAUI,EAAgBE,MAAM,GAEtC,OADAxU,KAAK2E,MAAM8P,yBAAyBT,EAAY,IACzC,CAAE/C,UAAWA,EAAWiD,QAASA,EAC5C,CAUOQ,aAAa3J,GAChB/K,KAAK2E,MAAMgQ,iBAAiB5J,EAAM/D,aAClC+D,EAAM/D,iBAAc5D,CACxB,CAeOwR,eAAeC,EAA+BhO,EAAmBiO,EAAwB5J,EAAwB6J,G,YACpH,MAAMvJ,EAAOqJ,EAAWrJ,KAClB0E,EAAU2E,EAAW3E,QAC3B,IAAK1E,IAAS0E,EAEV,YADA,SAAY,yDAGhB,GAAKrJ,EAAKa,qBAAqB/G,OAAS,QAAuByC,IAAlB8H,GAAiC4J,EAAUpN,qBAAqB/G,OAAS,QAA4ByC,IAAvB2R,EAEvH,YADA,SAAY,0FAIhB,MAAMC,EAAUhV,KAAK2E,MAAMsQ,uBAAuB,GAClDJ,EAAW7N,YAAcgO,EAGzB,MAAME,EAAQlV,KAAKiL,oBAAoBpE,EAAMqE,GAAejI,SACtDkS,EAAQnV,KAAKiL,oBAAoB6J,EAAWC,GAAoB9R,SACtEjD,KAAK2E,MAAMyQ,4BAA4BJ,EAASE,GAChDlV,KAAK2E,MAAM0Q,2BAA2BL,EAASG,GAG/C,MAAMG,EAASpF,EAAQoF,OAAStV,KAAK4F,UAAUsK,EAAQoF,QAAUtV,KAAK4F,UAAU,YAC1E2P,EAAqB,QAAb,EAAArF,EAAQqF,aAAK,QAAI,IAAI,IAAQ,EAAG,EAAG,GAC3CC,EAAYxV,KAAK+E,SAAS,GAC5BmL,EAAQsF,UACRA,EAAUhL,SAAS0F,EAAQsF,WAE3BD,EAAME,eAAeD,GAEzBxV,KAAK2E,MAAM+Q,gCAAgCV,EAASM,EAAQtV,KAAK4F,UAAU2P,GAAQvV,KAAK4F,UAAU4P,IAClG,MAAMG,EAASzF,EAAQyF,OAAS3V,KAAK4F,UAAUsK,EAAQyF,QAAU3V,KAAK4F,UAAU,YAC1EgQ,EAAqB,QAAb,EAAA1F,EAAQ0F,aAAK,QAAI,IAAI,IAAQ,EAAG,EAAG,GAC3CC,EAAY7V,KAAK+E,SAAS,GAQhC,GAPImL,EAAQ2F,UACRA,EAAUrL,SAAS0F,EAAQ2F,WAE3BD,EAAMH,eAAeI,GAEzB7V,KAAK2E,MAAMmR,+BAA+Bd,EAASW,EAAQ3V,KAAK4F,UAAUgQ,GAAQ5V,KAAK4F,UAAUiQ,IAE7FrK,GAAQ,UACRxL,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeC,SAAUjW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeI,SAAUpW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeK,SAAUrW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeM,UAAWtW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeO,UAAWvW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeQ,UAAWxW,KAAK2E,MAAMuR,wBAAwBC,aACnH,GAAI3K,GAAQ,cAAgC,CAC/C,MAAMiL,EAAWvG,EAAQwG,aAAe,EAClCC,EAAS3W,KAAK2E,MAAMqR,eAAeY,gBACzC5W,KAAK2E,MAAMoR,0BAA0Bf,EAAS2B,EAAQ3W,KAAK2E,MAAMuR,wBAAwBW,SACzF7W,KAAK2E,MAAMmS,8BAA8B9B,EAAS2B,EAAQF,GAC1DzW,KAAK2E,MAAMoS,8BAA8B/B,EAAS2B,EAAQF,E,MACvD,GAAIjL,GAAQ,WACfxL,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeC,SAAUjW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeI,SAAUpW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeK,SAAUrW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeO,UAAWvW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeQ,UAAWxW,KAAK2E,MAAMuR,wBAAwBC,aACnH,GAAI3K,GAAQ,eACfxL,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeI,SAAUpW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeK,SAAUrW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeM,UAAWtW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeO,UAAWvW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeQ,UAAWxW,KAAK2E,MAAMuR,wBAAwBC,aACnH,GAAI3K,GAAQ,YACfxL,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeI,SAAUpW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeK,SAAUrW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeO,UAAWvW,KAAK2E,MAAMuR,wBAAwBC,QACtHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeQ,UAAWxW,KAAK2E,MAAMuR,wBAAwBC,aACnH,GAAI3K,GAAQ,qBACfxL,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeC,SAAUjW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeI,SAAUpW,KAAK2E,MAAMuR,wBAAwBC,QACrHnW,KAAK2E,MAAMoR,0BAA0Bf,EAAShV,KAAK2E,MAAMqR,eAAeK,SAAUrW,KAAK2E,MAAMuR,wBAAwBC,YAClH,IAAI3K,GAAQ,aAmBf,MAAM,IAAIuB,MAAM,gCAnB8B,CAC9C,MAAMiK,EAA2DnC,EACjE,IAAK,MAAMoC,KAAKD,EAAWE,OAAQ,CAC/B,MAAMC,EAAOnX,KAAKoX,wBAAwBH,EAAEI,MAClB,IAAX,QAAV,EAAAJ,EAAEK,gBAAQ,SAAK,IAAiC,IAAX,QAAV,EAAAL,EAAEM,gBAAQ,SAAK,GAC3CvX,KAAK2E,MAAMoR,0BAA0Bf,EAASmC,EAAMnX,KAAK2E,MAAMuR,wBAAwBC,SAErE/S,MAAd6T,EAAEK,WACFtX,KAAK2E,MAAMoR,0BAA0Bf,EAASmC,EAAMnX,KAAK2E,MAAMuR,wBAAwBW,SACvF7W,KAAK2E,MAAMmS,8BAA8B9B,EAASmC,EAAMF,EAAEK,WAG5ClU,MAAd6T,EAAEM,WACFvX,KAAK2E,MAAMoR,0BAA0Bf,EAASmC,EAAMnX,KAAK2E,MAAMuR,wBAAwBW,SACvF7W,KAAK2E,MAAMoS,8BAA8B/B,EAASmC,EAAMF,EAAEM,W,GAQ1E,MAAMC,IAAqBtH,EAAQuH,UACnCzX,KAAK2E,MAAM+S,mCAAmC1C,EAASwC,GACvDxX,KAAK2E,MAAMgT,yBAAyB3C,GAAS,EACjD,CAWA4C,cAAc/Q,EAAmBiO,EAAwBD,EAA+B3J,EAAwB6J,GAE5G/U,KAAK4U,eAAeC,EAAYhO,EAAMiO,EAAW5J,EAAe6J,EACpE,CAQO8C,WAAWhD,EAA+BiD,GAC7C9X,KAAK2E,MAAMgT,yBAAyB9C,EAAW7N,YAAa8Q,EAChE,CAQOC,WAAWlD,GACd,OAAO7U,KAAK2E,MAAMqT,yBAAyBnD,EAAW7N,aAAa,EACvE,CAQOiR,qBAAqBpD,EAA+BiD,GACvD9X,KAAK2E,MAAM+S,mCAAmC7C,EAAW7N,YAAa8Q,EAC1E,CAQOI,qBAAqBrD,GACxB,OAAO7U,KAAK2E,MAAMwT,mCAAmCtD,EAAW7N,aAAa,EACjF,CAWOoR,gBAAgBvD,EAA+BwC,EAA6BjF,GAC/EpS,KAAK2E,MAAM0T,8BAA8BxD,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAOjF,EACzG,CAUOkG,gBAAgBzD,EAA+BwC,GAClD,OAAOrX,KAAK2E,MAAM4T,8BAA8B1D,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,EAChH,CAQOmB,YAAY3D,EAA+BwC,EAA6BoB,GAC3EzY,KAAK2E,MAAMoR,0BAA0BlB,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAOrX,KAAK0Y,mBAAmBD,GAC7H,CAUOE,YAAY9D,EAA+BwC,GAC9C,MAAMuB,EAAO5Y,KAAK2E,MAAMkU,0BAA0BhE,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,GAC9G,OAAOrX,KAAK8Y,mBAAmBF,EACnC,CASOG,gBAAgBlE,EAA+BwC,EAA6B2B,GAC/EhZ,KAAK2E,MAAMmS,8BAA8BjC,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAO2B,EACzG,CASOC,gBAAgBpE,EAA+BwC,GAClD,OAAOrX,KAAK2E,MAAMuU,8BAA8BrE,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,EAChH,CASO8B,gBAAgBtE,EAA+BwC,EAA6B2B,GAC/EhZ,KAAK2E,MAAMoS,8BAA8BlC,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAO2B,EACzG,CAUOI,gBAAgBvE,EAA+BwC,GAClD,OAAOrX,KAAK2E,MAAM0U,8BAA8BxE,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,EAChH,CAUOiC,iBAAiBzE,EAA+BwC,EAA6BkC,GAChFvZ,KAAK2E,MAAM6U,+BAA+B3E,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAOrX,KAAKyZ,6BAA6BF,GAC5I,CASOG,iBAAiB7E,EAA+BwC,GACnD,OAAOrX,KAAK2Z,mBAAmB3Z,KAAK2E,MAAMiV,+BAA+B/E,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,GACzI,CAUOwC,mBAAmBhF,EAA+BwC,EAA6ByC,GAClF9Z,KAAK2E,MAAMoV,iCAAiClF,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAOyC,EAC5G,CAUOE,mBAAmBnF,EAA+BwC,GACrD,OAAOrX,KAAK2E,MAAMsV,iCAAiCpF,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,EACnH,CASO6C,qBAAqBrF,EAA+BwC,EAA6B8C,GACpFna,KAAK2E,MAAMyV,mCAAmCvF,EAAW7N,YAAahH,KAAKoX,wBAAwBC,GAAO8C,EAC9G,CAUOE,qBAAqBxF,EAA+BwC,GACvD,OAAOrX,KAAK2E,MAAM2V,mCAAmCzF,EAAW7N,YAAahH,KAAKoX,wBAAwBC,IAAO,EACrH,CAUOkD,kBAAkB1F,GACrB,MAAMG,EAAUH,EAAW7N,YAC3BhH,KAAK2E,MAAMgT,yBAAyB3C,GAAS,GAC7ChV,KAAK2E,MAAM6V,sBAAsBxF,GACjCH,EAAW7N,iBAAc5D,CAC7B,CAYOqX,QAAQC,EAAeC,EAAaC,GAIvCA,EAAOC,MAAMH,EAAMC,GAEnB,MAAMG,EAAQ,CAAC9a,KAAK4F,UAAU8U,GAAO1a,KAAK4F,UAAU+U,GAAK,EALjC,GACC,IAOzB,GAFA3a,KAAK2E,MAAMoW,8BAA8B/a,KAAKqF,MAAOrF,KAAKuF,gBAAiBuV,GAEvE9a,KAAK2E,MAAMqW,6BAA6Bhb,KAAKuF,iBAAiB,GAAK,EAAG,CACtE,MAAM0V,EAAUjb,KAAK2E,MAAMuW,mCAAmClb,KAAKuF,gBAAiB,GAAG,GAEjF4V,EAASF,EAAQ,GAAG,GACpBG,EAAYH,EAAQ,GAAG,GAC7BL,EAAOS,WAAW,CAAE/Y,EAAG8Y,EAAU,GAAI7Y,EAAG6Y,EAAU,GAAI5Y,EAAG4Y,EAAU,IAAM,CAAE9Y,EAAG6Y,EAAO,GAAI5Y,EAAG4Y,EAAO,GAAI3Y,EAAG2Y,EAAO,KACjHP,EAAOU,uBACP,MAAMC,EAAUvb,KAAKgF,QAAQwW,IAAIP,EAAQ,GAAG,GAAG,IAC/CL,EAAO/T,KAAO0U,aAAO,EAAPA,EAAS1U,KACvB+T,EAAOa,UAAYF,aAAO,EAAPA,EAAS/T,K,CAEpC,CAMOkU,uBAAuB7U,GAC1B,MAAM7D,EAAS6D,EAAKG,YAAY/D,SAAS,GACzC,IAAI0Y,EAAa3b,KAAKkF,yBAAyBsW,IAAIxY,GAKnD,OAJK2Y,IACDA,EAAa,IAAI,KACjB3b,KAAKkF,yBAAyBd,IAAIpB,EAAQ2Y,IAEvCA,CACX,CAOOC,4BAA4B/U,EAAmBgV,GAElD,MAAMC,EAAgB9b,KAAK2E,MAAMoX,UAAUC,kBAAkBC,MAAQjc,KAAK2E,MAAMoX,UAAUG,oBAAoBD,MAAQjc,KAAK2E,MAAMoX,UAAUI,mBAAmBF,MAC1JpV,EAAKa,sBAAwBb,EAAKa,qBAAqB/G,OACvDkG,EAAKa,qBAAqB/F,SAASqB,IAC/BhD,KAAK2E,MAAMmH,qBAAqB9I,EAAOC,SAAU4Y,EAAUC,EAAgB,EAAE,IAE1EjV,EAAKG,aACZhH,KAAK2E,MAAMmH,qBAAqBjF,EAAKG,YAAY/D,SAAU4Y,EAAUC,EAAgB,EAE7F,CAKQpV,oBACJ,IAAI0V,EAAepc,KAAK2E,MAAM0X,4BAA4Brc,KAAKqF,OAAO,GACtE,MAAMiX,EAAQ,IAAI3Y,EACZ4Y,EAAYC,OAAOxc,KAAKqF,OAC9B,KAAO+W,GAAc,CACjBzY,EAAe8Y,UAAUzc,KAAK2E,MAAMvC,OAAOC,OAAQ+Z,EAAcE,GACjEA,EAAMzY,WAAW1D,SAASuc,cAAcJ,EAAM1Y,WAAWzD,SAAUH,KAAK+E,SAAS,IACjF,MAAM0R,EAAW,QAAYzW,KAAK+E,SAAS,GAAIuX,EAAM1Y,WAAWF,QAC1DiZ,EAAY3c,KAAKgF,QAAQwW,IAAIc,EAAM1Y,WAAWZ,QAC9C4Z,EAAY5c,KAAKgF,QAAQwW,IAAIc,EAAMzY,WAAWb,QAC9C6Z,EAAgB,CAClBC,SAAUH,EAAU9V,KACpBkW,cAAeJ,EAAUnV,MACzBwV,gBAAiBJ,EAAU/V,KAC3BoW,qBAAsBL,EAAUpV,MAChC0V,MAAOZ,EAAM1Y,WAAWzD,SACxBsW,SAAUA,EACV7H,QAAS0N,EAAMxY,eACfJ,OAAQ4Y,EAAM1Y,WAAWF,QAI7B,GAFA1D,KAAKmF,sBAAsBgY,gBAAgBN,GAEvC7c,KAAKkF,yBAAyBkY,KAAM,CACpC,MAAMC,EAAcrd,KAAKkF,yBAAyBsW,IAAIc,EAAM1Y,WAAWZ,QACjEsa,EAActd,KAAKkF,yBAAyBsW,IAAIc,EAAMzY,WAAWb,QAEnEqa,EACAA,EAAYF,gBAAgBN,GACrBS,IAGPT,EAAcC,SAAWF,EAAU/V,KACnCgW,EAAcE,cAAgBH,EAAUpV,MACxCqV,EAAcG,gBAAkBL,EAAU9V,KAC1CgW,EAAcI,qBAAuBN,EAAUnV,MAC/CqV,EAAcnZ,OAAS4Y,EAAMzY,WAAWH,OACxC4Z,EAAYH,gBAAgBN,G,CAIpCT,EAAepc,KAAK2E,MAAM4Y,+BAA+BhB,EAAWH,E,CAE5E,CAKWoB,gBACP,OAAOxd,KAAK2E,MAAM8Y,sBAAsBzd,KAAKqF,OAAO,EACxD,CAKOqY,UACH1d,KAAK2E,MAAMgZ,0BAA0B3d,KAAKuF,iBAC1CvF,KAAKuF,gBAAkB9B,OAAO,GAC9BzD,KAAK2E,MAAMiZ,iBAAiB5d,KAAKqF,OACjCrF,KAAKqF,WAAQjC,CACjB,CAEQqL,aAAaxN,EAAQ4c,GACzBA,EAAKzZ,IAAInD,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAC3B,CAEQ2E,UAAU3E,GACd,MAAO,CAACA,EAAE6c,GAAI7c,EAAE8c,GAAI9c,EAAE+c,GAC1B,CAEQ5W,WAAW6W,GACf,MAAO,CAACA,EAAEH,GAAIG,EAAEF,GAAIE,EAAED,GAAIC,EAAEC,GAChC,CAEQzE,6BAA6BF,GACjC,OAAQA,GACJ,KAAK,cACD,OAAOvZ,KAAK2E,MAAMwZ,oBAAoBC,SAC1C,KAAK,cACD,OAAOpe,KAAK2E,MAAMwZ,oBAAoBE,SAE9C,OAAOre,KAAK2E,MAAMwZ,oBAAoBG,IAC1C,CAEQ3E,mBAAmBJ,GACvB,OAAQA,GACJ,KAAKvZ,KAAK2E,MAAMwZ,oBAAoBC,SAChC,OAAO,cACX,KAAKpe,KAAK2E,MAAMwZ,oBAAoBE,SAChC,OAAO,cAEf,OAAO,SACX,CAEQ3L,yBAAyB6L,GAC7B,OAAQA,GACJ,KAAK,mBACD,OAAOve,KAAK2E,MAAM6Z,gBAAgBC,eACtC,KAAK,YACD,OAAOze,KAAK2E,MAAM6Z,gBAAgBE,QACtC,KAAK,YACD,OAAO1e,KAAK2E,MAAM6Z,gBAAgBG,QACtC,KAAK,oBACD,OAAO3e,KAAK2E,MAAM6Z,gBAAgBI,gBACtC,KAAK,aACD,OAAO5e,KAAK2E,MAAM6Z,gBAAgBK,SAE9C,CAEQzH,wBAAwBD,GAC5B,OAAQA,GACJ,KAAK,cACD,OAAOnX,KAAK2E,MAAMqR,eAAeC,SACrC,KAAK,cACD,OAAOjW,KAAK2E,MAAMqR,eAAeI,SACrC,KAAK,cACD,OAAOpW,KAAK2E,MAAMqR,eAAeK,SACrC,KAAK,eACD,OAAOrW,KAAK2E,MAAMqR,eAAeM,UACrC,KAAK,eACD,OAAOtW,KAAK2E,MAAMqR,eAAeO,UACrC,KAAK,eACD,OAAOvW,KAAK2E,MAAMqR,eAAeQ,UACrC,KAAK,qBACD,OAAOxW,KAAK2E,MAAMqR,eAAeY,gBAE7C,CAEQkC,mBAAmBF,GACvB,OAAQA,GACJ,KAAK5Y,KAAK2E,MAAMuR,wBAAwB4I,KACpC,OAAO,UACX,KAAK9e,KAAK2E,MAAMuR,wBAAwBW,QACpC,OAAO,aACX,KAAK7W,KAAK2E,MAAMuR,wBAAwBC,OACpC,OAAO,YAGf,OAAO,SACX,CAEQuC,mBAAmBE,GACvB,OAAQA,GACJ,KAAK,UACD,OAAO5Y,KAAK2E,MAAMuR,wBAAwB4I,KAC9C,KAAK,aACD,OAAO9e,KAAK2E,MAAMuR,wBAAwBW,QAC9C,KAAK,YACD,OAAO7W,KAAK2E,MAAMuR,wBAAwBC,OAEtD,E,wDCxxDG,MAAM4I,EAoDTC,YAAY3Y,EAA8BS,EAA+BmY,EAAuB1f,GAC5F,GAjDG,KAAAyH,iBAAmB5D,EAInB,KAAAsE,qBAAmC,GAYlC,KAAAwX,qBAA+B,EASvC,KAAA/Y,gBAA0B,GAwBjB5G,EACD,OAEJ,MAAM4f,EAAgB5f,EAAM6f,mBAC5B,IAAKD,EACD,MAAM,IAAIpS,MAAM,gCAGpB,GADA/M,KAAKqf,eAAiBF,EACkB,GAApCA,EAAcxY,mBACd,MAAM,IAAIoG,MAAM,oDAEpB,MAAMuS,EAAgBH,EAAcI,mBACpC,IAAKD,EACD,MAAM,IAAIvS,MAAM,gCAGpB/M,KAAKwf,eAAiBF,EACjBjZ,EAAcnG,qBACfmG,EAAcnG,mBAAqB,qBAA2BmG,EAAciC,SAAShG,EAAG+D,EAAciC,SAAS/F,EAAG8D,EAAciC,SAAS9F,IAG7IxC,KAAKuH,YAAc0X,EAGnB,MAAMxd,EAAI4E,EACN5E,EAAEge,iBACFzf,KAAKwf,eAAe1X,kBAAkB9H,KAAM8G,EAAYrF,GAGxDzB,KAAKwf,eAAe5Y,SAAS5G,KAAM8G,EAAYT,EAAciE,iBAAkBjE,EAAc8D,4BAEjGnK,KAAKqG,cAAgBA,EACrBA,EAAc3E,YAAc1B,KAC5Bmf,EAAcO,QAAQ1f,MAEtBA,KAAK2f,qBAAuBtZ,EAAcuZ,oBAAoBC,KAAI,KAC9D7f,KAAK0d,SAAS,GAEtB,CAMOoC,eACH,MAAO,aACX,CAOOC,MAAM1Z,GACT,MAAM2Z,EAAa,IAAIjB,EAAY1Y,EAAerG,KAAKiJ,gBAAiBjJ,KAAKuH,YAAavH,KAAKqG,cAAciF,YAE7G,OADA0U,EAAWjV,MAAQ/K,KAAK+K,MACjBiV,CACX,CAKOjX,sBACH,MAAMtH,EAAIzB,KAAKqG,cACX5E,EAAEge,kBACFzf,KAAKwf,eAAezW,oBAAoB/I,KAAMyB,EAEtD,CAKWgO,mBACP,OAAOzP,KAAK0H,qBAAqB/G,MACrC,CASWoK,UAAMA,GACb/K,KAAKwf,eAAe1U,SAAS9K,KAAM+K,EACvC,CAWWA,YACP,OAAO/K,KAAKwf,eAAerU,SAASnL,KACxC,CAUO0L,aAAaC,EAAmBT,GACnClL,KAAKwf,eAAe9T,aAAa1L,KAAM2L,EAAWT,EACtD,CAYOa,aAAab,GAChB,OAAOlL,KAAKwf,eAAezT,aAAa/L,KAAMkL,EAClD,CAKO2B,cAAc/F,EAA+BoE,GAChDlL,KAAKwf,eAAe3S,cAAc7M,KAAM8G,EAAYoE,EACxD,CAKOjC,cAAciC,GACjB,OAAOlL,KAAKwf,eAAevW,cAAcjJ,KAAMkL,EACnD,CASOmC,sBAAsBnC,GACzB,OAAOlL,KAAKwf,eAAenS,sBAAsBrN,KAAMkL,EAC3D,CAWOqC,kBAAkBlB,EAAkCnB,GACvDlL,KAAKwf,eAAejS,kBAAkBvN,KAAMqM,EAAWnB,EAC3D,CAYOsC,kBAAkBtC,GACrB,OAAOlL,KAAKwf,eAAehS,kBAAkBxN,KAAMkL,EACvD,CAWOwC,iBAAiBC,EAAiBzC,GACrClL,KAAKwf,eAAe9R,iBAAiB1N,KAAM2N,EAASzC,EACxD,CAUO2C,iBAAiB3C,GACpB,OAAOlL,KAAKwf,eAAe3R,iBAAiB7N,KAAMkL,EACtD,CAUO6C,kBAAkBJ,EAAiBzC,GACtClL,KAAKwf,eAAezR,kBAAkB/N,KAAM2N,EAASzC,EACzD,CAWO+C,kBAAkB/C,GACrB,OAAOlL,KAAKwf,eAAevR,kBAAkBjO,KAAMkL,EACvD,CAWOiD,kBAAkBC,EAAiBlD,GACtClL,KAAKwf,eAAerR,kBAAkBnO,KAAMoO,EAAQlD,EACxD,CAQOoD,uBAAuBF,EAAiBlD,GAC3C,OAAOlL,KAAKwf,eAAelR,uBAAuBtO,KAAMoO,EAAQlD,EACpE,CAUOgE,mBAAmBC,EAAiBjE,GACvClL,KAAKwf,eAAetQ,mBAAmBlP,KAAMmP,EAAQjE,EACzD,CASOmE,wBAAwBF,EAAiBjE,GAC5C,OAAOlL,KAAKwf,eAAenQ,wBAAwBrP,KAAMmP,EAAQjE,EACrE,CAYOyD,aAAaC,EAAkBC,EAAmB3D,GACrDlL,KAAKwf,eAAe7Q,aAAa3O,KAAM4O,EAASC,EAAU3D,EAC9D,CAYO6D,WAAWC,EAAgBH,EAAmB3D,GACjDlL,KAAKwf,eAAezQ,WAAW/O,KAAMgP,EAAOH,EAAU3D,EAC1D,CASO+U,cACH,OAAOjgB,KAAKwf,eAAe1L,gBAAgB9T,KAC/C,CAMO0b,yBACH,OAAO1b,KAAKwf,eAAe9D,uBAAuB1b,KACtD,CAMO4b,4BAA4BC,GAC/B7b,KAAKkf,oBAAsBrD,EAC3B7b,KAAKwf,eAAe5D,4BAA4B5b,KAAM6b,EAC1D,CAOOqE,qBAAqBhV,GACxB,MAAMiV,EAAM,IAAI,IAChB,OAAOngB,KAAKogB,0BAA0BD,EAAKjV,EAC/C,CAQOkV,0BAA0BD,EAAcjV,G,MAC3C,IAA6B,QAAzB,EAAAlL,KAAK0H,4BAAoB,eAAE/G,QAAS,EAAG,CACvC,MAAM6G,EAAQ0D,GAAiB,EACzBjD,EAAcjI,KAAKqG,cAAuB2B,yBAAyBC,WACrEA,GACAkY,EAAI/b,IAAI6D,EAAmB,GAART,EAAa,IAAKS,EAAmB,GAART,EAAa,IAAKS,EAAmB,GAART,EAAa,I,MAG9F2Y,EAAI3V,SAASxK,KAAKqG,cAAclG,UAEpC,OAAOggB,CACX,CAWOvI,cAAc9C,EAAwBD,EAA+B3J,EAAwB6J,GAChG/U,KAAKwf,eAAe5H,cAAc5X,KAAM8U,EAAWD,EAAY3J,EAAe6J,EAClF,CAWOsL,aAAaC,EAAYC,EAAwBC,EAAqBC,EAAsBC,EAA6BC,GAC5H,MAAMthB,EAAOW,KAAKqG,cAElB,GAAIhH,EAAKa,mBACL,GAAIwgB,EAAgB,CAChB,MAAME,EAAW,mBACjBN,EAAKO,2BAA2B,UAAaN,EAAUK,GACvDA,EAASE,cAAcJ,EAAgBrhB,EAAKa,mB,MAE5CogB,EAAKO,2BAA2B,UAAaN,EAAUlhB,EAAKa,oBAIpE,MAAMgB,EAAM,gBACN6f,EAAU,gBAEXJ,KACDA,EAAW,iBACFre,EAAI,EACbqe,EAASpe,EAAI,EACboe,EAASne,EAAI,GAGjB8d,EAAKU,kBAAkBL,EAAUJ,EAAUQ,GAC3CT,EAAKW,yBAAyBV,EAAUrf,GAEpC,MAACuf,GAAsDD,IACvDC,EAAcD,EAAW7f,UAGzB8f,UACAvf,EAAIoB,GAAKye,EAAQze,EAAIme,EACrBvf,EAAIqB,GAAKwe,EAAQxe,EAAIke,EACrBvf,EAAIsB,GAAKue,EAAQve,EAAIie,GAGzBphB,EAAK6hB,oBAAoBhgB,EAC7B,CAMOigB,wBAAwBC,G,MAC3B,IAA6B,QAAzB,EAAAphB,KAAK0H,4BAAoB,eAAE/G,QAAS,EACpC,IAAK,IAAIW,EAAI,EAAGA,EAAItB,KAAK0H,qBAAqB/G,OAAQW,IAClD8f,EAASphB,KAAMsB,QAGnB8f,EAASphB,UAAMoD,EAEvB,CAOOuM,iBAAiBC,EAAgB1E,GACpClL,KAAKwf,eAAe7P,iBAAiB3P,KAAM4P,EAAQ1E,EACvD,CAOO4E,iBAAiB5E,GACpB,OAAOlL,KAAKwf,eAAe1P,iBAAiB9P,KAAMkL,EACtD,CAOOwS,UAEC1d,KAAKkf,qBACLlf,KAAK4b,6BAA4B,GAEjC5b,KAAK2f,uBACL3f,KAAKqG,cAAcuZ,oBAAoByB,OAAOrhB,KAAK2f,sBACnD3f,KAAK2f,qBAAuB,MAEhC3f,KAAKqf,eAAe5X,WAAWzH,MAC/BA,KAAKwf,eAAe/X,WAAWzH,MAC/BA,KAAKwf,eAAexP,YAAYhQ,MAChCA,KAAKgH,YAAc,KACnBhH,KAAK0H,qBAAqB/G,OAAS,CACvC,E,iBCzhBJ,IAAY2gB,E,iBAAZ,SAAYA,GAKR,uCAKA,yBAIA,yBAIA,yCAKA,0BACH,CAxBD,CAAYA,IAAAA,EAA0B,I,yHC2B/B,MAAMC,EA2BTvC,YAAY9O,EAA6B3Q,G,MACrC,GAxBG,KAAAyH,iBAAmB5D,GAwBjB7D,EACD,OAEJ,MAAM4f,EAAgB5f,EAAM6f,mBAC5B,IAAKD,EACD,MAAM,IAAIpS,MAAM,gCAEpB,GAAwC,GAApCoS,EAAcxY,mBACd,MAAM,IAAIoG,MAAM,oDAEpB,MAAMuS,EAAgBH,EAAcI,mBACpC,IAAKD,EACD,MAAM,IAAIvS,MAAM,gCAIpB,GAFA/M,KAAKwf,eAAiBF,OAEKlc,IAAvB8M,EAAQvH,YAAmD,OAAvBuH,EAAQvH,WAC5C3I,KAAKgH,YAAckJ,EAAQvH,WAC3B3I,KAAKwhB,MAAQxhB,KAAKwf,eAAejU,aAAavL,WAC3C,QAAqBoD,IAAjB8M,EAAQ1E,MAAuC,OAAjB0E,EAAQ1E,KAAe,CAC5DxL,KAAKwhB,MAAQtR,EAAQ1E,KACrB,MAAMiW,EAA+B,QAAlB,EAAAvR,EAAQuR,kBAAU,QAAI,CAAC,EAC1CzhB,KAAKwf,eAAevP,UAAUjQ,KAAMkQ,EAAQ1E,KAAMiW,E,CAE1D,CAMO3B,eACH,MAAO,cACX,CAKWtU,WACP,OAAOxL,KAAKwhB,KAChB,CAUWE,yBAAqBlQ,GAC5BxR,KAAKwf,eAAejO,6BAA6BvR,KAAMwR,EAC3D,CAMWkQ,2BACP,OAAO1hB,KAAKwf,eAAe5N,6BAA6B5R,KAC5D,CAiBW2hB,sBAAkB7P,GACzB9R,KAAKwf,eAAe3N,0BAA0B7R,KAAM8R,EACxD,CAMW6P,wBACP,OAAO3hB,KAAKwf,eAAexN,0BAA0BhS,KACzD,CAKWkS,aAASA,GAChBlS,KAAKwf,eAAevN,YAAYjS,KAAMkS,GACtClS,KAAK4hB,UAAY1P,CACrB,CAMWA,eACP,OAAOlS,KAAK4hB,SAChB,CAMW/O,YAAQA,GACf7S,KAAKwf,eAAe5M,WAAW5S,KAAM6S,EACzC,CAKWA,cACP,OAAO7S,KAAKwf,eAAezM,WAAW/S,KAC1C,CAWO6hB,mBAAmBC,EAAgC3O,EAAwB4O,GAC9E,MAAMC,EAAeD,EAAepiB,oBAAmB,GACjDsiB,EAAgBH,EAAgBniB,oBAAmB,GACnDuiB,EAAgB,eACtBF,EAAalB,cAAc,YAAcmB,GAAgBC,GACzD,MAAM9O,EAAc,gBACd9K,EAAW,mBACX+K,EAAQ,gBACd6O,EAAcniB,UAAUsT,EAAO/K,EAAU8K,GACzCpT,KAAKwf,eAAetM,SAASlT,KAAMmT,EAAUC,EAAa9K,EAAU+K,EACxE,CASOH,SAASC,EAAwBC,EAAuB9K,EAAuB+K,GAClFrT,KAAKwf,eAAetM,SAASlT,KAAMmT,EAAUC,EAAa9K,EAAU+K,EACxE,CAMOG,YAAYC,GACfzT,KAAKwf,eAAehM,YAAYxT,KAAMyT,EAC1C,CAMOE,iBACH,OAAO3T,KAAKwf,eAAe7L,eAAe3T,KAC9C,CAKO6T,iBACH,OAAO7T,KAAKwf,eAAe3L,eAAe7T,KAC9C,CAKO0d,UACH1d,KAAKwf,eAAe9K,aAAa1U,KACrC,EAMG,MAAMmiB,UAA2BZ,EAOpCvC,YAAY5O,EAAiBD,EAAgB5Q,GACzC6iB,MAAM,CAAE5W,KAAM,YAAyBiW,WAAY,CAAErR,OAAQA,EAAQD,OAAQA,IAAY5Q,EAC7F,CAOAwE,gBAAgB1E,GACZ,MAAMgjB,EAAShjB,EAAKijB,kBACdC,EAAcF,EAAOG,eAAepS,OACpCqS,EAAKJ,EAAOK,YAAYC,WACxBxS,EAASyS,KAAKC,IAAIJ,EAAGngB,EAAGmgB,EAAGlgB,EAAGkgB,EAAGjgB,GACvC,OAAO,IAAI2f,EAAmBI,EAAapS,EAAQ9Q,EAAKiM,WAC5D,EAMG,MAAMwX,UAA4BvB,EAQrCvC,YAAYvO,EAAiBC,EAAiBP,EAAgB5Q,GAC1D6iB,MAAM,CAAE5W,KAAM,aAA0BiW,WAAY,CAAEhR,OAAQA,EAAQC,OAAQA,EAAQP,OAAQA,IAAY5Q,EAC9G,CAOAwE,gBAAgB1E,GACZ,MAAM0jB,EAAc1jB,EAAKijB,kBACnBnS,EAAS4S,EAAYL,YAAYC,WAAWrgB,EAC5C0gB,EAAkB,IAAI,IAAQ,EAAGD,EAAYL,YAAYC,WAAWpgB,EAAI4N,EAAQ,GAChFM,EAASsS,EAAYL,YAAYtS,OAAOyP,IAAImD,GAC5CtS,EAASqS,EAAYL,YAAYtS,OAAO6S,SAASD,GACvD,OAAO,IAAIF,EAAoBrS,EAAQC,EAAQP,EAAQ9Q,EAAKiM,WAChE,EAMG,MAAM4X,UAA6B3B,EAQtCvC,YAAYvO,EAAiBC,EAAiBP,EAAgB5Q,GAC1D6iB,MAAM,CAAE5W,KAAM,cAA2BiW,WAAY,CAAEhR,OAAQA,EAAQC,OAAQA,EAAQP,OAAQA,IAAY5Q,EAC/G,CAOAwE,gBAAgB1E,GACZ,MAAM0jB,EAAc1jB,EAAKijB,kBACnBnS,EAAS4S,EAAYL,YAAYC,WAAWrgB,EAC5C0gB,EAAkB,IAAI,IAAQ,EAAGD,EAAYL,YAAYC,WAAWpgB,EAAG,GACvEkO,EAASsS,EAAYL,YAAYtS,OAAOyP,IAAImD,GAC5CtS,EAASqS,EAAYL,YAAYtS,OAAO6S,SAASD,GACvD,OAAO,IAAIE,EAAqBzS,EAAQC,EAAQP,EAAQ9Q,EAAKiM,WACjE,EAMG,MAAM6X,UAAwB5B,EAQjCvC,YAAY5O,EAAiB9H,EAAsBiI,EAAkBhR,GACjE6iB,MAAM,CAAE5W,KAAM,SAAsBiW,WAAY,CAAErR,OAAQA,EAAQ9H,SAAUA,EAAUiI,QAASA,IAAahR,EAChH,CAOAwE,gBAAgB1E,GACZ,MAAMgjB,EAAShjB,EAAKijB,kBACdC,EAAcF,EAAOK,YAAYtS,OACjCG,EAAU8R,EAAOK,YAAYC,WAAWtP,MAAM,GACpD,OAAO,IAAI8P,EAAgBZ,EAAa,gBAAuBhS,EAASlR,EAAKiM,WACjF,EAMG,MAAM8X,UAA+B7B,EAMxCvC,YAAY3f,EAAYE,GACpB6iB,MAAM,CAAE5W,KAAM,iBAA8BiW,WAAY,CAAEpiB,KAAMA,IAAUE,EAC9E,EAMG,MAAM8jB,UAAyB9B,EAMlCvC,YAAY3f,EAAYE,GACpB6iB,MAAM,CAAE5W,KAAM,UAAuBiW,WAAY,CAAEpiB,KAAMA,IAAUE,EACvE,EAMG,MAAM+jB,UAA8B/B,EAKvCvC,YAAYzf,GACR6iB,MAAM,CAAE5W,KAAM,eAA4BiW,WAAY,CAAC,GAAKliB,EAChE,E","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/IPhysicsEnginePlugin.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/Plugins/havokPlugin.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/physicsBody.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/physicsMaterial.ts","webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Physics/v2/physicsShape.ts"],"sourcesContent":["import type { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observable } from \"core/Misc/observable\";\r\n\r\n/** How a specific axis can be constrained */\r\nexport enum PhysicsConstraintAxisLimitMode {\r\n    /*\r\n     * The axis is not restricted at all\r\n     */\r\n    FREE,\r\n    /*\r\n     * The axis has a minimum/maximum limit\r\n     */\r\n    LIMITED,\r\n    /*\r\n     * The axis allows no relative movement of the pivots\r\n     */\r\n    LOCKED,\r\n}\r\n\r\n/** The constraint specific axis to use when setting Friction, `ConstraintAxisLimitMode`, max force, ... */\r\nexport enum PhysicsConstraintAxis {\r\n    /*\r\n     * Translation along the primary axis of the constraint (i.e. the\r\n     * direction specified by PhysicsConstraintParameters.axisA/axisB)\r\n     */\r\n    LINEAR_X,\r\n    /*\r\n     * Translation along the second axis of the constraint (i.e. the\r\n     * direction specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\r\n     */\r\n    LINEAR_Y,\r\n    /*\r\n     * Translation along the third axis of the constraint. This axis is\r\n     * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\r\n     */\r\n    LINEAR_Z,\r\n    /*\r\n     * Rotation around the primary axis of the constraint (i.e. the\r\n     * axis specified by PhysicsConstraintParameters.axisA/axisB)\r\n     */\r\n    ANGULAR_X,\r\n    /*\r\n     * Rotation around the second axis of the constraint (i.e. the\r\n     * axis specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\r\n     */\r\n    ANGULAR_Y,\r\n    /*\r\n     * Rotation around the third axis of the constraint. This axis is\r\n     * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\r\n     */\r\n    ANGULAR_Z,\r\n    /*\r\n     * A 3D distance limit; similar to specifying the LINEAR_X/Y/Z axes\r\n     * individually, but the distance calculation uses all three axes\r\n     * simultaneously, instead of individually.\r\n     */\r\n    LINEAR_DISTANCE,\r\n}\r\n\r\n/** Type of Constraint */\r\nexport enum PhysicsConstraintType {\r\n    /**\r\n     * A ball and socket constraint will attempt to line up the pivot\r\n     * positions in each body, and have no restrictions on rotation\r\n     */\r\n    BALL_AND_SOCKET = 1,\r\n    /**\r\n     * A distance constraint will attempt to keep the pivot locations\r\n     * within a specified distance.\r\n     */\r\n    DISTANCE = 2,\r\n    /**\r\n     * A hinge constraint will keep the pivot positions aligned as well\r\n     * as two angular axes. The remaining angular axis will be free to rotate.\r\n     */\r\n    HINGE = 3,\r\n    /**\r\n     * A slider constraint allows bodies to translate along one axis and\r\n     * rotate about the same axis. The remaining two axes are locked in\r\n     * place\r\n     */\r\n    SLIDER = 4,\r\n    /**\r\n     * A lock constraint will attempt to keep the pivots completely lined\r\n     * up between both bodies, allowing no relative movement.\r\n     */\r\n    LOCK = 5,\r\n    /*\r\n     * A prismatic will lock the rotations of the bodies, and allow translation\r\n     * only along one axis\r\n     */\r\n    PRISMATIC = 6,\r\n    /*\r\n     * A generic constraint; this starts with no limits on how the bodies can\r\n     * move relative to each other, but limits can be added via the PhysicsConstraint\r\n     * interfaces. This can be used to specify a large variety of constraints\r\n     */\r\n    SIX_DOF = 7,\r\n}\r\n\r\n/** Type of Shape */\r\nexport enum PhysicsShapeType {\r\n    SPHERE,\r\n    CAPSULE,\r\n    CYLINDER,\r\n    BOX,\r\n    CONVEX_HULL,\r\n    CONTAINER,\r\n    MESH,\r\n    HEIGHTFIELD,\r\n}\r\n\r\n/** Optional motor which attempts to move a body at a specific velocity, or at a specific position */\r\nexport enum PhysicsConstraintMotorType {\r\n    NONE,\r\n    VELOCITY,\r\n    POSITION,\r\n}\r\n\r\n/**\r\n * Collision object that is the parameter when notification for collision fires.\r\n */\r\nexport interface IPhysicsCollisionEvent {\r\n    /**\r\n     * 1st physics body that collided\r\n     */\r\n    collider: PhysicsBody;\r\n    /**\r\n     * 2nd physics body that collided\r\n     */\r\n    collidedAgainst: PhysicsBody;\r\n    /**\r\n     * index in instances array for the collider\r\n     */\r\n    colliderIndex: number;\r\n    /**\r\n     * index in instances array for the collidedAgainst\r\n     */\r\n    collidedAgainstIndex: number;\r\n    /**\r\n     * World position where the collision occured\r\n     */\r\n    point: Nullable<Vector3>;\r\n    /**\r\n     * Penetration distance\r\n     */\r\n    distance: number;\r\n    /**\r\n     * Impulse value computed by the solver response\r\n     */\r\n    impulse: number;\r\n    /**\r\n     * Collision world normal direction\r\n     */\r\n    normal: Nullable<Vector3>;\r\n}\r\n\r\n/**\r\n * Parameters used to describe the Shape\r\n */\r\nexport interface PhysicsShapeParameters {\r\n    /**\r\n     * Shape center position\r\n     */\r\n    center?: Vector3;\r\n    /**\r\n     * Radius for cylinder, shape and capsule\r\n     */\r\n    radius?: number;\r\n    /**\r\n     * First point position that defines the cylinder or capsule\r\n     */\r\n    pointA?: Vector3;\r\n    /**\r\n     * Second point position that defines the cylinder or capsule\r\n     */\r\n    pointB?: Vector3;\r\n    /**\r\n     * Shape orientation\r\n     */\r\n    rotation?: Quaternion;\r\n    /**\r\n     * Dimesion extention for the box\r\n     */\r\n    extents?: Vector3;\r\n    /**\r\n     * Mesh used for Mesh shape or convex hull. It can be different than the mesh the body is attached to.\r\n     */\r\n    mesh?: Mesh;\r\n    /**\r\n     * Use children hierarchy\r\n     */\r\n    includeChildMeshes?: boolean;\r\n}\r\n\r\n/**\r\n * Parameters used to describe a Constraint\r\n */\r\nexport interface PhysicsConstraintParameters {\r\n    /**\r\n     * Location of the constraint pivot in the space of first body\r\n     */\r\n    pivotA?: Vector3;\r\n    /**\r\n     * Location of the constraint pivot in the space of the second body\r\n     */\r\n    pivotB?: Vector3;\r\n    /**\r\n     * An axis in the space of the first body which determines how\r\n     * distances/angles are measured for LINEAR_X/ANGULAR_X limits.\r\n     */\r\n    axisA?: Vector3;\r\n    /**\r\n     * An axis in the space of the second body which determines how\r\n     * distances/angles are measured for LINEAR_X/ANGULAR_X limits.\r\n     */\r\n    axisB?: Vector3;\r\n\r\n    /**\r\n     * An axis in the space of the first body which determines how\r\n     * distances/angles are measured for LINEAR_Y/ANGULAR_Y limits.\r\n     */\r\n    perpAxisA?: Vector3;\r\n\r\n    /**\r\n     * An axis in the space of the second body which determines how\r\n     * distances/angles are measured for LINEAR_Y/ANGULAR_Y limits.\r\n     */\r\n    perpAxisB?: Vector3;\r\n\r\n    /**\r\n     * The maximum distance that can seperate the two pivots.\r\n     * Only used for DISTANCE constraints\r\n     */\r\n    maxDistance?: number;\r\n\r\n    /**\r\n     * Determines if the connected bodies should collide. Generally,\r\n     * it is preferable to set this to false, especially if the constraint\r\n     * positions the bodies so that they overlap. Otherwise, the constraint\r\n     * will \"fight\" the collision detection and may cause jitter.\r\n     */\r\n    collision?: boolean;\r\n}\r\n\r\n/**\r\n * Parameters used to describe mass and inertia of the Physics Body\r\n */\r\nexport interface PhysicsMassProperties {\r\n    /**\r\n     * The center of mass, in local space. This is The\r\n     * point the body will rotate around when applying\r\n     * an angular velocity.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    centerOfMass?: Vector3;\r\n    /**\r\n     * The total mass of this object, in kilograms. This\r\n     * affects how easy it is to move the body. A value\r\n     * of zero will be used as an infinite mass.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    mass?: number;\r\n    /**\r\n     * The principal moments of inertia of this object\r\n     * for a unit mass. This determines how easy it is\r\n     * for the body to rotate. A value of zero on any\r\n     * axis will be used as infinite interia about that\r\n     * axis.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertia?: Vector3;\r\n    /**\r\n     * The rotation rotating from inertia major axis space\r\n     * to parent space (i.e., the rotation which, when\r\n     * applied to the 3x3 inertia tensor causes the inertia\r\n     * tensor to become a diagonal matrix). This determines\r\n     * how the values of inertia are aligned with the parent\r\n     * object.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertiaOrientation?: Quaternion;\r\n}\r\n\r\n/**\r\n * Indicates how the body will behave.\r\n */\r\nexport enum PhysicsMotionType {\r\n    STATIC,\r\n    ANIMATED,\r\n    DYNAMIC,\r\n}\r\n\r\n/** @internal */\r\nexport interface IPhysicsEnginePluginV2 {\r\n    /**\r\n     * Physics plugin world instance\r\n     */\r\n    world: any;\r\n    /**\r\n     * Physics plugin name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Collision observable\r\n     */\r\n    onCollisionObservable: Observable<IPhysicsCollisionEvent>;\r\n\r\n    setGravity(gravity: Vector3): void;\r\n    setTimeStep(timeStep: number): void;\r\n    getTimeStep(): number;\r\n    executeStep(delta: number, bodies: Array<PhysicsBody>): void; //not forgetting pre and post events\r\n    getPluginVersion(): number;\r\n\r\n    // body\r\n    initBody(body: PhysicsBody, motionType: PhysicsMotionType, position: Vector3, orientation: Quaternion): void;\r\n    initBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, mesh: Mesh): void;\r\n    updateBodyInstances(body: PhysicsBody, mesh: Mesh): void;\r\n    removeBody(body: PhysicsBody): void;\r\n    sync(body: PhysicsBody): void;\r\n    syncTransform(body: PhysicsBody, transformNode: TransformNode): void;\r\n    setShape(body: PhysicsBody, shape: Nullable<PhysicsShape>): void;\r\n    getShape(body: PhysicsBody): Nullable<PhysicsShape>;\r\n    getShapeType(shape: PhysicsShape): PhysicsShapeType;\r\n    setEventMask(body: PhysicsBody, eventMask: number, instanceIndex?: number): void;\r\n    getEventMask(body: PhysicsBody, instanceIndex?: number): number;\r\n    setMotionType(body: PhysicsBody, motionType: PhysicsMotionType, instanceIndex?: number): void;\r\n    getMotionType(body: PhysicsBody, instanceIndex?: number): PhysicsMotionType;\r\n    computeMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties;\r\n    setMassProperties(body: PhysicsBody, massProps: PhysicsMassProperties, instanceIndex?: number): void;\r\n    getMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties;\r\n    setLinearDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void;\r\n    getLinearDamping(body: PhysicsBody, instanceIndex?: number): number;\r\n    setAngularDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void;\r\n    getAngularDamping(body: PhysicsBody, instanceIndex?: number): number;\r\n    setLinearVelocity(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void;\r\n    getLinearVelocityToRef(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void;\r\n    applyImpulse(body: PhysicsBody, impulse: Vector3, location: Vector3, instanceIndex?: number): void;\r\n    applyForce(body: PhysicsBody, force: Vector3, location: Vector3, instanceIndex?: number): void;\r\n    setAngularVelocity(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void;\r\n    getAngularVelocityToRef(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void;\r\n    getBodyGeometry(body: PhysicsBody): {};\r\n    disposeBody(body: PhysicsBody): void;\r\n    setCollisionCallbackEnabled(body: PhysicsBody, enabled: boolean, instanceIndex?: number): void;\r\n    addConstraint(body: PhysicsBody, childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void;\r\n    getCollisionObservable(body: PhysicsBody, instanceIndex?: number): Observable<IPhysicsCollisionEvent>;\r\n    setGravityFactor(body: PhysicsBody, factor: number, instanceIndex?: number): void;\r\n    getGravityFactor(body: PhysicsBody, instanceIndex?: number): number;\r\n\r\n    // shape\r\n    initShape(shape: PhysicsShape, type: PhysicsShapeType, options: PhysicsShapeParameters): void;\r\n    setShapeFilterMembershipMask(shape: PhysicsShape, membershipMask: number): void;\r\n    getShapeFilterMembershipMask(shape: PhysicsShape): number;\r\n    setShapeFilterCollideMask(shape: PhysicsShape, collideMask: number): void;\r\n    getShapeFilterCollideMask(shape: PhysicsShape): number;\r\n    setMaterial(shape: PhysicsShape, material: PhysicsMaterial): void;\r\n    setDensity(shape: PhysicsShape, density: number): void;\r\n    getDensity(shape: PhysicsShape): number;\r\n    addChild(shape: PhysicsShape, newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void;\r\n    removeChild(shape: PhysicsShape, childIndex: number): void;\r\n    getNumChildren(shape: PhysicsShape): number;\r\n    getBoundingBox(shape: PhysicsShape): BoundingBox;\r\n    disposeShape(shape: PhysicsShape): void;\r\n\r\n    // constraint\r\n    initConstraint(constraint: PhysicsConstraint, body: PhysicsBody, childBody: PhysicsBody): void;\r\n    setEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getEnabled(constraint: PhysicsConstraint): boolean;\r\n    setCollisionsEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getCollisionsEnabled(constraint: PhysicsConstraint): boolean;\r\n    setAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, friction: number): void;\r\n    getAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number;\r\n    setAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limitMode: PhysicsConstraintAxisLimitMode): void;\r\n    getAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): PhysicsConstraintAxisLimitMode;\r\n    setAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, minLimit: number): void;\r\n    getAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number;\r\n    setAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void;\r\n    getAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number;\r\n    setAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, motorType: PhysicsConstraintMotorType): void;\r\n    getAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): PhysicsConstraintMotorType;\r\n    setAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, target: number): void;\r\n    getAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number;\r\n    setAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, maxForce: number): void;\r\n    getAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number;\r\n    disposeConstraint(constraint: PhysicsConstraint): void;\r\n\r\n    // raycast\r\n    raycast(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void;\r\n\r\n    dispose(): void;\r\n}\r\n","import { Matrix, Quaternion, TmpVectors, Vector3 } from \"../../../Maths/math.vector\";\r\nimport {\r\n    PhysicsShapeType,\r\n    PhysicsConstraintType,\r\n    PhysicsMotionType,\r\n    PhysicsConstraintMotorType,\r\n    PhysicsConstraintAxis,\r\n    PhysicsConstraintAxisLimitMode,\r\n} from \"../IPhysicsEnginePlugin\";\r\nimport type { PhysicsShapeParameters, IPhysicsEnginePluginV2, PhysicsMassProperties, IPhysicsCollisionEvent } from \"../IPhysicsEnginePlugin\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { PhysicsBody } from \"../physicsBody\";\r\nimport type { PhysicsConstraint, Physics6DoFConstraint } from \"../physicsConstraint\";\r\nimport type { PhysicsMaterial } from \"../physicsMaterial\";\r\nimport { PhysicsMaterialCombineMode } from \"../physicsMaterial\";\r\nimport { PhysicsShape } from \"../physicsShape\";\r\nimport type { BoundingBox } from \"../../../Culling/boundingBox\";\r\nimport type { TransformNode } from \"../../../Meshes/transformNode\";\r\nimport type { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport { Mesh } from \"../../../Meshes/mesh\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { ArrayTools } from \"../../../Misc/arrayTools\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\ndeclare let HK: any;\r\n\r\nclass MeshAccumulator {\r\n    /**\r\n     * Constructor of the mesh accumulator\r\n     * @param mesh - The mesh used to compute the world matrix.\r\n     * @param collectIndices - use mesh indices\r\n     * @param scene - The scene used to determine the right handed system.\r\n     *\r\n     * Merge mesh and its children so whole hierarchy can be used as a mesh shape or convex hull\r\n     */\r\n    public constructor(mesh: Mesh, collectIndices: boolean, scene: Scene) {\r\n        const worldFromRoot = mesh.computeWorldMatrix(true);\r\n        const rootScale = new Vector3();\r\n        const rootOrientation = new Quaternion();\r\n        const rootTranslation = new Vector3();\r\n        worldFromRoot.decompose(rootScale, rootOrientation, rootTranslation);\r\n\r\n        this._bodyFromWorld = Matrix.Compose(Vector3.One(), mesh.rotationQuaternion ? mesh.rotationQuaternion : Quaternion.Identity(), mesh.position);\r\n        this._bodyFromWorld = this._bodyFromWorld.invert();\r\n        this._isRightHanded = scene.useRightHandedSystem;\r\n        this._collectIndices = collectIndices;\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh to the physics engine.\r\n     * @param mesh The mesh to add.\r\n     * @param includeChildren Whether to include the children of the mesh.\r\n     *\r\n     * This method adds a mesh to the physics engine by computing the world matrix,\r\n     * multiplying it with the body from world matrix, and then transforming the\r\n     * coordinates of the mesh's vertices. It also adds the indices of the mesh\r\n     * to the physics engine. If includeChildren is true, it will also add the\r\n     * children of the mesh to the physics engine, ignoring any children which\r\n     * have a physics impostor. This is useful for creating a physics engine\r\n     * that accurately reflects the mesh and its children.\r\n     */\r\n    public addMesh(mesh: Mesh, includeChildren: boolean): void {\r\n        const indexOffset = this._vertices.length;\r\n        const worldFromShape = mesh.computeWorldMatrix(true);\r\n        const shapeFromBody = worldFromShape.multiply(this._bodyFromWorld);\r\n\r\n        const vertexData = mesh.getVerticesData(VertexBuffer.PositionKind) || [];\r\n        const numVerts = vertexData.length / 3;\r\n        for (let v = 0; v < numVerts; v++) {\r\n            const pos = new Vector3(vertexData[v * 3 + 0], vertexData[v * 3 + 1], vertexData[v * 3 + 2]);\r\n            this._vertices.push(Vector3.TransformCoordinates(pos, shapeFromBody));\r\n        }\r\n\r\n        if (this._collectIndices) {\r\n            const meshIndices = mesh.getIndices();\r\n            if (meshIndices) {\r\n                for (let i = 0; i < meshIndices.length; i += 3) {\r\n                    // Havok wants the correct triangle winding to enable the interior triangle optimization\r\n                    if (this._isRightHanded) {\r\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\r\n                    } else {\r\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (includeChildren) {\r\n            const children = mesh.getChildMeshes(false);\r\n            //  Ignore any children which have a physics body.\r\n            //  Other plugin implementations do not have this check, which appears to be\r\n            //  a bug, as otherwise, the mesh will have a duplicate collider\r\n            children.filter((m: any) => !m.physicsBody).forEach((m: any) => this.addMesh(m, includeChildren));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allocate and populate the vertex positions inside the physics plugin.\r\n     *\r\n     * @returns An array of floats, whose backing memory is inside the plugin. The array contains the\r\n     * positions of the mesh vertices, where a position is defined by three floats. You must call\r\n     * freeBuffer() on the returned array once you have finished with it, in order to free the\r\n     * memory inside the plugin..\r\n     */\r\n    public getVertices(plugin: any): Float32Array {\r\n        const nFloats = this._vertices.length * 3;\r\n        const bytesPerFloat = 4;\r\n        const nBytes = nFloats * bytesPerFloat;\r\n        const bufferBegin = plugin._malloc(nBytes);\r\n\r\n        const ret = new Float32Array(plugin.HEAPU8.buffer, bufferBegin, nFloats);\r\n        for (let i = 0; i < this._vertices.length; i++) {\r\n            ret[i * 3 + 0] = this._vertices[i].x;\r\n            ret[i * 3 + 1] = this._vertices[i].y;\r\n            ret[i * 3 + 2] = this._vertices[i].z;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    public freeBuffer(plugin: any, arr: Float32Array | Int32Array) {\r\n        plugin._free(arr.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * Allocate and populate the triangle indices inside the physics plugin\r\n     *\r\n     * @returns A new Int32Array, whose backing memory is inside the plugin. The array contains the indices\r\n     * of the triangle positions, where a single triangle is defined by three indices. You must call\r\n     * freeBuffer() on this array once you have finished with it, to free the memory inside the plugin..\r\n     */\r\n    public getTriangles(plugin: any): Int32Array {\r\n        const bytesPerInt = 4;\r\n        const nBytes = this._indices.length * bytesPerInt;\r\n        const bufferBegin = plugin._malloc(nBytes);\r\n        const ret = new Int32Array(plugin.HEAPU8.buffer, bufferBegin, this._indices.length);\r\n        for (let i = 0; i < this._indices.length; i++) {\r\n            ret[i] = this._indices[i];\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    private _isRightHanded: boolean;\r\n    private _collectIndices: boolean;\r\n    private _vertices: Vector3[] = []; /// Vertices in body space\r\n    private _indices: number[] = [];\r\n    private _bodyFromWorld: Matrix;\r\n}\r\n\r\nclass BodyPluginData {\r\n    public constructor(bodyId: any) {\r\n        this.hpBodyId = bodyId;\r\n        this.userMassProps = { centerOfMass: undefined, mass: undefined, inertia: undefined, inertiaOrientation: undefined };\r\n    }\r\n\r\n    public hpBodyId: any;\r\n\r\n    public worldTransformOffset: number;\r\n\r\n    public userMassProps: PhysicsMassProperties;\r\n}\r\n\r\n/*\r\nclass ShapePath\r\n{\r\n    public colliderId: number;\r\n    public pathData: number;\r\n}\r\n*/\r\n\r\nclass ContactPoint {\r\n    public bodyId: bigint = BigInt(0); //0,2\r\n    //public colliderId: number = 0; //2,4\r\n    //public shapePath: ShapePath = new ShapePath(); //4,8\r\n    public position: Vector3 = new Vector3(); //8,11\r\n    public normal: Vector3 = new Vector3(); //11,14\r\n    //public triIdx: number = 0; //14,15\r\n}\r\n\r\nclass CollisionEvent {\r\n    //public eventType: number = 0; //0,1\r\n    public contactOnA: ContactPoint = new ContactPoint(); //1\r\n    public contactOnB: ContactPoint = new ContactPoint();\r\n    public impulseApplied: number = 0;\r\n\r\n    static readToRef(buffer: any, offset: number, eventOut: CollisionEvent) {\r\n        const intBuf = new Int32Array(buffer, offset);\r\n        const floatBuf = new Float32Array(buffer, offset);\r\n        const offA = 2;\r\n        eventOut.contactOnA.bodyId = BigInt(intBuf[offA]); //<todo Need to get the high+low words!\r\n        eventOut.contactOnA.position.set(floatBuf[offA + 8], floatBuf[offA + 9], floatBuf[offA + 10]);\r\n        eventOut.contactOnA.normal.set(floatBuf[offA + 11], floatBuf[offA + 12], floatBuf[offA + 13]);\r\n        const offB = 18;\r\n        eventOut.contactOnB.bodyId = BigInt(intBuf[offB]);\r\n        eventOut.contactOnB.position.set(floatBuf[offB + 8], floatBuf[offB + 9], floatBuf[offB + 10]);\r\n        eventOut.contactOnB.normal.set(floatBuf[offB + 11], floatBuf[offB + 12], floatBuf[offB + 13]);\r\n        eventOut.impulseApplied = floatBuf[offB + 13 + 2];\r\n    }\r\n}\r\n\r\n/**\r\n * The Havok Physics plugin\r\n */\r\nexport class HavokPlugin implements IPhysicsEnginePluginV2 {\r\n    /**\r\n     * Reference to the WASM library\r\n     */\r\n    public _hknp: any = {};\r\n    /**\r\n     * Created Havok world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"HavokPlugin\";\r\n    /**\r\n     * We only have a single raycast in-flight right now\r\n     */\r\n    private _queryCollector: bigint;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _timeStep: number = 1 / 60;\r\n    private _tmpVec3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    private _bodies = new Map<bigint, { body: PhysicsBody; index: number }>();\r\n    private _bodyBuffer: number;\r\n    private _bodyCollisionObservable = new Map<bigint, Observable<IPhysicsCollisionEvent>>();\r\n    /**\r\n     *\r\n     */\r\n    public onCollisionObservable = new Observable<IPhysicsCollisionEvent>();\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, hpInjection: any = HK) {\r\n        if (typeof hpInjection === \"function\") {\r\n            Logger.Error(\"Havok is not ready. Please make sure you await HK() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this._hknp = hpInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"Havok is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.world = this._hknp.HP_World_Create()[1];\r\n        this._queryCollector = this._hknp.HP_QueryCollector_Create(1)[1];\r\n    }\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this._hknp !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world.\r\n     *\r\n     * @param gravity - The gravity vector to set.\r\n     *\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._hknp.HP_World_SetGravity(this.world, this._bVecToV3(gravity));\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed time step for the physics engine.\r\n     *\r\n     * @param timeStep - The fixed time step to use for the physics engine.\r\n     *\r\n     */\r\n    public setTimeStep(timeStep: number): void {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Gets the fixed time step used by the physics engine.\r\n     *\r\n     * @returns The fixed time step used by the physics engine.\r\n     *\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Executes a single step of the physics engine.\r\n     *\r\n     * @param delta The time delta in seconds since the last step.\r\n     * @param physicsBodies An array of physics bodies to be simulated.\r\n     * @returns void\r\n     *\r\n     * This method is useful for simulating the physics engine. It sets the physics body transformation,\r\n     * steps the world, syncs the physics body, and notifies collisions. This allows for the physics engine\r\n     * to accurately simulate the physics bodies in the world.\r\n     */\r\n    public executeStep(delta: number, physicsBodies: Array<PhysicsBody>): void {\r\n        for (const physicsBody of physicsBodies) {\r\n            if (physicsBody.disablePreStep) {\r\n                continue;\r\n            }\r\n            this.setPhysicsBodyTransformation(physicsBody, physicsBody.transformNode);\r\n        }\r\n\r\n        this._hknp.HP_World_Step(this.world, this._useDeltaForWorldStep ? delta : this._timeStep);\r\n\r\n        this._bodyBuffer = this._hknp.HP_World_GetBodyBuffer(this.world)[1];\r\n        for (const physicsBody of physicsBodies) {\r\n            this.sync(physicsBody);\r\n        }\r\n\r\n        this._notifyCollisions();\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the physics engine plugin.\r\n     *\r\n     * @returns The version of the physics engine plugin.\r\n     *\r\n     * This method is useful for determining the version of the physics engine plugin that is currently running.\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * Initializes a physics body with the given position and orientation.\r\n     *\r\n     * @param body - The physics body to initialize.\r\n     * @param motionType - The motion type of the body.\r\n     * @param position - The position of the body.\r\n     * @param orientation - The orientation of the body.\r\n     * This code is useful for initializing a physics body with the given position and orientation.\r\n     * It creates a plugin data for the body and adds it to the world. It then converts the position\r\n     * and orientation to a transform and sets the body's transform to the given values.\r\n     */\r\n    public initBody(body: PhysicsBody, motionType: PhysicsMotionType, position: Vector3, orientation: Quaternion): void {\r\n        body._pluginData = new BodyPluginData(this._hknp.HP_Body_Create()[1]);\r\n\r\n        this._internalSetMotionType(body._pluginData, motionType);\r\n        const transform = [this._bVecToV3(position), this._bQuatToV4(orientation)]; //<todo temp transform?\r\n        this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, transform);\r\n\r\n        this._hknp.HP_World_AddBody(this.world, body._pluginData.hpBodyId, body.startAsleep);\r\n        this._bodies.set(body._pluginData.hpBodyId[0], { body: body, index: 0 });\r\n    }\r\n\r\n    /**\r\n     * Removes a body from the world. To dispose of a body, it is necessary to remove it from the world first.\r\n     *\r\n     * @param body - The body to remove.\r\n     */\r\n    public removeBody(body: PhysicsBody): void {\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\r\n            for (const instance of body._pluginDataInstances) {\r\n                this._bodyCollisionObservable.delete(instance.hpBodyId[0]);\r\n                this._hknp.HP_World_RemoveBody(this.world, instance.hpBodyId);\r\n            }\r\n        }\r\n        if (body._pluginData) {\r\n            this._bodyCollisionObservable.delete(body._pluginData.hpBodyId[0]);\r\n            this._hknp.HP_World_RemoveBody(this.world, body._pluginData.hpBodyId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the body instances for a given physics body and mesh.\r\n     *\r\n     * @param body - The physics body to initialize.\r\n     * @param motionType - How the body will be handled by the engine\r\n     * @param mesh - The mesh to initialize.\r\n     *\r\n     * This code is useful for creating a physics body from a mesh. It creates a\r\n     * body instance for each instance of the mesh and adds it to the world. It also\r\n     * sets the position of the body instance to the position of the mesh instance.\r\n     * This allows for the physics engine to accurately simulate the mesh in the\r\n     * world.\r\n     */\r\n    public initBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, mesh: Mesh): void {\r\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\r\n        if (!matrixData) {\r\n            return; // TODO: error handling\r\n        }\r\n        this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, false);\r\n        body._pluginDataInstances.forEach((bodyId, index) => {\r\n            this._bodies.set(bodyId.hpBodyId[0], { body: body, index: index });\r\n        });\r\n    }\r\n\r\n    private _createOrUpdateBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, matrixData: Float32Array, startIndex: number, endIndex: number, update: boolean): void {\r\n        const rotation = TmpVectors.Quaternion[0];\r\n        const rotationMatrix = Matrix.Identity();\r\n        for (let i = startIndex; i < endIndex; i++) {\r\n            const position = [matrixData[i * 16 + 12], matrixData[i * 16 + 13], matrixData[i * 16 + 14]];\r\n            let hkbody;\r\n            if (!update) {\r\n                hkbody = this._hknp.HP_Body_Create()[1];\r\n            } else {\r\n                hkbody = body._pluginDataInstances[i].hpBodyId;\r\n            }\r\n            rotationMatrix.setRowFromFloats(0, matrixData[i * 16 + 0], matrixData[i * 16 + 1], matrixData[i * 16 + 2], 0);\r\n            rotationMatrix.setRowFromFloats(1, matrixData[i * 16 + 4], matrixData[i * 16 + 5], matrixData[i * 16 + 6], 0);\r\n            rotationMatrix.setRowFromFloats(2, matrixData[i * 16 + 8], matrixData[i * 16 + 9], matrixData[i * 16 + 10], 0);\r\n            Quaternion.FromRotationMatrixToRef(rotationMatrix, rotation);\r\n            const transform = [position, [rotation.x, rotation.y, rotation.z, rotation.w]];\r\n            this._hknp.HP_Body_SetQTransform(hkbody, transform);\r\n            if (!update) {\r\n                const pluginData = new BodyPluginData(hkbody);\r\n                if (body._pluginDataInstances.length) {\r\n                    // If an instance already exists, copy any user-provided mass properties\r\n                    pluginData.userMassProps = body._pluginDataInstances[0].userMassProps;\r\n                }\r\n                this._internalSetMotionType(pluginData, motionType);\r\n                this._internalUpdateMassProperties(pluginData);\r\n                body._pluginDataInstances.push(pluginData);\r\n                this._hknp.HP_World_AddBody(this.world, hkbody, body.startAsleep);\r\n                pluginData.worldTransformOffset = this._hknp.HP_Body_GetWorldTransformOffset(hkbody)[1];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the internal body instances for a given physics body to match the instances in a mesh.\r\n     * @param body the body that will be updated\r\n     * @param mesh the mesh with reference instances\r\n     */\r\n    public updateBodyInstances(body: PhysicsBody, mesh: Mesh): void {\r\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\r\n        if (!matrixData) {\r\n            return; // TODO: error handling\r\n        }\r\n        const pluginInstancesCount = body._pluginDataInstances.length;\r\n        const motionType = this.getMotionType(body);\r\n\r\n        if (instancesCount > pluginInstancesCount) {\r\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, pluginInstancesCount, instancesCount, false);\r\n            const firstBodyShape = this._hknp.HP_Body_GetShape(body._pluginDataInstances[0].hpBodyId)[1];\r\n            for (let i = pluginInstancesCount; i < instancesCount; i++) {\r\n                this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, firstBodyShape);\r\n                this._internalUpdateMassProperties(body._pluginDataInstances[i]);\r\n                this._bodies.set(body._pluginDataInstances[i].hpBodyId[0], { body: body, index: i });\r\n            }\r\n        } else if (instancesCount < pluginInstancesCount) {\r\n            const instancesToRemove = pluginInstancesCount - instancesCount;\r\n            for (let i = 0; i < instancesToRemove; i++) {\r\n                const hkbody = body._pluginDataInstances.pop();\r\n                this._bodies.delete(hkbody.hpBodyId[0]);\r\n                this._hknp.HP_World_RemoveBody(this.world, hkbody.hpBodyId);\r\n                this._hknp.HP_Body_Release(hkbody.hpBodyId);\r\n            }\r\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronizes the transform of a physics body with its transform node.\r\n     * @param body - The physics body to synchronize.\r\n     *\r\n     * This function is useful for keeping the physics body's transform in sync with its transform node.\r\n     * This is important for ensuring that the physics body is accurately represented in the physics engine.\r\n     */\r\n    sync(body: PhysicsBody): void {\r\n        this.syncTransform(body, body.transformNode);\r\n    }\r\n\r\n    /**\r\n     * Synchronizes the transform of a physics body with the transform of its\r\n     * corresponding transform node.\r\n     *\r\n     * @param body - The physics body to synchronize.\r\n     * @param transformNode - The destination Transform Node.\r\n     *\r\n     * This code is useful for synchronizing the position and orientation of a\r\n     * physics body with the position and orientation of its corresponding\r\n     * transform node. This is important for ensuring that the physics body and\r\n     * the transform node are in the same position and orientation in the scene.\r\n     * This is necessary for the physics engine to accurately simulate the\r\n     * physical behavior of the body.\r\n     */\r\n    syncTransform(body: PhysicsBody, transformNode: TransformNode): void {\r\n        if (body._pluginDataInstances.length) {\r\n            // instances\r\n            const m = transformNode as Mesh;\r\n            const matrixData = m._thinInstanceDataStorage.matrixData;\r\n            if (!matrixData) {\r\n                return; // TODO: error handling\r\n            }\r\n            const instancesCount = body._pluginDataInstances.length;\r\n            for (let i = 0; i < instancesCount; i++) {\r\n                const bufOffset = body._pluginDataInstances[i].worldTransformOffset;\r\n                const transformBuffer = new Float32Array(this._hknp.HEAPU8.buffer, this._bodyBuffer + bufOffset, 16);\r\n                const index = i * 16;\r\n\r\n                for (let mi = 0; mi < 15; mi++) {\r\n                    if ((mi & 3) != 3) {\r\n                        matrixData[index + mi] = transformBuffer[mi];\r\n                    }\r\n                }\r\n                matrixData[index + 15] = 1;\r\n            }\r\n            m.thinInstanceBufferUpdated(\"matrix\");\r\n        } else {\r\n            try {\r\n                // regular\r\n                const bodyTransform = this._hknp.HP_Body_GetQTransform(body._pluginData.hpBodyId)[1];\r\n                const bodyTranslation = bodyTransform[0];\r\n                const bodyOrientation = bodyTransform[1];\r\n                const quat = TmpVectors.Quaternion[0];\r\n\r\n                quat.set(bodyOrientation[0], bodyOrientation[1], bodyOrientation[2], bodyOrientation[3]);\r\n\r\n                const parent = transformNode.parent as TransformNode;\r\n                // transform position/orientation in parent space\r\n                if (parent && parent.absoluteRotationQuaternion) {\r\n                    TmpVectors.Vector3[2].set(bodyTranslation[0], bodyTranslation[1], bodyTranslation[2]);\r\n                    parent.absoluteRotationQuaternion.conjugateToRef(TmpVectors.Quaternion[1]);\r\n                    quat.multiplyInPlace(TmpVectors.Quaternion[1]);\r\n                    TmpVectors.Vector3[2].subtractToRef(parent.absolutePosition, TmpVectors.Vector3[0]);\r\n                    const localPosition = TmpVectors.Vector3[1];\r\n                    TmpVectors.Vector3[0].rotateByQuaternionToRef(TmpVectors.Quaternion[1], localPosition);\r\n                    transformNode.position.set(localPosition.x, localPosition.y, localPosition.z); // use set so position._isDirty is true\r\n                } else {\r\n                    transformNode.position.set(bodyTranslation[0], bodyTranslation[1], bodyTranslation[2]);\r\n                }\r\n\r\n                if (transformNode.rotationQuaternion) {\r\n                    transformNode.rotationQuaternion.copyFrom(quat);\r\n                } else {\r\n                    quat.toEulerAnglesToRef(transformNode.rotation);\r\n                }\r\n            } catch (e) {\r\n                console.log(`Syncing transform failed for node ${transformNode.name}: ${e.message}...`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of a physics body.\r\n     * @param body - The physics body to set the shape for.\r\n     * @param shape - The physics shape to set.\r\n     *\r\n     * This function is used to set the shape of a physics body. It is useful for\r\n     * creating a physics body with a specific shape, such as a box or a sphere,\r\n     * which can then be used to simulate physical interactions in a physics engine.\r\n     * This function is especially useful for meshes with multiple instances, as it\r\n     * will set the shape for each instance of the mesh.\r\n     */\r\n    public setShape(body: PhysicsBody, shape: Nullable<PhysicsShape>): void {\r\n        const shapeHandle = shape && shape._pluginData ? shape._pluginData : BigInt(0);\r\n        if (!(body.transformNode instanceof Mesh) || !body.transformNode._thinInstanceDataStorage?.matrixData) {\r\n            this._hknp.HP_Body_SetShape(body._pluginData.hpBodyId, shapeHandle);\r\n            this._internalUpdateMassProperties(body._pluginData);\r\n            return;\r\n        }\r\n        const m = body.transformNode as Mesh;\r\n        const instancesCount = m._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        for (let i = 0; i < instancesCount; i++) {\r\n            this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, shapeHandle);\r\n            this._internalUpdateMassProperties(body._pluginDataInstances[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a reference to the first instance of the plugin data for a physics body.\r\n     * @param body\r\n     * @param instanceIndex\r\n     * @returns a reference to the first instance\r\n     */\r\n    private _getPluginReference(body: PhysicsBody, instanceIndex?: number): BodyPluginData {\r\n        return body._pluginDataInstances?.length ? body._pluginDataInstances[instanceIndex ?? 0] : body._pluginData;\r\n    }\r\n\r\n    /**\r\n     * Gets the shape of a physics body. This will create a new shape object\r\n     *\r\n     * @param body - The physics body.\r\n     * @returns The shape of the physics body.\r\n     *\r\n     */\r\n    public getShape(body: PhysicsBody): Nullable<PhysicsShape> {\r\n        const pluginRef = this._getPluginReference(body);\r\n        const shapePluginData = this._hknp.HP_Body_GetShape(pluginRef.hpBodyId)[1];\r\n        if (shapePluginData != 0) {\r\n            const scene = body.transformNode.getScene();\r\n            return new PhysicsShape({ pluginData: shapePluginData }, scene);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of a physics shape.\r\n     * @param shape - The physics shape to get the type for.\r\n     * @returns The type of the physics shape.\r\n     *\r\n     */\r\n    public getShapeType(shape: PhysicsShape): PhysicsShapeType {\r\n        if (shape.type) {\r\n            return shape.type;\r\n        } else {\r\n            //<todo This returns a native type!\r\n            return this._hknp.HP_Shape_GetType(shape._pluginData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask of a physics body.\r\n     * @param body - The physics body to set the event mask for.\r\n     * @param eventMask - The event mask to set.\r\n     *\r\n     * This function is useful for setting the event mask of a physics body, which is used to determine which events the body will respond to. This is important for ensuring that the physics engine is able to accurately simulate the behavior of the body in the game world.\r\n     */\r\n    public setEventMask(body: PhysicsBody, eventMask: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (bodyPluginData) => {\r\n                this._hknp.HP_Body_SetEventMask(bodyPluginData.hpBodyId, eventMask);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Retrieves the event mask of a physics body.\r\n     *\r\n     * @param body - The physics body to retrieve the event mask from.\r\n     * @returns The event mask of the physics body.\r\n     *\r\n     */\r\n    public getEventMask(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetEventMask(pluginRef)[1];\r\n    }\r\n\r\n    private _fromMassPropertiesTuple(massPropsTuple: any[]): PhysicsMassProperties {\r\n        return {\r\n            centerOfMass: Vector3.FromArray(massPropsTuple[0]),\r\n            mass: massPropsTuple[1],\r\n            inertia: Vector3.FromArray(massPropsTuple[2]),\r\n            inertiaOrientation: Quaternion.FromArray(massPropsTuple[3]),\r\n        };\r\n    }\r\n\r\n    private _internalUpdateMassProperties(pluginData: BodyPluginData) {\r\n        // Recompute the mass based on the shape\r\n        const newProps = this._internalComputeMassProperties(pluginData);\r\n        const massProps = pluginData.userMassProps;\r\n\r\n        // Override the computed values with any the user has set\r\n        if (massProps.centerOfMass) {\r\n            newProps[0] = massProps.centerOfMass.asArray();\r\n        }\r\n        if (massProps.mass != undefined) {\r\n            newProps[1] = massProps.mass;\r\n        }\r\n        if (massProps.inertia) {\r\n            newProps[2] = massProps.inertia.asArray();\r\n        }\r\n        if (massProps.inertiaOrientation) {\r\n            newProps[3] = massProps.inertiaOrientation.asArray();\r\n        }\r\n        this._hknp.HP_Body_SetMassProperties(pluginData.hpBodyId, newProps);\r\n    }\r\n\r\n    public _internalSetMotionType(pluginData: BodyPluginData, motionType: PhysicsMotionType): void {\r\n        switch (motionType) {\r\n            case PhysicsMotionType.STATIC:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.STATIC);\r\n                break;\r\n            case PhysicsMotionType.ANIMATED:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.KINEMATIC);\r\n                break;\r\n            case PhysicsMotionType.DYNAMIC:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.DYNAMIC);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public setMotionType(body: PhysicsBody, motionType: PhysicsMotionType, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._internalSetMotionType(pluginData, motionType);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    public getMotionType(body: PhysicsBody, instanceIndex?: number): PhysicsMotionType {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const type = this._hknp.HP_Body_GetMotionType(pluginRef.hpBodyId)[1];\r\n        switch (type) {\r\n            case this._hknp.MotionType.STATIC:\r\n                return PhysicsMotionType.STATIC;\r\n            case this._hknp.MotionType.KINEMATIC:\r\n                return PhysicsMotionType.ANIMATED;\r\n            case this._hknp.MotionType.DYNAMIC:\r\n                return PhysicsMotionType.DYNAMIC;\r\n        }\r\n        throw new Error(\"Unknown motion type: \" + type);\r\n    }\r\n\r\n    private _internalComputeMassProperties(pluginData: BodyPluginData): any[] {\r\n        const shapeRes = this._hknp.HP_Body_GetShape(pluginData.hpBodyId);\r\n        if (shapeRes[0] == this._hknp.Result.RESULT_OK) {\r\n            const shapeMass = this._hknp.HP_Shape_BuildMassProperties(shapeRes[1]);\r\n            if (shapeMass[0] == this._hknp.Result.RESULT_OK) {\r\n                return shapeMass[1];\r\n            }\r\n        }\r\n\r\n        // Failed; return a unit inertia\r\n        return [[0, 0, 0], 1, [1, 1, 1], [0, 0, 0, 1]];\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of a physics body, from it's shape\r\n     *\r\n     * @param body - The physics body to copmute the mass properties of\r\n     */\r\n    public computeMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const computed = this._internalComputeMassProperties(pluginRef);\r\n        return this._fromMassPropertiesTuple(computed);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of a physics body.\r\n     *\r\n     * @param body - The physics body to set the mass properties of.\r\n     * @param massProps - The mass properties to set.\r\n     * @param instanceIndex - The index of the instance to set the mass properties of. If undefined, the mass properties of all the bodies will be set.\r\n     * This function is useful for setting the mass properties of a physics body,\r\n     * such as its mass, inertia, and center of mass. This is important for\r\n     * accurately simulating the physics of the body in the physics engine.\r\n     *\r\n     */\r\n    public setMassProperties(body: PhysicsBody, massProps: PhysicsMassProperties, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                pluginData.userMassProps = massProps;\r\n                this._internalUpdateMassProperties(pluginData);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    public getMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const massPropsTuple = this._hknp.HP_Body_GetMassProperties(pluginRef.hpBodyId)[1];\r\n        return this._fromMassPropertiesTuple(massPropsTuple);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the given body.\r\n     * @param body - The body to set the linear damping for.\r\n     * @param damping - The linear damping to set.\r\n     *\r\n     * This method is useful for controlling the linear damping of a body in a physics engine.\r\n     * Linear damping is a force that opposes the motion of the body, and is proportional to the velocity of the body.\r\n     * This method allows the user to set the linear damping of a body, which can be used to control the motion of the body.\r\n     */\r\n    public setLinearDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetLinearDamping(pluginData.hpBodyId, damping);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the given body.\r\n     * @param body - The body to get the linear damping from.\r\n     * @returns The linear damping of the given body.\r\n     *\r\n     * This method is useful for getting the linear damping of a body in a physics engine.\r\n     * Linear damping is a force that opposes the motion of the body and is proportional to the velocity of the body.\r\n     * It is used to simulate the effects of air resistance and other forms of friction.\r\n     */\r\n    public getLinearDamping(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetLinearDamping(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of a physics body.\r\n     * @param body - The physics body to set the angular damping for.\r\n     * @param damping - The angular damping value to set.\r\n     *\r\n     * This function is useful for controlling the angular velocity of a physics body.\r\n     * By setting the angular damping, the body's angular velocity will be reduced over time, allowing for more realistic physics simulations.\r\n     */\r\n    public setAngularDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetAngularDamping(pluginData.hpBodyId, damping);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of a physics body.\r\n     * @param body - The physics body to get the angular damping from.\r\n     * @returns The angular damping of the body.\r\n     *\r\n     * This function is useful for retrieving the angular damping of a physics body,\r\n     * which is used to control the rotational motion of the body. The angular damping is a value between 0 and 1, where 0 is no damping and 1 is full damping.\r\n     */\r\n    public getAngularDamping(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetAngularDamping(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of a physics body.\r\n     * @param body - The physics body to set the linear velocity of.\r\n     * @param linVel - The linear velocity to set.\r\n     *\r\n     * This function is useful for setting the linear velocity of a physics body, which is necessary for simulating\r\n     * motion in a physics engine. The linear velocity is the speed and direction of the body's movement.\r\n     */\r\n    public setLinearVelocity(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetLinearVelocity(pluginData.hpBodyId, this._bVecToV3(linVel));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of a physics body and stores it in a given vector.\r\n     * @param body - The physics body to get the linear velocity from.\r\n     * @param linVel - The vector to store the linear velocity in.\r\n     *\r\n     * This function is useful for retrieving the linear velocity of a physics body,\r\n     * which can be used to determine the speed and direction of the body. This\r\n     * information can be used to simulate realistic physics behavior in a game.\r\n     */\r\n    public getLinearVelocityToRef(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const lv = this._hknp.HP_Body_GetLinearVelocity(pluginRef.hpBodyId)[1];\r\n        this._v3ToBvecRef(lv, linVel);\r\n    }\r\n\r\n    /*\r\n     * Apply an operation either to all instances of a body, if instanceIndex is not specified, or to a specific instance.\r\n     */\r\n    private _applyToBodyOrInstances(body: PhysicsBody, fnToApply: (pluginRef: any) => void, instanceIndex?: number): void {\r\n        if (body._pluginDataInstances?.length > 0 && instanceIndex === undefined) {\r\n            for (let i = 0; i < body._pluginDataInstances.length; i++) {\r\n                fnToApply(body._pluginDataInstances[i]);\r\n            }\r\n        } else {\r\n            fnToApply(this._getPluginReference(body, instanceIndex));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to a physics body at a given location.\r\n     * @param body - The physics body to apply the impulse to.\r\n     * @param impulse - The impulse vector to apply.\r\n     * @param location - The location in world space to apply the impulse.\r\n     * @param instanceIndex - The index of the instance to apply the impulse to. If not specified, the impulse will be applied to all instances.\r\n     *\r\n     * This method is useful for applying an impulse to a physics body at a given location.\r\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\r\n     */\r\n    public applyImpulse(body: PhysicsBody, impulse: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_ApplyImpulse(pluginRef.hpBodyId, this._bVecToV3(location), this._bVecToV3(impulse));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Applies a force to a physics body at a given location.\r\n     * @param body - The physics body to apply the impulse to.\r\n     * @param force - The force vector to apply.\r\n     * @param location - The location in world space to apply the impulse.\r\n     * @param instanceIndex - The index of the instance to apply the force to. If not specified, the force will be applied to all instances.\r\n     *\r\n     * This method is useful for applying a force to a physics body at a given location.\r\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\r\n     */\r\n    public applyForce(body: PhysicsBody, force: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        force.scaleToRef(this.getTimeStep(), this._tmpVec3[0]);\r\n        this.applyImpulse(body, this._tmpVec3[0], location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of a physics body.\r\n     *\r\n     * @param body - The physics body to set the angular velocity of.\r\n     * @param angVel - The angular velocity to set.\r\n     *\r\n     * This function is useful for setting the angular velocity of a physics body in a physics engine.\r\n     * This allows for more realistic simulations of physical objects, as they can be given a rotational velocity.\r\n     */\r\n    public setAngularVelocity(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_SetAngularVelocity(pluginRef.hpBodyId, this._bVecToV3(angVel));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of a body.\r\n     * @param body - The body to get the angular velocity from.\r\n     * @param angVel - The vector3 to store the angular velocity.\r\n     *\r\n     * This method is useful for getting the angular velocity of a body in a physics engine. It\r\n     * takes the body and a vector3 as parameters and stores the angular velocity of the body\r\n     * in the vector3. This is useful for getting the angular velocity of a body in order to\r\n     * calculate the motion of the body in the physics engine.\r\n     */\r\n    public getAngularVelocityToRef(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const av = this._hknp.HP_Body_GetAngularVelocity(pluginRef.hpBodyId)[1];\r\n        this._v3ToBvecRef(av, angVel);\r\n    }\r\n\r\n    /**\r\n     * Sets the transformation of the given physics body to the given transform node.\r\n     * @param body The physics body to set the transformation for.\r\n     * @param node The transform node to set the transformation from.\r\n     * Sets the transformation of the given physics body to the given transform node.\r\n     *\r\n     * This function is useful for setting the transformation of a physics body to a\r\n     * transform node, which is necessary for the physics engine to accurately simulate\r\n     * the motion of the body. It also takes into account instances of the transform\r\n     * node, which is necessary for accurate simulation of multiple bodies with the\r\n     * same transformation.\r\n     */\r\n    public setPhysicsBodyTransformation(body: PhysicsBody, node: TransformNode) {\r\n        const transformNode = body.transformNode;\r\n        if (body.numInstances > 0) {\r\n            // instances\r\n            const m = transformNode as Mesh;\r\n            const matrixData = m._thinInstanceDataStorage.matrixData;\r\n            if (!matrixData) {\r\n                return; // TODO: error handling\r\n            }\r\n            const instancesCount = body.numInstances;\r\n            this._createOrUpdateBodyInstances(body, body.getMotionType(), matrixData, 0, instancesCount, true);\r\n        } else {\r\n            // regular\r\n            this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, this._getTransformInfos(node));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity factor of a body\r\n     * @param body the physics body to set the gravity factor for\r\n     * @param factor the gravity factor\r\n     * @param instanceIndex the index of the instance in an instanced body\r\n     */\r\n    public setGravityFactor(body: PhysicsBody, factor: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_SetGravityFactor(pluginRef.hpBodyId, factor);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the gravity factor of a body\r\n     * @param body the physics body to get the gravity factor from\r\n     * @param instanceIndex the index of the instance in an instanced body. If not specified, the gravity factor of the first instance will be returned.\r\n     * @returns the gravity factor\r\n     */\r\n    public getGravityFactor(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetGravityFactor(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Disposes a physics body.\r\n     *\r\n     * @param body - The physics body to dispose.\r\n     *\r\n     * This method is useful for releasing the resources associated with a physics body when it is no longer needed.\r\n     * This is important for avoiding memory leaks in the physics engine.\r\n     */\r\n    public disposeBody(body: PhysicsBody): void {\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\r\n            for (const instance of body._pluginDataInstances) {\r\n                this._hknp.HP_Body_Release(instance.hpBodyId);\r\n                instance.hpBodyId = undefined;\r\n            }\r\n        }\r\n        if (body._pluginData) {\r\n            this._hknp.HP_Body_Release(body._pluginData.hpBodyId);\r\n            body._pluginData.hpBodyId = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes a physics shape with the given type and parameters.\r\n     * @param shape - The physics shape to initialize.\r\n     * @param type - The type of shape to initialize.\r\n     * @param options - The parameters for the shape.\r\n     *\r\n     * This code is useful for initializing a physics shape with the given type and parameters.\r\n     * It allows for the creation of a sphere, box, capsule, container, cylinder, mesh, and heightfield.\r\n     * Depending on the type of shape, different parameters are required.\r\n     * For example, a sphere requires a radius, while a box requires extents and a rotation.\r\n     */\r\n    public initShape(shape: PhysicsShape, type: PhysicsShapeType, options: PhysicsShapeParameters): void {\r\n        switch (type) {\r\n            case PhysicsShapeType.SPHERE:\r\n                {\r\n                    const radius = options.radius || 1;\r\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateSphere(center, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.BOX:\r\n                {\r\n                    const rotation = options.rotation ? this._bQuatToV4(options.rotation) : [0, 0, 0, 1];\r\n                    const extent = options.extents ? this._bVecToV3(options.extents) : [1, 1, 1];\r\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateBox(center, rotation, extent)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CAPSULE:\r\n                {\r\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\r\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\r\n                    const radius = options.radius || 0;\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateCapsule(pointA, pointB, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CONTAINER:\r\n                {\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateContainer()[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CYLINDER:\r\n                {\r\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\r\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\r\n                    const radius = options.radius || 0;\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateCylinder(pointA, pointB, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CONVEX_HULL:\r\n            case PhysicsShapeType.MESH:\r\n                {\r\n                    const mesh = options.mesh;\r\n                    if (mesh) {\r\n                        const includeChildMeshes = !!options.includeChildMeshes;\r\n                        const needIndices = type != PhysicsShapeType.CONVEX_HULL;\r\n                        const accum = new MeshAccumulator(mesh, needIndices, mesh?.getScene());\r\n                        accum.addMesh(mesh, includeChildMeshes);\r\n\r\n                        const positions = accum.getVertices(this._hknp);\r\n                        const numVec3s = positions.length / 3;\r\n\r\n                        if (type == PhysicsShapeType.CONVEX_HULL) {\r\n                            shape._pluginData = this._hknp.HP_Shape_CreateConvexHull(positions.byteOffset, numVec3s)[1];\r\n                        } else {\r\n                            const triangles = accum.getTriangles(this._hknp);\r\n                            const numTriangles = triangles.length / 3;\r\n                            shape._pluginData = this._hknp.HP_Shape_CreateMesh(positions.byteOffset, numVec3s, triangles.byteOffset, numTriangles)[1];\r\n                            accum.freeBuffer(this._hknp, triangles);\r\n                        }\r\n                        accum.freeBuffer(this._hknp, positions);\r\n                    } else {\r\n                        throw new Error(\"No mesh provided to create physics shape.\");\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Unsupported Shape Type.\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    public setShapeFilterMembershipMask(shape: PhysicsShape, membershipMask: number): void {\r\n        const collideWith = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\r\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membershipMask, collideWith]);\r\n    }\r\n\r\n    public getShapeFilterMembershipMask(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\r\n    }\r\n\r\n    public setShapeFilterCollideMask(shape: PhysicsShape, collideMask: number): void {\r\n        const membership = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\r\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membership, collideMask]);\r\n    }\r\n\r\n    public getShapeFilterCollideMask(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\r\n    }\r\n\r\n    /**\r\n     * Sets the material of a physics shape.\r\n     * @param shape - The physics shape to set the material of.\r\n     * @param material - The material to set.\r\n     *\r\n     */\r\n    public setMaterial(shape: PhysicsShape, material: PhysicsMaterial): void {\r\n        const dynamicFriction = material.friction ?? 0.5;\r\n        const staticFriction = material.staticFriction ?? dynamicFriction;\r\n        const restitution = material.restitution ?? 0.0;\r\n        const frictionCombine = material.frictionCombine ?? PhysicsMaterialCombineMode.MINIMUM;\r\n        const restitutionCombine = material.restitutionCombine ?? PhysicsMaterialCombineMode.MAXIMUM;\r\n\r\n        const hpMaterial = [staticFriction, dynamicFriction, restitution, this._materialCombineToNative(frictionCombine), this._materialCombineToNative(restitutionCombine)];\r\n        this._hknp.HP_Shape_SetMaterial(shape._pluginData, hpMaterial);\r\n    }\r\n\r\n    /**\r\n     * Sets the density of a physics shape.\r\n     * @param shape - The physics shape to set the density of.\r\n     * @param density - The density to set.\r\n     *\r\n     */\r\n    public setDensity(shape: PhysicsShape, density: number): void {\r\n        this._hknp.HP_Shape_SetDensity(shape._pluginData, density);\r\n    }\r\n\r\n    /**\r\n     * Calculates the density of a given physics shape.\r\n     *\r\n     * @param shape - The physics shape to calculate the density of.\r\n     * @returns The density of the given physics shape.\r\n     *\r\n     */\r\n    public getDensity(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetDensity(shape._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the transform infos of a given transform node.\r\n     * @param node - The transform node.\r\n     * @returns An array containing the position and orientation of the node.\r\n     * This code is useful for getting the position and orientation of a given transform node.\r\n     * It first checks if the node has a rotation quaternion, and if not, it creates one from the node's rotation.\r\n     * It then creates an array containing the position and orientation of the node and returns it.\r\n     */\r\n    private _getTransformInfos(node: TransformNode): any[] {\r\n        if (node.parent) {\r\n            node.computeWorldMatrix();\r\n            return [this._bVecToV3(node.absolutePosition), this._bQuatToV4(node.absoluteRotationQuaternion)];\r\n        }\r\n\r\n        let orientation = TmpVectors.Quaternion[0];\r\n        if (node.rotationQuaternion) {\r\n            orientation = node.rotationQuaternion;\r\n        } else {\r\n            const r = node.rotation;\r\n            Quaternion.FromEulerAnglesToRef(r.x, r.y, r.z, orientation);\r\n        }\r\n        const transform = [this._bVecToV3(node.position), this._bQuatToV4(orientation)];\r\n        return transform;\r\n    }\r\n\r\n    /**\r\n     * Adds a child shape to the given shape.\r\n     * @param shape - The parent shape.\r\n     * @param newChild - The child shape to add.\r\n     * @param childTransform - The transform of the child shape relative to the parent shape.\r\n     *\r\n     */\r\n    public addChild(shape: PhysicsShape, newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void {\r\n        const transformNative = [\r\n            translation ? this._bVecToV3(translation) : [0, 0, 0],\r\n            rotation ? this._bQuatToV4(rotation) : [0, 0, 0, 1],\r\n            scale ? this._bVecToV3(scale) : [1, 1, 1],\r\n        ];\r\n        this._hknp.HP_Shape_AddChild(shape._pluginData, newChild._pluginData, transformNative);\r\n    }\r\n\r\n    /**\r\n     * Removes a child shape from a parent shape.\r\n     * @param shape - The parent shape.\r\n     * @param childIndex - The index of the child shape to remove.\r\n     *\r\n     */\r\n    public removeChild(shape: PhysicsShape, childIndex: number): void {\r\n        this._hknp.HP_Shape_RemoveChild(shape._pluginData, childIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of children of the given shape.\r\n     *\r\n     * @param shape - The shape to get the number of children from.\r\n     * @returns The number of children of the given shape.\r\n     *\r\n     */\r\n    public getNumChildren(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetNumChildren(shape._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Calculates the bounding box of a given physics shape.\r\n     *\r\n     * @param shape - The physics shape to calculate the bounding box for.\r\n     * @returns The calculated bounding box.\r\n     *\r\n     * This method is useful for physics engines as it allows to calculate the\r\n     * boundaries of a given shape. Knowing the boundaries of a shape is important\r\n     * for collision detection and other physics calculations.\r\n     */\r\n    public getBoundingBox(shape: PhysicsShape): BoundingBox {\r\n        return {} as BoundingBox;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry of a physics body.\r\n     *\r\n     * @param body - The physics body.\r\n     * @returns An object containing the positions and indices of the body's geometry.\r\n     *\r\n     */\r\n    public getBodyGeometry(body: PhysicsBody) {\r\n        const dataInfo = body._pluginDataInstances?.length > 0 ? body._pluginDataInstances[0] : body._pluginData;\r\n        const shape = this._hknp.HP_Body_GetShape(dataInfo.hpBodyId)[1];\r\n        const geometryRes = this._hknp.HP_Shape_CreateDebugDisplayGeometry(shape);\r\n\r\n        if (geometryRes[0] != this._hknp.Result.RESULT_OK) {\r\n            return { positions: [], indices: [] };\r\n        }\r\n\r\n        const geometryInfo = this._hknp.HP_DebugGeometry_GetInfo(geometryRes[1])[1];\r\n        const positionsInPlugin = new Float32Array(this._hknp.HEAPU8.buffer, geometryInfo[0], geometryInfo[1] * 3); // 3 floats per position\r\n        const indicesInPlugin = new Uint32Array(this._hknp.HEAPU8.buffer, geometryInfo[2], geometryInfo[3] * 3); // 3 indices per triangle\r\n\r\n        // HP_DebugGeometry_Release will free the buffer in the plugin. To avoid a\r\n        // use-after-free, we need  to make a copy of the data here.\r\n        const positions = positionsInPlugin.slice(0);\r\n        const indices = indicesInPlugin.slice(0);\r\n        this._hknp.HP_DebugGeometry_Release(geometryRes[1]);\r\n        return { positions: positions, indices: indices };\r\n    }\r\n\r\n    /**\r\n     * Releases a physics shape from the physics engine.\r\n     *\r\n     * @param shape - The physics shape to be released.\r\n     * @returns void\r\n     *\r\n     * This method is useful for releasing a physics shape from the physics engine, freeing up resources and preventing memory leaks.\r\n     */\r\n    public disposeShape(shape: PhysicsShape): void {\r\n        this._hknp.HP_Shape_Release(shape._pluginData);\r\n        shape._pluginData = undefined;\r\n    }\r\n\r\n    // constraint\r\n\r\n    /**\r\n     * Initializes a physics constraint with the given parameters.\r\n     *\r\n     * @param constraint - The physics constraint to be initialized.\r\n     * @param body - The main body\r\n     * @param childBody - The child body.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     *\r\n     * This function is useful for setting up a physics constraint in a physics engine.\r\n     */\r\n    public initConstraint(constraint: PhysicsConstraint, body: PhysicsBody, childBody: PhysicsBody, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        const type = constraint.type;\r\n        const options = constraint.options;\r\n        if (!type || !options) {\r\n            Logger.Warn(\"No constraint type or options. Constraint is invalid.\");\r\n            return;\r\n        }\r\n        if ((body._pluginDataInstances.length > 0 && instanceIndex === undefined) || (childBody._pluginDataInstances.length > 0 && childInstanceIndex === undefined)) {\r\n            Logger.Warn(\"Body is instanced but no instance index was specified. Constraint will not be applied.\");\r\n            return;\r\n        }\r\n\r\n        const jointId = this._hknp.HP_Constraint_Create()[1];\r\n        constraint._pluginData = jointId;\r\n\r\n        // body parenting\r\n        const bodyA = this._getPluginReference(body, instanceIndex).hpBodyId;\r\n        const bodyB = this._getPluginReference(childBody, childInstanceIndex).hpBodyId;\r\n        this._hknp.HP_Constraint_SetParentBody(jointId, bodyA);\r\n        this._hknp.HP_Constraint_SetChildBody(jointId, bodyB);\r\n\r\n        // anchors\r\n        const pivotA = options.pivotA ? this._bVecToV3(options.pivotA) : this._bVecToV3(Vector3.Zero());\r\n        const axisA = options.axisA ?? new Vector3(1, 0, 0);\r\n        const perpAxisA = this._tmpVec3[0];\r\n        if (options.perpAxisA) {\r\n            perpAxisA.copyFrom(options.perpAxisA);\r\n        } else {\r\n            axisA.getNormalToRef(perpAxisA);\r\n        }\r\n        this._hknp.HP_Constraint_SetAnchorInParent(jointId, pivotA, this._bVecToV3(axisA), this._bVecToV3(perpAxisA));\r\n        const pivotB = options.pivotB ? this._bVecToV3(options.pivotB) : this._bVecToV3(Vector3.Zero());\r\n        const axisB = options.axisB ?? new Vector3(1, 0, 0);\r\n        const perpAxisB = this._tmpVec3[0];\r\n        if (options.perpAxisB) {\r\n            perpAxisB.copyFrom(options.perpAxisB);\r\n        } else {\r\n            axisB.getNormalToRef(perpAxisB);\r\n        }\r\n        this._hknp.HP_Constraint_SetAnchorInChild(jointId, pivotB, this._bVecToV3(axisB), this._bVecToV3(perpAxisB));\r\n\r\n        if (type == PhysicsConstraintType.LOCK) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.DISTANCE) {\r\n            const distance = options.maxDistance || 0;\r\n            const dist3d = this._hknp.ConstraintAxis.LINEAR_DISTANCE;\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, dist3d, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n            this._hknp.HP_Constraint_SetAxisMinLimit(jointId, dist3d, distance);\r\n            this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, dist3d, distance);\r\n        } else if (type == PhysicsConstraintType.HINGE) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.PRISMATIC) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.SLIDER) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.BALL_AND_SOCKET) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.SIX_DOF) {\r\n            const sixdofData: Physics6DoFConstraint = <Physics6DoFConstraint>constraint;\r\n            for (const l of sixdofData.limits) {\r\n                const axId = this._constraintAxisToNative(l.axis);\r\n                if ((l.minLimit ?? -1) == 0 && (l.maxLimit ?? -1) == 0) {\r\n                    this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n                } else {\r\n                    if (l.minLimit != undefined) {\r\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n                        this._hknp.HP_Constraint_SetAxisMinLimit(jointId, axId, l.minLimit);\r\n                    }\r\n\r\n                    if (l.maxLimit != undefined) {\r\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n                        this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, axId, l.maxLimit);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new Error(\"Unsupported Constraint Type.\");\r\n        }\r\n\r\n        const collisionEnabled = !!options.collision;\r\n        this._hknp.HP_Constraint_SetCollisionsEnabled(jointId, collisionEnabled);\r\n        this._hknp.HP_Constraint_SetEnabled(jointId, true);\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param body - The main body to which the constraint is applied.\r\n     * @param childBody - The body to which the constraint is applied.\r\n     * @param constraint - The constraint to be applied.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     */\r\n    addConstraint(body: PhysicsBody, childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        //<todo It's real weird that initConstraint() is called only after adding to a body!\r\n        this.initConstraint(constraint, body, childBody, instanceIndex, childInstanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Enables or disables a constraint in the physics engine.\r\n     * @param constraint - The constraint to enable or disable.\r\n     * @param isEnabled - Whether the constraint should be enabled or disabled.\r\n     *\r\n     */\r\n    public setEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void {\r\n        this._hknp.HP_Constraint_SetEnabled(constraint._pluginData, isEnabled);\r\n    }\r\n\r\n    /**\r\n     * Gets the enabled state of the given constraint.\r\n     * @param constraint - The constraint to get the enabled state from.\r\n     * @returns The enabled state of the given constraint.\r\n     *\r\n     */\r\n    public getEnabled(constraint: PhysicsConstraint): boolean {\r\n        return this._hknp.HP_Constraint_GetEnabled(constraint._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Enables or disables collisions for the given constraint.\r\n     * @param constraint - The constraint to enable or disable collisions for.\r\n     * @param isEnabled - Whether collisions should be enabled or disabled.\r\n     *\r\n     */\r\n    public setCollisionsEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void {\r\n        this._hknp.HP_Constraint_SetCollisionsEnabled(constraint._pluginData, isEnabled);\r\n    }\r\n\r\n    /**\r\n     * Gets whether collisions are enabled for the given constraint.\r\n     * @param constraint - The constraint to get collisions enabled for.\r\n     * @returns Whether collisions are enabled for the given constraint.\r\n     *\r\n     */\r\n    public getCollisionsEnabled(constraint: PhysicsConstraint): boolean {\r\n        return this._hknp.HP_Constraint_GetCollisionsEnabled(constraint._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the friction of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to set the friction of.\r\n     * @param axis - The axis of the constraint to set the friction of.\r\n     * @param friction - The friction to set.\r\n     * @returns void\r\n     *\r\n     */\r\n    public setAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, friction: number): void {\r\n        this._hknp.HP_Constraint_SetAxisFriction(constraint._pluginData, this._constraintAxisToNative(axis), friction);\r\n    }\r\n\r\n    /**\r\n     * Gets the friction value of the specified axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the axis friction from.\r\n     * @param axis - The axis to get the friction from.\r\n     * @returns The friction value of the specified axis.\r\n     *\r\n     */\r\n    public getAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number {\r\n        return this._hknp.HP_Constraint_GetAxisFriction(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the limit mode of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to set the axis mode of.\r\n     * @param axis - The axis to set the limit mode of.\r\n     * @param limitMode - The limit mode to set.\r\n     */\r\n    public setAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limitMode: PhysicsConstraintAxisLimitMode): void {\r\n        this._hknp.HP_Constraint_SetAxisMode(constraint._pluginData, this._constraintAxisToNative(axis), this._limitModeToNative(limitMode));\r\n    }\r\n\r\n    /**\r\n     * Gets the axis limit mode of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the axis limit mode from.\r\n     * @param axis - The axis to get the limit mode from.\r\n     * @returns The axis limit mode of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): PhysicsConstraintAxisLimitMode {\r\n        const mode = this._hknp.HP_Constraint_GetAxisMode(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n        return this._nativeToLimitMode(mode);\r\n    }\r\n\r\n    /**\r\n     * Sets the minimum limit of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the minimum limit of.\r\n     * @param axis - The axis to set the minimum limit of.\r\n     * @param limit - The minimum limit to set.\r\n     *\r\n     */\r\n    public setAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void {\r\n        this._hknp.HP_Constraint_SetAxisMinLimit(constraint._pluginData, this._constraintAxisToNative(axis), limit);\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum limit of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to get the minimum limit from.\r\n     * @param axis - The axis to get the minimum limit from.\r\n     * @returns The minimum limit of the specified axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number {\r\n        return this._hknp.HP_Constraint_GetAxisMinLimit(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum limit of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the maximum limit of the given axis.\r\n     * @param axis - The axis to set the maximum limit of.\r\n     * @param limit - The maximum limit to set.\r\n     *\r\n     */\r\n    public setAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void {\r\n        this._hknp.HP_Constraint_SetAxisMaxLimit(constraint._pluginData, this._constraintAxisToNative(axis), limit);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum limit of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the maximum limit from.\r\n     * @param axis - The axis to get the maximum limit from.\r\n     * @returns The maximum limit of the given axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number {\r\n        return this._hknp.HP_Constraint_GetAxisMaxLimit(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the motor type of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the motor type of.\r\n     * @param axis - The axis of the constraint to set the motor type of.\r\n     * @param motorType - The motor type to set.\r\n     * @returns void\r\n     *\r\n     */\r\n    public setAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, motorType: PhysicsConstraintMotorType): void {\r\n        this._hknp.HP_Constraint_SetAxisMotorType(constraint._pluginData, this._constraintAxisToNative(axis), this._constraintMotorTypeToNative(motorType));\r\n    }\r\n\r\n    /**\r\n     * Gets the motor type of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to get the motor type from.\r\n     * @param axis - The axis of the constraint to get the motor type from.\r\n     * @returns The motor type of the specified axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): PhysicsConstraintMotorType {\r\n        return this._nativeToMotorType(this._hknp.HP_Constraint_GetAxisMotorType(constraint._pluginData, this._constraintAxisToNative(axis))[1]);\r\n    }\r\n\r\n    /**\r\n     * Sets the target of an axis motor of a constraint.\r\n     *\r\n     * @param constraint - The constraint to set the axis motor target of.\r\n     * @param axis - The axis of the constraint to set the motor target of.\r\n     * @param target - The target of the axis motor.\r\n     *\r\n     */\r\n    public setAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, target: number): void {\r\n        this._hknp.HP_Constraint_SetAxisMotorTarget(constraint._pluginData, this._constraintAxisToNative(axis), target);\r\n    }\r\n\r\n    /**\r\n     * Gets the target of the motor of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the motor target from.\r\n     * @param axis - The axis of the constraint to get the motor target from.\r\n     * @returns The target of the motor of the given axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number {\r\n        return this._hknp.HP_Constraint_GetAxisMotorTarget(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum force that can be applied by the motor of the given constraint axis.\r\n     * @param constraint - The constraint to set the motor max force for.\r\n     * @param axis - The axis of the constraint to set the motor max force for.\r\n     * @param maxForce - The maximum force that can be applied by the motor.\r\n     *\r\n     */\r\n    public setAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, maxForce: number): void {\r\n        this._hknp.HP_Constraint_SetAxisMotorMaxForce(constraint._pluginData, this._constraintAxisToNative(axis), maxForce);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum force of the motor of the given constraint axis.\r\n     *\r\n     * @param constraint - The constraint to get the motor maximum force from.\r\n     * @param axis - The axis of the constraint to get the motor maximum force from.\r\n     * @returns The maximum force of the motor of the given constraint axis.\r\n     *\r\n     */\r\n    public getAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): number {\r\n        return this._hknp.HP_Constraint_GetAxisMotorMaxForce(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n    }\r\n\r\n    /**\r\n     * Disposes a physics constraint.\r\n     *\r\n     * @param constraint - The physics constraint to dispose.\r\n     *\r\n     * This method is useful for releasing the resources associated with a physics constraint, such as\r\n     * the Havok constraint, when it is no longer needed. This is important for avoiding memory leaks.\r\n     */\r\n    public disposeConstraint(constraint: PhysicsConstraint): void {\r\n        const jointId = constraint._pluginData;\r\n        this._hknp.HP_Constraint_SetEnabled(jointId, false);\r\n        this._hknp.HP_Constraint_Release(jointId);\r\n        constraint._pluginData = undefined;\r\n    }\r\n\r\n    /**\r\n     * Performs a raycast from a given start point to a given end point and stores the result in a given PhysicsRaycastResult object.\r\n     *\r\n     * @param from - The start point of the raycast.\r\n     * @param to - The end point of the raycast.\r\n     * @param result - The PhysicsRaycastResult object to store the result of the raycast.\r\n     *\r\n     * Performs a raycast. It takes in two points, from and to, and a PhysicsRaycastResult object to store the result of the raycast.\r\n     * It then performs the raycast and stores the hit data in the PhysicsRaycastResult object.\r\n     */\r\n    public raycast(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        const queryMembership = ~0;\r\n        const queryCollideWith = ~0;\r\n\r\n        result.reset(from, to);\r\n\r\n        const query = [this._bVecToV3(from), this._bVecToV3(to), [queryMembership, queryCollideWith]];\r\n        this._hknp.HP_World_CastRayWithCollector(this.world, this._queryCollector, query);\r\n\r\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\r\n            const hitData = this._hknp.HP_QueryCollector_GetCastRayResult(this._queryCollector, 0)[1];\r\n\r\n            const hitPos = hitData[1][3];\r\n            const hitNormal = hitData[1][4];\r\n            result.setHitData({ x: hitNormal[0], y: hitNormal[1], z: hitNormal[2] }, { x: hitPos[0], y: hitPos[1], z: hitPos[2] });\r\n            result.calculateHitDistance();\r\n            const hitBody = this._bodies.get(hitData[1][0][0]);\r\n            result.body = hitBody?.body;\r\n            result.bodyIndex = hitBody?.index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the collision observable for a particular physics body.\r\n     * @param body the physics body\r\n     */\r\n    public getCollisionObservable(body: PhysicsBody): Observable<IPhysicsCollisionEvent> {\r\n        const bodyId = body._pluginData.hpBodyId[0];\r\n        let observable = this._bodyCollisionObservable.get(bodyId);\r\n        if (!observable) {\r\n            observable = new Observable<IPhysicsCollisionEvent>();\r\n            this._bodyCollisionObservable.set(bodyId, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Enable collision to be reported for a body when a callback is settup on the world\r\n     * @param body the physics body\r\n     * @param enabled\r\n     */\r\n    public setCollisionCallbackEnabled(body: PhysicsBody, enabled: boolean): void {\r\n        // Register for collide events by default\r\n        const collideEvents = this._hknp.EventType.COLLISION_STARTED.value | this._hknp.EventType.COLLISION_CONTINUED.value | this._hknp.EventType.COLLISION_FINISHED.value;\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length) {\r\n            body._pluginDataInstances.forEach((bodyId) => {\r\n                this._hknp.HP_Body_SetEventMask(bodyId.hpBodyId, enabled ? collideEvents : 0);\r\n            });\r\n        } else if (body._pluginData) {\r\n            this._hknp.HP_Body_SetEventMask(body._pluginData.hpBodyId, enabled ? collideEvents : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs thru all detected collisions and filter by body\r\n     */\r\n    private _notifyCollisions() {\r\n        let eventAddress = this._hknp.HP_World_GetCollisionEvents(this.world)[1];\r\n        const event = new CollisionEvent();\r\n        const worldAddr = Number(this.world);\r\n        while (eventAddress) {\r\n            CollisionEvent.readToRef(this._hknp.HEAPU8.buffer, eventAddress, event);\r\n            event.contactOnB.position.subtractToRef(event.contactOnA.position, this._tmpVec3[0]);\r\n            const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnA.normal);\r\n            const bodyInfoA = this._bodies.get(event.contactOnA.bodyId)!;\r\n            const bodyInfoB = this._bodies.get(event.contactOnB.bodyId)!;\r\n            const collisionInfo = {\r\n                collider: bodyInfoA.body,\r\n                colliderIndex: bodyInfoA.index,\r\n                collidedAgainst: bodyInfoB.body,\r\n                collidedAgainstIndex: bodyInfoB.index,\r\n                point: event.contactOnA.position,\r\n                distance: distance,\r\n                impulse: event.impulseApplied,\r\n                normal: event.contactOnA.normal,\r\n            };\r\n            this.onCollisionObservable.notifyObservers(collisionInfo);\r\n\r\n            if (this._bodyCollisionObservable.size) {\r\n                const observableA = this._bodyCollisionObservable.get(event.contactOnA.bodyId);\r\n                const observableB = this._bodyCollisionObservable.get(event.contactOnB.bodyId);\r\n\r\n                if (observableA) {\r\n                    observableA.notifyObservers(collisionInfo);\r\n                } else if (observableB) {\r\n                    //<todo This seems like it would give unexpected results when both bodies have observers?\r\n                    // Flip collision info:\r\n                    collisionInfo.collider = bodyInfoB.body;\r\n                    collisionInfo.colliderIndex = bodyInfoB.index;\r\n                    collisionInfo.collidedAgainst = bodyInfoA.body;\r\n                    collisionInfo.collidedAgainstIndex = bodyInfoA.index;\r\n                    collisionInfo.normal = event.contactOnB.normal;\r\n                    observableB.notifyObservers(collisionInfo);\r\n                }\r\n            }\r\n\r\n            eventAddress = this._hknp.HP_World_GetNextCollisionEvent(worldAddr, eventAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of bodies in the world\r\n     */\r\n    public get numBodies() {\r\n        return this._hknp.HP_World_GetNumBodies(this.world)[1];\r\n    }\r\n\r\n    /**\r\n     * Dispose the world and free resources\r\n     */\r\n    public dispose(): void {\r\n        this._hknp.HP_QueryCollector_Release(this._queryCollector);\r\n        this._queryCollector = BigInt(0);\r\n        this._hknp.HP_World_Release(this.world);\r\n        this.world = undefined;\r\n    }\r\n\r\n    private _v3ToBvecRef(v: any, vec3: Vector3): void {\r\n        vec3.set(v[0], v[1], v[2]);\r\n    }\r\n\r\n    private _bVecToV3(v: any): any {\r\n        return [v._x, v._y, v._z];\r\n    }\r\n\r\n    private _bQuatToV4(q: Quaternion): Array<number> {\r\n        return [q._x, q._y, q._z, q._w];\r\n    }\r\n\r\n    private _constraintMotorTypeToNative(motorType: PhysicsConstraintMotorType): any {\r\n        switch (motorType) {\r\n            case PhysicsConstraintMotorType.POSITION:\r\n                return this._hknp.ConstraintMotorType.POSITION;\r\n            case PhysicsConstraintMotorType.VELOCITY:\r\n                return this._hknp.ConstraintMotorType.VELOCITY;\r\n        }\r\n        return this._hknp.ConstraintMotorType.NONE;\r\n    }\r\n\r\n    private _nativeToMotorType(motorType: any): PhysicsConstraintMotorType {\r\n        switch (motorType) {\r\n            case this._hknp.ConstraintMotorType.POSITION:\r\n                return PhysicsConstraintMotorType.POSITION;\r\n            case this._hknp.ConstraintMotorType.VELOCITY:\r\n                return PhysicsConstraintMotorType.VELOCITY;\r\n        }\r\n        return PhysicsConstraintMotorType.NONE;\r\n    }\r\n\r\n    private _materialCombineToNative(mat: PhysicsMaterialCombineMode): any {\r\n        switch (mat) {\r\n            case PhysicsMaterialCombineMode.GEOMETRIC_MEAN:\r\n                return this._hknp.MaterialCombine.GEOMETRIC_MEAN;\r\n            case PhysicsMaterialCombineMode.MINIMUM:\r\n                return this._hknp.MaterialCombine.MINIMUM;\r\n            case PhysicsMaterialCombineMode.MAXIMUM:\r\n                return this._hknp.MaterialCombine.MAXIMUM;\r\n            case PhysicsMaterialCombineMode.ARITHMETIC_MEAN:\r\n                return this._hknp.MaterialCombine.ARITHMETIC_MEAN;\r\n            case PhysicsMaterialCombineMode.MULTIPLY:\r\n                return this._hknp.MaterialCombine.MULTIPLY;\r\n        }\r\n    }\r\n\r\n    private _constraintAxisToNative(axId: PhysicsConstraintAxis): any {\r\n        switch (axId) {\r\n            case PhysicsConstraintAxis.LINEAR_X:\r\n                return this._hknp.ConstraintAxis.LINEAR_X;\r\n            case PhysicsConstraintAxis.LINEAR_Y:\r\n                return this._hknp.ConstraintAxis.LINEAR_Y;\r\n            case PhysicsConstraintAxis.LINEAR_Z:\r\n                return this._hknp.ConstraintAxis.LINEAR_Z;\r\n            case PhysicsConstraintAxis.ANGULAR_X:\r\n                return this._hknp.ConstraintAxis.ANGULAR_X;\r\n            case PhysicsConstraintAxis.ANGULAR_Y:\r\n                return this._hknp.ConstraintAxis.ANGULAR_Y;\r\n            case PhysicsConstraintAxis.ANGULAR_Z:\r\n                return this._hknp.ConstraintAxis.ANGULAR_Z;\r\n            case PhysicsConstraintAxis.LINEAR_DISTANCE:\r\n                return this._hknp.ConstraintAxis.LINEAR_DISTANCE;\r\n        }\r\n    }\r\n\r\n    private _nativeToLimitMode(mode: number): PhysicsConstraintAxisLimitMode {\r\n        switch (mode) {\r\n            case this._hknp.ConstraintAxisLimitMode.FREE:\r\n                return PhysicsConstraintAxisLimitMode.FREE;\r\n            case this._hknp.ConstraintAxisLimitMode.LIMITED:\r\n                return PhysicsConstraintAxisLimitMode.LIMITED;\r\n            case this._hknp.ConstraintAxisLimitMode.LOCKED:\r\n                return PhysicsConstraintAxisLimitMode.LOCKED;\r\n        }\r\n\r\n        return PhysicsConstraintAxisLimitMode.FREE;\r\n    }\r\n\r\n    private _limitModeToNative(mode: PhysicsConstraintAxisLimitMode): any {\r\n        switch (mode) {\r\n            case PhysicsConstraintAxisLimitMode.FREE:\r\n                return this._hknp.ConstraintAxisLimitMode.FREE;\r\n            case PhysicsConstraintAxisLimitMode.LIMITED:\r\n                return this._hknp.ConstraintAxisLimitMode.LIMITED;\r\n            case PhysicsConstraintAxisLimitMode.LOCKED:\r\n                return this._hknp.ConstraintAxisLimitMode.LOCKED;\r\n        }\r\n    }\r\n}\r\n","import type { IPhysicsCollisionEvent, IPhysicsEnginePluginV2, PhysicsMassProperties, PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport { Space } from \"core/Maths/math.axis\";\r\nimport type { Observable, Observer } from \"../../Misc/observable\";\r\nimport type { Node } from \"../../node\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\n\r\n/**\r\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\r\n * the user to set the mass and velocity of the body, which can then be used to calculate the\r\n * motion of the body in the physics engine.\r\n */\r\nexport class PhysicsBody {\r\n    /**\r\n     * V2 Physics plugin private data for single Transform\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * V2 Physics plugin private data for instances\r\n     */\r\n    public _pluginDataInstances: Array<any> = [];\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n    /**\r\n     * The engine used to create and manage this Physics Body\r\n     */\r\n    private _physicsEngine: PhysicsEngine;\r\n    /**\r\n     * If the collision callback is enabled\r\n     */\r\n    private _collisionCBEnabled: boolean = false;\r\n    /**\r\n     * The transform node associated with this Physics Body\r\n     */\r\n    transformNode: TransformNode;\r\n    /**\r\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\r\n     * True by default for maximum performance.\r\n     */\r\n    disablePreStep: boolean = true;\r\n\r\n    /**\r\n     * Physics engine will try to make this body sleeping and not active\r\n     */\r\n    public startAsleep: boolean;\r\n\r\n    private _nodeDisposeObserver: Nullable<Observer<Node>>;\r\n\r\n    /**\r\n     * Constructs a new physics body for the given node.\r\n     * @param transformNode - The Transform Node to construct the physics body for.\r\n     * @param motionType - The motion type of the physics body. The options are:\r\n     *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.\r\n     *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.\r\n     *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.\r\n     * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.\r\n     * @param scene - The scene containing the physics engine.\r\n     *\r\n     * This code is useful for creating a physics body for a given Transform Node in a scene.\r\n     * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\r\n     * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\r\n     */\r\n    constructor(transformNode: TransformNode, motionType: PhysicsMotionType, startsAsleep: boolean, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine() as PhysicsEngine;\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        this._physicsEngine = physicsEngine;\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n        if (!transformNode.rotationQuaternion) {\r\n            transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\r\n        }\r\n\r\n        this.startAsleep = startsAsleep;\r\n\r\n        // instances?\r\n        const m = transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.initBodyInstances(this, motionType, m);\r\n        } else {\r\n            // single instance\r\n            this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);\r\n        }\r\n        this.transformNode = transformNode;\r\n        transformNode.physicsBody = this;\r\n        physicsEngine.addBody(this);\r\n\r\n        this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PhysicsBody\".\r\n     * @returns \"PhysicsBody\"\r\n     */\r\n    public getClassName() {\r\n        return \"PhysicsBody\";\r\n    }\r\n\r\n    /**\r\n     * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\r\n     * @param transformNode transformNode that will be used for the cloned PhysicsBody\r\n     * @returns the newly cloned PhysicsBody\r\n     */\r\n    public clone(transformNode: TransformNode): PhysicsBody {\r\n        const clonedBody = new PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());\r\n        clonedBody.shape = this.shape;\r\n        return clonedBody;\r\n    }\r\n\r\n    /**\r\n     * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\r\n     */\r\n    public updateBodyInstances() {\r\n        const m = this.transformNode as Mesh;\r\n        if (m.hasThinInstances) {\r\n            this._physicsPlugin.updateBodyInstances(this, m);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This returns the number of internal instances of the physics body\r\n     */\r\n    public get numInstances(): number {\r\n        return this._pluginDataInstances.length;\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of the physics body.\r\n     * @param shape - The shape of the physics body.\r\n     *\r\n     * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\r\n     * The shape is used to calculate the body's mass, inertia, and other properties.\r\n     */\r\n    public set shape(shape: Nullable<PhysicsShape>) {\r\n        this._physicsPlugin.setShape(this, shape);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the physics shape associated with this object.\r\n     *\r\n     * @returns The physics shape associated with this object, or `undefined` if no\r\n     * shape is associated.\r\n     *\r\n     * This method is useful for retrieving the physics shape associated with this object,\r\n     * which can be used to apply physical forces to the object or to detect collisions.\r\n     */\r\n    public get shape(): Nullable<PhysicsShape> {\r\n        return this._physicsPlugin.getShape(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask for the physics engine.\r\n     *\r\n     * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\r\n     *\r\n     * This method is useful for setting the event mask for the physics engine, which determines which events\r\n     * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\r\n     */\r\n    public setEventMask(eventMask: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the event mask of the physics engine.\r\n     *\r\n     * @returns The event mask of the physics engine.\r\n     *\r\n     * This method is useful for getting the event mask of the physics engine,\r\n     * which is used to determine which events the engine will respond to.\r\n     * This is important for ensuring that the engine is responding to the correct events and not\r\n     * wasting resources on unnecessary events.\r\n     */\r\n    public getEventMask(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getEventMask(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public setMotionType(motionType: PhysicsMotionType, instanceIndex?: number) {\r\n        this._physicsPlugin.setMotionType(this, motionType, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\r\n     */\r\n    public getMotionType(instanceIndex?: number): PhysicsMotionType {\r\n        return this._physicsPlugin.getMotionType(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\r\n     * This method is useful for computing the initial mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass; these values are important for accurately simulating the physics of the\r\n     * object in the physics engine, and computing values based on the shape will provide you with reasonable\r\n     * intial values, which you can then customize.\r\n     */\r\n    public computeMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.computeMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of the physics object.\r\n     *\r\n     * @param massProps - The mass properties to set.\r\n     * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.\r\n     *\r\n     * This method is useful for setting the mass properties of a physics object, such as its mass,\r\n     * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\r\n     */\r\n    public setMassProperties(massProps: PhysicsMassProperties, instanceIndex?: number): void {\r\n        this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the mass properties of the object.\r\n     *\r\n     * @returns The mass properties of the object.\r\n     *\r\n     * This method is useful for physics simulations, as it allows the user to\r\n     * retrieve the mass properties of the object, such as its mass, center of mass,\r\n     * and moment of inertia. This information is necessary for accurate physics\r\n     * simulations.\r\n     */\r\n    public getMassProperties(instanceIndex?: number): PhysicsMassProperties {\r\n        return this._physicsPlugin.getMassProperties(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the physics body.\r\n     *\r\n     * @param damping - The linear damping value.\r\n     *\r\n     * This method is useful for controlling the linear damping of the physics body,\r\n     * which is the rate at which the body's velocity decreases over time. This is useful for simulating\r\n     * the effects of air resistance or other forms of friction.\r\n     */\r\n    public setLinearDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the physics body.\r\n     * @returns The linear damping of the physics body.\r\n     *\r\n     * This method is useful for retrieving the linear damping of the physics body, which is the amount of\r\n     * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\r\n     * in a game.\r\n     */\r\n    public getLinearDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getLinearDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of the physics body.\r\n     * @param damping The angular damping of the body.\r\n     *\r\n     * This method is useful for controlling the angular velocity of a physics body.\r\n     * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\r\n     * This can be used to create realistic physical behavior in a physics engine.\r\n     */\r\n    public setAngularDamping(damping: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of the physics body.\r\n     *\r\n     * @returns The angular damping of the physics body.\r\n     *\r\n     * This method is useful for getting the angular damping of the physics body,\r\n     * which is the rate of reduction of the angular velocity over time.\r\n     * This is important for simulating realistic physics behavior in a game.\r\n     */\r\n    public getAngularDamping(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getAngularDamping(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics object.\r\n     * @param linVel - The linear velocity to set.\r\n     *\r\n     * This method is useful for setting the linear velocity of a physics object,\r\n     * which is necessary for simulating realistic physics in a game engine.\r\n     * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\r\n     * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\r\n     */\r\n    public setLinearVelocity(linVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of the physics body and stores it in the given vector3.\r\n     * @param linVel - The vector3 to store the linear velocity in.\r\n     *\r\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\r\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.*/\r\n    public getLinearVelocityToRef(linVel: Vector3, instanceIndex?: number): void {\r\n        return this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics object.\r\n     * @param angVel - The angular velocity to set.\r\n     *\r\n     * This method is useful for setting the angular velocity of a physics object, which is necessary for\r\n     * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\r\n     * which is important for simulating realistic motion.\r\n     */\r\n    public setAngularVelocity(angVel: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of the physics body and stores it in the given vector3.\r\n     * @param angVel - The vector3 to store the angular velocity in.\r\n     *\r\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\r\n     * rotational speed. This information can be used to create realistic physics simulations.\r\n     */\r\n    public getAngularVelocityToRef(angVel: Vector3, instanceIndex?: number): void {\r\n        return this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to the physics object.\r\n     *\r\n     * @param impulse The impulse vector.\r\n     * @param location The location of the impulse.\r\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\r\n     *\r\n     * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyImpulse(impulse: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Applies a force to the physics object.\r\n     *\r\n     * @param force The force vector.\r\n     * @param location The location of the force.\r\n     * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.\r\n     *\r\n     * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\r\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\r\n     */\r\n    public applyForce(force: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._physicsPlugin.applyForce(this, force, location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the geometry of the body from the physics plugin.\r\n     *\r\n     * @returns The geometry of the body.\r\n     *\r\n     * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\r\n     */\r\n    public getGeometry(): {} {\r\n        return this._physicsPlugin.getBodyGeometry(this);\r\n    }\r\n\r\n    /**\r\n     * Returns an observable that will be notified for all collisions happening for event-enabled bodies\r\n     * @returns Observable\r\n     */\r\n    public getCollisionObservable(): Observable<IPhysicsCollisionEvent> {\r\n        return this._physicsPlugin.getCollisionObservable(this);\r\n    }\r\n\r\n    /**\r\n     * Enable or disable collision callback for this PhysicsBody.\r\n     * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\r\n     */\r\n    public setCollisionCallbackEnabled(enabled: boolean): void {\r\n        this._collisionCBEnabled = enabled;\r\n        this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\r\n    }\r\n\r\n    /*\r\n     * Get the center of the object in world space.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorld(instanceIndex?: number): Vector3 {\r\n        const ref = new Vector3();\r\n        return this.getObjectCenterWorldToRef(ref, instanceIndex);\r\n    }\r\n\r\n    /*\r\n     * Get the center of the object in world space.\r\n     * @param ref - The vector3 to store the result in.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\r\n     * @returns geometric center of the associated mesh\r\n     */\r\n    public getObjectCenterWorldToRef(ref: Vector3, instanceIndex?: number): Vector3 {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            const index = instanceIndex || 0;\r\n            const matrixData = (this.transformNode as Mesh)._thinInstanceDataStorage.matrixData;\r\n            if (matrixData) {\r\n                ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);\r\n            }\r\n        } else {\r\n            ref.copyFrom(this.transformNode.position);\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param childBody - The body to which the constraint will be applied.\r\n     * @param constraint - The constraint to be applied.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     *\r\n     */\r\n    public addConstraint(childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sync with a bone\r\n     * @param bone The bone that the impostor will be synced to.\r\n     * @param boneMesh The mesh that the bone is influencing.\r\n     * @param jointPivot The pivot of the joint / bone in local space.\r\n     * @param distToJoint Optional distance from the impostor to the joint.\r\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\r\n     * @param boneAxis Optional vector3 axis the bone is aligned with\r\n     */\r\n    public syncWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3) {\r\n        const mesh = this.transformNode;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            if (adjustRotation) {\r\n                const tempQuat = TmpVectors.Quaternion[0];\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\r\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\r\n            } else {\r\n                bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\r\n            }\r\n        }\r\n\r\n        const pos = TmpVectors.Vector3[0];\r\n        const boneDir = TmpVectors.Vector3[1];\r\n\r\n        if (!boneAxis) {\r\n            boneAxis = TmpVectors.Vector3[2];\r\n            boneAxis.x = 0;\r\n            boneAxis.y = 1;\r\n            boneAxis.z = 0;\r\n        }\r\n\r\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\r\n        bone.getAbsolutePositionToRef(boneMesh, pos);\r\n\r\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\r\n            distToJoint = jointPivot.length();\r\n        }\r\n\r\n        if (distToJoint !== undefined && distToJoint !== null) {\r\n            pos.x += boneDir.x * distToJoint;\r\n            pos.y += boneDir.y * distToJoint;\r\n            pos.z += boneDir.z * distToJoint;\r\n        }\r\n\r\n        mesh.setAbsolutePosition(pos);\r\n    }\r\n\r\n    /**\r\n     * Executes a callback on the body or all of the instances of a body\r\n     * @param callback the callback to execute\r\n     */\r\n    public iterateOverAllInstances(callback: (body: PhysicsBody, instanceIndex?: number) => void) {\r\n        if (this._pluginDataInstances?.length > 0) {\r\n            for (let i = 0; i < this._pluginDataInstances.length; i++) {\r\n                callback(this, i);\r\n            }\r\n        } else {\r\n            callback(this, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity factor of the physics body\r\n     * @param factor the gravity factor to set\r\n     * @param instanceIndex the instance of the body to set, if undefined all instances will be set\r\n     */\r\n    public setGravityFactor(factor: number, instanceIndex?: number) {\r\n        this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Gets the gravity factor of the physics body\r\n     * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned\r\n     * @returns the gravity factor\r\n     */\r\n    public getGravityFactor(instanceIndex?: number): number {\r\n        return this._physicsPlugin.getGravityFactor(this, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Disposes the body from the physics engine.\r\n     *\r\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\r\n     */\r\n    public dispose() {\r\n        // Disable collisions CB so it doesn't fire when the body is disposed\r\n        if (this._collisionCBEnabled) {\r\n            this.setCollisionCallbackEnabled(false);\r\n        }\r\n        if (this._nodeDisposeObserver) {\r\n            this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\r\n            this._nodeDisposeObserver = null;\r\n        }\r\n        this._physicsEngine.removeBody(this);\r\n        this._physicsPlugin.removeBody(this);\r\n        this._physicsPlugin.disposeBody(this);\r\n        this._pluginData = null;\r\n        this._pluginDataInstances.length = 0;\r\n    }\r\n}\r\n","/**\r\n * Determines how values from the PhysicsMaterial are combined when\r\n * two objects are in contact. When each PhysicsMaterial specifies\r\n * a different combine mode for some property, the combine mode which\r\n * is used will be selected based on their order in this enum - i.e.\r\n * a value later in this list will be preferentially used.\r\n */\r\nexport enum PhysicsMaterialCombineMode {\r\n    /**\r\n     * The final value will be the geometric mean of the two values:\r\n     * sqrt( valueA *  valueB )\r\n     */\r\n    GEOMETRIC_MEAN,\r\n    /**\r\n     * The final value will be the smaller of the two:\r\n     * min( valueA , valueB )\r\n     */\r\n    MINIMUM,\r\n    /* The final value will be the larger of the two:\r\n     * max( valueA , valueB )\r\n     */\r\n    MAXIMUM,\r\n    /* The final value will be the arithmetic mean of the two values:\r\n     * (valueA + valueB) / 2\r\n     */\r\n    ARITHMETIC_MEAN,\r\n    /**\r\n     * The final value will be the product of the two values:\r\n     * valueA * valueB\r\n     */\r\n    MULTIPLY,\r\n}\r\n\r\n/**\r\n * Physics material class\r\n * Helps setting friction and restitution that are used to compute responding forces in collision response\r\n */\r\nexport interface PhysicsMaterial {\r\n    /**\r\n     * Sets the friction used by this material\r\n     *\r\n     * The friction determines how much an object will slow down when it is in contact with another object.\r\n     * This is important for simulating realistic physics, such as when an object slides across a surface.\r\n     *\r\n     * If not provided, a default value of 0.5 will be used.\r\n     */\r\n    friction?: number;\r\n\r\n    /**\r\n     * Sets the static friction used by this material.\r\n     *\r\n     * Static friction is the friction that must be overcome before a pair of objects can start sliding\r\n     * relative to each other; for physically-realistic behaviour, it should be at least as high as the\r\n     * normal friction value. If not provided, the friction value will be used\r\n     */\r\n    staticFriction?: number;\r\n\r\n    /**\r\n     * Sets the restitution of the physics material.\r\n     *\r\n     * The restitution is a factor which describes, the amount of energy that is retained after a collision,\r\n     * which should be a number between 0 and 1..\r\n     *\r\n     * A restitution of 0 means that no energy is retained and the objects will not bounce off each other,\r\n     * while a restitution of 1 means that all energy is retained and the objects will bounce.\r\n     *\r\n     * Note, though, due that due to the simulation implementation, an object with a restitution of 1 may\r\n     * still lose energy over time.\r\n     *\r\n     * If not provided, a default value of 0 will be used.\r\n     */\r\n    restitution?: number;\r\n\r\n    /**\r\n     * Describes how two different friction values should be combined. See PhysicsMaterialCombineMode for\r\n     * more details.\r\n     *\r\n     * If not provided, will use PhysicsMaterialCombineMode.MINIMUM\r\n     */\r\n    frictionCombine?: PhysicsMaterialCombineMode;\r\n\r\n    /**\r\n     * Describes how two different restitution values should be combined. See PhysicsMaterialCombineMode for\r\n     * more details.\r\n     *\r\n     * If not provided, will use PhysicsMaterialCombineMode.MAXIMUM\r\n     */\r\n    restitutionCombine?: PhysicsMaterialCombineMode;\r\n}\r\n","import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport { PhysicsShapeType } from \"./IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2, PhysicsShapeParameters } from \"./IPhysicsEnginePlugin\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport { Matrix, Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\n\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Options for creating a physics shape\r\n */\r\nexport interface PhysicShapeOptions {\r\n    /**\r\n     * The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\r\n     */\r\n    type?: PhysicsShapeType;\r\n    /**\r\n     * The parameters of the shape. Varies depending of the shape type.\r\n     */\r\n    parameters?: PhysicsShapeParameters;\r\n    /**\r\n     * Reference to an already existing physics shape in the plugin.\r\n     */\r\n    pluginData?: any;\r\n}\r\n\r\n/**\r\n * PhysicsShape class.\r\n * This class is useful for creating a physics shape that can be used in a physics engine.\r\n * A Physic Shape determine how collision are computed. It must be attached to a body.\r\n */\r\nexport class PhysicsShape {\r\n    /**\r\n     * V2 Physics plugin private data for single shape\r\n     */\r\n    public _pluginData: any = undefined;\r\n    /**\r\n     * The V2 plugin used to create and manage this Physics Body\r\n     */\r\n    private _physicsPlugin: IPhysicsEnginePluginV2;\r\n\r\n    private _type: PhysicsShapeType;\r\n\r\n    private _material: PhysicsMaterial;\r\n\r\n    /**\r\n     * Constructs a new physics shape.\r\n     * @param options The options for the physics shape. These are:\r\n     *  * type: The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\r\n     *  * parameters: The parameters of the shape.\r\n     *  * pluginData: The plugin data of the shape. This is used if you already have a reference to the object on the plugin side.\r\n     * You need to specify either type or pluginData.\r\n     * @param scene The scene the shape belongs to.\r\n     *\r\n     * This code is useful for creating a new physics shape with the given type, options, and scene.\r\n     * It also checks that the physics engine and plugin version are correct.\r\n     * If not, it throws an error. This ensures that the shape is created with the correct parameters and is compatible with the physics engine.\r\n     */\r\n    constructor(options: PhysicShapeOptions, scene: Scene) {\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const physicsEngine = scene.getPhysicsEngine();\r\n        if (!physicsEngine) {\r\n            throw new Error(\"No Physics Engine available.\");\r\n        }\r\n        if (physicsEngine.getPluginVersion() != 2) {\r\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\r\n        }\r\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\r\n        if (!physicsPlugin) {\r\n            throw new Error(\"No Physics Plugin available.\");\r\n        }\r\n        this._physicsPlugin = physicsPlugin as IPhysicsEnginePluginV2;\r\n\r\n        if (options.pluginData !== undefined && options.pluginData !== null) {\r\n            this._pluginData = options.pluginData;\r\n            this._type = this._physicsPlugin.getShapeType(this);\r\n        } else if (options.type !== undefined && options.type !== null) {\r\n            this._type = options.type;\r\n            const parameters = options.parameters ?? {};\r\n            this._physicsPlugin.initShape(this, options.type, parameters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PhysicsShape\".\r\n     * @returns \"PhysicsShape\"\r\n     */\r\n    public getClassName() {\r\n        return \"PhysicsShape\";\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public get type(): PhysicsShapeType {\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Set the membership mask of a shape. This is a bitfield of arbitrary\r\n     * \"categories\" to which the shape is a member. This is used in combination\r\n     * with the collide mask to determine if this shape should collide with\r\n     * another.\r\n     *\r\n     * @param membershipMask Bitfield of categories of this shape.\r\n     */\r\n    public set filterMembershipMask(membershipMask: number) {\r\n        this._physicsPlugin.setShapeFilterMembershipMask(this, membershipMask);\r\n    }\r\n\r\n    /**\r\n     * Get the membership mask of a shape.\r\n     * @returns Bitmask of categories which this shape is a member of.\r\n     */\r\n    public get filterMembershipMask(): number {\r\n        return this._physicsPlugin.getShapeFilterMembershipMask(this);\r\n    }\r\n\r\n    /**\r\n     * Sets the collide mask of a shape. This is a bitfield of arbitrary\r\n     * \"categories\" to which this shape collides with. Given two shapes,\r\n     * the engine will check if the collide mask and membership overlap:\r\n     * shapeA.filterMembershipMask & shapeB.filterCollideMask\r\n     *\r\n     * If this value is zero (i.e. shapeB only collides with categories\r\n     * which shapeA is _not_ a member of) then the shapes will not collide.\r\n     *\r\n     * Note, the engine will also perform the same test with shapeA and\r\n     * shapeB swapped; the shapes will not collide if either shape has\r\n     * a collideMask which prevents collision with the other shape.\r\n     *\r\n     * @param collideMask Bitmask of categories this shape should collide with\r\n     */\r\n    public set filterCollideMask(collideMask: number) {\r\n        this._physicsPlugin.setShapeFilterCollideMask(this, collideMask);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns Bitmask of categories that this shape should collide with\r\n     */\r\n    public get filterCollideMask(): number {\r\n        return this._physicsPlugin.getShapeFilterCollideMask(this);\r\n    }\r\n    /**\r\n     *\r\n     * @param material\r\n     */\r\n    public set material(material: PhysicsMaterial) {\r\n        this._physicsPlugin.setMaterial(this, material);\r\n        this._material = material;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns\r\n     */\r\n    public get material(): PhysicsMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param density\r\n     */\r\n    public set density(density: number) {\r\n        this._physicsPlugin.setDensity(this, density);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public get density(): number {\r\n        return this._physicsPlugin.getDensity(this);\r\n    }\r\n\r\n    /**\r\n     * Utility to add a child shape to this container,\r\n     * automatically computing the relative transform between\r\n     * the container shape and the child instance.\r\n     *\r\n     * @param parentTransform The transform node associated with this shape\r\n     * @param newChild The new PhysicsShape to add\r\n     * @param childTransform The transform node associated with the child shape\r\n     */\r\n    public addChildFromParent(parentTransform: TransformNode, newChild: PhysicsShape, childTransform: TransformNode): void {\r\n        const childToWorld = childTransform.computeWorldMatrix(true);\r\n        const parentToWorld = parentTransform.computeWorldMatrix(true);\r\n        const childToParent = TmpVectors.Matrix[0];\r\n        childToWorld.multiplyToRef(Matrix.Invert(parentToWorld), childToParent);\r\n        const translation = TmpVectors.Vector3[0];\r\n        const rotation = TmpVectors.Quaternion[0];\r\n        const scale = TmpVectors.Vector3[1];\r\n        childToParent.decompose(scale, rotation, translation);\r\n        this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\r\n    }\r\n\r\n    /**\r\n     * Adds a child shape to a container with an optional transform\r\n     * @param newChild The new PhysicsShape to add\r\n     * @param translation Optional position of the child shape relative to this shape\r\n     * @param rotation Optional rotation of the child shape relative to this shape\r\n     * @param scale Optional scale of the child shape relative to this shape\r\n     */\r\n    public addChild(newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void {\r\n        this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param childIndex\r\n     */\r\n    public removeChild(childIndex: number): void {\r\n        this._physicsPlugin.removeChild(this, childIndex);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns\r\n     */\r\n    public getNumChildren(): number {\r\n        return this._physicsPlugin.getNumChildren(this);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public getBoundingBox(): BoundingBox {\r\n        return this._physicsPlugin.getBoundingBox(this);\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public dispose() {\r\n        this._physicsPlugin.disposeShape(this);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a sphere shape\r\n */\r\nexport class PhysicsShapeSphere extends PhysicsShape {\r\n    /**\r\n     * Constructor for the Sphere Shape\r\n     * @param center local center of the sphere\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(center: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.SPHERE, parameters: { center: center, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mesh\r\n     * @returns PhysicsShapeSphere\r\n     */\r\n    static FromMesh(mesh: AbstractMesh) {\r\n        const bounds = mesh.getBoundingInfo();\r\n        const centerLocal = bounds.boundingSphere.center;\r\n        const he = bounds.boundingBox.extendSize;\r\n        const radius = Math.max(he.x, he.y, he.z);\r\n        return new PhysicsShapeSphere(centerLocal, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a capsule shape\r\n */\r\nexport class PhysicsShapeCapsule extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param pointA Starting point that defines the capsule segment\r\n     * @param pointB ending point of that same segment\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(pointA: Vector3, pointB: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CAPSULE, parameters: { pointA: pointA, pointB: pointB, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     * Derive an approximate capsule from the transform node. Note, this is\r\n     * not the optimal bounding capsule.\r\n     * @param TransformNode node Node from which to derive a cylinder shape\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeCapsule {\r\n        const boundsLocal = mesh.getBoundingInfo();\r\n        const radius = boundsLocal.boundingBox.extendSize.x;\r\n        const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y - radius, 0);\r\n        const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\r\n        const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\r\n        return new PhysicsShapeCapsule(pointA, pointB, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a cylinder shape\r\n */\r\nexport class PhysicsShapeCylinder extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param pointA Starting point that defines the cylinder segment\r\n     * @param pointB ending point of that same segment\r\n     * @param radius radius\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(pointA: Vector3, pointB: Vector3, radius: number, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CYLINDER, parameters: { pointA: pointA, pointB: pointB, radius: radius } }, scene);\r\n    }\r\n\r\n    /**\r\n     * Derive an approximate cylinder from the transform node. Note, this is\r\n     * not the optimal bounding cylinder.\r\n     * @param TransformNode node Node from which to derive a cylinder shape\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeCylinder {\r\n        const boundsLocal = mesh.getBoundingInfo();\r\n        const radius = boundsLocal.boundingBox.extendSize.x;\r\n        const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y, 0);\r\n        const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\r\n        const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\r\n        return new PhysicsShapeCylinder(pointA, pointB, radius, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a box shape\r\n */\r\nexport class PhysicsShapeBox extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param center local center of the sphere\r\n     * @param rotation local orientation\r\n     * @param extents size of the box in each direction\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(center: Vector3, rotation: Quaternion, extents: Vector3, scene: Scene) {\r\n        super({ type: PhysicsShapeType.BOX, parameters: { center: center, rotation: rotation, extents: extents } }, scene);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param mesh\r\n     * @returns PhysicsShapeBox\r\n     */\r\n    static FromMesh(mesh: AbstractMesh): PhysicsShapeBox {\r\n        const bounds = mesh.getBoundingInfo();\r\n        const centerLocal = bounds.boundingBox.center;\r\n        const extents = bounds.boundingBox.extendSize.scale(2.0); //<todo.eoin extendSize seems to really be half-extents?\r\n        return new PhysicsShapeBox(centerLocal, Quaternion.Identity(), extents, mesh.getScene());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a convex hull shape\r\n */\r\nexport class PhysicsShapeConvexHull extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param mesh the mesh to be used as topology infos for the convex hull\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(mesh: Mesh, scene: Scene) {\r\n        super({ type: PhysicsShapeType.CONVEX_HULL, parameters: { mesh: mesh } }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * Helper object to create a mesh shape\r\n */\r\nexport class PhysicsShapeMesh extends PhysicsShape {\r\n    /**\r\n     *\r\n     * @param mesh the mesh topology that will be used to create the shape\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(mesh: Mesh, scene: Scene) {\r\n        super({ type: PhysicsShapeType.MESH, parameters: { mesh: mesh } }, scene);\r\n    }\r\n}\r\n\r\n/**\r\n * A shape container holds a variable number of shapes. Use AddChild to append to newly created parent container.\r\n */\r\nexport class PhysicsShapeContainer extends PhysicsShape {\r\n    /**\r\n     * Constructor of the Shape container\r\n     * @param scene scene to attach to\r\n     */\r\n    constructor(scene: Scene) {\r\n        super({ type: PhysicsShapeType.CONTAINER, parameters: {} }, scene);\r\n    }\r\n}\r\n"],"names":["PhysicsConstraintAxisLimitMode","PhysicsConstraintAxis","PhysicsConstraintType","PhysicsShapeType","PhysicsConstraintMotorType","PhysicsMotionType","MeshAccumulator","mesh","collectIndices","scene","_vertices","_indices","worldFromRoot","computeWorldMatrix","rootScale","rootOrientation","rootTranslation","decompose","this","_bodyFromWorld","rotationQuaternion","position","invert","_isRightHanded","useRightHandedSystem","_collectIndices","addMesh","includeChildren","indexOffset","length","shapeFromBody","multiply","vertexData","getVerticesData","numVerts","v","pos","push","meshIndices","getIndices","i","getChildMeshes","filter","m","physicsBody","forEach","getVertices","plugin","nFloats","nBytes","bufferBegin","_malloc","ret","Float32Array","HEAPU8","buffer","x","y","z","freeBuffer","arr","_free","byteOffset","getTriangles","Int32Array","BodyPluginData","bodyId","hpBodyId","userMassProps","centerOfMass","undefined","mass","inertia","inertiaOrientation","ContactPoint","BigInt","normal","CollisionEvent","contactOnA","contactOnB","impulseApplied","static","offset","eventOut","intBuf","floatBuf","set","offA","offB","HavokPlugin","_useDeltaForWorldStep","hpInjection","HK","_hknp","name","_fixedTimeStep","_timeStep","_tmpVec3","_bodies","Map","_bodyCollisionObservable","onCollisionObservable","isSupported","world","HP_World_Create","_queryCollector","HP_QueryCollector_Create","setGravity","gravity","HP_World_SetGravity","_bVecToV3","setTimeStep","timeStep","getTimeStep","executeStep","delta","physicsBodies","disablePreStep","setPhysicsBodyTransformation","transformNode","HP_World_Step","_bodyBuffer","HP_World_GetBodyBuffer","sync","_notifyCollisions","getPluginVersion","initBody","body","motionType","orientation","_pluginData","HP_Body_Create","_internalSetMotionType","transform","_bQuatToV4","HP_Body_SetQTransform","HP_World_AddBody","startAsleep","index","removeBody","_pluginDataInstances","instance","delete","HP_World_RemoveBody","initBodyInstances","instancesCount","_thinInstanceDataStorage","matrixData","_createOrUpdateBodyInstances","startIndex","endIndex","update","rotation","rotationMatrix","hkbody","setRowFromFloats","w","pluginData","_internalUpdateMassProperties","worldTransformOffset","HP_Body_GetWorldTransformOffset","updateBodyInstances","pluginInstancesCount","getMotionType","firstBodyShape","HP_Body_GetShape","HP_Body_SetShape","instancesToRemove","pop","HP_Body_Release","syncTransform","bufOffset","transformBuffer","mi","thinInstanceBufferUpdated","bodyTransform","HP_Body_GetQTransform","bodyTranslation","bodyOrientation","quat","parent","absoluteRotationQuaternion","conjugateToRef","multiplyInPlace","absolutePosition","localPosition","copyFrom","toEulerAnglesToRef","e","console","log","message","setShape","shape","shapeHandle","_getPluginReference","instanceIndex","getShape","pluginRef","shapePluginData","getScene","getShapeType","type","HP_Shape_GetType","setEventMask","eventMask","_applyToBodyOrInstances","bodyPluginData","HP_Body_SetEventMask","getEventMask","HP_Body_GetEventMask","_fromMassPropertiesTuple","massPropsTuple","newProps","_internalComputeMassProperties","massProps","asArray","HP_Body_SetMassProperties","HP_Body_SetMotionType","MotionType","STATIC","KINEMATIC","DYNAMIC","setMotionType","HP_Body_GetMotionType","Error","shapeRes","Result","RESULT_OK","shapeMass","HP_Shape_BuildMassProperties","computeMassProperties","computed","setMassProperties","getMassProperties","HP_Body_GetMassProperties","setLinearDamping","damping","HP_Body_SetLinearDamping","getLinearDamping","HP_Body_GetLinearDamping","setAngularDamping","HP_Body_SetAngularDamping","getAngularDamping","HP_Body_GetAngularDamping","setLinearVelocity","linVel","HP_Body_SetLinearVelocity","getLinearVelocityToRef","lv","HP_Body_GetLinearVelocity","_v3ToBvecRef","fnToApply","applyImpulse","impulse","location","HP_Body_ApplyImpulse","applyForce","force","scaleToRef","setAngularVelocity","angVel","HP_Body_SetAngularVelocity","getAngularVelocityToRef","av","HP_Body_GetAngularVelocity","node","numInstances","_getTransformInfos","setGravityFactor","factor","HP_Body_SetGravityFactor","getGravityFactor","HP_Body_GetGravityFactor","disposeBody","initShape","options","radius","center","HP_Shape_CreateSphere","extent","extents","HP_Shape_CreateBox","pointA","pointB","HP_Shape_CreateCapsule","HP_Shape_CreateContainer","HP_Shape_CreateCylinder","includeChildMeshes","needIndices","accum","positions","numVec3s","HP_Shape_CreateConvexHull","triangles","numTriangles","HP_Shape_CreateMesh","setShapeFilterMembershipMask","membershipMask","collideWith","HP_Shape_GetFilterInfo","HP_Shape_SetFilterInfo","getShapeFilterMembershipMask","setShapeFilterCollideMask","collideMask","membership","getShapeFilterCollideMask","setMaterial","material","dynamicFriction","friction","staticFriction","restitution","frictionCombine","restitutionCombine","hpMaterial","_materialCombineToNative","HP_Shape_SetMaterial","setDensity","density","HP_Shape_SetDensity","getDensity","HP_Shape_GetDensity","r","addChild","newChild","translation","scale","transformNative","HP_Shape_AddChild","removeChild","childIndex","HP_Shape_RemoveChild","getNumChildren","HP_Shape_GetNumChildren","getBoundingBox","getBodyGeometry","dataInfo","geometryRes","HP_Shape_CreateDebugDisplayGeometry","indices","geometryInfo","HP_DebugGeometry_GetInfo","positionsInPlugin","indicesInPlugin","Uint32Array","slice","HP_DebugGeometry_Release","disposeShape","HP_Shape_Release","initConstraint","constraint","childBody","childInstanceIndex","jointId","HP_Constraint_Create","bodyA","bodyB","HP_Constraint_SetParentBody","HP_Constraint_SetChildBody","pivotA","axisA","perpAxisA","getNormalToRef","HP_Constraint_SetAnchorInParent","pivotB","axisB","perpAxisB","HP_Constraint_SetAnchorInChild","HP_Constraint_SetAxisMode","ConstraintAxis","LINEAR_X","ConstraintAxisLimitMode","LOCKED","LINEAR_Y","LINEAR_Z","ANGULAR_X","ANGULAR_Y","ANGULAR_Z","distance","maxDistance","dist3d","LINEAR_DISTANCE","LIMITED","HP_Constraint_SetAxisMinLimit","HP_Constraint_SetAxisMaxLimit","sixdofData","l","limits","axId","_constraintAxisToNative","axis","minLimit","maxLimit","collisionEnabled","collision","HP_Constraint_SetCollisionsEnabled","HP_Constraint_SetEnabled","addConstraint","setEnabled","isEnabled","getEnabled","HP_Constraint_GetEnabled","setCollisionsEnabled","getCollisionsEnabled","HP_Constraint_GetCollisionsEnabled","setAxisFriction","HP_Constraint_SetAxisFriction","getAxisFriction","HP_Constraint_GetAxisFriction","setAxisMode","limitMode","_limitModeToNative","getAxisMode","mode","HP_Constraint_GetAxisMode","_nativeToLimitMode","setAxisMinLimit","limit","getAxisMinLimit","HP_Constraint_GetAxisMinLimit","setAxisMaxLimit","getAxisMaxLimit","HP_Constraint_GetAxisMaxLimit","setAxisMotorType","motorType","HP_Constraint_SetAxisMotorType","_constraintMotorTypeToNative","getAxisMotorType","_nativeToMotorType","HP_Constraint_GetAxisMotorType","setAxisMotorTarget","target","HP_Constraint_SetAxisMotorTarget","getAxisMotorTarget","HP_Constraint_GetAxisMotorTarget","setAxisMotorMaxForce","maxForce","HP_Constraint_SetAxisMotorMaxForce","getAxisMotorMaxForce","HP_Constraint_GetAxisMotorMaxForce","disposeConstraint","HP_Constraint_Release","raycast","from","to","result","reset","query","HP_World_CastRayWithCollector","HP_QueryCollector_GetNumHits","hitData","HP_QueryCollector_GetCastRayResult","hitPos","hitNormal","setHitData","calculateHitDistance","hitBody","get","bodyIndex","getCollisionObservable","observable","setCollisionCallbackEnabled","enabled","collideEvents","EventType","COLLISION_STARTED","value","COLLISION_CONTINUED","COLLISION_FINISHED","eventAddress","HP_World_GetCollisionEvents","event","worldAddr","Number","readToRef","subtractToRef","bodyInfoA","bodyInfoB","collisionInfo","collider","colliderIndex","collidedAgainst","collidedAgainstIndex","point","notifyObservers","size","observableA","observableB","HP_World_GetNextCollisionEvent","numBodies","HP_World_GetNumBodies","dispose","HP_QueryCollector_Release","HP_World_Release","vec3","_x","_y","_z","q","_w","ConstraintMotorType","POSITION","VELOCITY","NONE","mat","MaterialCombine","GEOMETRIC_MEAN","MINIMUM","MAXIMUM","ARITHMETIC_MEAN","MULTIPLY","FREE","PhysicsBody","constructor","startsAsleep","_collisionCBEnabled","physicsEngine","getPhysicsEngine","_physicsEngine","physicsPlugin","getPhysicsPlugin","_physicsPlugin","hasThinInstances","addBody","_nodeDisposeObserver","onDisposeObservable","add","getClassName","clone","clonedBody","getGeometry","getObjectCenterWorld","ref","getObjectCenterWorldToRef","syncWithBone","bone","boneMesh","jointPivot","distToJoint","adjustRotation","boneAxis","tempQuat","getRotationQuaternionToRef","multiplyToRef","boneDir","getDirectionToRef","getAbsolutePositionToRef","setAbsolutePosition","iterateOverAllInstances","callback","remove","PhysicsMaterialCombineMode","PhysicsShape","_type","parameters","filterMembershipMask","filterCollideMask","_material","addChildFromParent","parentTransform","childTransform","childToWorld","parentToWorld","childToParent","PhysicsShapeSphere","super","bounds","getBoundingInfo","centerLocal","boundingSphere","he","boundingBox","extendSize","Math","max","PhysicsShapeCapsule","boundsLocal","pointFromCenter","subtract","PhysicsShapeCylinder","PhysicsShapeBox","PhysicsShapeConvexHull","PhysicsShapeMesh","PhysicsShapeContainer"],"sourceRoot":""}