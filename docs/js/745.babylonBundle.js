"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[745],{86521:(t,e,i)=>{i.d(e,{z:()=>l});var r=i(32085),s=i(90972),n=i(43743),o=i(46825),a=i(8714),c=i(95593),h=i(40078);class l{constructor(t,e,i=Number.MAX_VALUE){this.origin=t,this.direction=e,this.length=i}clone(){return new l(this.origin.clone(),this.direction.clone(),this.length)}intersectsBoxMinMax(t,e,i=0){const r=l._TmpVector3[0].copyFromFloats(t.x-i,t.y-i,t.z-i),s=l._TmpVector3[1].copyFromFloats(e.x+i,e.y+i,e.z+i);let n,o,a,c,h=0,f=Number.MAX_VALUE;if(Math.abs(this.direction.x)<1e-7){if(this.origin.x<r.x||this.origin.x>s.x)return!1}else if(n=1/this.direction.x,o=(r.x-this.origin.x)*n,a=(s.x-this.origin.x)*n,a===-1/0&&(a=1/0),o>a&&(c=o,o=a,a=c),h=Math.max(o,h),f=Math.min(a,f),h>f)return!1;if(Math.abs(this.direction.y)<1e-7){if(this.origin.y<r.y||this.origin.y>s.y)return!1}else if(n=1/this.direction.y,o=(r.y-this.origin.y)*n,a=(s.y-this.origin.y)*n,a===-1/0&&(a=1/0),o>a&&(c=o,o=a,a=c),h=Math.max(o,h),f=Math.min(a,f),h>f)return!1;if(Math.abs(this.direction.z)<1e-7){if(this.origin.z<r.z||this.origin.z>s.z)return!1}else if(n=1/this.direction.z,o=(r.z-this.origin.z)*n,a=(s.z-this.origin.z)*n,a===-1/0&&(a=1/0),o>a&&(c=o,o=a,a=c),h=Math.max(o,h),f=Math.min(a,f),h>f)return!1;return!0}intersectsBox(t,e=0){return this.intersectsBoxMinMax(t.minimum,t.maximum,e)}intersectsSphere(t,e=0){const i=t.center.x-this.origin.x,r=t.center.y-this.origin.y,s=t.center.z-this.origin.z,n=i*i+r*r+s*s,o=t.radius+e,a=o*o;if(n<=a)return!0;const c=i*this.direction.x+r*this.direction.y+s*this.direction.z;return!(c<0)&&n-c*c<=a}intersectsTriangle(t,e,i){const r=l._TmpVector3[0],n=l._TmpVector3[1],a=l._TmpVector3[2],c=l._TmpVector3[3],h=l._TmpVector3[4];e.subtractToRef(t,r),i.subtractToRef(t,n),s.P.CrossToRef(this.direction,n,a);const f=s.P.Dot(r,a);if(0===f)return null;const g=1/f;this.origin.subtractToRef(t,c);const d=s.P.Dot(c,a)*g;if(d<0||d>1)return null;s.P.CrossToRef(c,r,h);const u=s.P.Dot(this.direction,h)*g;if(u<0||d+u>1)return null;const p=s.P.Dot(n,h)*g;return p>this.length?null:new o.c(1-d-u,d,p)}intersectsPlane(t){let e;const i=s.P.Dot(t.normal,this.direction);if(Math.abs(i)<9.99999997475243e-7)return null;{const r=s.P.Dot(t.normal,this.origin);return e=(-t.d-r)/i,e<0?e<-9.99999997475243e-7?null:0:e}}intersectsAxis(t,e=0){switch(t){case"y":{const t=(this.origin.y-e)/this.direction.y;return t>0?null:new s.P(this.origin.x+this.direction.x*-t,e,this.origin.z+this.direction.z*-t)}case"x":{const t=(this.origin.x-e)/this.direction.x;return t>0?null:new s.P(e,this.origin.y+this.direction.y*-t,this.origin.z+this.direction.z*-t)}case"z":{const t=(this.origin.z-e)/this.direction.z;return t>0?null:new s.P(this.origin.x+this.direction.x*-t,this.origin.y+this.direction.y*-t,e)}default:return null}}intersectsMesh(t,e,i,r=!1,n,o=!1){const a=s.jp.Matrix[0];return t.getWorldMatrix().invertToRef(a),this._tmpRay?l.TransformToRef(this,a,this._tmpRay):this._tmpRay=l.Transform(this,a),t.intersects(this._tmpRay,e,i,r,n,o)}intersectsMeshes(t,e,i){i?i.length=0:i=[];for(let r=0;r<t.length;r++){const s=this.intersectsMesh(t[r],e);s.hit&&i.push(s)}return i.sort(this._comparePickingInfo),i}_comparePickingInfo(t,e){return t.distance<e.distance?-1:t.distance>e.distance?1:0}intersectionSegment(t,e,i){const r=this.origin,n=s.jp.Vector3[0],o=s.jp.Vector3[1],a=s.jp.Vector3[2],c=s.jp.Vector3[3];e.subtractToRef(t,n),this.direction.scaleToRef(l._Rayl,a),r.addToRef(a,o),t.subtractToRef(r,c);const h=s.P.Dot(n,n),f=s.P.Dot(n,a),g=s.P.Dot(a,a),d=s.P.Dot(n,c),u=s.P.Dot(a,c),p=h*g-f*f;let y,m,b=p,x=p;p<l._Smallnum?(y=0,b=1,m=u,x=g):(y=f*u-g*d,m=h*u-f*d,y<0?(y=0,m=u,x=g):y>b&&(y=b,m=u+f,x=g)),m<0?(m=0,-d<0?y=0:-d>h?y=b:(y=-d,b=h)):m>x&&(m=x,-d+f<0?y=0:-d+f>h?y=b:(y=-d+f,b=h));const P=Math.abs(y)<l._Smallnum?0:y/b,R=Math.abs(m)<l._Smallnum?0:m/x,_=s.jp.Vector3[4];a.scaleToRef(R,_);const T=s.jp.Vector3[5];n.scaleToRef(P,T),T.addInPlace(c);const M=s.jp.Vector3[6];return T.subtractToRef(_,M),R>0&&R<=this.length&&M.lengthSquared()<i*i?T.length():-1}update(t,e,i,r,n,o,a,c=!1){if(c){l._RayDistant||(l._RayDistant=l.Zero()),l._RayDistant.unprojectRayToRef(t,e,i,r,s.y3.IdentityReadOnly,o,a);const c=s.jp.Matrix[0];n.invertToRef(c),l.TransformToRef(l._RayDistant,c,this)}else this.unprojectRayToRef(t,e,i,r,n,o,a);return this}static Zero(){return new l(s.P.Zero(),s.P.Zero())}static CreateNew(t,e,i,r,s,n,o){return l.Zero().update(t,e,i,r,s,n,o)}static CreateNewFromTo(t,e,i=s.y3.IdentityReadOnly){const r=e.subtract(t),n=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);return r.normalize(),l.Transform(new l(t,r,n),i)}static Transform(t,e){const i=new l(new s.P(0,0,0),new s.P(0,0,0));return l.TransformToRef(t,e,i),i}static TransformToRef(t,e,i){s.P.TransformCoordinatesToRef(t.origin,e,i.origin),s.P.TransformNormalToRef(t.direction,e,i.direction),i.length=t.length;const r=i.direction,n=r.length();if(0!==n&&1!==n){const t=1/n;r.x*=t,r.y*=t,r.z*=t,i.length*=n}}unprojectRayToRef(t,e,i,r,n,o,a){const c=s.jp.Matrix[0];n.multiplyToRef(o,c),c.multiplyToRef(a,c),c.invert();const l=h.l.LastCreatedEngine,f=s.jp.Vector3[0];f.x=t/i*2-1,f.y=-(e/r*2-1),f.z=(null==l?void 0:l.useReverseDepthBuffer)?1:(null==l?void 0:l.isNDCHalfZRange)?0:-1;const g=s.jp.Vector3[1].copyFromFloats(f.x,f.y,1-1e-8),d=s.jp.Vector3[2],u=s.jp.Vector3[3];s.P._UnprojectFromInvertedMatrixToRef(f,c,d),s.P._UnprojectFromInvertedMatrixToRef(g,c,u),this.origin.copyFrom(d),u.subtractToRef(d,this.direction),this.direction.normalize()}}l._TmpVector3=r.B.BuildArray(6,s.P.Zero),l._RayDistant=l.Zero(),l._Smallnum=1e-8,l._Rayl=1e9,a.x.prototype.createPickingRay=function(t,e,i,r,s=!1){const n=l.Zero();return this.createPickingRayToRef(t,e,i,n,r,s),n},a.x.prototype.createPickingRayToRef=function(t,e,i,r,n,o=!1,a=!1){const c=this.getEngine();if(!n){if(!this.activeCamera)return this;n=this.activeCamera}const h=n.viewport.toGlobal(c.getRenderWidth(),c.getRenderHeight());return t=t/c.getHardwareScalingLevel()-h.x,e=e/c.getHardwareScalingLevel()-(c.getRenderHeight()-h.y-h.height),r.update(t,e,h.width,h.height,i||s.y3.IdentityReadOnly,o?s.y3.IdentityReadOnly:n.getViewMatrix(),n.getProjectionMatrix(),a),this},a.x.prototype.createPickingRayInCameraSpace=function(t,e,i){const r=l.Zero();return this.createPickingRayInCameraSpaceToRef(t,e,r,i),r},a.x.prototype.createPickingRayInCameraSpaceToRef=function(t,e,i,r){if(!n.p)return this;const o=this.getEngine();if(!r){if(!this.activeCamera)throw new Error("Active camera not set");r=this.activeCamera}const a=r.viewport.toGlobal(o.getRenderWidth(),o.getRenderHeight()),c=s.y3.Identity();return t=t/o.getHardwareScalingLevel()-a.x,e=e/o.getHardwareScalingLevel()-(o.getRenderHeight()-a.y-a.height),i.update(t,e,a.width,a.height,c,c,r.getProjectionMatrix()),this},a.x.prototype._internalPickForMesh=function(t,e,i,r,s,n,o,a){const c=e(r,i.enableDistantPicking),h=i.intersects(c,s,o,n,r,a);return h&&h.hit?!s&&null!=t&&h.distance>=t.distance?null:h:null},a.x.prototype._internalPick=function(t,e,i,r,o){let a=null;const c=!!(this.activeCameras&&this.activeCameras.length>1&&this.cameraToUseForPointers!==this.activeCamera),h=this.cameraToUseForPointers||this.activeCamera;for(let n=0;n<this.meshes.length;n++){const l=this.meshes[n];if(e){if(!e(l))continue}else if(!l.isEnabled()||!l.isVisible||!l.isPickable)continue;const f=c&&l.isWorldMatrixCameraDependent(),g=l.computeWorldMatrix(f,h);if(l.hasThinInstances&&l.thinInstanceEnablePicking){const e=this._internalPickForMesh(a,t,l,g,!0,!0,o);if(e){if(r)return e;const n=s.jp.Matrix[1],c=l.thinInstanceGetWorldMatrices();for(let e=0;e<c.length;e++){c[e].multiplyToRef(g,n);const s=this._internalPickForMesh(a,t,l,n,i,r,o,!0);if(s&&(a=s,a.thinInstanceIndex=e,i))return a}}}else{const e=this._internalPickForMesh(a,t,l,g,i,r,o);if(e&&(a=e,i))return a}}return a||new n.p},a.x.prototype._internalMultiPick=function(t,e,i){if(!n.p)return null;const r=new Array,o=!!(this.activeCameras&&this.activeCameras.length>1&&this.cameraToUseForPointers!==this.activeCamera),a=this.cameraToUseForPointers||this.activeCamera;for(let n=0;n<this.meshes.length;n++){const c=this.meshes[n];if(e){if(!e(c))continue}else if(!c.isEnabled()||!c.isVisible||!c.isPickable)continue;const h=o&&c.isWorldMatrixCameraDependent(),l=c.computeWorldMatrix(h,a);if(c.hasThinInstances&&c.thinInstanceEnablePicking){if(this._internalPickForMesh(null,t,c,l,!0,!0,i)){const e=s.jp.Matrix[1],n=c.thinInstanceGetWorldMatrices();for(let s=0;s<n.length;s++){n[s].multiplyToRef(l,e);const o=this._internalPickForMesh(null,t,c,e,!1,!1,i,!0);o&&(o.thinInstanceIndex=s,r.push(o))}}}else{const e=this._internalPickForMesh(null,t,c,l,!1,!1,i);e&&r.push(e)}}return r},a.x.prototype.pickWithBoundingInfo=function(t,e,i,r,o){if(!n.p)return null;const a=this._internalPick((i=>(this._tempPickingRay||(this._tempPickingRay=l.Zero()),this.createPickingRayToRef(t,e,i,this._tempPickingRay,o||null),this._tempPickingRay)),i,r,!0);return a&&(a.ray=this.createPickingRay(t,e,s.y3.Identity(),o||null)),a},Object.defineProperty(a.x.prototype,"_pickingAvailable",{get:()=>!0,enumerable:!1,configurable:!1}),a.x.prototype.pick=function(t,e,i,r,n,o,a=!1){const c=this._internalPick(((i,r)=>(this._tempPickingRay||(this._tempPickingRay=l.Zero()),this.createPickingRayToRef(t,e,i,this._tempPickingRay,n||null,!1,r),this._tempPickingRay)),i,r,!1,o);return c&&(c.ray=this.createPickingRay(t,e,s.y3.Identity(),n||null)),c},a.x.prototype.pickWithRay=function(t,e,i,r){const n=this._internalPick((e=>(this._pickWithRayInverseMatrix||(this._pickWithRayInverseMatrix=s.y3.Identity()),e.invertToRef(this._pickWithRayInverseMatrix),this._cachedRayForTransform||(this._cachedRayForTransform=l.Zero()),l.TransformToRef(t,this._pickWithRayInverseMatrix,this._cachedRayForTransform),this._cachedRayForTransform)),e,i,!1,r);return n&&(n.ray=t),n},a.x.prototype.multiPick=function(t,e,i,r,s){return this._internalMultiPick((i=>this.createPickingRay(t,e,i,r||null)),i,s)},a.x.prototype.multiPickWithRay=function(t,e,i){return this._internalMultiPick((e=>(this._pickWithRayInverseMatrix||(this._pickWithRayInverseMatrix=s.y3.Identity()),e.invertToRef(this._pickWithRayInverseMatrix),this._cachedRayForTransform||(this._cachedRayForTransform=l.Zero()),l.TransformToRef(t,this._pickWithRayInverseMatrix,this._cachedRayForTransform),this._cachedRayForTransform)),e,i)},c.V.prototype.getForwardRay=function(t=100,e,i){return this.getForwardRayToRef(new l(s.P.Zero(),s.P.Zero(),t),t,e,i)},c.V.prototype.getForwardRayToRef=function(t,e=100,i,r){return i||(i=this.getWorldMatrix()),t.length=e,r?t.origin.copyFrom(r):t.origin.copyFrom(this.position),s.jp.Vector3[2].set(0,0,this._scene.useRightHandedSystem?-1:1),s.P.TransformNormalToRef(s.jp.Vector3[2],i,s.jp.Vector3[3]),s.P.NormalizeToRef(s.jp.Vector3[3],t.direction),t}},69609:(t,e,i)=>{i.d(e,{M:()=>o});var r=i(23501),s=i(59288),n=i(81755);function o(t,e,i=null){let o=e.m||1;o!==Math.floor(o)&&(Math.floor(o),s.Y.Warn("m not an integer only floor(m) used"));let a=e.n||0;if(a!==Math.floor(a)&&(Math.floor(a),s.Y.Warn("n not an integer only floor(n) used")),a>o){const t=a;a=o,o=t,s.Y.Warn("n > m therefore m and n swapped")}const c=new n.Bn;c.build(o,a);const h={custom:n.zz.BuildGeodesicData(c),size:e.size,sizeX:e.sizeX,sizeY:e.sizeY,sizeZ:e.sizeZ,faceUV:e.faceUV,faceColors:e.faceColors,flat:e.flat,updatable:e.updatable,sideOrientation:e.sideOrientation,frontUVs:e.frontUVs,backUVs:e.backUVs};return(0,r.sh)(t,h,i)}},80133:(t,e,i)=>{i.d(e,{p:()=>l,v:()=>h});var r=i(41021),s=i(90972),n=i(33632),o=i(57700);class a{constructor(t){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=t}moveTo(t,e){this._currentPath=new r.ZZ(t,e),this._tempPaths.push(this._currentPath)}lineTo(t,e){this._currentPath.addLineTo(t,e)}quadraticCurveTo(t,e,i,r){this._currentPath.addQuadraticCurveTo(t,e,i,r,this._resolution)}bezierCurveTo(t,e,i,r,s,n){this._currentPath.addBezierCurveTo(t,e,i,r,s,n,this._resolution)}extractHoles(){for(const t of this._tempPaths)t.area()>0?this._holes.push(t):this._paths.push(t);if(!this._paths.length&&this._holes.length){const t=this._holes;this._holes=this._paths,this._paths=t}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function c(t,e,i,r,s,n){const o=n.glyphs[t]||n.glyphs["?"];if(!o)return null;const c=new a(s);if(o.o){const t=o.o.split(" ");for(let s=0,n=t.length;s<n;)switch(t[s++]){case"m":{const n=parseInt(t[s++])*e+i,o=parseInt(t[s++])*e+r;c.moveTo(n,o);break}case"l":{const n=parseInt(t[s++])*e+i,o=parseInt(t[s++])*e+r;c.lineTo(n,o);break}case"q":{const n=parseInt(t[s++])*e+i,o=parseInt(t[s++])*e+r,a=parseInt(t[s++])*e+i,h=parseInt(t[s++])*e+r;c.quadraticCurveTo(a,h,n,o);break}case"b":{const n=parseInt(t[s++])*e+i,o=parseInt(t[s++])*e+r,a=parseInt(t[s++])*e+i,h=parseInt(t[s++])*e+r,l=parseInt(t[s++])*e+i,f=parseInt(t[s++])*e+r;c.bezierCurveTo(a,h,l,f,n,o);break}}}return c.extractHoles(),{offsetX:o.ha*e,shapePath:c}}function h(t,e,i,r){const s=Array.from(t),n=e/r.resolution,o=(r.boundingBox.yMax-r.boundingBox.yMin+r.underlineThickness)*n,a=[];let h=0,l=0;for(let t=0;t<s.length;t++){const e=s[t];if("\n"===e)h=0,l-=o;else{const t=c(e,n,h,l,i,r);t&&(h+=t.offsetX,a.push(t.shapePath))}}return a}function l(t,e,i,r={size:50,resolution:8,depth:1},a=null,c=earcut){var l,f;const g=h(e,r.size||50,r.resolution||8,i),d=[];let u=0;for(const e of g){if(!e.paths.length)continue;const i=e.holes.slice();for(const h of e.paths){const e=[],g=[],p=h.getPoints();for(const t of p)g.push(new s.P(t.x,0,t.y));const y=i.slice();for(const t of y){const r=t.getPoints();let n=!1;for(const t of r)if(h.isPointInside(t)){n=!0;break}if(!n)continue;const o=[];for(const t of r)o.push(new s.P(t.x,0,t.y));e.push(o),i.splice(i.indexOf(t),1)}if(!e.length&&i.length)for(const t of i){const i=t.getPoints(),r=[];for(const t of i)r.push(new s.P(t.x,0,t.y));e.push(r)}const m=(0,o.Yo)(t,{shape:g,holes:e.length?e:void 0,depth:r.depth||1,faceUV:r.faceUV||(null===(l=r.perLetterFaceUV)||void 0===l?void 0:l.call(r,u)),faceColors:r.faceColors||(null===(f=r.perLetterFaceColors)||void 0===f?void 0:f.call(r,u)),sideOrientation:n.Kj._GetDefaultSideOrientation(r.sideOrientation||n.Kj.DOUBLESIDE)},a,c);d.push(m),u++}}const p=n.Kj.MergeMeshes(d,!0,!0);if(p){const e=null==p?void 0:p.getBoundingInfo();p.position.x=-(null==e?void 0:e.boundingBox.extendSizeWorld._x),p.position.y=-(null==e?void 0:e.boundingBox.extendSizeWorld._y),p.position.z=-(null==e?void 0:e.boundingBox.extendSizeWorld._z),p.name=t,p.rotation.x=-Math.PI/2,p.bakeCurrentTransformIntoVertices()}return p}},19044:(t,e,i)=>{i.d(e,{R:()=>c});var r=i(90972),s=i(37959),n=i(33632),o=i(89859),a=i(59288);n.Kj._GoldbergMeshParser=(t,e)=>c.Parse(t,e);class c extends n.Kj{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(t,e){return void 0===e?(t>this.goldbergData.nbUnsharedFaces-1&&(a.Y.Warn("Maximum number of unshared faces used"),t=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+t):(t>11&&(a.Y.Warn("Last pole used"),t=11),e>this.goldbergData.nbFacesAtPole-1&&(a.Y.Warn("Maximum number of faces at a pole used"),e=this.goldbergData.nbFacesAtPole-1),12+t*this.goldbergData.nbFacesAtPole+e)}_changeGoldbergFaceColors(t){for(let e=0;e<t.length;e++){const i=t[e][0],r=t[e][1],s=t[e][2];for(let t=i;t<r+1;t++)this.goldbergData.faceColors[t]=s}const e=[];for(let t=0;t<12;t++)for(let i=0;i<5;i++)e.push(this.goldbergData.faceColors[t].r,this.goldbergData.faceColors[t].g,this.goldbergData.faceColors[t].b,this.goldbergData.faceColors[t].a);for(let t=12;t<this.goldbergData.faceColors.length;t++)for(let i=0;i<6;i++)e.push(this.goldbergData.faceColors[t].r,this.goldbergData.faceColors[t].g,this.goldbergData.faceColors[t].b,this.goldbergData.faceColors[t].a);return e}setGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.setVerticesData(s.o.ColorKind,e)}updateGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.updateVerticesData(s.o.ColorKind,e)}_changeGoldbergFaceUVs(t){const e=this.getVerticesData(s.o.UVKind);for(let i=0;i<t.length;i++){const r=t[i][0],s=t[i][1],n=t[i][2],o=t[i][3],a=t[i][4],c=[],h=[];let l,f;for(let t=0;t<5;t++)l=n.x+o*Math.cos(a+t*Math.PI/2.5),f=n.y+o*Math.sin(a+t*Math.PI/2.5),l<0&&(l=0),l>1&&(l=1),c.push(l,f);for(let t=0;t<6;t++)l=n.x+o*Math.cos(a+t*Math.PI/3),f=n.y+o*Math.sin(a+t*Math.PI/3),l<0&&(l=0),l>1&&(l=1),h.push(l,f);for(let t=r;t<Math.min(12,s+1);t++)for(let i=0;i<5;i++)e[10*t+2*i]=c[2*i],e[10*t+2*i+1]=c[2*i+1];for(let t=Math.max(12,r);t<s+1;t++)for(let i=0;i<6;i++)e[12*t-24+2*i]=h[2*i],e[12*t-23+2*i]=h[2*i+1]}return e}setGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.setVerticesData(s.o.UVKind,e)}updateGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.updateVerticesData(s.o.UVKind,e)}placeOnGoldbergFaceAt(t,e,i){const s=r.P.RotationFromAxis(this.goldbergData.faceXaxis[e],this.goldbergData.faceYaxis[e],this.goldbergData.faceZaxis[e]);t.rotation=s,t.position=this.goldbergData.faceCenters[e].add(this.goldbergData.faceXaxis[e].scale(i.x)).add(this.goldbergData.faceYaxis[e].scale(i.y)).add(this.goldbergData.faceZaxis[e].scale(i.z))}serialize(t){super.serialize(t),t.type="GoldbergMesh";const e={};if(e.adjacentFaces=this.goldbergData.adjacentFaces,e.nbSharedFaces=this.goldbergData.nbSharedFaces,e.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,e.nbFaces=this.goldbergData.nbFaces,e.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){e.faceColors=[];for(const t of this.goldbergData.faceColors)e.faceColors.push(t.asArray())}if(this.goldbergData.faceCenters){e.faceCenters=[];for(const t of this.goldbergData.faceCenters)e.faceCenters.push(t.asArray())}if(this.goldbergData.faceZaxis){e.faceZaxis=[];for(const t of this.goldbergData.faceZaxis)e.faceZaxis.push(t.asArray())}if(this.goldbergData.faceYaxis){e.faceYaxis=[];for(const t of this.goldbergData.faceYaxis)e.faceYaxis.push(t.asArray())}if(this.goldbergData.faceXaxis){e.faceXaxis=[];for(const t of this.goldbergData.faceXaxis)e.faceXaxis.push(t.asArray())}t.goldbergData=e}static Parse(t,e){const i=t.goldbergData;i.faceColors=i.faceColors.map((t=>o.HE.FromArray(t))),i.faceCenters=i.faceCenters.map((t=>r.P.FromArray(t))),i.faceZaxis=i.faceZaxis.map((t=>r.P.FromArray(t))),i.faceXaxis=i.faceXaxis.map((t=>r.P.FromArray(t))),i.faceYaxis=i.faceYaxis.map((t=>r.P.FromArray(t)));const s=new c(t.name,e);return s.goldbergData=i,s}}}}]);
//# sourceMappingURL=745.babylonBundle.js.map