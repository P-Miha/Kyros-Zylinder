{"version":3,"file":"js/156.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/freeCamera.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Cameras/freeCameraInputsManager.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        let rotation = (this.rotationSpeed * this._engine.getDeltaTime()) / 1000;\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            rotation *= -1;\r\n        }\r\n        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            rotation *= -1;\r\n        }\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n","import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: () => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (engine.isInVRExclusivePointerMode) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        let offsetX = evt.clientX - this._previousPosition.x;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n                        if (this.camera.getScene().useRightHandedSystem) {\r\n                            offsetX *= -1;\r\n                        }\r\n                        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                            offsetX *= -1;\r\n                        }\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            let offsetX = evt.movementX;\r\n            if (this.camera.getScene().useRightHandedSystem) {\r\n                offsetX *= -1;\r\n            }\r\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                offsetX *= -1;\r\n            }\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = this.onContextMenu.bind(this);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n","import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n","import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n","import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n","import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n"],"names":["BaseCameraMouseWheelInput","wheelPrecisionX","wheelPrecisionY","wheelPrecisionZ","onChangedObservable","_wheelDeltaX","_wheelDeltaY","_wheelDeltaZ","_ffMultiplier","_normalize","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","this","_wheel","pointer","type","POINTERWHEEL","event","platformScale","deltaMode","DOM_DELTA_LINE","deltaX","deltaY","deltaZ","preventDefault","_observer","camera","getScene","_inputManager","_addCameraPointerObserver","detachControl","_removeCameraPointerObserver","clear","checkInputs","notifyObservers","wheelDeltaX","wheelDeltaY","wheelDeltaZ","getClassName","getSimpleName","FreeCameraKeyboardMoveInput","keysUp","keysUpward","keysDown","keysDownward","keysLeft","keysRight","rotationSpeed","keysRotateLeft","keysRotateRight","keysRotateUp","keysRotateDown","_keys","Array","_onCanvasBlurObserver","_scene","_engine","getEngine","onCanvasBlurObservable","add","length","_onKeyboardObserver","onKeyboardObservable","info","evt","metaKey","KEYDOWN","indexOf","keyCode","push","index","splice","remove","speed","_computeLocalCameraSpeed","_localDirection","copyFromFloats","cameraRotation","y","_getLocalRotation","x","useRightHandedSystem","z","getViewMatrix","invertToRef","_cameraTransformMatrix","TransformNormalToRef","_transformedDirection","cameraDirection","addInPlace","_onLostFocus","rotation","getDeltaTime","parent","_getWorldMatrixDeterminant","FreeCameraMouseInput","constructor","touchEnabled","buttons","angularSensibility","_previousPosition","onPointerMovedObservable","_allowCameraRotation","_currentActiveButton","_activePointerId","engine","element","getInputElement","_pointerInput","p","isTouch","pointerType","isInVRExclusivePointerMode","POINTERMOVE","button","srcElement","target","POINTERDOWN","pointerId","setPointerCapture","e","clientX","clientY","focus","isPointerLock","_onMouseMove","POINTERUP","releasePointerCapture","offsetX","offsetY","movementX","movementY","_contextMenuBind","onContextMenu","bind","addEventListener","removeEventListener","_CameraProperty","FreeCameraMouseWheelInput","_moveRelative","Zero","_rotateRelative","_moveScene","_wheelXAction","MoveRelative","_wheelXActionCoordinate","X","_wheelYAction","_wheelYActionCoordinate","Z","_wheelZAction","_wheelZActionCoordinate","wheelXMoveRelative","axis","wheelYMoveRelative","wheelZMoveRelative","wheelXRotateRelative","RotateRelative","wheelYRotateRelative","wheelZRotateRelative","wheelXMoveScene","MoveScene","wheelYMoveScene","wheelZMoveScene","setAll","_updateCamera","cameraTransformMatrix","transformedDirection","super","_updateCameraProperty","value","cameraProperty","coordinate","action","set","Y","FreeCameraTouchInput","allowMouse","touchAngularSensibility","touchMoveSensibility","singleFingerRotate","_offsetX","_offsetY","_pointerPressed","_isSafari","IsSafari","previousPosition","undefined","isMouseEvent","direction","RotationYawPitchRollToRef","_cameraRotationMatrix","TransformCoordinates","FreeCamera","mouse","inputs","attached","keyboard","name","position","scene","setActiveOnSceneIfNoneActive","ellipsoid","ellipsoidOffset","checkCollisions","applyGravity","_needMoveForGravity","_oldPosition","_diffPosition","_newPosition","_collisionMask","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","copyFrom","subtractToRef","CollisionsEpsilon","addToRef","_deferredPositionUpdate","_deferOnly","_deferredUpdated","onCollide","addKeyboard","addMouse","ignored","attachElement","detachElement","collisionMask","mask","isNaN","_collideWithWorld","displacement","globalPosition","getWorldMatrix","subtractFromFloatsToRef","coordinator","collisionCoordinator","_collider","createCollider","_radius","actualDisplacement","gravity","getNewPosition","uniqueId","_checkInputs","needMoveForGravity","_decideIfNeedsToMove","Math","abs","_updatePosition","collisionsEnabled","dispose","FreeCameraInputsManager","_mouseInput","_mouseWheelInput","removeMouse","addMouseWheel","removeMouseWheel","addTouch"],"sourceRoot":""}