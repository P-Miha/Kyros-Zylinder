{"version":3,"file":"js/426.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/nagelDistanceField.ts","webpack://babylonjs-typescript-webpack-template/./src/contactForce.ts","webpack://babylonjs-typescript-webpack-template/./assets/meshes/Nagel1.stl","webpack://babylonjs-typescript-webpack-template/./src/scenes/nagelPuzzle.ts","webpack://babylonjs-typescript-webpack-template/./src/offParser.ts","webpack://babylonjs-typescript-webpack-template/./src/sdfParser.ts","webpack://babylonjs-typescript-webpack-template/./assets/grass.jpg"],"sourcesContent":["import { Mesh, float, int } from \"@babylonjs/core\";\r\nimport { Matrix, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { SDFData } from \"./sdfParser\";\r\n\r\n\r\nexport function index2(x: int, y: int, z: int, resolution: Vector3): number {\r\n    //console.log(\"Index \" , x + resolution.x*(y + resolution.y*z))\r\n    return x + resolution.x*(y + resolution.y*z)}\r\n\r\nexport function index(point: Vector3, sdfFile: SDFData): number{\r\n    const o = sdfFile.bbox.min;\r\n    if (!inBox(point, sdfFile.bbox.min, sdfFile.bbox.max)) {\r\n        return -1; // Nicht in BoundingBox, daher trivialer Fall\r\n    }\r\n    let calculatedPoint = point.subtract(o);\r\n    calculatedPoint = calculatedPoint.divide(new Vector3(sdfFile.cellSize, sdfFile.cellSize, sdfFile.cellSize));\r\n    const roundedPoint = new Vector3(\r\n        Math.round(calculatedPoint.x),\r\n        Math.round(calculatedPoint.y),\r\n        Math.round(calculatedPoint.z)\r\n        )\r\n    // console.log(\"Berechneter Punkt \", calculatedPoint, \" gerundet auf: \" , roundedPoint)\r\n    //return index2(calculatedPoint.x, calculatedPoint.y, calculatedPoint.z, sdfFile.res);\r\n    return index2(roundedPoint.x, roundedPoint.y, roundedPoint.z, sdfFile.res);\r\n}\r\n\r\nexport function pointFunction(x: int, y: int, z: int, sdfFile: SDFData): Vector3{\r\n    const o = sdfFile.bbox.min;\r\n    return o.add(new Vector3((x + 0.5) * sdfFile.cellSize, (y + 0.5) * sdfFile.cellSize, (z + 0.5) * sdfFile.cellSize));\r\n}\r\n/**\r\n * Ist im gegebenen Codeabschnitt aufgerufen, jedoch nicht dabei gewesen, daher selbst implementiert.\r\n * @param vector\r\n * @param bboxMin\r\n * @param bboxMax\r\n * @returns true, wenn Point: Vector3 in BoundingBox liegt, sonst false\r\n */\r\nfunction inBox(vector: Vector3, bboxMin: Vector3, bboxMax: Vector3): boolean{\r\n    return vector.x >= bboxMin.x && vector.y >= bboxMin.y && vector.z >= bboxMin.z && vector.x <= bboxMax.x && vector.y <= bboxMax.y && vector.z <= bboxMax.z;\r\n}\r\n\r\n/**\r\n *  Gegeben ein Punkt und ein Mesh, wird der Punkt in das lokale Koordinatensystem des Meshes transformiert,\r\n *  indem die WorldMatrix des Meshes invertiert wird und der Punkt mit der invertierten Matrix transformiert wird. \r\n * @param point \r\n * @param mesh \r\n * @returns localpoint vom Mesh\r\n */\r\nexport function calculateLocalPoint(point: Vector3, mesh: Mesh): Vector3 {\r\n    const worldMatrix = mesh.getWorldMatrix();\r\n    const invertedWorldMatrix = new Matrix();\r\n    worldMatrix.invertToRef(invertedWorldMatrix);\r\n\r\n    const localPoint = Vector3.TransformCoordinates(point, invertedWorldMatrix);\r\n    return localPoint;\r\n}\r\n\r\nexport function distanceToWorldpoint(point: Vector3, mesh: Mesh, sdfFile: SDFData): number {\r\n    const localPoint = calculateLocalPoint(point, mesh);\r\n    //const gitterPoint = pointFunction(localPoint.x, localPoint.y, localPoint.z, sdfFile)\r\n    // console.log(\"Localpoint: \" ,localPoint)\r\n    // console.log(\"Gitterpoint: \" ,gitterPoint)\r\n    const indexofPoint = index(localPoint, sdfFile);\r\n    if (indexofPoint === -1) {\r\n        return -1;\r\n    }\r\n    return sdfFile.distances[indexofPoint];\r\n}   \r\n","import { Matrix, Mesh, Quaternion, Vector3, Vector4, float } from \"@babylonjs/core\";\r\nimport { SDFData } from \"./sdfParser\";\r\nimport { calculateLocalPoint, index } from \"./nagelDistanceField\";\r\n\r\n//DEBUG Konstante!\r\n// Normalerweise 1\r\nconst cDeltaMultiplier = 1;\r\nconst scaling = 0.01;\r\n\r\n\r\n\r\n/**\r\n * Berechnet die benötigte änderung in Position und Orientierung, um von einer überschneideten Kollision zu einer an der Oberfläche berührenden Kollision zu kommen.\r\n * Dabei wird der Kontaktpunkt der Kollision über den Gradienten bestimmt\r\n */\r\n// export function distanceAndOriantationDelta(collisionPoint: Vector3, sdfFile: SDFData,){\r\n//     // Bestimmte Kontaktpunkt durch Gradienten der Distanzwerte\r\n//     const dDelta = new Vector3(\r\n//         (sdfFile.distances[index(collisionPoint.add(new Vector3(sdfFile.cellSize, 0, 0)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(sdfFile.cellSize, 0, 0)), sdfFile)]) / 2, \r\n//         (sdfFile.distances[index(collisionPoint.add(new Vector3(0, sdfFile.cellSize, 0)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(0, sdfFile.cellSize, 0)), sdfFile)]) / 2,\r\n//         (sdfFile.distances[index(collisionPoint.add(new Vector3(0, 0, sdfFile.cellSize)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(0, 0, sdfFile.cellSize)), sdfFile)]) / 2);\r\n//     const normalVector = dDelta.divide(new Vector3(dDelta.length(), dDelta.length(), dDelta.length()));\r\n\r\n//     return normalVector;\r\n// }\r\n// export function inertiaMatrix(radius: float, mass: float): Matrix {\r\n//     const inertia: float = (2 / 5) * mass * radius * radius;\r\n//     const values = [inertia, 0, 0,\r\n//                     0, inertia, 0,\r\n//                     0, 0, inertia];\r\n//     return Matrix.FromArray(values);\r\n// }\r\n\r\n// export function invertedIneratiaMatrix(radius: float, mass: float): Matrix {\r\n//     const inertia: float = 5 /( 2 * mass * radius * radius);\r\n//     const values = [inertia, 0, 0, \r\n//                     0, inertia, 0,\r\n//                     0, 0, inertia];\r\n//     console.log(\"DEBUG: inertiaMatrix: \", Matrix.FromArray(values))\r\n\r\n//     return Matrix.FromArray(values);\r\n// }\r\n\r\nexport function calculateBoundingBoxDiagonalLength(minBox: Vector3, maxBox: Vector3): number {\r\n    const diffX = maxBox.x - minBox.x;\r\n    const diffY = maxBox.y - minBox.y;\r\n    const diffZ = maxBox.z - minBox.z;\r\n  \r\n    const diagonalLength = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);\r\n  \r\n    return diagonalLength / 2;\r\n  }\r\n\r\nexport function localRadius(contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh){\r\n    const localContactPoint = calculateLocalPoint(contactPoint, staticMesh)\r\n    const localRootPoint = calculateLocalPoint(rootPoint, staticMesh)\r\n    return localContactPoint.subtract(localRootPoint)\r\n\r\n}\r\n\r\nexport function lambdaAlt(minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, normalVector: Vector3, distance: float){\r\n    // Diagonale Berechnen und ^2\r\n    const g = Math.pow(maxBox.subtract(minBox).length(), 2) / 2\r\n    // r ist der Abstand des Kontaktpunktes zum Schwerpunkts-mittelpunkt da wir vom Center als Schwerpunkt ausgehen ist der Vektor: R - Schwerpunkt, mit schwerpunkt = 0,0,0 => R\r\n    const r = contactPoint\r\n    // NormalenVektor muss umgedreht werden, da er momentan in Kollisionsrichtung zeigt\r\n    // const n = normalVector.scale(-1)\r\n    const n = new Vector3(normalVector.x, normalVector.y, normalVector.z)\r\n\r\n    return (distance * scaling) / (1 + (5 / (2 * g)) * Math.pow((r.cross(n)).length(), 2)) \r\n}\r\nexport function ccDelta(distance: float, minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh, normalVector: Vector3){\r\n    const lambda = lambdaAlt(minBox, maxBox, contactPoint, normalVector, distance)\r\n    // return normalVector.scale(distance / (1 + (5 / (2 * Math.pow(calculateBoundingBoxDiagonalLength(minBox, maxBox), 2))) * Math.pow(((contactPoint.subtract(rootPoint)).cross(normalVector)).length(), 2)))\r\n    // Wieder den normalVektor umdrehen\r\n    // const n = normalVector.scale(-1)\r\n    const n = new Vector3(normalVector.x, normalVector.y, normalVector.z)\r\n    // cDeltaMultiplier ist dafür da, um die Kraft beliebig zu Skalieren, Variable am Anfang dieser Datei. Damit kann man testweise nur 1/2 der \"Kraft\" anwenden oder das Doppelte\r\n    return (n.multiply(new Vector3(lambda, lambda, lambda))).multiply(new Vector3(0.4, 0.4, 0.4))\r\n}\r\n\r\nexport function qqDelta(distance: float, minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh, normalVector: Vector3, movingMesh: Mesh){\r\n//     // 5 geteilt durch 2*radius^2 * lambda'\r\n\r\n    \r\n    // Diagonale Berechnen und ^2\r\n    const g = Math.pow(maxBox.subtract(minBox).length(), 2) / 2\r\n    const RxN = contactPoint.cross(normalVector)\r\n    const constantPart = 50000/(2*g) * lambdaAlt(minBox, maxBox, contactPoint, normalVector, distance)\r\n    const wTimesDeltaT = RxN.multiply(new Vector3(constantPart, constantPart, constantPart))\r\n\r\n    const q = movingMesh.rotationQuaternion as Quaternion // Momentane Orientierung\r\n    // Skalare Komponente ist in Babylon anscheinend die letzte Komponente\r\n    const wQuaternion = new Quaternion(wTimesDeltaT.x / 2, wTimesDeltaT.y / 2, wTimesDeltaT.z / 2, 0) // Durch 2 da * 1/2\r\n    return wQuaternion.multiply(q)\r\n\r\n}\r\n","export default __webpack_public_path__ + \"628b10094e62129397fc4859ae7349d6.stl\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { Axis, BoundingInfo, Color3, HighlightLayer, Mesh, MeshBuilder, Nullable, SceneLoader, WebXRControllerComponent } from \"@babylonjs/core\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\n// import \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport grassTextureUrl from \"../../assets/grass.jpg\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\r\nimport \"@babylonjs/loaders/STL/stlFileLoader\";\r\nimport \"@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent\";\r\n\r\n// Custom Importe / \r\nimport { calculateLocalPoint, index, index2, pointFunction, distanceToWorldpoint } from \"../nagelDistanceField\";\r\nimport { calculateBoundingBoxDiagonalLength, ccDelta, qqDelta } from \"../contactForce\";\r\nimport { STLFileLoader } from \"@babylonjs/loaders/STL/stlFileLoader\";\r\n// Laden und Parsen von SDF Dateien\r\nimport { loadSDFFile, parseSDFFileContent } from '../sdfParser';\r\nimport { SDFData } from '../sdfParser';\r\nimport { loadOffFile, parseOffFileContent } from '../offParser';\r\nimport NagelPuzzleStatic from \"../../assets/meshes/Nagel1.stl\";\r\nimport { AdvancedDynamicTexture, Button } from \"@babylonjs/gui\";\r\n\r\n\r\n\r\nexport class DefaultSceneWithTexture implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n        /*********************************************************\r\n         * Anzeigen von Debug-Layern\r\n         *********************************************************/\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        /*********************************************************\r\n         * Einlesen von SDF & OFF Datein, sowie loaden von Meshes und deren Properties \r\n         *********************************************************/\r\n        STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = true;\r\n        // Import Nagel Puzzle Mesh via STL\r\n        const nagelPuzzleStaticLoad = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n            \"\",\r\n            NagelPuzzleStatic,\r\n            scene, \r\n            undefined,\r\n            \".stl\"\r\n        );\r\n        const nagelPuzzleStatic = nagelPuzzleStaticLoad.meshes[0] as Mesh;\r\n\r\n        // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n        nagelPuzzleStatic.scaling = new Vector3(1, 1, -1);\r\n\r\n        const nagelPuzzleMoveableLoad = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n            \"\",\r\n            NagelPuzzleStatic,\r\n            scene,\r\n            undefined,\r\n            \".stl\"\r\n            \r\n        );\r\n        const nagelPuzzleMoveable = nagelPuzzleMoveableLoad.meshes[0] as Mesh;\r\n        nagelPuzzleMoveable.name = \"NagelPuzzleMoveable\";\r\n        nagelPuzzleMoveable.visibility = 1;\r\n        // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n        nagelPuzzleMoveable.scaling = new Vector3(1, 1, -1);\r\n        \r\n        // Erstelle leere Mesh um die Punkte zu speichern\r\n        // dabei sind die Punkte, die Punkte der Oberfläche des moveable Meshes\r\n        const nagelPunkte = new Mesh(\"NagelPunkte\", scene);\r\n        nagelPunkte.parent = nagelPuzzleMoveableLoad.meshes[0];\r\n        const punkteInfo: Promise<string> = loadOffFile(\"https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.noff\");\r\n        const offInfo = parseOffFileContent(await punkteInfo);\r\n        const punkte = offInfo.vertices\r\n        const normals = offInfo.normals\r\n\r\n\r\n        // Erstelle ein leeres Mesh an jeden dieser Punkte und parente diesen an nagelPunkte \r\n        // Vorerst sichbar \r\n        for (let i = 0; i < punkte.length; i++) {\r\n            const punkt = new Mesh(\"Punkt\" + i, scene)\r\n            punkt.position = punkte[i];\r\n            punkt.parent = nagelPunkte;\r\n            punkt.visibility = 0;\r\n        }\r\n        nagelPuzzleMoveable.position = new Vector3(-0.5, 1, 0);\r\n        nagelPuzzleStatic.position = new Vector3(0, 1, 0);\r\n\r\n        // Drehe Moveable Mesh um 180°\r\n        nagelPuzzleMoveable.rotationQuaternion = Quaternion.FromEulerVector( new Vector3(Math.PI / 2, Math.PI, 0));\r\n\r\n        // Scaling der Meshe für WebXr\r\n        nagelPuzzleMoveable.scaling = new Vector3(0.01, 0.01, 0.01);\r\n        nagelPuzzleStatic.scaling = new Vector3(0.01, 0.01, 0.01);\r\n\r\n  \r\n        // Die URL der SDF-Datei\r\n        const sdfFileUrl = 'https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.sdf';\r\n        // Definiert in einer ausgelagerten Datei\r\n        // Laded die SDF-Datei aus dem Internet und Parset diese in ein SDFData-Objekt\r\n        const loadFile = loadSDFFile(sdfFileUrl);\r\n        const sdfContent = parseSDFFileContent(await loadFile);\r\n  \r\n        // //Print SDF-Data\r\n        // console.log(\"SDF-Data: \", sdfContent);\r\n        \r\n        // Erstelle empty mesh um eine Custom boundingbox zu erstellen\r\n        const boundingBox = new Mesh(\"boundingBox\", scene);\r\n        boundingBox.setBoundingInfo(new BoundingInfo(sdfContent.bbox.min, sdfContent.bbox.max));\r\n        boundingBox.showBoundingBox = true;\r\n        \r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\r\n            \"my first camera\",\r\n            0,\r\n            Math.PI / 3,\r\n            10,\r\n            new Vector3(0, 0, 0),\r\n            scene\r\n        );\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\r\n            \"ground\",\r\n            { width: 6, height: 6 },\r\n            scene\r\n        );\r\n\r\n        // Load a texture to be used as the ground material\r\n        const groundMaterial = new StandardMaterial(\"ground material\", scene);\r\n        groundMaterial.diffuseTexture = new Texture(grassTextureUrl, scene);\r\n\r\n        ground.material = groundMaterial;\r\n        ground.receiveShadows = true;\r\n\r\n        const light = new DirectionalLight(\r\n            \"light\",\r\n            new Vector3(0, -1, 1),\r\n            scene\r\n        );\r\n        light.intensity = 0.5;\r\n        light.position.y = 10;\r\n\r\n        const shadowGenerator = new ShadowGenerator(512, light)\r\n        shadowGenerator.useBlurExponentialShadowMap = true;\r\n        shadowGenerator.blurScale = 2;\r\n        shadowGenerator.setDarkness(0.2);\r\n\r\n        //shadowGenerator.getShadowMap()!.renderList!.push(sphere);\r\n        //Erstelle Material für Kollision mit Farbe Rot und Kollisionsfrei mit Farbe Grün\r\n        const collisionMaterial = new StandardMaterial(\"collisionMaterial\", scene);\r\n        collisionMaterial.diffuseColor = new Color3(1, 0, 0);\r\n\r\n        const noCollisionMaterial = new StandardMaterial(\"noCollisionMaterial\", scene);\r\n        noCollisionMaterial.diffuseColor = new Color3(0, 1, 0);\r\n        \r\n        const moveableNagelPunkte = nagelPunkte.getChildMeshes()\r\n        /************************************************************\r\n         * GUI-Interface zum setzen der Kollisionsvariable zum Debug\r\n         *************************************************************/\r\n        // Button Textur & Properties\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n        const button = Button.CreateSimpleButton(\"toggleCollisionCorrection\", \"Toggle Collision Correction\");\r\n        button.width = \"150px\";\r\n        button.height = \"40px\";\r\n        button.background = \"red\"; // Startzustand\r\n        button.color = \"white\";\r\n        button.left = \"35%\"; \r\n        button.top = \"-45%\"; \r\n\r\n        // Var für Kollisionsabfrage\r\n        let collisionCorrectionEnabled = false;\r\n        \r\n        // Funktion für den Button\r\n        function toggleCollisionCorrection() {\r\n            collisionCorrectionEnabled = !collisionCorrectionEnabled;\r\n            // Update Button-Background\r\n            if (collisionCorrectionEnabled) {\r\n                button.background = \"green\";\r\n            } else {\r\n                button.background = \"red\";\r\n            }\r\n        }\r\n        // Button Event-Handler\r\n        button.onPointerClickObservable.add(() => {\r\n            toggleCollisionCorrection();\r\n        })\r\n        // Hinzufügen vom Button zur GUI-Texture\r\n        advancedTexture.addControl(button);\r\n\r\n\r\n        /*********************************************************\r\n         * VR Implementation (Variablen sowie Event-Handler für den Controller) \r\n         *********************************************************/\r\n        // VR-Integration, \"WebXR\"\r\n        const xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });\r\n\r\n        // XR-Sitzung abrufen\r\n        const xrSession = xr.baseExperience.sessionManager.session;\r\n        \r\n        const targetMesh = nagelPuzzleMoveable; // Hier musst du den Code zum Erstellen oder Laden deines Ziel-Meshs einfügen\r\n\r\n        // Vorherigen Status des Controllers speichern\r\n        let previousPosition: Nullable<Vector3> = null;\r\n        let previousRotation: Nullable<Quaternion> = null;\r\n\r\n        // Controller-Status für \"Dragging\" speichern\r\n        let isDragging = false;\r\n\r\n        // Event-Handler für den rechten Controller hinzufügen\r\n        xr.input.onControllerAddedObservable.add((controller) => {\r\n        // Überprüfen, ob der Controller der rechte Controller ist\r\n        if (controller.inputSource.handedness === 'right') {\r\n            // Event-Handler für den Trigger hinzufügen\r\n            controller.onMotionControllerInitObservable.add(() => {\r\n            // Event-Handler für den Trigger\r\n            const triggerComponent = controller.motionController?.getComponent('xr-standard-trigger');\r\n\r\n            if (triggerComponent) {\r\n                triggerComponent.onButtonStateChangedObservable.add((buttonValue) => {\r\n                if (buttonValue.value > 0.5) {\r\n                    // Trigger ist gedrückt\r\n                    isDragging = true;\r\n                } else {\r\n                    // Trigger ist nicht gedrückt\r\n                    isDragging = false;\r\n                    previousPosition = null;\r\n                    previousRotation = null;\r\n                }\r\n                });\r\n            }\r\n            });\r\n        }\r\n        });        \r\n\r\n        /*******************************************************************\r\n         * Each Frame Check: (2)Beinhaltet Kollisionserkennung und behebung\r\n         *                   (1)sowie das Bewegen des Moveable Meshes durch VR\r\n         *******************************************************************/\r\n        // (1)\r\n        // Checke Punkte per Frame\r\n        scene.onBeforeRenderObservable.add(() => { \r\n        const currentPunkt = moveableNagelPunkte;\r\n        let distance = 1\r\n        let index = 0\r\n        // Controller Movement\r\n        // Überprüfen, ob der Trigger gedrückt ist und \"Dragging\" aktiv ist\r\n        if (isDragging) {\r\n            // Controller abrufen\r\n            const controller = xr.input.controllers.find((c) => c.inputSource.handedness === 'right');\r\n\r\n            // Überprüfen, ob der Controller gefunden wurde und die Komponenten vorhanden sind\r\n            if (controller && controller.grip && controller.grip.position && controller.grip.rotationQuaternion) {\r\n            // Aktuelle Position und Rotation des Controllers abrufen\r\n            const currentPosition = controller.grip.position;\r\n            const currentRotation = controller.grip.rotationQuaternion;\r\n\r\n            // Prüfen, ob die Position und Rotation definiert sind und der vorherige Status vorhanden ist\r\n            if (currentPosition && currentRotation && previousPosition && previousRotation) {\r\n                // Skalierung und Rotation des Ziel-Meshes berücksichtigen\r\n                // const scaledPositionDelta = currentPosition.subtract(previousPosition).divide(targetMesh.scaling);\r\n\r\n            // Rotation des Controllers in das Koordinatensystem des Weltursprungs umwandeln\r\n            const worldOriginRotation = Quaternion.Identity();\r\n            const controllerRotation = worldOriginRotation.multiply(currentRotation).multiply(previousRotation.conjugate());\r\n\r\n            // Berechne die Änderung der Position und Rotation des Controllers im Vergleich zum vorherigen Frame\r\n            const positionDelta = currentPosition.subtract(previousPosition);\r\n            const rotationDelta = controllerRotation;\r\n\r\n            // Skalierung und Rotation des Ziel-Meshes berücksichtigen\r\n            const scaledPositionDelta = positionDelta.divide(targetMesh.scaling);\r\n\r\n            // Ziel-Mesh transformieren\r\n            targetMesh.position.addInPlace(scaledPositionDelta.scaleInPlace(0.01)); // Skaliere die Bewegung nach Bedarf\r\n            targetMesh.rotationQuaternion!.multiplyInPlace(rotationDelta);\r\n            }\r\n\r\n        // Vorherigen Status aktualisieren\r\n        previousPosition = currentPosition.clone();\r\n        previousRotation = currentRotation.clone();\r\n        }\r\n    }\r\n        \r\n        // Controller Movement Ende\r\n        /**********************************************************************\r\n         * Kollisionsabfrage und Behebung (2)\r\n        **********************************************************************/\r\n        for (let i = 0; i < moveableNagelPunkte.length; i++) {\r\n            // Schaue ob wir eine Kollision haben, und wenn ja, ob diese Tiefer drinne ist als unsere bereits gespeicherte\r\n            \r\n            const currentPointDistance = distanceToWorldpoint(currentPunkt[i].absolutePosition, nagelPuzzleStatic, sdfContent)\r\n            //Wenn wir keine debugvalue haben(-1) und die Distanz eine kollision wiederspiegelt (kleiner 0), speichere diese wenn diese tiefer ist als die bereits gespeicherte\r\n            if (currentPointDistance < distance && currentPointDistance != -1.0 && currentPointDistance < 0) {\r\n                console.log(\"KOLLISSION\")\r\n                distance = currentPointDistance\r\n                index = i\r\n            }\r\n        }\r\n        // // eslint-disable-next-line no-constant-condition\r\n        // if (true){\r\n        if (distance > 0 ) {\r\n            nagelPuzzleStatic.material = noCollisionMaterial;\r\n        } else {\r\n            // Kollision, daher Material ändern\r\n            nagelPuzzleStatic.material = collisionMaterial;\r\n            // An-Aus Steuerbar über Button\r\n            if(collisionCorrectionEnabled){\r\n                // Starte cDelta und qDelta Berechnung\r\n                // Tiefster Punkt umgerechnet zum lokalen Koordinatensystem\r\n                const currentPoint = currentPunkt[index].absolutePosition\r\n                // Momentaner Root Node des NagelPuzzles als Lokaler Punkt\r\n                const rootPoint = nagelPuzzleMoveable.absolutePosition;\r\n\r\n                // Invertiere Normalenvektor, da er in die andere Richtung zeigt als für die Berechnung benötigt\r\n                // ---> zu <-----\r\n                const normalVector = new Vector3(normals[index].x, normals[index].y, normals[index].z);\r\n                let transformedNormal = Vector3.TransformNormal(normalVector, nagelPuzzleMoveable.getWorldMatrix());\r\n                transformedNormal = transformedNormal.multiply(new Vector3(-1, -1, -1));\r\n                console.log(transformedNormal)\r\n\r\n                // Kollision wurde erkannt, daher berechne die benötigte Änderung in Position und Orientierung\r\n                const radius = calculateBoundingBoxDiagonalLength(sdfContent.bbox.min, sdfContent.bbox.max);\r\n                //const positionOffset = cDelta(nagelPuzzleMoveable, currentPoint, transformedNormal, distance, radius, 1);\r\n                const positionOffset = ccDelta(distance, sdfContent.bbox.min, sdfContent.bbox.max, currentPoint, rootPoint, nagelPuzzleStatic, transformedNormal);\r\n\r\n                const orientationOffset = qqDelta(distance, sdfContent.bbox.min, sdfContent.bbox.max, currentPoint, rootPoint, nagelPuzzleStatic, transformedNormal, nagelPuzzleMoveable);\r\n                // Berechne neue Position und Orientierung (c + cDelta, q + qDelta)\r\n\r\n                const newPosition = nagelPuzzleMoveable.absolutePosition.add(positionOffset);\r\n                console.log(\"CurrentPosition: \", nagelPuzzleMoveable.absolutePosition)\r\n                console.log(\"PositionOffset: \", positionOffset)\r\n                console.log(\"NewPosition: \", newPosition)\r\n\r\n                const currentOrientation = nagelPuzzleMoveable.rotationQuaternion as Quaternion;\r\n                // console.log(\"CurrentOrientation: \", currentOrientation)\r\n                // console.log(\"OrientationOffset: \", orientationOffset)\r\n                // console.log(\"NewOrientation: \", currentOrientation.add(orientationOffset))\r\n                const newOrientation = (currentOrientation.add(orientationOffset));\r\n\r\n                // Setze neue Position und Orientierung\r\n                // Orientierung zuerst, da diese die Position eventuell beeinflusst,\r\n                // dannach Position um die geänderte Position von der Rotation zu überschreiben\r\n                nagelPuzzleMoveable.rotationQuaternion = newOrientation;\r\n                nagelPuzzleMoveable.position = new Vector3(newPosition.x, newPosition.y, newPosition.z);\r\n        }\r\n        }\r\n        });\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new DefaultSceneWithTexture();\r\n\r\n","import { Vector3 } from \"@babylonjs/core\";\r\n\r\nexport async function loadOffFile(url: string): Promise<string> {\r\n    try {\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return text;\r\n    } catch (error) {\r\n    console.error('Fehler beim Laden der Off-Datei:', error);\r\n    throw error;\r\n    }\r\n}\r\n\r\nexport function parseOffFileContent(offContent: string): { vertices: Vector3[], normals: Vector3[] } {\r\n    const lines = offContent.trim().split('\\n');\r\n    const vertices: Vector3[] = [];\r\n    const normals: Vector3[] = [];\r\n  \r\n    // Zeile 1: OFF\r\n    // Zeile 2: Anzahl der Vertices, Anzahl der Faces, Anzahl der Kanten (nicht benötigt)\r\n  \r\n    for (let i = 3; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      const values = line.split(' ').map(parseFloat);\r\n  \r\n      if (values.length >= 3) {\r\n        const vertex = Vector3.FromArray(values.slice(0, 3));\r\n        vertices.push(vertex);\r\n  \r\n        if (values.length >= 6) {\r\n          const normal = Vector3.FromArray(values.slice(3, 6));\r\n          normals.push(normal);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { vertices, normals };\r\n  }","import { Vector3 } from \"@babylonjs/core\";\r\n\r\nexport async function loadSDFFile(url: string): Promise<string> {\r\n    try {\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return text;\r\n    } catch (error) {\r\n    console.error('Fehler beim Laden der SDF-Datei:', error);\r\n    throw error;\r\n    }\r\n}\r\n\r\nexport interface SDFData {\r\n    bbox: {\r\n      min: Vector3,\r\n      max: Vector3\r\n    },\r\n    cellSize: number,\r\n    res: Vector3,\r\n    numCells: number,\r\n    distances: number[]\r\n  }\r\n  \r\n  export  function parseSDFFileContent(sdfContent: string): SDFData {\r\n    const lines = sdfContent.trim().split('\\n');\r\n    const data: SDFData = {\r\n      bbox: {\r\n        min: Vector3.Zero(),\r\n        max: Vector3.Zero()\r\n      },\r\n      cellSize: 0,\r\n      res: Vector3.Zero(),\r\n      numCells: 0,\r\n      distances: []\r\n    };\r\n  \r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      \r\n      // Kommentare ignorieren\r\n      const commentIndex = line.indexOf('#');\r\n      if (commentIndex !== -1) {\r\n        // Nur den Teil der Zeile vor dem Kommentar extrahieren\r\n        const cleanedLine = line.substring(0, commentIndex).trim();\r\n        \r\n        if (cleanedLine.length === 0) {\r\n          continue;\r\n        }\r\n  \r\n        const values = cleanedLine.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      } else {\r\n        const values = line.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    return data;\r\n  }","export default __webpack_public_path__ + \"9b31293ea96c8dfa518b45622da82a13.jpg\";"],"names":["distanceToWorldpoint","point","mesh","sdfFile","localPoint","worldMatrix","getWorldMatrix","invertedWorldMatrix","invertToRef","indexofPoint","o","bbox","min","vector","bboxMin","bboxMax","max","x","y","z","calculatedPoint","subtract","divide","cellSize","roundedPoint","Math","round","resolution","res","index","distances","lambdaAlt","minBox","maxBox","contactPoint","normalVector","distance","g","pow","length","r","n","Vector3","cross","DefaultSceneWithTexture","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","nagelPuzzleStatic","SceneLoader","meshes","scaling","nagelPuzzleMoveableLoad","nagelPuzzleMoveable","name","visibility","nagelPunkte","Mesh","parent","punkteInfo","url","response","fetch","text","error","loadOffFile","offInfo","offContent","lines","trim","split","vertices","normals","i","values","map","parseFloat","vertex","slice","push","normal","parseOffFileContent","punkte","punkt","position","rotationQuaternion","PI","loadFile","loadSDFFile","sdfContent","data","numCells","line","commentIndex","indexOf","cleanedLine","substring","parseSDFFileContent","boundingBox","setBoundingInfo","BoundingInfo","showBoundingBox","camera","setTarget","attachControl","ground","width","height","groundMaterial","diffuseTexture","grass","material","receiveShadows","light","intensity","shadowGenerator","useBlurExponentialShadowMap","blurScale","setDarkness","collisionMaterial","diffuseColor","Color3","noCollisionMaterial","moveableNagelPunkte","getChildMeshes","advancedTexture","AdvancedDynamicTexture","button","Button","background","color","left","top","collisionCorrectionEnabled","onPointerClickObservable","add","addControl","xr","createDefaultXRExperienceAsync","floorMeshes","targetMesh","baseExperience","sessionManager","session","previousPosition","previousRotation","isDragging","input","onControllerAddedObservable","controller","inputSource","handedness","onMotionControllerInitObservable","triggerComponent","motionController","getComponent","onButtonStateChangedObservable","buttonValue","value","onBeforeRenderObservable","currentPunkt","controllers","find","c","grip","currentPosition","currentRotation","rotationDelta","multiply","conjugate","scaledPositionDelta","addInPlace","scaleInPlace","multiplyInPlace","clone","currentPointDistance","absolutePosition","currentPoint","transformedNormal","diffX","diffY","diffZ","sqrt","calculateBoundingBoxDiagonalLength","positionOffset","rootPoint","staticMesh","lambda","ccDelta","orientationOffset","movingMesh","RxN","constantPart","wTimesDeltaT","q","Quaternion","qqDelta","newPosition","newOrientation"],"sourceRoot":""}