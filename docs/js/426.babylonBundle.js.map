{"version":3,"file":"js/426.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/nagelDistanceField.ts","webpack://babylonjs-typescript-webpack-template/./src/contactForce.ts","webpack://babylonjs-typescript-webpack-template/./assets/meshes/Nagel1.stl","webpack://babylonjs-typescript-webpack-template/./src/scenes/nagelPuzzle.ts","webpack://babylonjs-typescript-webpack-template/./src/offParser.ts","webpack://babylonjs-typescript-webpack-template/./src/sdfParser.ts","webpack://babylonjs-typescript-webpack-template/./assets/grass.jpg","webpack://babylonjs-typescript-webpack-template/./lts/loaders/generated/STL/stlFileLoader.ts"],"sourcesContent":["import { Mesh, float, int } from \"@babylonjs/core\";\r\nimport { Matrix, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { SDFData } from \"./sdfParser\";\r\n\r\n\r\nexport function index2(x: int, y: int, z: int, resolution: Vector3): number {\r\n    //console.log(\"Index \" , x + resolution.x*(y + resolution.y*z))\r\n    return x + resolution.x*(y + resolution.y*z)}\r\n\r\nexport function index(point: Vector3, sdfFile: SDFData): number{\r\n    const o = sdfFile.bbox.min;\r\n    if (!inBox(point, sdfFile.bbox.min, sdfFile.bbox.max)) {\r\n        return -1; // Nicht in BoundingBox, daher trivialer Fall\r\n    }\r\n    let calculatedPoint = point.subtract(o);\r\n    calculatedPoint = calculatedPoint.divide(new Vector3(sdfFile.cellSize, sdfFile.cellSize, sdfFile.cellSize));\r\n    const roundedPoint = new Vector3(\r\n        Math.round(calculatedPoint.x),\r\n        Math.round(calculatedPoint.y),\r\n        Math.round(calculatedPoint.z)\r\n        )\r\n    // console.log(\"Berechneter Punkt \", calculatedPoint, \" gerundet auf: \" , roundedPoint)\r\n    //return index2(calculatedPoint.x, calculatedPoint.y, calculatedPoint.z, sdfFile.res);\r\n    return index2(roundedPoint.x, roundedPoint.y, roundedPoint.z, sdfFile.res);\r\n}\r\n\r\nexport function pointFunction(x: int, y: int, z: int, sdfFile: SDFData): Vector3{\r\n    const o = sdfFile.bbox.min;\r\n    return o.add(new Vector3((x + 0.5) * sdfFile.cellSize, (y + 0.5) * sdfFile.cellSize, (z + 0.5) * sdfFile.cellSize));\r\n}\r\n/**\r\n * Ist im gegebenen Codeabschnitt aufgerufen, jedoch nicht dabei gewesen, daher selbst implementiert.\r\n * @param vector\r\n * @param bboxMin\r\n * @param bboxMax\r\n * @returns true, wenn Point: Vector3 in BoundingBox liegt, sonst false\r\n */\r\nfunction inBox(vector: Vector3, bboxMin: Vector3, bboxMax: Vector3): boolean{\r\n    return vector.x >= bboxMin.x && vector.y >= bboxMin.y && vector.z >= bboxMin.z && vector.x <= bboxMax.x && vector.y <= bboxMax.y && vector.z <= bboxMax.z;\r\n}\r\n\r\n/**\r\n *  Gegeben ein Punkt und ein Mesh, wird der Punkt in das lokale Koordinatensystem des Meshes transformiert,\r\n *  indem die WorldMatrix des Meshes invertiert wird und der Punkt mit der invertierten Matrix transformiert wird. \r\n * @param point \r\n * @param mesh \r\n * @returns localpoint vom Mesh\r\n */\r\nexport function calculateLocalPoint(point: Vector3, mesh: Mesh): Vector3 {\r\n    const worldMatrix = mesh.getWorldMatrix();\r\n    const invertedWorldMatrix = new Matrix();\r\n    worldMatrix.invertToRef(invertedWorldMatrix);\r\n\r\n    const localPoint = Vector3.TransformCoordinates(point, invertedWorldMatrix);\r\n    return localPoint;\r\n}\r\n\r\nexport function distanceToWorldpoint(point: Vector3, mesh: Mesh, sdfFile: SDFData): number {\r\n    const localPoint = calculateLocalPoint(point, mesh);\r\n    //const gitterPoint = pointFunction(localPoint.x, localPoint.y, localPoint.z, sdfFile)\r\n    // console.log(\"Localpoint: \" ,localPoint)\r\n    // console.log(\"Gitterpoint: \" ,gitterPoint)\r\n    const indexofPoint = index(localPoint, sdfFile);\r\n    if (indexofPoint === -1) {\r\n        return -1;\r\n    }\r\n    return sdfFile.distances[indexofPoint];\r\n}   \r\n","import { Matrix, Mesh, Quaternion, Vector3, Vector4, float } from \"@babylonjs/core\";\r\nimport { SDFData } from \"./sdfParser\";\r\nimport { calculateLocalPoint, index } from \"./nagelDistanceField\";\r\n\r\n//DEBUG Konstante!\r\n// Normalerweise 1\r\nconst cDeltaMultiplier = 1;\r\n\r\n/**\r\n * Liefert das Ergebnis von einer Multiplikation von einer 3x3 Matrix und einem Vector3 (Matrix * Vector3)\r\n * Als Funktion implementiert, da Babylon nur Punkttransformationen aber nicht basic Matrix berechnung hat\r\n * @param matrix \r\n * @param vector \r\n * @returns vector3\r\n */\r\nfunction multiplyMatrix3x3WithVector3(matrix: Matrix, vector: Vector3): Vector3 {\r\n  const result = new Vector3();\r\n\r\n  result.x = matrix.m[0] * vector.x + matrix.m[1] * vector.y + matrix.m[2] * vector.z;\r\n  result.y = matrix.m[3] * vector.x + matrix.m[4] * vector.y + matrix.m[5] * vector.z;\r\n  result.z = matrix.m[6] * vector.x + matrix.m[7] * vector.y + matrix.m[8] * vector.z;\r\n\r\n  return result;    \r\n}\r\n\r\n/**\r\n * Berechnet die benötigte änderung in Position und Orientierung, um von einer überschneideten Kollision zu einer an der Oberfläche berührenden Kollision zu kommen.\r\n * Dabei wird der Kontaktpunkt der Kollision über den Gradienten bestimmt\r\n */\r\nexport function distanceAndOriantationDelta(collisionPoint: Vector3, sdfFile: SDFData,){\r\n    // Bestimmte Kontaktpunkt durch Gradienten der Distanzwerte\r\n    const dDelta = new Vector3(\r\n        (sdfFile.distances[index(collisionPoint.add(new Vector3(sdfFile.cellSize, 0, 0)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(sdfFile.cellSize, 0, 0)), sdfFile)]) / 2, \r\n        (sdfFile.distances[index(collisionPoint.add(new Vector3(0, sdfFile.cellSize, 0)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(0, sdfFile.cellSize, 0)), sdfFile)]) / 2,\r\n        (sdfFile.distances[index(collisionPoint.add(new Vector3(0, 0, sdfFile.cellSize)), sdfFile)] - sdfFile.distances[index(collisionPoint.subtract(new Vector3(0, 0, sdfFile.cellSize)), sdfFile)]) / 2);\r\n    const normalVector = dDelta.divide(new Vector3(dDelta.length(), dDelta.length(), dDelta.length()));\r\n\r\n    return normalVector;\r\n}\r\nexport function inertiaMatrix(radius: float, mass: float): Matrix {\r\n    const inertia: float = (2 / 5) * mass * radius * radius;\r\n    const values = [inertia, 0, 0,\r\n                    0, inertia, 0,\r\n                    0, 0, inertia];\r\n    return Matrix.FromArray(values);\r\n}\r\n\r\nexport function invertedIneratiaMatrix(radius: float, mass: float): Matrix {\r\n    const inertia: float = 5 /( 2 * mass * radius * radius);\r\n    const values = [inertia, 0, 0, \r\n                    0, inertia, 0,\r\n                    0, 0, inertia];\r\n    console.log(\"DEBUG: inertiaMatrix: \", Matrix.FromArray(values))\r\n\r\n    return Matrix.FromArray(values);\r\n}\r\n\r\nexport function calculateBoundingBoxDiagonalLength(minBox: Vector3, maxBox: Vector3): number {\r\n    const diffX = maxBox.x - minBox.x;\r\n    const diffY = maxBox.y - minBox.y;\r\n    const diffZ = maxBox.z - minBox.z;\r\n  \r\n    const diagonalLength = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);\r\n  \r\n    return diagonalLength / 2;\r\n  }\r\n\r\nfunction lambda(movingMesh: Mesh, contactPoint: Vector3, normal: Vector3, distance: float, radius: float, mass: float){\r\n    const vector =(contactPoint.cross(normal)).asArray()\r\n    console.log(\"DEBUG: vector: \", vector)\r\n    const firstMultp = [0, 0, 0]\r\n    const matrix = invertedIneratiaMatrix(radius, mass).asArray()\r\n    for (let i = 0; i < 3; i++) {\r\n        for (let j = 0; j < 3; j++) {\r\n            firstMultp[i] += vector[j] * matrix[j * 3 + i];\r\n        }\r\n      }\r\n    const result = (firstMultp[0] * vector[0] + firstMultp[1] * vector[1] + firstMultp[2] * vector[2])\r\n    const lamda = (distance) / ((1 / mass) + result) \r\n    return lamda\r\n}\r\n\r\nexport function cDelta(movingMesh: Mesh, contactPoint: Vector3, normal: Vector3, distance: float, radius: float, mass: float) : Vector3{\r\n    const factor = ((1/mass)*lambda(movingMesh, contactPoint, normal, distance, radius, mass))\r\n    return normal.multiply(new Vector3(factor, factor, factor))\r\n}\r\nexport function localRadius(contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh){\r\n    const localContactPoint = calculateLocalPoint(contactPoint, staticMesh)\r\n    const localRootPoint = calculateLocalPoint(rootPoint, staticMesh)\r\n    return localContactPoint.subtract(localRootPoint)\r\n\r\n}\r\n\r\nexport function lambdaAlt(minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, normalVector: Vector3){\r\n    // Diagonale Berechnen und ^2\r\n    const g = Math.pow(maxBox.subtract(minBox).length(), 2) / 2\r\n    // r ist der Abstand des Kontaktpunktes zum Schwerpunkts-mittelpunkt da wir vom Center als Schwerpunkt ausgehen ist der Vektor: R - Schwerpunkt, mit schwerpunkt = 0,0,0 => R\r\n    const r = contactPoint\r\n    // NormalenVektor muss umgedreht werden, da er momentan in Kollisionsrichtung zeigt\r\n    // const n = normalVector.scale(-1)\r\n    const n = new Vector3(normalVector.x, normalVector.y, normalVector.z)\r\n\r\n    return (1 + (5 / (2 * g)) * Math.pow((r.cross(n)).length(), 2)) \r\n}\r\nexport function ccDelta(distance: float, minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh, normalVector: Vector3){\r\n    const lambda = lambdaAlt(minBox, maxBox, contactPoint, normalVector)\r\n    // return normalVector.scale(distance / (1 + (5 / (2 * Math.pow(calculateBoundingBoxDiagonalLength(minBox, maxBox), 2))) * Math.pow(((contactPoint.subtract(rootPoint)).cross(normalVector)).length(), 2)))\r\n    // Wieder den normalVektor umdrehen\r\n    // const n = normalVector.scale(-1)\r\n    const n = new Vector3(normalVector.x, normalVector.y, normalVector.z)\r\n    return (n.multiply(new Vector3(lambda, lambda, lambda))).multiply(new Vector3(cDeltaMultiplier, cDeltaMultiplier, cDeltaMultiplier))\r\n}\r\n\r\nexport function qqDelta(distance: float, minBox: Vector3, maxBox: Vector3, contactPoint: Vector3, rootPoint: Vector3, staticMesh: Mesh, normalVector: Vector3, movingMesh: Mesh){\r\n//     // 5 geteilt durch 2*radius^2 * lambda'\r\n//    const constantPart = (5 / (2 * Math.pow(calculateBoundingBoxDiagonalLength(minBox, maxBox), 2)) * \r\n//                     distance / (1 + (5 / (2 * Math.pow(calculateBoundingBoxDiagonalLength(minBox, maxBox), 2))) * Math.pow(((contactPoint.subtract(rootPoint)).cross(normalVector)).length(), 2))) \r\n//    const wTimesT = (contactPoint.subtract(rootPoint)).cross(normalVector).scale(constantPart)\r\n//    const tempQ = new Quaternion(wTimesT.x, wTimesT.y, wTimesT.z, 0)\r\n//    const deltaQ = (tempQ.multiply(movingMesh.rotationQuaternion as Quaternion)).scale(1/2)\r\n//    return deltaQ\r\n    \r\n    // Diagonale Berechnen und ^2\r\n    const g = Math.pow(maxBox.subtract(minBox).length(), 2) / 2\r\n    const RxN = contactPoint.cross(normalVector)\r\n    const constantPart = 5/(2*g) * lambdaAlt(minBox, maxBox, contactPoint, normalVector)\r\n    const wTimesDeltaT = RxN.multiply(new Vector3(constantPart, constantPart, constantPart))\r\n\r\n    const q = movingMesh.rotationQuaternion as Quaternion // Momentane Orientierung\r\n    // Skalare Komponente ist in Babylon anscheinend die letzte Komponente\r\n    const wQuaternion = new Quaternion(wTimesDeltaT.x / 2, wTimesDeltaT.y / 2, wTimesDeltaT.z / 2, 0) // Durch 2 da * 1/2\r\n    return wQuaternion.multiply(q)\r\n\r\n}\r\nexport function qDelta(movingMesh: Mesh, contactPoint: Vector3, normal: Vector3, distance: float, radius: float, mass: float){\r\n    const lambaTimesInverse = invertedIneratiaMatrix(radius, mass).scale(lambda(movingMesh, contactPoint, normal, distance, radius, mass))\r\n    const radiusCrossNormal = contactPoint.cross(normal)\r\n    const quaterionChange = multiplyMatrix3x3WithVector3(lambaTimesInverse, radiusCrossNormal).scale(1/2)\r\n    // Momentanes Quaterion vom Mesh\r\n    const currentQuaterion = movingMesh.rotationQuaternion as Quaternion\r\n    const quaterionChangeCast = new Quaternion(quaterionChange.x, quaterionChange.y, quaterionChange.z, 0)\r\n    // Mutliplikation von Quaterionen\r\n    // Dabei Skalarkomponente ist hier die 4te Komponente, und 0 da wir von Vektor3 umwandeln\r\n    const newQuaterion = currentQuaterion.multiply(quaterionChangeCast)\r\n\r\n    //return (0, quaterionChange) \r\n    return newQuaterion\r\n}","export default __webpack_public_path__ + \"628b10094e62129397fc4859ae7349d6.stl\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { Axis, BoundingInfo, Color3, HighlightLayer, Mesh, MeshBuilder, Nullable, SceneLoader, WebXRControllerComponent } from \"@babylonjs/core\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\n// import \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport grassTextureUrl from \"../../assets/grass.jpg\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\r\nimport \"@babylonjs/loaders/STL/stlFileLoader\";\r\nimport \"@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent\";\r\n\r\n// Custom Importe / \r\nimport { calculateLocalPoint, index, index2, pointFunction, distanceToWorldpoint } from \"../nagelDistanceField\";\r\nimport { cDelta, qDelta, calculateBoundingBoxDiagonalLength, ccDelta, qqDelta } from \"../contactForce\";\r\nimport { STLFileLoader } from \"@babylonjs/loaders/STL/stlFileLoader\";\r\n// Laden und Parsen von SDF Dateien\r\nimport { loadSDFFile, parseSDFFileContent } from '../sdfParser';\r\nimport { SDFData } from '../sdfParser';\r\nimport { loadOffFile, parseOffFileContent } from '../offParser';\r\nimport NagelPuzzleStatic from \"../../assets/meshes/Nagel1.stl\";\r\n\r\n\r\n\r\nexport class DefaultSceneWithTexture implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = true;\r\n        // Import Nagel Puzzle Mesh via STL\r\n        const nagelPuzzleStaticLoad = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n            \"\",\r\n            NagelPuzzleStatic,\r\n            scene, \r\n            undefined,\r\n            \".stl\"\r\n        );\r\n        const nagelPuzzleStatic = nagelPuzzleStaticLoad.meshes[0] as Mesh;\r\n\r\n        // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n        nagelPuzzleStatic.scaling = new Vector3(1, 1, -1);\r\n\r\n        const nagelPuzzleMoveableLoad = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n            \"\",\r\n            NagelPuzzleStatic,\r\n            scene,\r\n            undefined,\r\n            \".stl\"\r\n            \r\n        );\r\n        const nagelPuzzleMoveable = nagelPuzzleMoveableLoad.meshes[0] as Mesh;\r\n        nagelPuzzleMoveable.name = \"NagelPuzzleMoveable\";\r\n        nagelPuzzleMoveable.visibility = 1;\r\n        // Scale z Axis mit -1 um Koordinatensystem an Babylon's anzupassen\r\n        nagelPuzzleMoveable.scaling = new Vector3(1, 1, -1);\r\n        \r\n        // Erstelle leere Mesh um die Punkte zu speichern\r\n        // dabei sind die Punkte, die Punkte der Oberfläche des moveable Meshes\r\n        const nagelPunkte = new Mesh(\"NagelPunkte\", scene);\r\n        nagelPunkte.parent = nagelPuzzleMoveableLoad.meshes[0];\r\n        const punkteInfo: Promise<string> = loadOffFile(\"https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.noff\");\r\n        const offInfo = parseOffFileContent(await punkteInfo);\r\n        const punkte = offInfo.vertices\r\n        const normals = offInfo.normals\r\n\r\n\r\n        // Erstelle ein leeres Mesh an jeden dieser Punkte und parente diesen an nagelPunkte \r\n        // Vorerst sichbar \r\n        for (let i = 0; i < punkte.length; i++) {\r\n            const punkt = new Mesh(\"Punkt\" + i, scene)\r\n            punkt.position = punkte[i];\r\n            punkt.parent = nagelPunkte;\r\n            punkt.visibility = 0;\r\n        }\r\n        nagelPuzzleMoveable.position = new Vector3(-0.5, 1, 0);\r\n        nagelPuzzleStatic.position = new Vector3(0, 1, 0);\r\n\r\n        // Drehe Moveable Mesh um 180°\r\n        nagelPuzzleMoveable.rotationQuaternion = Quaternion.FromEulerVector( new Vector3(Math.PI / 2, Math.PI, 0));\r\n\r\n        // Scaling der Meshe für WebXr\r\n        nagelPuzzleMoveable.scaling = new Vector3(0.01, 0.01, 0.01);\r\n        nagelPuzzleStatic.scaling = new Vector3(0.01, 0.01, 0.01);\r\n\r\n  \r\n        // Die URL der SDF-Datei\r\n        const sdfFileUrl = 'https://raw.githubusercontent.com/P-Miha/Kyros-Zylinder/master/assets/SDFInformation/Nagel1.sdf';\r\n        // Definiert in einer ausgelagerten Datei\r\n        // Laded die SDF-Datei aus dem Internet und Parset diese in ein SDFData-Objekt\r\n        const loadFile = loadSDFFile(sdfFileUrl);\r\n        const sdfContent = parseSDFFileContent(await loadFile);\r\n  \r\n        // //Print SDF-Data\r\n        // console.log(\"SDF-Data: \", sdfContent);\r\n        \r\n        // Erstelle empty mesh um eine Custom boundingbox zu erstellen\r\n        const boundingBox = new Mesh(\"boundingBox\", scene);\r\n        boundingBox.setBoundingInfo(new BoundingInfo(sdfContent.bbox.min, sdfContent.bbox.max));\r\n        boundingBox.showBoundingBox = true;\r\n        \r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\r\n            \"my first camera\",\r\n            0,\r\n            Math.PI / 3,\r\n            10,\r\n            new Vector3(0, 0, 0),\r\n            scene\r\n        );\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        // const light = new HemisphericLight(\r\n        //     \"light\",\r\n        //     new Vector3(0, 1, 0),\r\n        //     scene\r\n        // );\r\n\r\n        // // Default intensity is 1. Let's dim the light a small amount\r\n        // light.intensity = 0.7;\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\r\n            \"ground\",\r\n            { width: 6, height: 6 },\r\n            scene\r\n        );\r\n\r\n        // Load a texture to be used as the ground material\r\n        const groundMaterial = new StandardMaterial(\"ground material\", scene);\r\n        groundMaterial.diffuseTexture = new Texture(grassTextureUrl, scene);\r\n\r\n        ground.material = groundMaterial;\r\n        ground.receiveShadows = true;\r\n\r\n        const light = new DirectionalLight(\r\n            \"light\",\r\n            new Vector3(0, -1, 1),\r\n            scene\r\n        );\r\n        light.intensity = 0.5;\r\n        light.position.y = 10;\r\n\r\n        const shadowGenerator = new ShadowGenerator(512, light)\r\n        shadowGenerator.useBlurExponentialShadowMap = true;\r\n        shadowGenerator.blurScale = 2;\r\n        shadowGenerator.setDarkness(0.2);\r\n\r\n        //shadowGenerator.getShadowMap()!.renderList!.push(sphere);\r\n        //Erstelle Material für Kollision mit Farbe Rot und Kollisionsfrei mit Farbe Grün\r\n        const collisionMaterial = new StandardMaterial(\"collisionMaterial\", scene);\r\n        collisionMaterial.diffuseColor = new Color3(1, 0, 0);\r\n\r\n        const noCollisionMaterial = new StandardMaterial(\"noCollisionMaterial\", scene);\r\n        noCollisionMaterial.diffuseColor = new Color3(0, 1, 0);\r\n        \r\n        const moveableNagelPunkte = nagelPunkte.getChildMeshes()\r\n        // Checke jeden Frame ob die Kugel im Nagel ist\r\n        // scene.onBeforeRenderObservable.add(() => {\r\n        //     const collided = Array<Vector3>();\r\n        //     // Checke jeden Punkt von NagelPunkte ob die SDF Distanz kleiner als 0 ist\r\n        //     for (let i = 0; i < moveableNagelPunkte.length; i++) {\r\n        //         const currentPunkt = moveableNagelPunkte[i];\r\n        //         const distance = distanceToWorldpoint(currentPunkt.absolutePosition, nagelPuzzleStatic, sdfContent)\r\n        //         // Wenn Distanz = -1 ist, ist der Punkt nicht in der SDF, daher ignorieren\r\n        //         if (distance < 0 && distance != -1.0) {\r\n        //             collided.push(currentPunkt.absolutePosition);\r\n        //             //console.log(\"Collision mit Punkt\", currentPunkt.absolutePosition, \" and NormalVector: \", distanceAndOriantationDelta(currentPunkt.absolutePosition, sdfContent))\r\n        //         }\r\n        //     }\r\n        //     if (collided.length == 0) {\r\n        //         nagelPuzzleStatic.material = noCollisionMaterial;\r\n        //     } else {\r\n        //         nagelPuzzleStatic.material = collisionMaterial;\r\n        //     }\r\n        // }\r\n        // );\r\n       \r\n        // DEBUG \r\n        // const sphere = MeshBuilder.CreateSphere(\r\n        //     \"sphere\",\r\n        //     { diameter: 1 },\r\n        //     scene\r\n        // );\r\n        // sphere.position = moveableNagelPunkte[0].absolutePosition;\r\n        // const hl = new HighlightLayer(\"hl1\", scene);\r\n        // hl.addMesh(sphere, Color3.Green());\r\n        // Erstelle Pfeil\r\n        // const direction = new Vector3(0, 0, 1);\r\n        // const arrow = MeshBuilder.CreateTube('arrow', {\r\n        //     path: [new Vector3(0, 0, 0), direction.scale(2)],\r\n        //     radius: 0.05,\r\n        //     tessellation: 16,\r\n        //     updatable: true\r\n        //   }, scene);      \r\n          \r\n        // VR-Integration, \"WebXR\"\r\n        const xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });\r\n\r\n        // XR-Sitzung abrufen\r\n        const xrSession = xr.baseExperience.sessionManager.session;\r\n        \r\n        const targetMesh = nagelPuzzleMoveable; // Hier musst du den Code zum Erstellen oder Laden deines Ziel-Meshs einfügen\r\n\r\n        // Vorherigen Status des Controllers speichern\r\n        let previousPosition: Nullable<Vector3> = null;\r\n        let previousRotation: Nullable<Quaternion> = null;\r\n\r\n        // Controller-Status für \"Dragging\" speichern\r\n        let isDragging = false;\r\n\r\n        // Event-Handler für den rechten Controller hinzufügen\r\n        xr.input.onControllerAddedObservable.add((controller) => {\r\n        // Überprüfen, ob der Controller der rechte Controller ist\r\n        if (controller.inputSource.handedness === 'right') {\r\n            // Event-Handler für den Trigger hinzufügen\r\n            controller.onMotionControllerInitObservable.add(() => {\r\n            // Event-Handler für den Trigger\r\n            const triggerComponent = controller.motionController?.getComponent('xr-standard-trigger');\r\n\r\n            if (triggerComponent) {\r\n                triggerComponent.onButtonStateChangedObservable.add((buttonValue) => {\r\n                if (buttonValue.value > 0.5) {\r\n                    // Trigger ist gedrückt\r\n                    isDragging = true;\r\n                } else {\r\n                    // Trigger ist nicht gedrückt\r\n                    isDragging = false;\r\n                    previousPosition = null;\r\n                    previousRotation = null;\r\n                }\r\n                });\r\n            }\r\n            });\r\n        }\r\n        });        \r\n\r\n\r\n        // Checke Punkte per Frame\r\n        scene.onBeforeRenderObservable.add(() => { \r\n        const currentPunkt = moveableNagelPunkte;\r\n        let distance = 1\r\n        let index = 0\r\n        // Controller Movement\r\n // Überprüfen, ob der Trigger gedrückt ist und \"Dragging\" aktiv ist\r\n if (isDragging) {\r\n    // Controller abrufen\r\n    const controller = xr.input.controllers.find((c) => c.inputSource.handedness === 'right');\r\n\r\n    // Überprüfen, ob der Controller gefunden wurde und die Komponenten vorhanden sind\r\n    if (controller && controller.grip && controller.grip.position && controller.grip.rotationQuaternion) {\r\n      // Aktuelle Position und Rotation des Controllers abrufen\r\n      const currentPosition = controller.grip.position;\r\n      const currentRotation = controller.grip.rotationQuaternion;\r\n\r\n      // Prüfen, ob die Position und Rotation definiert sind und der vorherige Status vorhanden ist\r\n      if (currentPosition && currentRotation && previousPosition && previousRotation) {\r\n        // Skalierung und Rotation des Ziel-Meshes berücksichtigen\r\n        // const scaledPositionDelta = currentPosition.subtract(previousPosition).divide(targetMesh.scaling);\r\n\r\n    // Rotation des Controllers in das Koordinatensystem des Weltursprungs umwandeln\r\n    const worldOriginRotation = Quaternion.Identity();\r\n    const controllerRotation = worldOriginRotation.multiply(currentRotation).multiply(previousRotation.conjugate());\r\n\r\n    // Berechne die Änderung der Position und Rotation des Controllers im Vergleich zum vorherigen Frame\r\n    const positionDelta = currentPosition.subtract(previousPosition);\r\n    const rotationDelta = controllerRotation;\r\n\r\n    // Skalierung und Rotation des Ziel-Meshes berücksichtigen\r\n    const scaledPositionDelta = positionDelta.divide(targetMesh.scaling);\r\n\r\n    // Ziel-Mesh transformieren\r\n    targetMesh.position.addInPlace(scaledPositionDelta.scaleInPlace(0.01)); // Skaliere die Bewegung nach Bedarf\r\n    targetMesh.rotationQuaternion!.multiplyInPlace(rotationDelta);\r\n    }\r\n\r\n      // Vorherigen Status aktualisieren\r\n      previousPosition = currentPosition.clone();\r\n      previousRotation = currentRotation.clone();\r\n    }\r\n  }\r\n        \r\n        // Controller Movement Ende\r\n\r\n        for (let i = 0; i < moveableNagelPunkte.length; i++) {\r\n            // Schaue ob wir eine Kollision haben, und wenn ja, ob diese Tiefer drinne ist als unsere bereits gespeicherte\r\n            \r\n            const currentPointDistance = distanceToWorldpoint(currentPunkt[i].absolutePosition, nagelPuzzleStatic, sdfContent)\r\n            //Wenn wir keine debugvalue haben(-1) und die Distanz eine kollision wiederspiegelt (kleiner 0), speichere diese wenn diese tiefer ist als die bereits gespeicherte\r\n            if (currentPointDistance < distance && currentPointDistance != -1.0 && currentPointDistance < 0) {\r\n                console.log(\"KOLLISSION\")\r\n                distance = currentPointDistance\r\n                index = i\r\n            }\r\n        }\r\n        // // eslint-disable-next-line no-constant-condition\r\n        // if (true){\r\n        if (distance > 0 ) {\r\n            nagelPuzzleStatic.material = noCollisionMaterial;\r\n        } else {\r\n            // Kollision, daher Material ändern\r\n            nagelPuzzleStatic.material = collisionMaterial;\r\n            // Starte cDelta und qDelta Berechnung\r\n            \r\n            // Tiefster Punkt umgerechnet zum lokalen Koordinatensystem\r\n            const currentPoint = currentPunkt[index].absolutePosition\r\n            // Momentaner Root Node des NagelPuzzles als Lokaler Punkt\r\n            const rootPoint = nagelPuzzleMoveable.absolutePosition;\r\n\r\n            // Invertiere Normalenvektor, da er in die andere Richtung zeigt als für die Berechnung benötigt\r\n            // ---> zu <-----\r\n            const normalVector = new Vector3(normals[index].x, normals[index].y, normals[index].z);\r\n\r\n            // const NagelPuzzleMoveableWorldMatrix = nagelPuzzleMoveable.getWorldMatrix();\r\n            let transformedNormal = Vector3.TransformNormal(normalVector, nagelPuzzleMoveable.getWorldMatrix());\r\n            transformedNormal = transformedNormal.multiply(new Vector3(-1, -1, -1));\r\n\r\n            // Kollision wurde erkannt, daher berechne die benötigte Änderung in Position und Orientierung\r\n            const radius = calculateBoundingBoxDiagonalLength(sdfContent.bbox.min, sdfContent.bbox.max);\r\n            //const positionOffset = cDelta(nagelPuzzleMoveable, currentPoint, transformedNormal, distance, radius, 1);\r\n            const positionOffset = ccDelta(distance, sdfContent.bbox.min, sdfContent.bbox.max, currentPoint, rootPoint, nagelPuzzleStatic, transformedNormal);\r\n            console.log(\"Offset: \", positionOffset)\r\n            console.log(\"CurrentPoint: \", currentPoint)\r\n            // const orientationOffset = qDelta(nagelPuzzleMoveable, currentPoint, transformedNormal, distance, radius, 1);\r\n            const orientationOffset = qqDelta(distance, sdfContent.bbox.min, sdfContent.bbox.max, currentPoint, rootPoint, nagelPuzzleStatic, transformedNormal, nagelPuzzleMoveable);\r\n            // Berechne neue Position und Orientierung (c + cDelta, q + qDelta)\r\n\r\n            // const newPosition = currentPoint.add(positionOffset);\r\n            const newPosition = nagelPuzzleMoveable.absolutePosition.add(positionOffset);\r\n            console.log(\"NewPosition: \", newPosition)\r\n            const currentOrientation = nagelPuzzleMoveable.rotationQuaternion as Quaternion;\r\n            const newOrientation = currentOrientation.add(orientationOffset);\r\n            // Setze neue Position und Orientierung\r\n            nagelPuzzleMoveable.position = new Vector3(newPosition.x, newPosition.y, newPosition.z);\r\n            nagelPuzzleMoveable.rotationQuaternion = newOrientation;\r\n        }\r\n        });\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new DefaultSceneWithTexture();\r\n\r\n","import { Vector3 } from \"@babylonjs/core\";\r\n\r\nexport async function loadOffFile(url: string): Promise<string> {\r\n    try {\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return text;\r\n    } catch (error) {\r\n    console.error('Fehler beim Laden der Off-Datei:', error);\r\n    throw error;\r\n    }\r\n}\r\n\r\nexport function parseOffFileContent(offContent: string): { vertices: Vector3[], normals: Vector3[] } {\r\n    const lines = offContent.trim().split('\\n');\r\n    const vertices: Vector3[] = [];\r\n    const normals: Vector3[] = [];\r\n  \r\n    // Zeile 1: OFF\r\n    // Zeile 2: Anzahl der Vertices, Anzahl der Faces, Anzahl der Kanten (nicht benötigt)\r\n  \r\n    for (let i = 3; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      const values = line.split(' ').map(parseFloat);\r\n  \r\n      if (values.length >= 3) {\r\n        const vertex = Vector3.FromArray(values.slice(0, 3));\r\n        vertices.push(vertex);\r\n  \r\n        if (values.length >= 6) {\r\n          const normal = Vector3.FromArray(values.slice(3, 6));\r\n          normals.push(normal);\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { vertices, normals };\r\n  }","import { Vector3 } from \"@babylonjs/core\";\r\n\r\nexport async function loadSDFFile(url: string): Promise<string> {\r\n    try {\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return text;\r\n    } catch (error) {\r\n    console.error('Fehler beim Laden der SDF-Datei:', error);\r\n    throw error;\r\n    }\r\n}\r\n\r\nexport interface SDFData {\r\n    bbox: {\r\n      min: Vector3,\r\n      max: Vector3\r\n    },\r\n    cellSize: number,\r\n    res: Vector3,\r\n    numCells: number,\r\n    distances: number[]\r\n  }\r\n  \r\n  export  function parseSDFFileContent(sdfContent: string): SDFData {\r\n    const lines = sdfContent.trim().split('\\n');\r\n    const data: SDFData = {\r\n      bbox: {\r\n        min: Vector3.Zero(),\r\n        max: Vector3.Zero()\r\n      },\r\n      cellSize: 0,\r\n      res: Vector3.Zero(),\r\n      numCells: 0,\r\n      distances: []\r\n    };\r\n  \r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      \r\n      // Kommentare ignorieren\r\n      const commentIndex = line.indexOf('#');\r\n      if (commentIndex !== -1) {\r\n        // Nur den Teil der Zeile vor dem Kommentar extrahieren\r\n        const cleanedLine = line.substring(0, commentIndex).trim();\r\n        \r\n        if (cleanedLine.length === 0) {\r\n          continue;\r\n        }\r\n  \r\n        const values = cleanedLine.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      } else {\r\n        const values = line.split(' ').map(parseFloat);\r\n        \r\n        if (values.length > 0) {\r\n          if (i === 0) {\r\n            data.bbox.min = Vector3.FromArray(values)\r\n          } else if (i === 1) {\r\n            data.bbox.max = Vector3.FromArray(values)\r\n          } else if (i === 2) {\r\n            data.cellSize = values[0];\r\n          } else if (i === 3) {\r\n            data.res = Vector3.FromArray(values);\r\n          } else if (i === 4) {\r\n            data.numCells = values[0];\r\n          } else {\r\n            data.distances.push(...values);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    return data;\r\n  }","export default __webpack_public_path__ + \"9b31293ea96c8dfa518b45622da82a13.jpg\";","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { ISceneLoaderPlugin, ISceneLoaderPluginExtensions } from \"core/Loading/sceneLoader\";\r\nimport { SceneLoader } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * STL file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class STLFileLoader implements ISceneLoaderPlugin {\r\n    /** @internal */\r\n    public solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g;\r\n\r\n    /** @internal */\r\n    public facetsPattern = /facet([\\s\\S]*?)endfacet/g;\r\n    /** @internal */\r\n    public normalPattern = /normal[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n    /** @internal */\r\n    public vertexPattern = /vertex[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public name = \"stl\";\r\n\r\n    /**\r\n     * Defines the extensions the stl loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     * we'll convert to string if it looks like it's an ASCII .stl\r\n     */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".stl\": { isBinary: true },\r\n    };\r\n\r\n    /**\r\n     * Defines if Y and Z axes are swapped or not when loading an STL file.\r\n     * The default is false to maintain backward compatibility. When set to\r\n     * true, coordinates from the STL file are used without change.\r\n     */\r\n    public static DO_NOT_ALTER_FILE_COORDINATES = false;\r\n\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    public importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>): boolean {\r\n        let matches;\r\n\r\n        if (typeof data !== \"string\") {\r\n            if (this._isBinary(data)) {\r\n                // binary .stl\r\n                const babylonMesh = new Mesh(\"stlmesh\", scene);\r\n                this._parseBinary(babylonMesh, data);\r\n                if (meshes) {\r\n                    meshes.push(babylonMesh);\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // ASCII .stl\r\n\r\n            // convert to string\r\n            const array_buffer = new Uint8Array(data);\r\n            let str = \"\";\r\n            for (let i = 0; i < data.byteLength; i++) {\r\n                str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\r\n            }\r\n            data = str;\r\n        }\r\n\r\n        //if arrived here, data is a string, containing the STLA data.\r\n\r\n        while ((matches = this.solidPattern.exec(data))) {\r\n            let meshName = matches[1];\r\n            const meshNameFromEnd = matches[3];\r\n            if (meshNameFromEnd && meshName != meshNameFromEnd) {\r\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\r\n                return false;\r\n            }\r\n\r\n            // check meshesNames\r\n            if (meshesNames && meshName) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (!meshesNames.indexOf(meshName)) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (meshName !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // stl mesh name can be empty as well\r\n            meshName = meshName || \"stlmesh\";\r\n\r\n            const babylonMesh = new Mesh(meshName, scene);\r\n            this._parseASCII(babylonMesh, matches[2]);\r\n            if (meshes) {\r\n                meshes.push(babylonMesh);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns true if successful or false otherwise\r\n     */\r\n    public load(scene: Scene, data: any, rootUrl: string): boolean {\r\n        const result = this.importMesh(null, scene, data, rootUrl, null);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainer(scene: Scene, data: string, rootUrl: string): AssetContainer {\r\n        const container = new AssetContainer(scene);\r\n        scene._blockEntityCollection = true;\r\n        this.importMesh(null, scene, data, rootUrl, container.meshes);\r\n        scene._blockEntityCollection = false;\r\n        return container;\r\n    }\r\n\r\n    private _isBinary(data: any) {\r\n        // check if file size is correct for binary stl\r\n        const reader = new DataView(data);\r\n\r\n        // A Binary STL header is 80 bytes, if the data size is not great than\r\n        // that then it's not a binary STL.\r\n        if (reader.byteLength <= 80) {\r\n            return false;\r\n        }\r\n\r\n        const faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;\r\n        const nFaces = reader.getUint32(80, true);\r\n\r\n        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {\r\n            return true;\r\n        }\r\n\r\n        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'\r\n        const ascii = [115, 111, 108, 105, 100];\r\n        for (let off = 0; off < 5; off++) {\r\n            if (reader.getUint8(off) !== ascii[off]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _parseBinary(mesh: Mesh, data: ArrayBuffer) {\r\n        const reader = new DataView(data);\r\n        const faces = reader.getUint32(80, true);\r\n\r\n        const dataOffset = 84;\r\n        const faceLength = 12 * 4 + 2;\r\n\r\n        let offset = 0;\r\n\r\n        const positions = new Float32Array(faces * 3 * 3);\r\n        const normals = new Float32Array(faces * 3 * 3);\r\n        const indices = new Uint32Array(faces * 3);\r\n        let indicesCount = 0;\r\n\r\n        for (let face = 0; face < faces; face++) {\r\n            const start = dataOffset + face * faceLength;\r\n            const normalX = reader.getFloat32(start, true);\r\n            const normalY = reader.getFloat32(start + 4, true);\r\n            const normalZ = reader.getFloat32(start + 8, true);\r\n\r\n            for (let i = 1; i <= 3; i++) {\r\n                const vertexstart = start + i * 12;\r\n\r\n                // ordering is intentional to match ascii import\r\n                positions[offset] = reader.getFloat32(vertexstart, true);\r\n                normals[offset] = normalX;\r\n\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 2] = normalY;\r\n                    normals[offset + 1] = normalZ;\r\n                } else {\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 1] = normalY;\r\n                    normals[offset + 2] = normalZ;\r\n                }\r\n\r\n                offset += 3;\r\n            }\r\n\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices[indicesCount] = indicesCount;\r\n                indices[indicesCount + 1] = indicesCount + 2;\r\n                indices[indicesCount + 2] = indicesCount + 1;\r\n                indicesCount += 3;\r\n            } else {\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n\r\n    private _parseASCII(mesh: Mesh, solidData: string) {\r\n        const positions = [];\r\n        const normals = [];\r\n        const indices = [];\r\n        let indicesCount = 0;\r\n\r\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\r\n        let matches;\r\n        while ((matches = this.facetsPattern.exec(solidData))) {\r\n            const facet = matches[1];\r\n            //one normal per face\r\n            const normalMatches = this.normalPattern.exec(facet);\r\n            this.normalPattern.lastIndex = 0;\r\n            if (!normalMatches) {\r\n                continue;\r\n            }\r\n            const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\r\n\r\n            let vertexMatch;\r\n            while ((vertexMatch = this.vertexPattern.exec(facet))) {\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\r\n                    normals.push(normal[0], normal[1], normal[2]);\r\n                } else {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));\r\n\r\n                    // Flipping the second and third component because inverted\r\n                    // when normal was declared.\r\n                    normals.push(normal[0], normal[2], normal[1]);\r\n                }\r\n            }\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\r\n                indicesCount += 3;\r\n            } else {\r\n                indices.push(indicesCount++, indicesCount++, indicesCount++);\r\n            }\r\n            this.vertexPattern.lastIndex = 0;\r\n        }\r\n\r\n        this.facetsPattern.lastIndex = 0;\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new STLFileLoader());\r\n}\r\n"],"names":["distanceToWorldpoint","point","mesh","sdfFile","localPoint","worldMatrix","getWorldMatrix","invertedWorldMatrix","invertToRef","indexofPoint","o","bbox","min","vector","bboxMin","bboxMax","max","x","y","z","calculatedPoint","subtract","divide","cellSize","roundedPoint","Math","round","resolution","res","distances","lambdaAlt","minBox","maxBox","contactPoint","normalVector","g","pow","length","r","n","Vector3","cross","DefaultSceneWithTexture","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","nagelPuzzleStatic","SceneLoader","meshes","scaling","nagelPuzzleMoveableLoad","nagelPuzzleMoveable","name","visibility","nagelPunkte","Mesh","parent","punkteInfo","url","response","fetch","text","error","loadOffFile","offInfo","offContent","lines","trim","split","vertices","normals","i","values","map","parseFloat","vertex","slice","push","normal","parseOffFileContent","punkte","punkt","position","rotationQuaternion","PI","loadFile","loadSDFFile","sdfContent","data","numCells","line","commentIndex","indexOf","cleanedLine","substring","parseSDFFileContent","boundingBox","setBoundingInfo","BoundingInfo","showBoundingBox","camera","setTarget","attachControl","ground","width","height","groundMaterial","diffuseTexture","grass","material","receiveShadows","light","intensity","shadowGenerator","useBlurExponentialShadowMap","blurScale","setDarkness","collisionMaterial","diffuseColor","Color3","noCollisionMaterial","moveableNagelPunkte","getChildMeshes","xr","createDefaultXRExperienceAsync","floorMeshes","targetMesh","baseExperience","sessionManager","session","previousPosition","previousRotation","isDragging","input","onControllerAddedObservable","add","controller","inputSource","handedness","onMotionControllerInitObservable","triggerComponent","motionController","getComponent","onButtonStateChangedObservable","buttonValue","value","onBeforeRenderObservable","currentPunkt","distance","index","controllers","find","c","grip","currentPosition","currentRotation","rotationDelta","multiply","conjugate","scaledPositionDelta","addInPlace","scaleInPlace","multiplyInPlace","clone","currentPointDistance","absolutePosition","currentPoint","transformedNormal","diffX","diffY","diffZ","sqrt","calculateBoundingBoxDiagonalLength","positionOffset","rootPoint","staticMesh","lambda","ccDelta","orientationOffset","movingMesh","RxN","constantPart","wTimesDeltaT","q","Quaternion","qqDelta","newPosition","newOrientation","STLFileLoader","solidPattern","facetsPattern","normalPattern","vertexPattern","extensions","isBinary","importMesh","meshesNames","rootUrl","matches","this","_isBinary","babylonMesh","_parseBinary","array_buffer","Uint8Array","str","byteLength","String","fromCharCode","exec","meshName","meshNameFromEnd","Array","_parseASCII","load","loadAssetContainer","container","_blockEntityCollection","reader","DataView","getUint32","ascii","off","getUint8","faces","offset","positions","Float32Array","indices","Uint32Array","indicesCount","face","start","normalX","getFloat32","normalY","normalZ","vertexstart","DO_NOT_ALTER_FILE_COORDINATES","setVerticesData","setIndices","computeWorldMatrix","solidData","facet","normalMatches","lastIndex","Number","vertexMatch"],"sourceRoot":""}