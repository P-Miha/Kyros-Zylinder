{"version":3,"file":"js/467.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./src/externals/havok.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleStaticPiece.glb","webpack://babylonjs-typescript-webpack-template/./src/scenes/alphaPuzzle.ts","webpack://babylonjs-typescript-webpack-template/./assets/glb/AlphaPuzzleMoveablePiece.glb","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/Shadows/shadowGeneratorSceneComponent.ts"],"sourcesContent":["import HavokPlugin from \"@babylonjs/havok\";\r\n\r\nexport const havokModule = HavokPlugin();\r\n","export default __webpack_public_path__ + \"af84c650d8f3c742962ce5d36ec5bb3f.glb\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport \"@babylonjs/core/Physics/physicsEngineComponent\";\r\nimport \"@babylonjs/loaders/glTF\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\nimport \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { havokModule } from \"../externals/havok\";\r\nimport { PhysicsShapeBox } from \"@babylonjs/core/Physics/v2/physicsShape\";\r\nimport { PhysicsBody } from \"@babylonjs/core/Physics/v2/physicsBody\";\r\nimport { PhysicsMotionType } from \"@babylonjs/core/Physics/v2/IPhysicsEnginePlugin\";\r\nimport { HavokPlugin } from \"@babylonjs/core/Physics/v2/Plugins/havokPlugin\";\r\n\r\n// Import AlphaPuzzle Pieces\r\nimport MoveablePiece from \"../../assets/glb/AlphaPuzzleMoveablePiece.glb\";\r\nimport StaticPiece from \"../../assets/glb/AlphaPuzzleStaticPiece.glb\";\r\nimport {Color3, FloatArray, HighlightLayer, IndicesArray, Mesh, MeshBuilder, SceneLoader, StandardMaterial, VertexBuffer, float } from \"@babylonjs/core\";\r\n\r\nclass AlphaPuzzle implements CreateSceneClass {\r\n    preTasks = [havokModule];\r\n\r\n    createScene = async (engine: Engine, canvas: HTMLCanvasElement): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n         // Enable Inspector and Scene Exlporer\r\n         void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n        // Inspector and Scene Explorer End\r\n\r\n        // Generate both Meshes via Sceneloader\r\n      \r\n        // function generatePhysicsContainer(): PhysicsBody{\r\n        //     // Placeholder for now\r\n        //     return new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n        // }\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"my first camera\", 0, Math.PI / 3, 10, new Vector3(0, 0, 0), scene);\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n        const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\r\n\r\n        // Default intensity is 1. Let's dim the light a small amount\r\n        light.intensity = 0.7;\r\n\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\"ground\", { width: 10, height: 10 }, scene);\r\n        \r\n        // PHYSICS!\r\n        scene.enablePhysics(null, new HavokPlugin(true, await havokModule));\r\n\r\n        // Create a static box shape\r\n        const groundShape = new PhysicsShapeBox(new Vector3(0, 0, 0)\r\n            , Quaternion.Identity()\r\n            , new Vector3(10, 0.1, 10)\r\n            , scene);\r\n\r\n        // Create a body and attach it to the ground. Set it as Static.\r\n        const groundBody = new PhysicsBody(ground, PhysicsMotionType.STATIC, false, scene);\r\n\r\n        // Set material properties\r\n        groundShape.material = { friction: 0.2, restitution: 0.8 };\r\n\r\n        // Associate the body and the shape\r\n        groundBody.shape = groundShape;\r\n\r\n        // Set the mass to 0\r\n        groundBody.setMassProperties({ mass: 0 });\r\n\r\n        function importedMeshSettings(meshes: Mesh){\r\n            // Preparing material for colouring\r\n            const materialLightGreen = new StandardMaterial(\"material\", scene);\r\n            materialLightGreen.diffuseColor = new Color3(0.5, 1, 0.5);\r\n            const materialLightGray = new StandardMaterial(\"material\", scene);\r\n            materialLightGray.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n\r\n            // Setting Colour based in Childname (since Rootnode is in both called __root__)\r\n            if (meshes.name === \"moveable\") {\r\n                meshes.material = materialLightGreen;\r\n            } else {\r\n                meshes.material = materialLightGray;\r\n            }\r\n            // Setting Scaling for both meshes\r\n            meshes.scaling = new Vector3(0.08, 0.08, 0.08);\r\n            // Translating Mesh out of ground\r\n            meshes.position = new Vector3(0, 2, 0);\r\n            // Setting new Camera Focus\r\n            const initCameraPosition = new Vector3(0, 0, 0);\r\n            initCameraPosition.addInPlace(meshes.position);\r\n            camera.setTarget(initCameraPosition);\r\n        }\r\n        function randomInt(min: number, max: number){\r\n            return Math.floor(Math.random() * (max - min + 1)) + min;\r\n         }\r\n         \r\n        /**\r\n         * Generates small Meshboxes on multiple facets of the mesh, as a visual indicator / highlight\r\n         * this SHOULD NOT be included in the final version, since it is only for debugging purposes and creates\r\n         * a lot of overhead!\r\n         * \r\n        */ \r\n        function createFacetHightlights(mesh: Mesh, percentage: float) {\r\n            // Getting position of facets\r\n            const facetPositions = mesh.getFacetLocalPositions();\r\n            // Saving location for already used facet positions, to avoid duplicates at the same location\r\n            const usedFacetNumbers: number[] = []\r\n            let generatedBoxes = 0;\r\n            // Preparing Material for Highlighting\r\n            const materialHighlight = new StandardMaterial(\"material\", scene);\r\n            materialHighlight.diffuseColor = Color3.Yellow();\r\n            console.log(\"Before for loop\")\r\n            while (generatedBoxes <= mesh.facetNb * percentage) {\r\n                const randomIndex = randomInt(0, mesh.facetNb);\r\n                if (randomIndex in usedFacetNumbers) {\r\n                    console.log(\"in if Branch\")\r\n                    continue;\r\n                } else {\r\n                    //usedFacetNumbers.push(randomIndex)\r\n                    console.log(\"in else Branch\")\r\n                    const box = MeshBuilder.CreateSphere(\"sphere\", { diameter: 0.5 }, scene);\r\n                    box.material = materialHighlight;\r\n                    box.position = facetPositions[generatedBoxes];\r\n                    box.parent = mesh;\r\n                    generatedBoxes++;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Function in order to find out if a given point is inside a facet of a mesh\r\n         * where the facet is in form of a triangle.\r\n         * \r\n         * @param p Point to check\r\n         * @param a First point of triangle\r\n         * @param b Second point of triangle\r\n         * @param c Third point of triangle\r\n         * dependend on (helper)functions: sign, dot, dot2, clamp\r\n         * \r\n         * @return positive float if outside, negative float if inside\r\n         * \r\n         * Math taken from https://iquilezles.org/articles/distfunctions/ and rewritten to work in typescript & babylonjs\r\n         */\r\n        function udTriangle(p: Vector3, a: Vector3, b: Vector3, c: Vector3 ){\r\n            // Definitions and Vectorcombinations\r\n            const ba: Vector3 = b.subtract(a); \r\n            const cb: Vector3 = c.subtract(b); \r\n            const ac: Vector3 = a.subtract(c); \r\n            const nor: Vector3 = ba.cross(ac);\r\n\r\n            const pa: Vector3 = p.subtract(a);\r\n            const pb: Vector3 = p.subtract(b);\r\n            const pc: Vector3 = p.subtract(c);\r\n            return Math.sqrt(\r\n                (sign(dot(ba.cross(nor),pa)) +\r\n                sign(dot(cb.cross(nor),pb)) +\r\n                sign(dot(ac.cross(nor),pc)) < 2.0)\r\n                ?\r\n                Math.min( Math.min(\r\n                dot2((ba.scale(clamp(dot(ba,pa)/dot2(ba),0.0,1.0))).subtract(pa)),\r\n                dot2((cb.scale(clamp(dot(cb,pb)/dot2(cb),0.0,1.0))).subtract(pb))),\r\n                dot2((ac.scale(clamp(dot(ac,pc)/dot2(ac),0.0,1.0))).subtract(pc)))\r\n                :\r\n                dot(nor,pa) * dot(nor,pa) / dot2(nor) );\r\n        }\r\n\r\n        /**\r\n         * Helperfunctions to calculate the dotproduct of a vector with another vector\r\n        */\r\n        function dot(a: Vector3, b: Vector3){\r\n            return a.x*b.x + a.y*b.y + a.z*b.z;\r\n        }\r\n\r\n        function dot2(a: Vector3){\r\n            return dot(a,a);\r\n        }\r\n\r\n        /**\r\n         * Helperfunctions to \"extract the sign of the parameter\" source-definition: https://registry.khronos.org/OpenGL-Refpages/gl4/html/sign.xhtml\r\n         * own implementation in typescript, since the glsl function is not available in typescript\r\n         * \r\n         * @param x float to check\r\n         * @return -1 if x < 0, 0 if x == 0, 1 if x > 0\r\n         */\r\n        function sign(x: float){\r\n            if (x < 0.0) {\r\n                return -1;\r\n            } else if (x == 0.0) {\r\n                return 0;\r\n            } else {\r\n                return 1;\r\n            }\r\n        }\r\n        function clamp(x: float, min: float, max: float){\r\n            return Math.min(Math.max(x, min), max);\r\n        }\r\n\r\n        /**\r\n         * Function to get the facet vertices in world coordinates in form of an Vector3 array\r\n         * @param mesh\r\n         * @return Vector3 array of facet vertices\r\n         */\r\n        function getFacetVertices(mesh: Mesh){\r\n            const returnArray: Vector3[] = [];\r\n            const vertexInfo = mesh.getVerticesData(VertexBuffer.PositionKind) as FloatArray;\r\n            for (let i = 0; i < mesh.facetNb; i++) {\r\n                returnArray.push(Vector3.FromArray(vertexInfo, i * 3));\r\n            }\r\n            return returnArray;\r\n        }\r\n\r\n\r\n        // Loading Meshes\r\n        const moveablePieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", MoveablePiece, scene, undefined);\r\n        const staticPieceLoad = await SceneLoader.ImportMeshAsync(\"\",\"\", StaticPiece, scene, undefined, \".glb\");\r\n        // Casting Loadresult (ISceneLoaderAsyncResult) to Mesh for easier handling and enabling useage of updateFacetData()\r\n        // [0] is the rootnode of the mesh (Empty Parent), [1] is the actual mesh\r\n        const moveablePiece = moveablePieceLoad.meshes[1] as Mesh;\r\n        const staticPiece = staticPieceLoad.meshes[1] as Mesh;\r\n        importedMeshSettings(moveablePiece);\r\n        importedMeshSettings(staticPiece);\r\n        moveablePiece.updateFacetData();\r\n        staticPiece.updateFacetData();\r\n        // Creating Highlight Layer\r\n        const hl = new HighlightLayer(\"hl1\", scene);\r\n        // Highlighting Current Debug Facet\r\n        // hl.addMesh(moveablePiece, Color3.Green());\r\n\r\n        //createFacetHightlights(moveablePiece, 0.99);\r\n\r\n        // Saving Facets Coordinates of Staticpiece for later use\r\n        //const staticPieceFacetCoordinates = staticPiece.getFacetPosition();\r\n        const staticPieceIndices = staticPiece.getIndices() as IndicesArray;\r\n        \r\n        // Pre-Rendering, called once before the first frame\r\n        const moveablePieceNbFacets = moveablePiece.facetNb;\r\n        //console.log(\"Temp \", staticPositions);\r\n        //console.log(\"facetNb \", staticPiece.facetNb);\r\n        //console.log(\"indices \", staticPieceIndices?.length);\r\n        // Getting all Facet Positions of the static piece\r\n        const staticPieceFacetPositions = getFacetVertices(staticPiece);\r\n        //console.log(\"staticFacetPositions \", staticPieceFacetPositions);\r\n\r\n        // Placeholder, to be used to be overwritten per frame with the current position of the moving piece of the to be checked facet\r\n        const currentFacetPosition = moveablePiece.getFacetPosition(0); \r\n        // Renderfunction, called every frame\r\n        // scene.onBeforeRenderObservable.add(() => {\r\n        //     // Get current position of facets of moveablePiece\r\n        //     // Check if any of the points of the moving Piece is inside a facet of the static piece\r\n        //     // Currently we \"place\" a point to check for collision at the center of each facet of the moving piece\r\n        //      for(let i = 0; i < (moveablePieceNbFacets - 800); i++){\r\n        //         // Check if the currently selected facet-middle is inside of one of the staticPiece facets\r\n        //         moveablePiece.getFacetPositionToRef(i, currentFacetPosition);\r\n        //         for (let j = 0; j < staticPiece.facetNb; j++){\r\n        //             const staticIndex = staticPieceIndices[j * 3];\r\n        //             if (udTriangle(currentFacetPosition, staticPieceFacetPositions[staticIndex], staticPieceFacetPositions[staticIndex + 1], staticPieceFacetPositions[staticIndex + 2]) < 0){\r\n        //                 console.log(\"Collision\");\r\n        //             }\r\n        //         }\r\n        //      }\r\n        // });\r\n        \r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new AlphaPuzzle();\r\n","export default __webpack_public_path__ + \"87c16888db5ebec0fb7b6c3bb705d897.glb\";","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"names":["havokModule","preTasks","havok","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Math","PI","setTarget","Zero","attachControl","intensity","ground","width","height","enablePhysics","groundShape","Identity","groundBody","STATIC","importedMeshSettings","meshes","materialLightGreen","StandardMaterial","diffuseColor","Color3","materialLightGray","name","material","scaling","position","initCameraPosition","addInPlace","friction","restitution","shape","setMassProperties","mass","moveablePieceLoad","SceneLoader","ImportMeshAsync","staticPieceLoad","moveablePiece","staticPiece","updateFacetData","HighlightLayer","getIndices","facetNb","mesh","returnArray","vertexInfo","getVerticesData","VertexBuffer","PositionKind","i","push","FromArray","getFacetVertices","getFacetPosition","AddParser","NAME_SHADOWGENERATOR","parsedData","shadowGenerators","index","cache","length","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","this","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","light","getShadowGenerators","iterator","values","key","next","done","shadowGenerator","value","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":""}