{"version":3,"file":"js/89.babylonBundle.js","mappings":"4NAeO,MAAMA,UAAa,EAAAC,EAgDtB,WAAIC,GAEA,OADAC,KAAKC,WACED,KAAKE,YAChB,CAGA,WAAIH,CAAQI,IAEJA,EAAMC,aAAeJ,KAAKE,aAAaE,YAAeJ,KAAKK,kBAI/DL,KAAKK,gBAAiB,EAEtBL,KAAKE,aAAaI,SAASH,GAC3BH,KAAKO,2BACT,CAYA,WAAAC,CAIWC,EACPC,EACAC,EAA6B,KAC7BC,EAAgC,KAChCC,EAA+B,KAC/BC,EAA+B,KAC/BC,EAA0B,M,MAE1BC,MAAMP,EAAMC,EAASO,YARd,KAAAR,KAAAA,EAxEJ,KAAAS,SAAW,IAAIC,MAGf,KAAAC,WAAa,IAAID,MAYjB,KAAAE,OAA2B,KAU1B,KAAAC,oBAAsB,EAKtB,KAAAC,kBAAmB,EACnB,KAAAlB,gBAAiB,EAGlB,KAAAmB,qBAAgD,KAGhD,KAAAC,wBAA4C,KA4C/CzB,KAAK0B,UAAYhB,EACjBV,KAAKE,aAAmC,QAApB,EAAAU,aAAW,EAAXA,EAAae,eAAO,QAAI,KAAOC,WACnD5B,KAAK6B,YAAchB,QAAAA,EAAcb,KAAKE,aAAayB,QACnD3B,KAAK8B,YAAchB,QAAAA,EAAcd,KAAKE,aAAayB,QACnD3B,KAAKqB,OAASN,EAEdf,KAAK+B,gBAAkB,IAAI,KAC3B/B,KAAKgC,oBAAsB,IAAI,KAC/BhC,KAAKiC,2BAA6B,IAAI,KACtCjC,KAAKkC,aAAe,IAAI,KAExBxB,EAASyB,MAAMC,KAAKpC,MAEpBA,KAAKqC,UAAU1B,GAAY,GAE3BX,KAAKsC,6BACT,CAMO,YAAAC,GACH,MAAO,MACX,CAQO,WAAAC,GACH,OAAOxC,KAAK0B,SAChB,CAEA,UAAWe,GACP,OAAOzC,KAAK0C,WAChB,CAMO,SAAAC,GACH,OAAO3C,KAAKyC,MAChB,CAMO,WAAAG,GACH,OAAO5C,KAAKkB,QAChB,CAMO,QAAA2B,GACH,OAAuB,OAAhB7C,KAAKqB,OAAkBrB,KAAKwC,cAAcL,MAAMW,QAAQ9C,MAAQA,KAAKqB,MAChF,CAEA,UAAWoB,CAAOM,GACd/C,KAAKqC,UAAUU,EACnB,CAOO,SAAAV,CAAUI,EAAwBO,GAAsC,GAC3E,GAAIhD,KAAKyC,SAAWA,EAApB,CAIA,GAAIzC,KAAKyC,OAAQ,CACb,MAAM1B,EAAQf,KAAKyC,OAAOvB,SAAS4B,QAAQ9C,OAC5B,IAAXe,GACAf,KAAKyC,OAAOvB,SAAS+B,OAAOlC,EAAO,E,CAI3Cf,KAAK0C,YAAcD,EAEfzC,KAAKyC,QACLzC,KAAKyC,OAAOvB,SAASkB,KAAKpC,MAG1BgD,GACAhD,KAAKsC,8BAGTtC,KAAKkD,a,CACT,CAMO,cAAAC,GAEH,OADAnD,KAAKC,WACED,KAAKE,YAChB,CAMO,aAAAkD,GACH,OAAOpD,KAAK8B,WAChB,CAOO,aAAAuB,GACH,OAAOrD,KAAKoD,eAChB,CAMO,aAAAE,GACH,OAAOtD,KAAK6B,WAChB,CAOO,WAAA0B,GACH,OAAOvD,KAAKsD,eAChB,CAMO,aAAAE,CAAcC,GACjBzD,KAAK6B,YAAYvB,SAASmD,EAC9B,CAOO,WAAAC,CAAYD,GACfzD,KAAKwD,cAAcC,EACvB,CAOO,WAAAE,GACH,OAAO3D,KAAKoD,eAChB,CAQO,aAAAQ,CAAcH,GACjBzD,KAAK6D,aAAaJ,EACtB,CAOO,WAAAK,CAAYL,GACfzD,KAAK4D,cAAcH,EACvB,CAKO,cAAAM,GACH,OAAO/D,KAAKkC,YAChB,CAMO,cAAA8B,GACH,OAAOhE,KAAK+D,gBAChB,CAKO,YAAAE,G,MACH,GAAIjE,KAAKwB,qBAAsB,CAC3B,MAAM0C,EAAe,KAAWC,QAAQ,GAClCC,EAAgB,KAAWC,WAAW,GACtCC,EAAgB,KAAWH,QAAQ,GAEzCnE,KAAKsD,gBAAgBiB,UAAUL,EAAcE,EAAeE,GAE5DtE,KAAKwB,qBAAqBgD,SAASlE,SAASgE,GAC5CtE,KAAKwB,qBAAqBiD,mBAAiE,QAA5C,EAAAzE,KAAKwB,qBAAqBiD,0BAAkB,QAAI,KAAW7C,WAC1G5B,KAAKwB,qBAAqBiD,mBAAmBnE,SAAS8D,GACtDpE,KAAKwB,qBAAqBkD,QAAQpE,SAAS4D,E,MAE3ClE,KAAKD,QAAUC,KAAK6B,WAE5B,CAMO,4BAAA8C,GACH,OAAO3E,KAAKiC,0BAChB,CAOO,4BAAA2C,GACH,OAAO5E,KAAK2E,8BAChB,CAMO,iBAAAE,GACH,OAAO7E,KAAK+B,eAChB,CAOO,oBAAA+C,GACH,OAAO9E,KAAK+B,eAChB,CAOO,iBAAAgD,CAAkBC,GACjBhF,KAAKwB,sBACLxB,KAAK0B,UAAUuD,mCAGnBjF,KAAKwB,qBAAuBwD,EAExBhF,KAAKwB,sBACLxB,KAAK0B,UAAUuD,kCAEvB,CAQO,gBAAAC,GACH,OAAOlF,KAAKwB,oBAChB,CAGA,YAAWgD,GAEP,OADAxE,KAAKmF,aACEnF,KAAKoF,cAChB,CAEA,YAAWZ,CAASa,GAChBrF,KAAKmF,aACLnF,KAAKoF,eAAe9E,SAAS+E,GAE7BrF,KAAKsF,wBACT,CAGA,YAAWC,GACP,OAAOvF,KAAKwF,aAChB,CAEA,YAAWD,CAASE,GAChBzF,KAAK0F,YAAYD,EACrB,CAGA,sBAAWhB,GAEP,OADAzE,KAAKmF,aACEnF,KAAK2F,cAChB,CAEA,sBAAWlB,CAAmBgB,GAC1BzF,KAAK4F,sBAAsBH,EAC/B,CAGA,WAAWf,GACP,OAAO1E,KAAK6F,UAChB,CAEA,WAAWnB,CAAQoB,GACf9F,KAAK+F,SAASD,EAClB,CAKA,+BAAWE,GACP,OAAOhG,KAAK0B,UAAUsE,2BAC1B,CAGQ,UAAAb,GACCnF,KAAKuB,mBAIVvB,KAAKuB,kBAAmB,EAEnBvB,KAAKiG,gBACNjG,KAAKiG,cAAgB,IAAQC,OAC7BlG,KAAK2F,eAAiB,KAAWO,OACjClG,KAAKoF,eAAiB,IAAQc,QAElClG,KAAKE,aAAaqE,UAAUvE,KAAKiG,cAAejG,KAAK2F,eAAgB3F,KAAKoF,gBAC9E,CAEQ,QAAAnF,GACCD,KAAKK,iBAILL,KAAKiG,eAKVjG,KAAKK,gBAAiB,EACtB,KAAO8F,aAAanG,KAAKiG,cAAejG,KAAK2F,eAAgB3F,KAAKoF,eAAgBpF,KAAKE,eALnFF,KAAKK,gBAAiB,EAM9B,CAQO,YAAAwD,CAAa/C,EAAoBkC,GAA6B,EAAMoD,GAAoB,GAC3FpG,KAAK8B,YAAYxB,SAASQ,GAEtBkC,GACAhD,KAAKsC,8BAGL8D,EACApG,KAAKD,QAAUe,EAEfd,KAAKkD,aAEb,CAKO,2BAAAZ,CAA4BxB,EAAqBuF,GAAiB,GAarE,GAZKvF,IACDA,EAAad,KAAK8B,aAGlB9B,KAAKyC,OACL3B,EAAWwF,cAActG,KAAKyC,OAAOT,oBAAqBhC,KAAKgC,qBAE/DhC,KAAKgC,oBAAoB1B,SAASQ,GAGtCd,KAAKgC,oBAAoBuE,YAAYvG,KAAKiC,4BAEtCoE,EACA,IAAK,IAAItF,EAAQ,EAAGA,EAAQf,KAAKkB,SAASsF,OAAQzF,IAC9Cf,KAAKkB,SAASH,GAAOuB,8BAI7BtC,KAAKsB,oBAAsBtB,KAAKgC,oBAAoByE,cAAgB,GAAK,EAAI,CACjF,CAMO,WAAAvD,GAIH,OAHAlD,KAAK0G,mBACL1G,KAAK2G,iBACL3G,KAAK0B,UAAUkF,eACR5G,IACX,CAGO,sBAAAsF,GACHtF,KAAKkD,cACLlD,KAAKK,gBAAiB,CAC1B,CAEQ,wBAAAE,GACJP,KAAKkD,cACLlD,KAAKuB,kBAAmB,CAC5B,CAEQ,eAAAsF,CAAgBC,EAAcC,EAAQ,IAAMC,MAAOC,EAAuBC,GAAkB,GAChG,MAAMC,EAAKnH,KAAKmD,iBAEhB,GAAI4D,GAAS,IAAMC,MACXE,GACAC,EAAGC,WAAW,GAAIN,EAAIO,GACtBF,EAAGC,WAAW,GAAIN,EAAIQ,GACtBH,EAAGC,WAAW,GAAIN,EAAIS,IAEtBJ,EAAGK,yBAAyBV,EAAIO,EAAGP,EAAIQ,EAAGR,EAAIS,OAE/C,CACH,IAAIE,EAAuB,KAGvBR,IACAQ,EAAKR,EAAMjD,kBAGfhE,KAAK0B,UAAUgG,0BAEf,MAAMC,EAAO9H,EAAK+H,SAAS,GACrBC,EAAOhI,EAAKiI,SAAS,GAEvB9H,KAAKyC,OACDwE,GAASQ,GACTE,EAAKrH,SAASN,KAAKyC,OAAOoC,qBAC1B8C,EAAKrB,cAAcmB,EAAIE,IAEvBA,EAAKrH,SAASN,KAAKyC,OAAOoC,qBAG9B,KAAOkD,cAAcJ,GAGrBT,GACAS,EAAKH,yBAAyB,EAAG,EAAG,GAExCG,EAAKK,SACL,IAAQC,0BAA0BnB,EAAKa,EAAME,GAEzCX,GACAC,EAAGC,WAAW,GAAIS,EAAKR,GACvBF,EAAGC,WAAW,GAAIS,EAAKP,GACvBH,EAAGC,WAAW,GAAIS,EAAKN,IAEvBJ,EAAGK,yBAAyBK,EAAKR,EAAGQ,EAAKP,EAAGO,EAAKN,E,CAIzDvH,KAAKO,0BACT,CAQO,SAAA2H,CAAUpB,EAAcC,EAAQ,IAAMC,MAAOC,GAChDjH,KAAK6G,gBAAgBC,EAAKC,EAAOE,GAAO,EAC5C,CAQO,WAAAkB,CAAY3D,EAAmBuC,EAAQ,IAAMC,MAAOC,GACvDjH,KAAK6G,gBAAgBrC,EAAUuC,EAAOE,GAAO,EACjD,CAOO,mBAAAmB,CAAoB5D,EAAmByC,GAC1CjH,KAAKmI,YAAY3D,EAAU,IAAM6D,MAAOpB,EAC5C,CASO,KAAAqB,CAAMjB,EAAWC,EAAWC,EAAWgB,GAAgB,GAC1D,MAAMC,EAASxI,KAAKmD,iBAGdsF,EAAW5I,EAAK+H,SAAS,GAC/B,KAAOc,aAAarB,EAAGC,EAAGC,EAAGkB,GAC7BA,EAASnC,cAAckC,EAAQA,GAG/BC,EAAST,SAET,IAAK,MAAMW,KAAS3I,KAAKkB,SAAU,CAC/B,MAAM0H,EAAKD,EAAMxF,iBACjByF,EAAGtC,cAAcmC,EAAUG,GAC3BA,EAAGC,gBAAgB,GAAIxB,GACvBuB,EAAGC,gBAAgB,GAAIvB,GACvBsB,EAAGC,gBAAgB,GAAItB,GAEvBoB,EAAMpI,0B,CAKV,GAFAP,KAAKO,2BAEDgI,EACA,IAAK,MAAMI,KAAS3I,KAAKkB,SACrByH,EAAML,MAAMjB,EAAGC,EAAGC,EAAGgB,EAGjC,CAMO,QAAAxC,CAASuC,GACZtI,KAAKmF,aACLnF,KAAKiG,cAAc3F,SAASgI,GAC5BtI,KAAKsF,wBACT,CAMO,QAAAO,GAEH,OADA7F,KAAKmF,aACEnF,KAAKiG,aAChB,CAMO,aAAA6C,CAAcC,GACjB/I,KAAKmF,aACL4D,EAAOzI,SAASN,KAAKiG,cACzB,CAUO,eAAA+C,CAAgBC,EAAaC,EAAeC,EAAcpC,EAAQ,IAAMC,MAAOC,GAClF,GAAIF,IAAU,IAAMC,MAAO,CACvB,MAAMoC,EAAOvJ,EAAKwJ,SAGlB,OAFA,KAAWC,0BAA0BL,EAAKC,EAAOC,EAAMC,QACvDpJ,KAAK4F,sBAAsBwD,EAAMrC,EAAOE,E,CAI5C,MAAMsC,EAAY1J,EAAK+H,SAAS,GAChC,IAAK5H,KAAKwJ,uCAAuCD,EAAWtC,GACxD,OAGJ,MAAMwC,EAAS5J,EAAK+H,SAAS,GAC7B,KAAO0B,0BAA0BL,EAAKC,EAAOC,EAAMM,GAEnDF,EAAUjD,cAAcmD,EAAQA,GAChCzJ,KAAK0J,kBAAkBD,EAAQ1C,EAAOE,EAC1C,CASO,MAAA0C,CAAOC,EAAeC,EAAgB9C,EAAQ,IAAMC,MAAOC,GAC9D,MAAM6C,EAAOjK,EAAK+H,SAAS,GAC3BkC,EAAKtC,yBAAyB,EAAG,EAAG,GACpC,KAAOuC,kBAAkBH,EAAMC,EAAQC,GACvC9J,KAAK0J,kBAAkBI,EAAM/C,EAAOE,EACxC,CASO,YAAA+C,CAAaJ,EAAeK,EAAelD,EAAQ,IAAMC,MAAOC,GACnE,GAAIF,IAAU,IAAMC,MAAO,CACvB,MAAMoC,EAAOvJ,EAAKwJ,SAIlB,OAHA,KAAWU,kBAAkBH,EAAMK,EAAOb,QAE1CpJ,KAAK4F,sBAAsBwD,EAAMrC,EAAOE,E,CAI5C,MAAMsC,EAAY1J,EAAK+H,SAAS,GAChC,IAAK5H,KAAKwJ,uCAAuCD,EAAWtC,GACxD,OAGJ,MAAMwC,EAAS5J,EAAK+H,SAAS,GAC7B,KAAOmC,kBAAkBH,EAAMK,EAAOR,GAEtCF,EAAUjD,cAAcmD,EAAQA,GAChCzJ,KAAK0J,kBAAkBD,EAAQ1C,EAAOE,EAC1C,CAQO,WAAAvB,CAAYH,EAAmBwB,EAAQ,IAAMC,MAAOC,GACvDjH,KAAKgJ,gBAAgBzD,EAAS+B,EAAG/B,EAAS8B,EAAG9B,EAASgC,EAAGR,EAAOE,EACpE,CAQO,qBAAArB,CAAsBwD,EAAkBrC,EAAQ,IAAMC,MAAOC,GAChE,GAAIF,IAAU,IAAMC,MAMhB,OALAhH,KAAKmF,aACLnF,KAAK2F,eAAerF,SAAS8I,QAE7BpJ,KAAKsF,yBAKT,MAAMiE,EAAY1J,EAAK+H,SAAS,GAChC,IAAK5H,KAAKwJ,uCAAuCD,EAAWtC,GACxD,OAGJ,MAAMwC,EAAS5J,EAAK+H,SAAS,GAC7B,KAAOsC,oBAAoBd,EAAMK,GAEjCF,EAAUjD,cAAcmD,EAAQA,GAEhCzJ,KAAK0J,kBAAkBD,EAAQ1C,EAAOE,EAC1C,CAQO,iBAAAkD,CAAkBV,EAAgB1C,EAAQ,IAAMC,MAAOC,GAC1D,GAAIF,IAAU,IAAMC,MAAO,CACvB,MAAMoC,EAAOvJ,EAAKwJ,SAGlB,OAFA,KAAWe,wBAAwBX,EAAQL,QAC3CpJ,KAAK4F,sBAAsBwD,EAAMrC,EAAOE,E,CAI5C,MAAMsC,EAAY1J,EAAK+H,SAAS,GAChC,IAAK5H,KAAKwJ,uCAAuCD,EAAWtC,GACxD,OAGJ,MAAMoD,EAAUxK,EAAK+H,SAAS,GAC9ByC,EAAQ/J,SAASmJ,GAEjBF,EAAUjD,cAAcmD,EAAQY,GAEhCrK,KAAK0J,kBAAkBW,EAAStD,EAAOE,EAC3C,CAEQ,iBAAAyC,CAAkBI,EAAc/C,EAAQ,IAAMC,MAAOC,GACzD,MAAMqD,EAAOtK,KAAKmD,iBACZoH,EAAKD,EAAKE,EAAE,IACZC,EAAKH,EAAKE,EAAE,IACZE,EAAKJ,EAAKE,EAAE,IACZ/H,EAASzC,KAAK2C,YACdgI,EAAc9K,EAAK+H,SAAS,GAC5BgD,EAAiB/K,EAAK+H,SAAS,GAEjCnF,GAAUsE,GAAS,IAAMsB,OACrBpB,GACA0D,EAAYrK,SAAS2G,EAAMjD,kBAC3BvB,EAAOoC,oBAAoByB,cAAcqE,EAAaA,IAEtDA,EAAYrK,SAASmC,EAAOoC,qBAEhC+F,EAAetK,SAASqK,GACxBC,EAAe5C,SACfsC,EAAKhE,cAAcqE,EAAaL,GAChCA,EAAKhE,cAAcwD,EAAMQ,GACzBA,EAAKhE,cAAcsE,EAAgBN,IAE/BvD,GAAS,IAAMsB,OAASpB,GACxB0D,EAAYrK,SAAS2G,EAAMjD,kBAC3B4G,EAAetK,SAASqK,GACxBC,EAAe5C,SACfsC,EAAKhE,cAAcqE,EAAaL,GAChCA,EAAKhE,cAAcwD,EAAMQ,GACzBA,EAAKhE,cAAcsE,EAAgBN,IAEnCA,EAAKhE,cAAcwD,EAAMQ,GAIjCA,EAAK9C,yBAAyB+C,EAAIE,EAAIC,GAEtC1K,KAAK0H,0BACL1H,KAAKO,0BACT,CAEQ,sCAAAiJ,CAAuCD,EAAmBtC,GAC9D,MAAM4D,EAAchL,EAAK+H,SAAS,GAWlC,OAVA2B,EAAUjJ,SAASN,KAAK6E,qBAEpBoC,GACAsC,EAAUjD,cAAcW,EAAMjD,iBAAkBuF,GAChD,KAAOb,aAAazB,EAAMvC,QAAQ2C,EAAGJ,EAAMvC,QAAQ4C,EAAGL,EAAMvC,QAAQ6C,EAAGsD,IAEvE,KAAO9C,cAAc8C,GAGzBtB,EAAUvB,UACN8C,MAAMvB,EAAUiB,EAAE,MAMtBK,EAAYhC,gBAAgB,EAAG7I,KAAKsB,qBACpCiI,EAAUjD,cAAcuE,EAAatB,IAE9B,EACX,CAQO,WAAAwB,CAAYhE,EAAQ,IAAMC,MAAOC,EAAiC,MACrE,MAAM+D,EAAM,IAAQ9E,OAIpB,OAFAlG,KAAKiL,iBAAiBlE,EAAOE,EAAO+D,GAE7BA,CACX,CAQO,gBAAAC,CAAiBlE,EAAQ,IAAMC,MAAOC,EAAgC8B,GACzE,GAAIhC,GAAS,IAAMC,MAAO,CACtB,MAAMG,EAAKnH,KAAKmD,iBAEhB4F,EAAO1B,EAAIF,EAAGqD,EAAE,IAChBzB,EAAOzB,EAAIH,EAAGqD,EAAE,IAChBzB,EAAOxB,EAAIJ,EAAGqD,EAAE,G,KACb,CACH,IAAI/C,EAAuB,KAGvBR,IACAQ,EAAKR,EAAMjD,kBAGfhE,KAAK0B,UAAUgG,0BAEf,IAAIC,EAAO9H,EAAK+H,SAAS,GAErBX,GAASQ,GACTE,EAAKrH,SAASN,KAAK6E,qBACnB8C,EAAKrB,cAAcmB,EAAIE,IAEvBA,EAAO3H,KAAK6E,oBAGhBkE,EAAO1B,EAAIM,EAAK6C,EAAE,IAClBzB,EAAOzB,EAAIK,EAAK6C,EAAE,IAClBzB,EAAOxB,EAAII,EAAK6C,EAAE,G,CAE1B,CAOO,mBAAAU,CAAoBjE,EAAiC,MACxD,MAAM+D,EAAM,IAAQ9E,OAIpB,OAFAlG,KAAKiL,iBAAiB,IAAM5C,MAAOpB,EAAO+D,GAEnCA,CACX,CAOO,wBAAAG,CAAyBlE,EAAsB8B,GAClD/I,KAAKiL,iBAAiB,IAAM5C,MAAOpB,EAAO8B,EAC9C,CAKO,uBAAArB,GAGH,GAFA1H,KAAKC,WAEDD,KAAKyC,OACLzC,KAAKE,aAAaoG,cAActG,KAAKyC,OAAOV,gBAAiB/B,KAAK+B,qBAC/D,CACH/B,KAAK+B,gBAAgBzB,SAASN,KAAKE,cAEnC,MAAMkL,EAAapL,KAAK0B,UAAU2J,gBAE9BD,GACApL,KAAK+B,gBAAgBuE,cAAc8E,EAAYpL,KAAK+B,gB,CAI5D,MAAMb,EAAWlB,KAAKkB,SAChBoK,EAAMpK,EAASsF,OAErB,IAAK,IAAI+E,EAAI,EAAGA,EAAID,EAAKC,IACrBrK,EAASqK,GAAG7D,yBAEpB,CAMO,yBAAA8D,GACHxL,KAAK0H,yBACT,CAQO,YAAA+D,CAAaC,EAAoBzE,EAAiC,MACrE,MAAM8B,EAAS,IAAQ7C,OAIvB,OAFAlG,KAAK2L,kBAAkBD,EAAWzE,EAAO8B,GAElCA,CACX,CAQO,iBAAA4C,CAAkBD,EAAoBzE,EAAiC,KAAM8B,GAChF,IAAItB,EAAuB,KAGvBR,IACAQ,EAAKR,EAAMjD,kBAGfhE,KAAK0B,UAAUgG,0BAEf,MAAMkE,EAAM/L,EAAK+H,SAAS,GAE1BgE,EAAItL,SAASN,KAAK6E,qBAEdoC,GAASQ,GACTmE,EAAItF,cAAcmB,EAAImE,GAG1B,IAAQC,qBAAqBH,EAAWE,EAAK7C,GAE7CA,EAAO+C,WACX,CAQO,WAAAtG,CAAYuB,EAAQ,IAAMC,MAAOC,EAAiC,MACrE,MAAM8B,EAAS,IAAQ7C,OAIvB,OAFAlG,KAAK+L,iBAAiBhF,EAAOE,EAAO8B,GAE7BA,CACX,CAQO,gBAAAgD,CAAiBhF,EAAQ,IAAMC,MAAOC,EAAiC,KAAM8B,GAChF,MAAMK,EAAOvJ,EAAKwJ,SAElBrJ,KAAKgM,2BAA2BjF,EAAOE,EAAOmC,GAE9CA,EAAK6C,mBAAmBlD,EAC5B,CAQO,qBAAAmD,CAAsBnF,EAAQ,IAAMC,MAAOC,EAAiC,MAC/E,MAAM8B,EAAS,KAAWnH,WAI1B,OAFA5B,KAAKgM,2BAA2BjF,EAAOE,EAAO8B,GAEvCA,CACX,CAQO,0BAAAiD,CAA2BjF,EAAQ,IAAMC,MAAOC,EAAiC,KAAM8B,GAC1F,GAAIhC,GAAS,IAAMC,MACfhH,KAAKmF,aACL4D,EAAOzI,SAASN,KAAK2F,oBAClB,CACH,MAAMiG,EAAM/L,EAAK+H,SAAS,GACpBuE,EAAOnM,KAAK6E,oBAEdoC,EACAkF,EAAK7F,cAAcW,EAAMjD,iBAAkB4H,GAE3CA,EAAItL,SAAS6L,GAGjBP,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAC5BsK,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAC5BsK,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAE5BsK,EAAIrH,eAAU6H,EAAWrD,OAAQqD,E,CAEzC,CAQO,iBAAAC,CAAkBtF,EAAQ,IAAMC,MAAOC,GAC1C,MAAM8B,EAAS,KAAOnH,WAItB,OAFA5B,KAAKsM,uBAAuBvF,EAAOE,EAAO8B,GAEnCA,CACX,CAQO,sBAAAuD,CAAuBvF,EAAQ,IAAMC,MAAOC,EAAsB8B,GACrE,GAAIhC,GAAS,IAAMC,MACfhH,KAAKmD,iBAAiBmJ,uBAAuBvD,OAC1C,CACH,MAAM6C,EAAM/L,EAAK+H,SAAS,GACpBuE,EAAOnM,KAAK6E,oBAEdoC,EACAkF,EAAK7F,cAAcW,EAAMjD,iBAAkB4H,GAE3CA,EAAItL,SAAS6L,GAGjBP,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAC5BsK,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAC5BsK,EAAI/C,gBAAgB,EAAG7I,KAAKsB,qBAE5BsK,EAAIU,uBAAuBvD,E,CAEnC,CAQO,4BAAAwD,CAA6B/H,EAAmByC,EAAiC,MACpF,MAAM8B,EAAS,IAAQ7C,OAIvB,OAFAlG,KAAKwM,kCAAkChI,EAAUyC,EAAO8B,GAEjDA,CACX,CAQO,iCAAAyD,CAAkChI,EAAmByC,EAAiC,KAAM8B,GAC/F,IAAItB,EAAuB,KAGvBR,IACAQ,EAAKR,EAAMjD,kBAGfhE,KAAK0B,UAAUgG,0BAEf,MAAMC,EAAO9H,EAAK+H,SAAS,GAE3BD,EAAKrH,SAASN,KAAK6E,qBAEfoC,GAASQ,GACTE,EAAKrB,cAAcmB,EAAIE,GAG3B,IAAQM,0BAA0BzD,EAAUmD,EAAMoB,EACtD,CAQO,4BAAA0D,CAA6BjI,EAAmByC,EAAiC,MACpF,MAAM8B,EAAS,IAAQ7C,OAIvB,OAFAlG,KAAK0M,kCAAkClI,EAAUyC,EAAO8B,GAEjDA,CACX,CAQO,iCAAA2D,CAAkClI,EAAmByC,EAAiC,KAAM8B,GAC/F,IAAItB,EAAuB,KAGvBR,IACAQ,EAAKR,EAAMjD,kBAGfhE,KAAK0B,UAAUgG,0BAEf,MAAMC,EAAO9H,EAAK+H,SAAS,GAE3BD,EAAKrH,SAASN,KAAK6E,qBAEfoC,GAASQ,GACTE,EAAKrB,cAAcmB,EAAIE,GAG3BA,EAAKK,SAEL,IAAQC,0BAA0BzD,EAAUmD,EAAMoB,EACtD,CAKO,oBAAA4D,GACH3M,KAAKwD,cAAcxD,KAAKmD,iBAC5B,EA7rCe,EAAA2E,SAAsB,IAAW8E,WAAW,EAAG,IAAQ1G,MACvD,EAAAmD,SAAW,KAAWzH,WACtB,EAAAgG,SAAqB,IAAWgF,WAAW,EAAG,KAAOhL,S,0ICKjE,MAAMiL,EAuDT,iCAAWC,GACP,OAAO9M,KAAK+M,8BAChB,CAEA,iCAAWD,CAA8B3M,GACrCH,KAAK+M,+BAAiC5M,EACtCH,KAAK4G,cACT,CAOA,+BAAWZ,GACP,OAAKhG,KAAKgN,6BAGHhN,KAAKgN,6BAFDhN,KAAKiN,OAAOjH,2BAG3B,CAEA,+BAAWA,CAA4B7F,GACnCH,KAAKgN,6BAA+B7M,CACxC,CAkBA,6BAAW+M,GACP,OAAOlN,KAAK8M,+BAAiC9M,KAAKmN,sBACtD,CAKA,YAAWC,GACP,OAAOpN,KAAKqN,SAChB,CAQA,WAAA7M,CAEWC,EAEA6M,EACPC,GAHO,KAAA9M,KAAAA,EAEA,KAAA6M,GAAAA,EAjHJ,KAAAnL,MAAQ,IAAIhB,MAQZ,KAAAqM,uBAAwB,EAQvB,KAAAC,UAAW,EAGX,KAAAC,sBAAwB,IAAIvM,MAE5B,KAAAwM,UAAY,KAAO/L,WAEnB,KAAA8E,kBAAoB,EAEpB,KAAAkH,QAAwD,CAAC,EAEzD,KAAAC,2BAA4B,EAE5B,KAAAV,wBAAyB,EACzB,KAAAE,UAAY,EAGb,KAAApI,iCAAmC,EAGnC,KAAA6I,gBAAqC,KAGrC,KAAAC,iBAA4C,KAK5C,KAAAC,gBAAiB,EAEhB,KAAAjB,gCAAiC,EAcjC,KAAAC,6BAAsE,KA2BvE,KAAAiB,0BAA4B,IAAI,KA6BnCjO,KAAKmC,MAAQ,GAEbnC,KAAKiN,OAASM,GAAS,IAAYW,iBACnClO,KAAKqN,UAAYrN,KAAKiN,OAAOkB,cAE7BnO,KAAKiN,OAAOmB,YAAYpO,MAGxBA,KAAKyN,UAAW,EAEhB,MAAMY,EAAarO,KAAKiN,OAAOqB,YAAYC,UAC3CvO,KAAKmN,uBAAyBkB,EAAWG,cAAgBH,EAAWI,2BAA6B,CACrG,CAMO,YAAAlM,GACH,MAAO,UACX,CAMO,WAAAK,GACH,OAAO5C,KAAKmC,MAAMuM,QAAQC,IAAOA,EAAEhM,aACvC,CAQO,oBAAAiM,CAAqBC,GACxB,OAAI7O,KAAKwN,uBACAqB,EAAKC,yBACN9O,KAAK+O,UAGFF,EAAKC,0BAGX9O,KAAKgP,qBAAsBhP,KAAKyN,UACjCzN,KAAK+O,UAGF/O,KAAKgP,mBAChB,CAOO,yBAAAC,CAA0BJ,GAC7B,OAAI7O,KAAKwN,uBAAyBqB,EAAKK,wBAC5BL,EAAKK,wBAGTlP,KAAKkP,uBAChB,CAMO,QAAAjO,GACH,OAAOjB,KAAKiN,MAChB,CASO,QAAAkC,CAASC,GACZ,IAAIC,EAAM,SAASrP,KAAKS,iBAAiBT,KAAKmC,MAAMqE,SAEpD,GADA6I,GAAO,uBAAuBrP,KAAK4N,QAAU0B,OAAOC,KAAKvP,KAAK4N,SAASpH,OAAS,SAC5E4I,EAAa,CACbC,GAAO,cACP,IAAIG,GAAQ,EACZ,IAAK,MAAM/O,KAAQT,KAAK4N,QAChB4B,IACAH,GAAO,KACPG,GAAQ,GAEZH,GAAO5O,EAEX4O,GAAO,G,CAEX,OAAOA,CACX,CAOO,kBAAAI,CAAmBhP,GACtB,IAAK,IAAIiP,EAAY,EAAGC,EAAQ3P,KAAKmC,MAAMqE,OAAQkJ,EAAYC,EAAOD,IAClE,GAAI1P,KAAKmC,MAAMuN,GAAWjP,OAASA,EAC/B,OAAOiP,EAGf,OAAQ,CACZ,CAQO,oBAAAE,CAAqBnP,EAAcoP,EAAcC,GAEpD,IAAK9P,KAAK4N,QAAQnN,GAAO,CACrBT,KAAK4N,QAAQnN,GAAQ,IAAI,IAAeA,EAAMoP,EAAMC,GACpD,IAAK,IAAIvE,EAAI,EAAGwE,EAAS/P,KAAKmC,MAAMqE,OAAQ+E,EAAIwE,EAAQxE,IAChDvL,KAAKmC,MAAMoJ,GAAGnK,WAAW,IACzBpB,KAAKmC,MAAMoJ,GAAGnK,WAAW,GAAG4O,YAAYvP,EAAMoP,EAAMC,E,CAIpE,CAOO,oBAAAG,CAAqBxP,EAAcyP,GAAe,GACrD,IAAK,IAAI3E,EAAI,EAAGwE,EAAS/P,KAAKmC,MAAMqE,OAAQ+E,EAAIwE,EAAQxE,IAChDvL,KAAKmC,MAAMoJ,GAAGnK,WAAW,IACzBpB,KAAKmC,MAAMoJ,GAAGnK,WAAW,GAAG+O,YAAY1P,EAAMyP,GAGtDlQ,KAAK4N,QAAQnN,GAAQ,IACzB,CAOO,iBAAA2P,CAAkB3P,GACrB,OAAOT,KAAK4N,QAAQnN,IAAS,IACjC,CAMO,kBAAA4P,GACH,MAAMC,EAA8C,GACpD,IAAI7P,EACJ,IAAKA,KAAQT,KAAK4N,QACd0C,EAAgBlO,KAAKpC,KAAK4N,QAAQnN,IAEtC,OAAO6P,CACX,CAUO,kBAAAC,CAAmBC,EAAkB/P,EAAcgQ,GAAoB,GAC1E,GAAIzQ,KAAK4N,QAAQnN,KAAU+P,EAAOJ,kBAAkB3P,GAChD,OAAO,EAEX,IAAI4O,GAAM,EACV,MAAMqB,EAAc1Q,KAAK2Q,4BAA8B,EAGjDC,EAAoC,CAAC,EACrCC,EAAcL,EAAOrO,MAC3B,IAAI4N,EACAxE,EACJ,IAAKA,EAAI,EAAGwE,EAASc,EAAYrK,OAAQ+E,EAAIwE,EAAQxE,IACjDqF,EAASC,EAAYtF,GAAG9K,MAAQoQ,EAAYtF,GAG5CvL,KAAKmC,MAAMqE,SAAWqK,EAAYrK,SAClC,IAAOsK,KAAK,oCAAoC9Q,KAAKmC,MAAMqE,iCAAiCqK,EAAYrK,UACxG6I,GAAM,GAGV,MAAM0B,EAAsBN,GAAqBzQ,KAAKgR,kBAAoBR,EAAOQ,iBAAmBhR,KAAKgR,iBAAiBC,OAAOT,EAAOQ,kBAAoB,KAE5J,IAAKzF,EAAI,EAAGwE,EAAS/P,KAAKmC,MAAMqE,OAAQ+E,EAAIwE,EAAQxE,IAAK,CACrD,MAAM2F,EAAWlR,KAAKmC,MAAMoJ,GAAG9K,KACzB0Q,EAAaP,EAASM,GACxBC,EACA9B,EAAMA,GAAOrP,KAAKmC,MAAMoJ,GAAGgF,mBAAmBY,EAAY1Q,EAAMiQ,EAAaD,EAAmBM,IAEhG,IAAOD,KAAK,yDAA2DI,GACvE7B,GAAM,E,CAId,MAAM+B,EAAQZ,EAAOJ,kBAAkB3P,GAIvC,OAHI2Q,IACApR,KAAK4N,QAAQnN,GAAQ,IAAI,IAAeA,EAAM2Q,EAAMvB,KAAOa,EAAaU,EAAMtB,GAAKY,IAEhFrB,CACX,CAKO,YAAApL,GACH,IAAK,MAAMoN,KAAQrR,KAAKmC,OACC,IAAjBkP,EAAKhQ,QACLgQ,EAAKpN,cAGjB,CAEQ,yBAAA0M,GACJ,IAAItB,EAAM,EACV,IAAK,IAAI9D,EAAI,EAAGwE,EAAS/P,KAAKmC,MAAMqE,OAAQ+E,EAAIwE,EAAQxE,IACpD,GAAIvL,KAAKmC,MAAMoJ,GAAGnK,WAAW,GAAI,CAC7B,MAAMkQ,EAAUtR,KAAKmC,MAAMoJ,GAAGnK,WAAW,GAAGmQ,kBACxClC,EAAMiC,IACNjC,EAAMiC,E,CAIlB,OAAOjC,CACX,CAUO,cAAAmC,CAAe/Q,EAAcgR,EAAgBC,EAAqBC,GACrE,MAAMP,EAAQpR,KAAKoQ,kBAAkB3P,GAErC,OAAK2Q,EAIEpR,KAAKiN,OAAOuE,eAAexR,KAAMoR,EAAMvB,KAAMuB,EAAMtB,GAAI2B,EAAMC,EAAYC,GAHrE,IAIf,CASO,4BAAOC,CAAsBlR,EAAoBmR,EAAiB,EAAGT,GACxE,MAAMU,EAAapR,EAAS0P,kBAAkBgB,GAG9C,IAAKU,EACD,OAAO,KAIX,MAAMC,EAAmBrR,EAASuM,OAAO+E,0BAA0BtR,GACnE,IAAIuR,EAAwC,KAE5C,IAAK,IAAIlR,EAAQ,EAAGA,EAAQgR,EAAiBvL,OAAQzF,IAAS,CAC1D,MAAMmR,EAAkBH,EAAiBhR,GAEzC,GAAImR,EAAgBC,aAAcL,aAAU,EAAVA,EAAYjC,OAAQqC,EAAgBE,WAAYN,aAAU,EAAVA,EAAYhC,IAAI,CAC9FmC,EAAkBC,EAClB,K,EAKR,MAAMG,EAAc3R,EAAS4R,iBAE7B,IAAK,IAAIvR,EAAQ,EAAGA,EAAQsR,EAAY7L,OAAQzF,IAAS,CACrD,MACMK,EADaiR,EAAYtR,GACDK,WAE9B,GAAKA,EAIL,IAAK,IAAImR,EAAY,EAAGA,EAAYnR,EAAWoF,OAAQ+L,IACnD,IAAUX,sBAAsBxQ,EAAWmR,GAAYV,EAAgBT,E,CAS/E,OAJIa,IACAA,EAAgBO,YAAa,GAG1B9R,CACX,CAGO,YAAAkG,GACH5G,KAAKyN,UAAW,EAChBzN,KAAK6N,2BAA4B,CACrC,CAKO,2BAAA4E,CAA4B5D,GAC/B7O,KAAK0N,sBAAsBtL,KAAKyM,EACpC,CAKO,6BAAA6D,CAA8B7D,GACjC,MAAM9N,EAAQf,KAAK0N,sBAAsB5K,QAAQ+L,GAE7C9N,GAAS,GACTf,KAAK0N,sBAAsBzK,OAAOlC,EAAO,EAEjD,CAEQ,yBAAA4R,CAA0BC,EAA4BC,GAC1D7S,KAAKiO,0BAA0B6E,gBAAgB9S,MAE/C,IAAK,IAAIe,EAAQ,EAAGA,EAAQf,KAAKmC,MAAMqE,OAAQzF,IAAS,CACpD,MAAMsQ,EAAOrR,KAAKmC,MAAMpB,GACxBsQ,EAAK1K,iBACL,MAAMhG,EAAa0Q,EAAK1O,YAYxB,GAVIhC,EACA0Q,EAAKlO,iBAAiBmD,cAAc3F,EAAWoD,iBAAkBsN,EAAKtN,kBAElE8O,EACAxB,EAAKlO,iBAAiBmD,cAAcuM,EAAmBxB,EAAKtN,kBAE5DsN,EAAKtN,iBAAiBzD,SAAS+Q,EAAKlO,mBAIvB,IAAjBkO,EAAKhQ,OAAe,CACpB,MAAM0R,EAA8B,OAAhB1B,EAAKhQ,OAAkBN,EAAQsQ,EAAKhQ,OACxDgQ,EAAK1M,+BAA+BqO,gBAAgB3B,EAAKtN,iBAAkB6O,EAA4B,GAAdG,E,EAIjG/S,KAAK2N,UAAUsF,YAAYL,EAAkC,GAApB5S,KAAKmC,MAAMqE,OACxD,CAMO,OAAAuI,CAAQmE,GAAmB,GAC9B,IAAKA,EAAkB,CACnB,MAAMC,EAAkBnT,KAAKiB,WAAWmS,cACxC,GAAIpT,KAAK0G,mBAAqByM,EAC1B,OAEJnT,KAAK0G,iBAAmByM,C,CAI5B,GAAInT,KAAKiF,iCAAmC,EACxC,IAAK,MAAMoM,KAAQrR,KAAKmC,MACpB,GAAIkP,EAAK7P,qBAAsB,CAC3B,MAAM6R,EAAOhC,EAAK7P,qBAClB6P,EAAK7M,SAAW6O,EAAK7O,SACjB6O,EAAK5O,mBACL4M,EAAK5M,mBAAqB4O,EAAK5O,mBAE/B4M,EAAK9L,SAAW8N,EAAK9N,SAEzB8L,EAAK3M,QAAU2O,EAAK3O,O,CAKhC,GAAI1E,KAAKwN,sBACL,IAAK,MAAMqB,KAAQ7O,KAAK0N,sBAAuB,CAC3C,MAAMtC,EAAayD,EAAKxD,gBAExB,IAAIiI,EAActT,KAAKyN,SAMvB,GALKoB,EAAKC,yBAA2BD,EAAKC,wBAAwBtI,SAAW,IAAMxG,KAAKmC,MAAMqE,OAAS,KACnGqI,EAAKC,wBAA0B,IAAIyE,aAAa,IAAMvT,KAAKmC,MAAMqE,OAAS,IAC1E8M,GAAc,GAGbA,EAAL,CAIA,GAAItT,KAAKwT,wBAA0B3E,EAAM,CACrC7O,KAAKwT,sBAAwB3E,EAG7B,IAAK,MAAMwC,KAAQrR,KAAKmC,MACfkP,EAAK1O,cACS0O,EAAKjO,gBACbkD,cAAc8E,EAAY,KAAWqI,OAAO,IACnDpC,EAAK/O,4BAA4B,KAAWmR,OAAO,KAI3D,GAAIzT,KAAKkN,0BAA2B,CAChC,MAAMwG,EAAyC,GAAzB1T,KAAKmC,MAAMqE,OAAS,GACrCqI,EAAKK,yBAA2BL,EAAKK,wBAAwByE,UAAUC,QAAUF,IAC9E7E,EAAKK,yBACLL,EAAKK,wBAAwB2E,UAGjChF,EAAKK,wBAA0B,IAAW4E,kBACtCjF,EAAKC,wBACqB,GAAzB9O,KAAKmC,MAAMqE,OAAS,GACrB,EACAxG,KAAKiN,QACL,GACA,EACA,K,EAOhBjN,KAAK2S,0BAA0B9D,EAAKC,wBAAyB1D,GAEzDpL,KAAKkN,2BAA6B2B,EAAKK,yBACvCL,EAAKK,wBAAwB6E,OAAOlF,EAAKC,wB,MAG9C,CACH,IAAK9O,KAAKyN,SACN,OAGCzN,KAAKgP,oBAAsBhP,KAAKgP,mBAAmBxI,SAAW,IAAMxG,KAAKmC,MAAMqE,OAAS,KACzFxG,KAAKgP,mBAAqB,IAAIuE,aAAa,IAAMvT,KAAKmC,MAAMqE,OAAS,IAEjExG,KAAKkN,4BACDlN,KAAKkP,yBACLlP,KAAKkP,wBAAwB2E,UAGjC7T,KAAKkP,wBAA0B,IAAW4E,kBACtC9T,KAAKgP,mBACqB,GAAzBhP,KAAKmC,MAAMqE,OAAS,GACrB,EACAxG,KAAKiN,QACL,GACA,EACA,OAMZjN,KAAK2S,0BAA0B3S,KAAKgP,mBAAoB,MAEpDhP,KAAKkN,2BAA6BlN,KAAKkP,yBACvClP,KAAKkP,wBAAwB6E,OAAO/T,KAAKgP,mB,CAIjDhP,KAAKyN,UAAW,CACpB,CAMO,cAAA6E,GACH,IAAKtS,KAAKgU,cAAgBhU,KAAKgU,aAAaxN,SAAWxG,KAAKmC,MAAMqE,OAAQ,CACtExG,KAAKgU,aAAe,GAEpB,IAAK,IAAIjT,EAAQ,EAAGA,EAAQf,KAAKmC,MAAMqE,OAAQzF,IAC3Cf,KAAKgU,aAAa5R,KAAKpC,KAAKmC,MAAMpB,G,CAI1C,OAAOf,KAAKgU,YAChB,CAQO,KAAArS,CAAMlB,EAAc6M,GACvB,MAAMvE,EAAS,IAAI8D,EAASpM,EAAM6M,GAAM7M,EAAMT,KAAKiN,QAEnDlE,EAAOyE,sBAAwBxN,KAAKwN,sBAEpC,IAAK,IAAIzM,EAAQ,EAAGA,EAAQf,KAAKmC,MAAMqE,OAAQzF,IAAS,CACpD,MAAMyP,EAASxQ,KAAKmC,MAAMpB,GAC1B,IAAIJ,EAAa,KAEjB,MAAM8B,EAAS+N,EAAO7N,YACtB,GAAIF,EAAQ,CACR,MAAMwR,EAAcjU,KAAKmC,MAAMW,QAAQL,GACvC9B,EAAaoI,EAAO5G,MAAM8R,E,CAG9B,MAAM5C,EAAO,IAAI,IAAKb,EAAO/P,KAAMsI,EAAQpI,EAAY6P,EAAOpN,gBAAgBzB,QAAS6O,EAAOlN,gBAAgB3B,SAC9G0P,EAAKhQ,OAASmP,EAAOnP,OAEjBmP,EAAOhP,sBACP6P,EAAKtM,kBAAkByL,EAAOhP,sBAGlC,IAAW0S,SAAS1D,EAAOpP,WAAYiQ,EAAKjQ,W,CAGhD,GAAIpB,KAAK4N,QAAS,CACd7E,EAAO6E,QAAU,CAAC,EAClB,IAAK,MAAMuG,KAAanU,KAAK4N,QAAS,CAClC,MAAMwD,EAAQpR,KAAK4N,QAAQuG,GAEvB/C,IACArI,EAAO6E,QAAQuG,GAAa/C,EAAMzP,Q,EAS9C,OAJA3B,KAAKyN,UAAW,EAEhB1E,EAAOgG,SAAQ,GAERhG,CACX,CAOO,cAAAqL,CAAeC,EAAgB,KAClCrU,KAAKmC,MAAMmS,SAASjD,IAChBA,EAAKjQ,WAAWkT,SAASC,IACrBA,EAAUH,gBAAiB,EAC3BG,EAAUF,cAAgBA,CAAa,GACzC,GAEV,CAKO,OAAAR,GASH,GARA7T,KAAK0N,sBAAsBlH,OAAS,EAGpCxG,KAAKiB,WAAWuT,cAAcxU,MAG9BA,KAAKiB,WAAWwT,eAAezU,MAE3BA,KAAK+N,iBAAkB,CACvB,MAAMhN,EAAQf,KAAK+N,iBAAiB2G,UAAU5R,QAAQ9C,MAClDe,GAAS,GACTf,KAAK+N,iBAAiB2G,UAAUzR,OAAOlC,EAAO,GAElDf,KAAK+N,iBAAmB,I,CAGxB/N,KAAKkP,0BACLlP,KAAKkP,wBAAwB2E,UAC7B7T,KAAKkP,wBAA0B,KAEvC,CAMO,SAAAyF,G,MACH,MAAMC,EAA2B,CAAC,EAElCA,EAAoBnU,KAAOT,KAAKS,KAChCmU,EAAoBtH,GAAKtN,KAAKsN,GAE1BtN,KAAKgR,mBACL4D,EAAoB5D,iBAAmBhR,KAAKgR,iBAAiB6D,WAGjED,EAAoBzS,MAAQ,GAE5ByS,EAAoBpH,sBAAwBxN,KAAKwN,sBAEjD,IAAK,IAAIzM,EAAQ,EAAGA,EAAQf,KAAKmC,MAAMqE,OAAQzF,IAAS,CACpD,MAAMsQ,EAAOrR,KAAKmC,MAAMpB,GAClB0B,EAAS4O,EAAK1O,YAEdmS,EAAsB,CACxBC,gBAAiBtS,EAASzC,KAAKmC,MAAMW,QAAQL,IAAW,EACxD1B,MAAOsQ,EAAKxO,WACZpC,KAAM4Q,EAAK5Q,KACX6M,GAAI+D,EAAK/D,GACT7J,OAAQ4N,EAAKjO,gBAAgB4R,UAC7BC,KAAM5D,EAAK/N,gBAAgB0R,UAC3BE,sBAA8C,QAAvB,EAAA7D,EAAKnM,0BAAkB,eAAEoI,IAGpDsH,EAAoBzS,MAAMC,KAAK0S,GAE3BzD,EAAK7K,SACLsO,EAAetO,OAAS6K,EAAK7K,QAG7B6K,EAAK8D,WACLL,EAAeK,SAAW9D,EAAK8D,UAG/B9D,EAAKjQ,YAAciQ,EAAKjQ,WAAWoF,OAAS,IAC5CsO,EAAeP,UAAYlD,EAAKjQ,WAAW,GAAGuT,aAGlDC,EAAoBQ,OAAS,GAC7B,IAAK,MAAM3U,KAAQT,KAAK4N,QAAS,CAC7B,MAAM4C,EAASxQ,KAAK4N,QAAQnN,GAE5B,IAAK+P,EACD,SAGJ,MAAMY,EAAa,CAAC,EACpBA,EAAM3Q,KAAOA,EACb2Q,EAAMvB,KAAOW,EAAOX,KACpBuB,EAAMtB,GAAKU,EAAOV,GAClB8E,EAAoBQ,OAAOhT,KAAKgP,E,EAGxC,OAAOwD,CACX,CAQO,YAAOS,CAAMC,EAAqB/H,GACrC,MAAM7M,EAAW,IAAImM,EAASyI,EAAe7U,KAAM6U,EAAehI,GAAIC,GAOtE,IAAIxM,EACJ,IAPIuU,EAAetE,mBACftQ,EAASsQ,iBAAmB,IAAQuE,UAAUD,EAAetE,mBAGjEtQ,EAAS8M,sBAAwB8H,EAAe9H,sBAG3CzM,EAAQ,EAAGA,EAAQuU,EAAenT,MAAMqE,OAAQzF,IAAS,CAC1D,MAAMyU,EAAaF,EAAenT,MAAMpB,GAClC0U,EAAkBH,EAAenT,MAAMpB,GAAOA,MACpD,IAAIJ,EAAa,KACb6U,EAAWT,iBAAmB,IAC9BpU,EAAaD,EAASyB,MAAMqT,EAAWT,kBAG3C,MAAME,EAAyBO,EAAWP,KAAO,KAAOM,UAAUC,EAAWP,MAAQ,KAC/E5D,EAAO,IAAI,IAAKmE,EAAW/U,KAAMC,EAAUC,EAAY,KAAO4U,UAAUC,EAAW/R,QAASwR,EAAM,KAAMQ,QAExFrJ,IAAlBoJ,EAAWlI,IAAsC,OAAlBkI,EAAWlI,KAC1C+D,EAAK/D,GAAKkI,EAAWlI,IAGrBkI,EAAWhP,SACX6K,EAAK7K,OAASgP,EAAWhP,QAGzBgP,EAAWL,WACX9D,EAAK8D,SAAWK,EAAWL,UAG3BK,EAAWjB,WACXlD,EAAKjQ,WAAWgB,KAAK,IAAUiT,MAAMG,EAAWjB,iBAGXnI,IAArCoJ,EAAWN,uBAA4E,OAArCM,EAAWN,wBAC7DxU,EAASoN,iBAAkB,EAC3BuD,EAAK5P,wBAA0B+T,EAAWN,sB,CAKlD,GAAII,EAAeF,OACf,IAAKrU,EAAQ,EAAGA,EAAQuU,EAAeF,OAAO5O,OAAQzF,IAAS,CAC3D,MAAM2U,EAAOJ,EAAeF,OAAOrU,GACnCL,EAASkP,qBAAqB8F,EAAKjV,KAAMiV,EAAK7F,KAAM6F,EAAK5F,G,CAGjE,OAAOpP,CACX,CAMO,uBAAAgH,CAAwBiO,GAAc,IACrC3V,KAAK6N,2BAA6B8H,KAClC3V,KAAKmC,MAAM,GAAGuF,0BACd1H,KAAK6N,2BAA4B,EAEzC,CAOO,yBAAArC,CAA0BmK,GAAc,GAC3C3V,KAAK0H,wBAAwBiO,EACjC,CAMO,aAAAtK,GACH,IAAID,EAA+B,KAMnC,OAJIpL,KAAK0N,sBAAsBlH,OAAS,IACpC4E,EAAapL,KAAK0N,sBAAsB,GAAGrC,iBAGxCD,CACX,CAKO,SAAAwK,GACH,MAAMzT,EAAQ,IAAIhB,MACZ0U,EAAU,IAAI1U,MAAenB,KAAKmC,MAAMqE,QAC9C,IAAK,IAAIzF,EAAQ,EAAGA,EAAQf,KAAKmC,MAAMqE,OAAQzF,IAC3Cf,KAAK8V,WAAW/U,EAAOoB,EAAO0T,GAGlC7V,KAAKmC,MAAQA,CACjB,CAEQ,UAAA2T,CAAW/U,EAAeoB,EAAe0T,GAC7C,GAAIA,EAAQ9U,GACR,OAGJ8U,EAAQ9U,IAAS,EAEjB,MAAMsQ,EAAOrR,KAAKmC,MAAMpB,GACxB,IAAKsQ,EAAM,YAESjF,IAAhBiF,EAAKhQ,SACLgQ,EAAKhQ,OAASN,GAGlB,MAAMJ,EAAa0Q,EAAK1O,YACpBhC,GACAX,KAAK8V,WAAW9V,KAAKmC,MAAMW,QAAQnC,GAAawB,EAAO0T,GAG3D1T,EAAMC,KAAKiP,EACf,CAKO,oBAAA1E,GACH3M,KAAKmC,MAAMmS,SAAS3F,IAChBA,EAAEhC,sBAAsB,GAEhC,E,2EChvBJ,IAAWoJ,UAAUC,+BAAiC,SAAUC,EAAcC,EAAsCC,GAChH,MAAMC,EAAkB,IAAI,IAAgBpW,KAAM,IAAsBqW,cAGxE,GAFAD,EAAgBE,QAAS,EAEC,IAAtBtW,KAAKuW,aAEL,OADA,IAAOC,MAAM,mDACNJ,EAGX,MAAMK,EAAkB,OAAH,QACjBC,mBAAmB,EACnBC,mBAAoB,EACpBC,iBAAiB,GACdV,GAGDW,EAAK7W,KAAK8W,IAChB9W,KAAK+W,qBAAqBF,EAAGG,iBAAkBZ,GAAiB,GAEhEpW,KAAKiX,0BAA0Bb,EAAiBH,EAAMQ,EAAgBG,gBAAiBH,EAAgBC,kBAAmBD,EAAgBE,oBAE1IR,EAAUe,qBAAuBd,EACjCD,EAAUgB,gCAAkCV,EAAgBG,gBAG5D,IAAK,IAAIQ,EAAO,EAAGA,EAAO,EAAGA,IACrBX,EAAgBG,gBAChBC,EAAGQ,WAAWR,EAAGS,4BAA8BF,EAAM,EAAGP,EAAGU,iBAAkBtB,EAAMA,EAAM,EAAGY,EAAGW,cAAeX,EAAGY,kBAAmB,MAEpIZ,EAAGQ,WAAWR,EAAGS,4BAA8BF,EAAM,EAAGP,EAAGa,kBAAmBzB,EAAMA,EAAM,EAAGY,EAAGc,gBAAiBd,EAAGe,aAAc,MAQ1I,OAJA5X,KAAK+W,qBAAqBF,EAAGG,iBAAkB,MAE/ChX,KAAK6X,uBAAuBzV,KAAKgU,GAE1BA,CACX,EAEA,IAAWL,UAAU+B,iBAAmB,SACpCC,EACAhX,EACAiX,EACAC,EACAC,EAAyE,MAiBzElY,KAAKmY,UAAUJ,GAfCrC,IACZsC,EAAYjX,GAAS2U,EACfsC,EAAaI,iBAEuB,IAAhCJ,EAAaI,gBACnBH,EAASD,E,QAUmD5L,OAAWA,GAAW,GAN1E,CAACiM,EAAuBC,KAChCJ,GAAmBG,GACnBH,EAAgBG,EAAQE,OAAS,IAAMF,EAAQG,WAAYF,E,GAKvE,EAEA,IAAWvC,UAAU0C,kBAAoB,SACrClL,EACA0K,EACAS,EACAC,EAAiE,MAEjE,MAAMX,EAA6B,GAC7BA,EAAaI,eAAiB,EAEpC,IAAK,IAAIrX,EAAQ,EAAGA,EAAQ,EAAGA,IAC3Bf,KAAK8X,iBAAiBY,EAAM3X,GAAQA,EAAOiX,EAAaC,EAAUU,EAE1E,EAEA,IAAW5C,UAAU6C,iBAAmB,SACpCrL,EACAsL,EACAZ,EACAS,EACAC,EAAiE,KACjEG,GAEA,MAAMC,EAAmD,GACnDA,EAAcX,eAAiB,EAErC,IAAK,IAAIrX,EAAQ,EAAGA,EAAQ,EAAGA,IAC3Bf,KAAKgZ,gBAAgBN,EAAM3X,GAAQA,EAAOgY,EAAcxL,EAAOsL,EAASZ,EAAUU,EAASG,EAEnG,EAEA,IAAW/C,UAAUiD,gBAAkB,SACnCjB,EACAhX,EACAgY,EACAxL,EACAsL,EACAZ,EACAC,EAAyE,KACzEY,GAEA,MAAMG,GAAmB,UAyBzB,QAAUlB,GAvBMmB,IACZH,EAAahY,GAASmY,EAChBH,EAAcX,iBAEhB7K,GACAA,EAAM4L,kBAAkBF,GAGe,IAAjCF,EAAcX,gBAAwBH,GAC5CA,EAASY,EAASE,E,IAIV,CAACK,EAAkBd,KAC3B/K,GACAA,EAAM4L,kBAAkBF,GAGxBf,GACAA,EAAgBkB,EAASd,E,GAID/K,EAAQA,EAAM8L,gBAAkB,KAAMP,GAClEvL,GACAA,EAAM+L,eAAeL,EAE7B,EAEA,IAAWlD,UAAUwD,yBAA2B,SAAUV,EAA0BW,EAAqBC,GACrG,MAAM5C,EAAK7W,KAAK8W,IAChBD,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAG8C,mBAAoB9C,EAAG+C,QAChE/C,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGgD,mBAAoBL,EAAa3C,EAAGiD,qBAAuBjD,EAAG+C,QACvG/C,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGkD,eAAgBlD,EAAGmD,eAC5DnD,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGoD,eAAgBpD,EAAGmD,eAC5DnB,EAAQqB,aAAeV,EAAa,IAEhCA,GAAcxZ,KAAKuO,UAAU4L,sBAAgC/N,IAAbqN,GAA0BA,EAAW,IACrF5C,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGuD,kBAAmBX,GAC5DZ,EAAQwB,aAAeZ,GAG3BzZ,KAAK+W,qBAAqBF,EAAGG,iBAAkB,KACnD,EAEA,IAAWjB,UAAUuE,sBAAwB,SACzCC,EACAhN,EACAmL,EACA8B,EACAC,EAAyC,KACzC9B,EAAiE,KACjE+B,EACAC,EAAuB,KACvBC,GAA6B,EAC7BC,EAAmB,EACnBC,EAAoB,EACpBC,EAAsC,KACtCC,EAAsH,KACtHC,EAAuG,KACvGC,GAAgB,GAEhB,MAAMrC,EAAUkC,GAAsB,IAAI,IAAgB/a,KAAM,IAAsBmb,MACtFtC,EAAQvC,QAAS,EACjBuC,EAAQd,IAAMwC,EACd1B,EAAQuC,iBAAmBZ,EAC3B3B,EAAQwC,oBAAsBR,EAC9BhC,EAAQyC,qBAAuBR,EAC/BjC,EAAQ0C,iBAAmBL,GAAiBlb,KAAKwb,MAAMC,qBAAuBzb,KAAKuW,aAAe,GAAKvW,KAAK0b,YAAclB,GACtH3B,IAAYkC,IACZlC,EAAQ8C,MAAQpB,EAAQqB,UAAU,EAAG,KAGpC5b,KAAK6b,0BACNhD,EAAQiD,WAAanB,EACrB9B,EAAQkD,OAASrD,GAGrB,MAAMsD,EAAkBzB,EACpBva,KAAKic,uBAAyBlB,IAC9BR,EAAUva,KAAKic,qBAAqB1B,IAGxC,MAAM2B,EAA0B3B,EAAQ4B,MAAM,KAAK,GAC7CC,EAAUF,EAAwBG,YAAY,KAC9CC,EAAY3B,IAAoCyB,GAAW,EAAIF,EAAwBN,UAAUQ,GAASG,cAAgB,IAEhI,IAAIC,EAA2C,KAC/C,IAAK,MAAMC,KAAmB,IAAWC,gBACrC,GAAID,EAAgBE,QAAQL,GAAY,CACpCE,EAASC,EACT,K,CAIR,MAAMG,EAAkB,CAACvE,EAAuBC,KACxCiC,IAAYyB,EACRrD,GAAWN,GACXM,EAAQN,EAAQE,OAAS,IAAMF,EAAQG,WAAYF,IAIvD,IAAOxH,KAAK,kBAAkByJ,0BAAgCyB,KAC9Dhc,KAAKsa,sBACD0B,EACAzO,EACAmL,IACE8B,EACFC,EACA9B,EACA+B,EACAC,EACAC,EACAC,EACAC,EACAjC,EACAmC,EACAC,EACAC,G,EAKZ,GAAIsB,EAAQ,CACR,MAAMK,EAAcnH,IACZsF,GACAA,EAA2BnC,EAASnD,GAExC8G,EAAQM,aAAapH,EAAMmD,EAAS+B,EAAmBH,EAAQ9B,EAAQ,EAEvED,GAA0B,IAAjBA,EAAMlS,OACXgW,EAAOO,gBACP/c,KAAKyY,kBAAkBlL,GAAQyP,GAAWH,EAAWG,EAAOC,KAAKC,GAAU,IAAIC,WAAWD,OAAUxE,EAAOC,GAEvGA,EACAA,EAAQ,4CAER,IAAO7H,KAAK,6CAIpB9Q,KAAKmY,UAAUoC,GAAU7E,GAASmH,EAAW,IAAIM,WAAWzH,UAAuBtJ,OAAWA,GAAW,EAAMwQ,E,KAEhH,CACH,IAAKlE,EACD,MAAM,IAAIlC,MAAM,sDAGpBxW,KAAK4Y,iBACDrL,EACAsL,GACA,CAACA,EAA0BuE,KACnBnC,GACAA,EAAapC,EAASuE,E,GAG9B1E,EACAC,E,CAMR,OAFA3Y,KAAK6X,uBAAuBzV,KAAKyW,GAE1BA,CACX,EAEA,IAAW9C,UAAUsH,kBAAoB,SACrC9C,EACAhN,EACAmL,EACA8B,EACAC,EAAyC,KACzC9B,EAAiE,KACjE+B,EACAC,EAAuB,KACvBC,GAA6B,EAC7BC,EAAmB,EACnBC,EAAoB,EACpBC,EAAsC,KACtCuC,EACApC,GAAgB,GAEhB,MAAMrE,EAAK7W,KAAK8W,IAEhB,OAAO9W,KAAKsa,sBACRC,EACAhN,EACAmL,IACE8B,EACFC,EACA9B,EACA+B,EACAC,EACAC,EACAC,EACAC,EACAC,GACClC,GAA6B7Y,KAAK+W,qBAAqBF,EAAGG,iBAAkB6B,GAAS,KACtF,CAACA,EAA0BuE,KACvB,MAAMxJ,EAAQ5T,KAAKud,gBAAkB,IAAWC,iBAAiBJ,EAAK,GAAGxJ,MAAO5T,KAAKwb,MAAMiC,uBAAyBL,EAAK,GAAGxJ,MACtH8J,EAAS9J,EAET+J,EAAQ,CACV9G,EAAGS,4BACHT,EAAG+G,4BACH/G,EAAGgH,4BACHhH,EAAGiH,4BACHjH,EAAGkH,4BACHlH,EAAGmH,6BAGPhe,KAAK+W,qBAAqBF,EAAGG,iBAAkB6B,GAAS,GACxD7Y,KAAKie,cAAa,GAElB,MAAMC,EAAiBxD,EAAS1a,KAAKme,mBAAmBzD,EAAQ7B,EAAQ0C,gBAAkB1C,EAAQ0C,eAAiBvb,KAAKoe,uBAAuBC,aAAexH,EAAGyH,KACjK,IAAIC,EAAc7D,EAAS1a,KAAKme,mBAAmBzD,GAAU7D,EAAGyH,KAE5DzF,EAAQ0C,gBAAwC,IAAtBvb,KAAKuW,eAC/BgI,EAAcL,GAGlB,IAAK,IAAInd,EAAQ,EAAGA,EAAQ4c,EAAMnX,OAAQzF,IACtC,GAAIqc,EAAKrc,GAAO6S,QAAUA,GAASwJ,EAAKrc,GAAO2c,SAAWA,EAAQ,CAG9D,GAFA1d,KAAKwe,yBAEAxe,KAAKye,iBAAmBze,KAAK0e,gBAE9B,YADA,IAAO5N,KAAK,2CAGhB9Q,KAAKye,eAAe7K,MAAQA,EAC5B5T,KAAKye,eAAef,OAASA,EAE7B1d,KAAK0e,gBAAgBC,UAAUvB,EAAKrc,GAAQ,EAAG,EAAGqc,EAAKrc,GAAO6S,MAAOwJ,EAAKrc,GAAO2c,OAAQ,EAAG,EAAG9J,EAAO8J,GACtG7G,EAAGQ,WAAWsG,EAAM5c,GAAQ,EAAGmd,EAAgBK,EAAa1H,EAAG+H,cAAe5e,KAAKye,e,MAEnF5H,EAAGQ,WAAWsG,EAAM5c,GAAQ,EAAGmd,EAAgBK,EAAa1H,EAAG+H,cAAexB,EAAKrc,IAItFyZ,GACD3D,EAAGgI,eAAehI,EAAGG,kBAGzBhX,KAAKuZ,yBAAyBV,GAAU2B,GAExC3B,EAAQjF,MAAQA,EAChBiF,EAAQ6E,OAASA,EACjB7E,EAAQiG,SAAU,EACdpE,IACA7B,EAAQ6B,OAASA,GAGrB7B,EAAQkG,mBAAmBjM,gBAAgB+F,GAC3CA,EAAQkG,mBAAmBC,QAEvBvE,GACAA,G,KAGNS,EAEV,C,gECsHA,SAAS+D,EAA6BC,EAActL,EAAe8J,EAAgByB,GAE/E,IAAIC,EACAC,EAAO,EACS,IAAhBF,EACAC,EAAW,IAAI7L,aAAaK,EAAQ8J,EAAS,GACtB,IAAhByB,GACPC,EAAW,IAAIE,YAAY1L,EAAQ8J,EAAS,GAC5C2B,EAAO,OAEPD,EADuB,IAAhBD,EACI,IAAII,YAAY3L,EAAQ8J,EAAS,GAEjC,IAAIP,WAAWvJ,EAAQ8J,EAAS,GAI/C,IAAK,IAAIrW,EAAI,EAAGA,EAAIuM,EAAOvM,IACvB,IAAK,IAAIC,EAAI,EAAGA,EAAIoW,EAAQpW,IAAK,CAC7B,MAAMvG,EAA0B,GAAjBuG,EAAIsM,EAAQvM,GACrBmY,EAA6B,GAAjBlY,EAAIsM,EAAQvM,GAG9B+X,EAASI,EAAW,GAAKN,EAAQne,EAAQ,GACzCqe,EAASI,EAAW,GAAKN,EAAQne,EAAQ,GACzCqe,EAASI,EAAW,GAAKN,EAAQne,EAAQ,GAGzCqe,EAASI,EAAW,GAAKH,C,CAIjC,OAAOD,CACX,CAQA,SAASK,EAA8BC,GACnC,OAAO,SAEHhK,EACA9B,EACA8J,EACAiC,EACAjF,EACAU,EACAwE,EACA1F,EACA2F,EAAgC,KAChCV,EAAsB,GAEtB,MAAMW,EAASJ,EAAO1f,KAAK8W,IAAIiJ,WAAa/f,KAAK8W,IAAIkJ,iBAC/CxP,EAASkP,EAAO,IAAsBO,MAAQ,IAAsBC,WACpErH,EAAU,IAAI,IAAgB7Y,KAAMwQ,GAC1CqI,EAAQsH,UAAYvM,EACpBiF,EAAQuH,WAAa1C,EACrB7E,EAAQwH,UAAYV,EACpB9G,EAAQjF,MAAQA,EAChBiF,EAAQ6E,OAASA,EACjB7E,EAAQ8G,MAAQA,EAChB9G,EAAQ6B,OAASA,EACjB7B,EAAQyH,KAAOnB,EACftG,EAAQuC,gBAAkBA,EAC1BvC,EAAQqB,aAAeA,EACnBwF,EACA7G,EAAQ6G,MAAO,EAEf7G,EAAQ0H,WAAY,EAGnBvgB,KAAK6b,0BACNhD,EAAQ2H,YAAc9K,GAGtBgK,EACA1f,KAAKygB,mBAAmB5H,EAASnD,EAAMgF,EAAQkF,EAASC,EAAaV,GAErEnf,KAAK0gB,wBAAwB7H,EAASnD,EAAMgF,EAAQkF,EAASC,EAAaV,GAE9Enf,KAAK+W,qBAAqB+I,EAAQjH,GAAS,GAG3C,MAAM8H,EAAU3gB,KAAK4gB,uBAAuB1G,EAAckB,GAa1D,OAXApb,KAAK8W,IAAI4C,cAAcoG,EAAQ9f,KAAK8W,IAAI6C,mBAAoBgH,EAAQE,KACpE7gB,KAAK8W,IAAI4C,cAAcoG,EAAQ9f,KAAK8W,IAAI+C,mBAAoB8G,EAAQG,KAEhE1F,GACApb,KAAK8W,IAAI+H,eAAeiB,GAG5B9f,KAAK+W,qBAAqB+I,EAAQ,MAElC9f,KAAK6X,uBAAuBzV,KAAKyW,GAE1BA,CACX,CACJ,CAWA,SAASkI,EAA8BrB,GACnC,OAAO,SAEH7G,EACAnD,EACAgF,EACAkF,EACAC,EAAgC,KAChCV,EAAsB,GAEtB,MAAMW,EAASJ,EAAO1f,KAAK8W,IAAIiJ,WAAa/f,KAAK8W,IAAIkJ,iBAC/CgB,EAAehhB,KAAKihB,qBAAqB9B,GACzCjB,EAAiBle,KAAKme,mBAAmBzD,GACzCwG,EAAqBlhB,KAAKmhB,kCAAkChC,EAAazE,GAE/E1a,KAAK+W,qBAAqB+I,EAAQjH,GAAS,GAC3C7Y,KAAKie,kBAAyB7R,IAAZwT,KAA+BA,GAE5C5f,KAAK6b,0BACNhD,EAAQ2H,YAAc9K,EACtBmD,EAAQ6B,OAASA,EACjB7B,EAAQ+G,QAAUA,EAClB/G,EAAQuI,aAAevB,GAGvBhH,EAAQjF,MAAQ,GAAM,GACtB5T,KAAK8W,IAAIuK,YAAYrhB,KAAK8W,IAAIwK,iBAAkB,GAGhDzB,GAAenK,EACf1V,KAAK8W,IAAIyK,qBAAqBzB,EAAQ,EAAS9f,KAAKuO,UAAUiT,KAAM3B,GAAchH,EAAQjF,MAAOiF,EAAQ6E,OAAQ7E,EAAQ8G,MAAO,EAAGjK,GAEnI1V,KAAK8W,IAAI2K,WAAW3B,EAAQ,EAAGoB,EAAoBrI,EAAQjF,MAAOiF,EAAQ6E,OAAQ7E,EAAQ8G,MAAO,EAAGzB,EAAgB8C,EAActL,GAGlImD,EAAQuC,iBACRpb,KAAK8W,IAAI+H,eAAeiB,GAE5B9f,KAAK+W,qBAAqB+I,EAAQ,MAElCjH,EAAQiG,SAAU,CACtB,CACJ,CAzgBA,IAAW/I,UAAU2L,iBAAmB,SACpC7I,EACAnD,EACAgF,EACAkF,EACAC,EAAgC,KAChCS,EAAe,KAAU,GAGzB,IAAKzH,EACD,OAGJ,MAAMqI,EAAqBlhB,KAAKmhB,kCAAkCb,EAAM5F,EAAQQ,GAG1EgD,EAAiBle,KAAKme,mBAAmBzD,GACzCyE,EAAcnf,KAAKihB,qBAAqBX,GAC9CtgB,KAAK+W,qBAAqB/W,KAAK8W,IAAI6K,WAAY9I,GAAS,GACxD7Y,KAAKie,kBAAyB7R,IAAZwT,KAA+BA,GAE5C5f,KAAK6b,0BACNhD,EAAQ2H,YAAc9K,EACtBmD,EAAQ6B,OAASA,EACjB7B,EAAQyH,KAAOA,EACfzH,EAAQ+G,QAAUA,EAClB/G,EAAQuI,aAAevB,GAGvBhH,EAAQjF,MAAQ,GAAM,GACtB5T,KAAK8W,IAAIuK,YAAYrhB,KAAK8W,IAAIwK,iBAAkB,GAGhDzB,GAAenK,EACf1V,KAAK8W,IAAI8K,qBAAqB5hB,KAAK8W,IAAI6K,WAAY,EAAS3hB,KAAKuO,UAAUiT,KAAM3B,GAAchH,EAAQjF,MAAOiF,EAAQ6E,OAAQ,EAAahI,GAE3I1V,KAAK8W,IAAIO,WAAWrX,KAAK8W,IAAI6K,WAAY,EAAGT,EAAoBrI,EAAQjF,MAAOiF,EAAQ6E,OAAQ,EAAGQ,EAAgBiB,EAAazJ,GAG/HmD,EAAQuC,iBACRpb,KAAK8W,IAAI+H,eAAe7e,KAAK8W,IAAI6K,YAErC3hB,KAAK+W,qBAAqB/W,KAAK8W,IAAI6K,WAAY,MAE/C9I,EAAQiG,SAAU,CACtB,EAEA,IAAW/I,UAAU8L,iBAAmB,SACpCnM,EACA9B,EACA8J,EACAhD,EACAU,EACAwE,EACA1F,EACA2F,EAAgC,KAChCS,EAAe,EAEfwB,EAAgB,EAChB5G,GAAgB,GAEhB,MAAMrC,EAAU,IAAI,IAAgB7Y,KAAM,IAAsB+hB,KAChElJ,EAAQsH,UAAYvM,EACpBiF,EAAQuH,WAAa1C,EACrB7E,EAAQjF,MAAQA,EAChBiF,EAAQ6E,OAASA,EACjB7E,EAAQ6B,OAASA,EACjB7B,EAAQuC,gBAAkBA,EAC1BvC,EAAQqB,aAAeA,EACvBrB,EAAQ+G,QAAUA,EAClB/G,EAAQuI,aAAevB,EACvBhH,EAAQyH,KAAOA,EACfzH,EAAQ0C,eAAiBvb,KAAKgiB,kBAAkB9G,GAAgBE,GAE3Dpb,KAAK6b,0BACNhD,EAAQ2H,YAAc9K,GAG1B1V,KAAK0hB,iBAAiB7I,EAASnD,EAAMgF,EAAQkF,EAASC,EAAaS,EAAMzH,EAAQ0C,gBACjFvb,KAAK+W,qBAAqB/W,KAAK8W,IAAI6K,WAAY9I,GAAS,GAGxD,MAAM8H,EAAU3gB,KAAK4gB,uBAAuB1G,EAAckB,GAa1D,OAXApb,KAAK8W,IAAI4C,cAAc1Z,KAAK8W,IAAI6K,WAAY3hB,KAAK8W,IAAI6C,mBAAoBgH,EAAQE,KACjF7gB,KAAK8W,IAAI4C,cAAc1Z,KAAK8W,IAAI6K,WAAY3hB,KAAK8W,IAAI+C,mBAAoB8G,EAAQG,KAE7E1F,GACApb,KAAK8W,IAAI+H,eAAe7e,KAAK8W,IAAI6K,YAGrC3hB,KAAK+W,qBAAqB/W,KAAK8W,IAAI6K,WAAY,MAE/C3hB,KAAK6X,uBAAuBzV,KAAKyW,GAE1BA,CACX,EAEA,IAAW9C,UAAUkM,qBAAuB,SACxCvM,EACAO,EACAyE,EACA4F,EACAlF,EACAwE,EACA1F,EACA2F,EAAgC,MAEhC,MAAMhJ,EAAK7W,KAAK8W,IACV+B,EAAU,IAAI,IAAgB7Y,KAAM,IAAsBkiB,SAChErJ,EAAQvC,QAAS,EACjBuC,EAAQ6B,OAASA,EACjB7B,EAAQyH,KAAOA,EACVtgB,KAAK6b,0BACNhD,EAAQsJ,iBAAmBzM,GAG/B,MAAMyJ,EAAcnf,KAAKihB,qBAAqBX,GAC9C,IAAIpC,EAAiBle,KAAKme,mBAAmBzD,GAEzCwD,IAAmBrH,EAAGuL,MACtBlE,EAAiBrH,EAAGyH,MAIpBa,IAAgBtI,EAAGwL,OAAUriB,KAAKwb,MAAM8G,4BAIjCnD,IAAgBnf,KAAK8W,IAAIyL,gBAAmBviB,KAAKwb,MAAMgH,gCAIvDrD,IAAgBtI,EAAGwL,OAAUriB,KAAKwb,MAAMiH,mBAGxCtD,IAAgBtI,EAAG6L,YAAe1iB,KAAKwb,MAAMmH,mBACpDvH,GAAkB,EAClB,IAAOtK,KAAK,wFAJZsK,GAAkB,EAClB,IAAOtK,KAAK,mFALZsK,GAAkB,EAClBlB,EAAe,EACf,IAAOpJ,KAAK,4JANZsK,GAAkB,EAClBlB,EAAe,EACf,IAAOpJ,KAAK,sJAahB,MAAM8C,EAAQqC,EACRyH,EAAS9J,EAcf,GAZAiF,EAAQjF,MAAQA,EAChBiF,EAAQ6E,OAASA,EACjB7E,EAAQ+G,QAAUA,EAClB/G,EAAQuI,aAAevB,GAGR7f,KAAKud,iBAAoB,KAAMqF,gBAAgB/J,EAAQjF,QAAU,KAAMgP,gBAAgB/J,EAAQ6E,UAE1GtC,GAAkB,GAIlB1F,EACA1V,KAAK6iB,qBAAqBhK,EAASnD,EAAMgF,EAAQ4F,EAAMV,EAASC,OAC7D,CACH,MAAMqB,EAAqBlhB,KAAKmhB,kCAAkCb,GAC5DwC,EAAQ,EAEd9iB,KAAK+W,qBAAqBF,EAAGG,iBAAkB6B,GAAS,GAExD,IAAK,IAAIkK,EAAY,EAAGA,EAAY,EAAGA,IAC/BlD,EACAhJ,EAAG+K,qBACC/K,EAAGS,4BAA8ByL,EACjCD,EACM9iB,KAAKuO,UAAUiT,KAAM3B,GAC3BhH,EAAQjF,MACRiF,EAAQ6E,OACR,OACAtR,GAGJyK,EAAGQ,WAAWR,EAAGS,4BAA8ByL,EAAWD,EAAO5B,EAAoBrI,EAAQjF,MAAOiF,EAAQ6E,OAAQ,EAAGQ,EAAgBiB,EAAa,MAI5Jnf,KAAK+W,qBAAqB/W,KAAK8W,IAAIE,iBAAkB,K,CAGzDhX,KAAK+W,qBAAqB/W,KAAK8W,IAAIE,iBAAkB6B,GAAS,GAG1DnD,GAAQ0F,GACRpb,KAAK8W,IAAI+H,eAAe7e,KAAK8W,IAAIE,kBAGrC,MAAM2J,EAAU3gB,KAAK4gB,uBAAuB1G,EAAckB,GAY1D,OAXAvE,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAG8C,mBAAoBgH,EAAQE,KACrEhK,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGgD,mBAAoB8G,EAAQG,KAErEjK,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGkD,eAAgBlD,EAAGmD,eAC5DnD,EAAG6C,cAAc7C,EAAGG,iBAAkBH,EAAGoD,eAAgBpD,EAAGmD,eAC5Dha,KAAK+W,qBAAqBF,EAAGG,iBAAkB,MAE/C6B,EAAQuC,gBAAkBA,EAC1BvC,EAAQqB,aAAeA,EACvBrB,EAAQiG,SAAU,EAEXjG,CACX,EAEA,IAAW9C,UAAU8M,qBAAuB,SACxChK,EACAnD,EACAgF,EACA4F,EACAV,EACAC,EAAgC,KAChCiD,EAAgB,GAEhBjK,EAAQsJ,iBAAmBzM,EAC3BmD,EAAQ6B,OAASA,EACjB7B,EAAQyH,KAAOA,EACfzH,EAAQ+G,QAAUA,EAClB/G,EAAQuI,aAAevB,EAEvB,MAAMhJ,EAAK7W,KAAK8W,IACVqI,EAAcnf,KAAKihB,qBAAqBX,GAC9C,IAAIpC,EAAiBle,KAAKme,mBAAmBzD,GAC7C,MAAMwG,EAAqBlhB,KAAKmhB,kCAAkCb,GAElE,IAAI0C,GAAiB,EACjB9E,IAAmBrH,EAAGuL,MACtBlE,EAAiBrH,EAAGyH,KACpB0E,GAAiB,GAGrBhjB,KAAK+W,qBAAqBF,EAAGG,iBAAkB6B,GAAS,GACxD7Y,KAAKie,kBAAyB7R,IAAZwT,KAA+BA,GAE7C/G,EAAQjF,MAAQ,GAAM,GACtBiD,EAAGwK,YAAYxK,EAAGyK,iBAAkB,GAIxC,IAAK,IAAIyB,EAAY,EAAGA,EAAY,EAAGA,IAAa,CAChD,IAAIE,EAAWvN,EAAKqN,GAEhBlD,EACAhJ,EAAG+K,qBACC/K,EAAGS,4BAA8ByL,EACjCD,EACM9iB,KAAKuO,UAAUiT,KAAM3B,GAC3BhH,EAAQjF,MACRiF,EAAQ6E,OACR,EACUuF,IAGVD,IACAC,EAAWhE,EAA6BgE,EAAUpK,EAAQjF,MAAOiF,EAAQ6E,OAAQ4C,IAErFzJ,EAAGQ,WAAWR,EAAGS,4BAA8ByL,EAAWD,EAAO5B,EAAoBrI,EAAQjF,MAAOiF,EAAQ6E,OAAQ,EAAGQ,EAAgBiB,EAAa8D,G,GAI7IjjB,KAAKud,iBAAoB,KAAMqF,gBAAgB/J,EAAQjF,QAAU,KAAMgP,gBAAgB/J,EAAQ6E,UACjG7E,EAAQuC,iBAA6B,IAAV0H,GACpC9iB,KAAK8W,IAAI+H,eAAe7e,KAAK8W,IAAIE,kBAErChX,KAAK+W,qBAAqB/W,KAAK8W,IAAIE,iBAAkB,MAGrD6B,EAAQiG,SAAU,CACtB,EAEA,IAAW/I,UAAUmN,4BAA8B,SAC/CnL,EACAxK,EACA0I,EACAyE,EACA4F,EACA9F,EACA2I,EACAC,EACA3I,EAA+B,KAC/B9B,EAAiE,KACjEuB,EAAuB,KAAU,GAGjC,MAAMrD,EAAK7W,KAAK8W,IACV+B,EAAU7Y,KAAKiiB,qBAAqB,KAAMhM,EAAMyE,EAAQ4F,GAAO9F,EAAUoF,EAAS1F,EAAc,MACtG3M,SAAAA,EAAO+L,eAAeT,GACtBA,EAAQd,IAAMA,EACdc,EAAQiG,SAAU,EAClB9e,KAAK6X,uBAAuBzV,KAAKyW,GAEjC,MAOMwK,EAAoB3N,IACtB,MAAM9B,EAAQiF,EAAQjF,MAChB0P,EAAiBH,EAASzN,GAEhC,GAAK4N,EAAL,CAIA,GAAIF,EAAiB,CACjB,MAAMjE,EAAcnf,KAAKihB,qBAAqBX,GAC9C,IAAIpC,EAAiBle,KAAKme,mBAAmBzD,GAC7C,MAAMwG,EAAqBlhB,KAAKmhB,kCAAkCb,GAElE,IAAI0C,GAAiB,EACjB9E,IAAmBrH,EAAGuL,MACtBlE,EAAiBrH,EAAGyH,KACpB0E,GAAiB,GAGrBhjB,KAAK+W,qBAAqBF,EAAGG,iBAAkB6B,GAAS,GACxD7Y,KAAKie,cAAa,GAElB,MAAMsF,EAAUH,EAAgBE,GAChC,IAAK,IAAIR,EAAQ,EAAGA,EAAQS,EAAQ/c,OAAQsc,IAAS,CACjD,MAAMU,EAAU5P,GAASkP,EAEzB,IAAK,IAAIC,EAAY,EAAGA,EAAY,EAAGA,IAAa,CAChD,IAAIU,EAAcF,EAAQT,GAAOC,GAC7BC,IACAS,EAAcxE,EAA6BwE,EAAaD,EAASA,EAASlD,IAE9EzJ,EAAGQ,WAAW0L,EAAWD,EAAO5B,EAAoBsC,EAASA,EAAS,EAAGtF,EAAgBiB,EAAasE,E,EAI9GzjB,KAAK+W,qBAAqBF,EAAGG,iBAAkB,K,MAE/ChX,KAAK6iB,qBAAqBhK,EAASyK,EAAgB5I,EAAQ4F,EAAMV,GAGrE/G,EAAQiG,SAAU,EAElBvR,SAAAA,EAAO4L,kBAAkBN,GAEzBA,EAAQkG,mBAAmBjM,gBAAgB+F,GAC3CA,EAAQkG,mBAAmBC,QAEvBvE,GACAA,G,GAeR,OAXAza,KAAKmY,UACDJ,GACCrC,IACG2N,EAAiB3N,EAAK,QAE1BtJ,EACAmB,aAAK,EAALA,EAAO8L,iBACP,GAlEY,CAAChB,EAAuBC,KACpC/K,SAAAA,EAAO4L,kBAAkBN,GACrBF,GAAWN,GACXM,EAAQN,EAAQE,OAAS,IAAMF,EAAQG,WAAYF,E,IAmEpDO,CACX,EA4GA,IAAW9C,UAAU2N,wBAA0BjE,GAA8B,GAC7E,IAAW1J,UAAU4N,mBAAqBlE,GAA8B,GAoDxE,IAAW1J,UAAU2K,wBAA0BK,GAA8B,GAC7E,IAAWhL,UAAU0K,mBAAqBM,GAA8B,E,qLC/mBjE,MAAM6C,EAoBD,yBAAOC,CAAmBtW,GAC9B,MAAO,CACHuW,cAAc,EACdC,WAAY,GACZC,cAAehkB,KAAKikB,qBACpBC,YAAa,IAAI,KAAO,GAAK,GAAK,IAAKC,cAAc5W,EAAMe,YAAY8V,yBAAyB9b,MAAM,GACtG+b,cAAe,GACfC,oBAAoB,EACpBC,kBAAmB,GAEnBC,oBAAoB,EACpBC,sBAAuB,GACvBC,uBAAwB,GACxBC,mBAAoB,EACpBC,0BAA2B,EAC3BC,4BAA6B,EAC7BC,wBAAyB,EAEzBC,YAAa,KAEbC,cAAc,EACdC,WAAY,GACZC,cAAellB,KAAKmlB,qBACpBC,YAAa,IAAI,KAAO,GAAK,GAAK,IAAKjB,cAAc5W,EAAMe,YAAY8V,yBAAyB9b,MAAM,GAEtG+c,oBAAqB,EACrBC,UAAU,EACVC,aAAc,IAAQrf,OAEtBsf,sBAAsB,EACtBC,mBAAoBzlB,KAAK0lB,0BACzBC,eAAgB,GAChBC,eAAgB,IAChBC,oBAAoB,EAE5B,CAMA,YAAWC,GACP,OAAO9lB,KAAK+lB,SAChB,CAMA,UAAWC,GACP,OAAOhmB,KAAKimB,OAChB,CAMA,iBAAWf,GACP,OAAOllB,KAAKkmB,cAChB,CAMA,kBAAWC,GACP,OAAOnmB,KAAKomB,eAChB,CAMA,UAAWC,GACP,OAAOrmB,KAAKsmB,OAChB,CAMA,iBAAWtC,GACP,OAAOhkB,KAAKumB,cAChB,CAMA,gBAAWC,GACP,OAAOxmB,KAAKymB,aAChB,CAMA,0BAAWC,GACP,OAAI1mB,KAAKymB,cACEzmB,KAAKymB,cAAcE,WAEvB,IACX,CAMA,kBAAWC,GACP,OAAO5mB,KAAK6mB,eAChB,CAmBA,WAAArmB,CAAY0V,EAA6C3I,GAkWjD,KAAAuZ,cAAgB,CAAC1N,EAAkBd,KACvCtY,KAAK+mB,kBAAkBjU,gBAAgB,CAAEsG,QAASA,EAASd,UAAWA,GAAY,EAlWlFtY,KAAKgnB,SAAW,OAAH,wBACNpD,EAAkBC,mBAAmBtW,IACrC2I,GAEPlW,KAAKiN,OAASM,EACdvN,KAAK+mB,kBAAoB,IAAI,KAE7B/mB,KAAKinB,mBACLjnB,KAAKknB,uBACT,CAMO,aAAAC,CAAcjR,GACjB,MAAMkR,EAAa,OAAH,wBACTpnB,KAAKgnB,UACL9Q,GAGHlW,KAAKsmB,UAAYc,EAAWtD,eAC5B9jB,KAAKsmB,QAAQzS,UACb7T,KAAKsmB,QAAU,MAGftmB,KAAK6mB,kBAAoBO,EAAWtD,eACpC9jB,KAAK6mB,gBAAgBhT,UACrB7T,KAAK6mB,gBAAkB,MAGvB7mB,KAAKumB,gBACDvmB,KAAKgnB,SAAShD,eAAiBoD,EAAWpD,gBAC1ChkB,KAAKumB,eAAe1S,UACpB7T,KAAKumB,eAAiB,MAI1BvmB,KAAKimB,UAAYmB,EAAWpC,eAC5BhlB,KAAKimB,QAAQpS,UACb7T,KAAKimB,QAAU,MAGfjmB,KAAKomB,kBAAoBgB,EAAWpC,eACpChlB,KAAKomB,gBAAgBvS,UACrB7T,KAAKomB,gBAAkB,MAGvBpmB,KAAKkmB,gBACDlmB,KAAKgnB,SAAS9B,eAAiBkC,EAAWlC,gBAC1CllB,KAAKkmB,eAAerS,UACpB7T,KAAKkmB,eAAiB,MAI1BlmB,KAAKymB,gBAAkBW,EAAW5C,qBAClCxkB,KAAKymB,cAAc5S,UACnB7T,KAAKymB,cAAgB,MAGrBzmB,KAAKiN,OAAOwY,oBACRzlB,KAAKgnB,SAASvB,oBAAsB2B,EAAW3B,oBAC/CzlB,KAAKiN,OAAOwY,mBAAmB5R,UAIvC7T,KAAKgnB,SAAWI,EAEhBpnB,KAAKinB,mBACLjnB,KAAKknB,uBACT,CAMO,YAAAG,CAAaC,GACZtnB,KAAK4mB,iBACL5mB,KAAK4mB,eAAeW,aAAeD,GAGnCtnB,KAAKmmB,iBACLnmB,KAAKmmB,eAAeoB,aAAeD,GAGnCtnB,KAAKwmB,eACLxmB,KAAKwmB,aAAagB,WAAa,IAAI,KAAOF,EAAMG,EAAGH,EAAMI,EAAGJ,EAAM3Y,EAAG,GAE7E,CAKQ,qBAAAuY,GACAlnB,KAAKgnB,SAASxB,uBACdxlB,KAAKiN,OAAO0a,6BAA6BC,SAAW5nB,KAAKgnB,SAASpB,eAClE5lB,KAAKiN,OAAO0a,6BAA6BE,SAAW7nB,KAAKgnB,SAASrB,eAClE3lB,KAAKiN,OAAO0a,6BAA6B9B,mBAAqB7lB,KAAKgnB,SAASnB,mBAC5E7lB,KAAK8nB,2BAEb,CAKQ,wBAAAA,GACJ,GAAI9nB,KAAKiN,OAAOwY,mBACZ,OAGJ,GAAIzlB,KAAKgnB,SAASvB,8BAA8B,IAE5C,YADAzlB,KAAKiN,OAAOwY,mBAAqBzlB,KAAKgnB,SAASvB,oBAInD,MAAMA,EAAqB,IAAYsC,0BAA0B/nB,KAAKgnB,SAASvB,mBAAoBzlB,KAAKiN,QACxGjN,KAAKiN,OAAOwY,mBAAqBA,CACrC,CAKQ,gBAAAwB,GACCjnB,KAAK+lB,YACN/lB,KAAK+lB,UAAY,IAAI,KAAK,mBAAoB/lB,KAAKiN,SAEvDjN,KAAK+lB,UAAUxgB,SAAS+B,EAAItH,KAAKgnB,SAAS3B,oBAE1C,MAAM2C,EAAYhoB,KAAKioB,gBACnBjoB,KAAKgnB,SAASlD,eACd9jB,KAAKkoB,aAAaF,GAClBhoB,KAAKmoB,uBACLnoB,KAAKooB,6BAEDpoB,KAAKgnB,SAASxC,oBACdxkB,KAAKqoB,0BAA0BL,GAEnChoB,KAAKsoB,gCAGLtoB,KAAKgnB,SAAShC,eACdhlB,KAAKuoB,aAAaP,GAClBhoB,KAAKwoB,uBACLxoB,KAAKyoB,iCAGTzoB,KAAK+lB,UAAUvhB,SAAS6C,EAAI2gB,EAAUzC,aAAale,EACnDrH,KAAK+lB,UAAUvhB,SAAS+C,EAAIygB,EAAUzC,aAAahe,EACnDvH,KAAK+lB,UAAUvhB,SAAS8C,EAAI0gB,EAAUzC,aAAaje,CACvD,CAKQ,aAAA2gB,GACJ,IAAIlE,EAAa/jB,KAAKgnB,SAASjD,WAC3BkB,EAAajlB,KAAKgnB,SAAS/B,WAC3BM,EAAevlB,KAAKgnB,SAASzB,aACjC,IAAKvlB,KAAKiN,OAAOyb,QAAwC,IAA9B1oB,KAAKiN,OAAOyb,OAAOliB,OAE1C,MAAO,CAAEud,aAAYkB,aAAYM,gBAGrC,MAAMoD,EAAe3oB,KAAKiN,OAAO2b,iBAAiB/Z,GACvCA,IAAS7O,KAAKsmB,SAAWzX,IAAS7O,KAAK+lB,WAAalX,IAAS7O,KAAKimB,UAEvE4C,EAAgBF,EAAaG,IAAIC,SAASJ,EAAa7H,KAE7D,GAAI9gB,KAAKgnB,SAAS1B,SAAU,CACpBtlB,KAAKiN,OAAO+b,wBAAwB,KAAmBhpB,KAAKiN,OAAO+b,aAAaC,mBAChFlF,EAAyD,EAA5C/jB,KAAKiN,OAAO+b,aAAaC,iBACtChE,EAAalB,GAGjB,MAAMmF,EAAsBL,EAAcriB,SACtC0iB,EAAsBnF,IACtBA,EAAmC,EAAtBmF,EACbjE,EAAalB,GAIjBA,GAAc,IACdkB,GAAc,IACdM,EAAeoD,EAAa7H,IAAIqI,IAAIN,EAAcvgB,MAAM,KACxDid,EAAaje,EAAIqhB,EAAa7H,IAAIxZ,EAAItH,KAAKgnB,SAASjC,W,CAGxD,MAAO,CAAEhB,aAAYkB,aAAYM,eACrC,CAMQ,YAAA2C,CAAaF,GACZhoB,KAAKsmB,UAAWtmB,KAAKsmB,QAAQ8C,eAC9BppB,KAAKsmB,SAAU,QAAY,kBAAmB,CAAErQ,KAAM+R,EAAUjE,YAAc/jB,KAAKiN,QACnFjN,KAAKsmB,QAAQ/gB,SAAS8B,EAAIgiB,KAAKC,GAAK,EACpCtpB,KAAKsmB,QAAQ7jB,OAASzC,KAAK+lB,UAC3B/lB,KAAKsmB,QAAQiD,oBAAoBJ,KAAI,KACjCnpB,KAAKsmB,QAAU,IAAI,KAI3BtmB,KAAKsmB,QAAQkD,eAAiBxpB,KAAKgnB,SAAS1C,kBAChD,CAKQ,oBAAA6D,GACCnoB,KAAK6mB,kBACN7mB,KAAK6mB,gBAAkB,IAAI,IAAmB,0BAA2B7mB,KAAKiN,SAElFjN,KAAK6mB,gBAAgB4C,MAAQzpB,KAAKgnB,SAAS3C,cAC3CrkB,KAAK6mB,gBAAgB6C,UAAY,EACjC1pB,KAAK6mB,gBAAgB8C,YAAc3pB,KAAKgnB,SAASzC,kBACjDvkB,KAAK6mB,gBAAgBU,aAAevnB,KAAKgnB,SAAS9C,YAClDlkB,KAAK6mB,gBAAgB+C,aAAc,EACnC5pB,KAAK6mB,gBAAgBgD,aAAc,EAE/B7pB,KAAKsmB,UACLtmB,KAAKsmB,QAAQwD,SAAW9pB,KAAK6mB,gBAErC,CAKQ,0BAAAuB,GACCpoB,KAAK6mB,kBAIN7mB,KAAKumB,iBAILvmB,KAAKgnB,SAAShD,yBAAyB,IACvChkB,KAAK6mB,gBAAgBkD,eAAiB/pB,KAAKgnB,SAAShD,eAIxDhkB,KAAKumB,eAAiB,IAAI,IAAQvmB,KAAKgnB,SAAShD,cAAehkB,KAAKiN,YAAQb,OAAWA,OAAWA,OAAWA,EAAWpM,KAAK8mB,eAC7H9mB,KAAKumB,eAAeyD,YAAa,EACjChqB,KAAKumB,eAAe0D,UAAW,EAC/BjqB,KAAK6mB,gBAAgBkD,eAAiB/pB,KAAKumB,iBAC/C,CAMQ,yBAAA8B,CAA0BL,GAC9B,MAAMkC,EAAW,IAAQC,kBACzB,IAAKnqB,KAAKymB,gBACNzmB,KAAKymB,cAAgB,IAAI,IACrB,+BACA,CAAE2D,MAAOpqB,KAAKgnB,SAASvC,uBACvBzkB,KAAKiN,QACL,EACAjN,KAAKgnB,SAASlC,wBACd,IAAQuF,uBACR,GAEJrqB,KAAKymB,cAAc6D,YAAc,IAAI,IAAM,GAAI,EAAG,EAAGtC,EAAUzC,aAAaje,GAC5EtH,KAAKymB,cAAc8D,0BAA4B,EAC/CvqB,KAAKymB,cAAc+D,MAAQN,EAC3BlqB,KAAKymB,cAAcgE,MAAQP,EAEvBlqB,KAAKymB,cAAcE,YACnB,IAAK,IAAIpb,EAAI,EAAGA,EAAIvL,KAAKiN,OAAOyb,OAAOliB,OAAQ+E,IAAK,CAChD,MAAMsD,EAAO7O,KAAKiN,OAAOyb,OAAOnd,GAC5BsD,IAAS7O,KAAKsmB,SAAWzX,IAAS7O,KAAKimB,SAAWpX,IAAS7O,KAAK+lB,WAChE/lB,KAAKymB,cAAcE,WAAWvkB,KAAKyM,E,CAMnD,MAAM6b,EAAc1qB,KAAKgnB,SAAS9C,YAAYyG,aAAa3qB,KAAKiN,OAAOqB,YAAY8V,yBACnFpkB,KAAKymB,cAAce,WAAa,IAAI,KAAOkD,EAAYjD,EAAGiD,EAAYhD,EAAGgD,EAAY/b,EAAG,GACxF3O,KAAKymB,cAAcmE,mBAAqB5qB,KAAKgnB,SAAStC,sBAC1D,CAKQ,4BAAA4D,GACAtoB,KAAK6mB,kBACL7mB,KAAK6mB,gBAAgBgE,kBAAoB7qB,KAAKymB,cAC9CzmB,KAAK6mB,gBAAgBiE,mBAAoB,EACzC9qB,KAAK6mB,gBAAgBkE,iBAAmB/qB,KAAKgnB,SAASrC,mBACtD3kB,KAAK6mB,gBAAgBmE,gCAAkChrB,KAAKgnB,SAASpC,0BACrE5kB,KAAK6mB,gBAAgBoE,0BAA4BjrB,KAAKgnB,SAASnC,4BAEvE,CAMQ,YAAA0D,CAAaP,GACZhoB,KAAKimB,UAAWjmB,KAAKimB,QAAQmD,eAC9BppB,KAAKimB,SAAU,QAAU,mBAAoB,CAAEhQ,KAAM+R,EAAU/C,WAAYiG,gBAAiB,KAAKC,UAAYnrB,KAAKiN,QAClHjN,KAAKimB,QAAQsD,oBAAoBJ,KAAI,KACjCnpB,KAAKimB,QAAU,IAAI,KAG3BjmB,KAAKimB,QAAQxjB,OAASzC,KAAK+lB,SAC/B,CAKQ,oBAAAyC,GACCxoB,KAAKimB,UAILjmB,KAAKomB,kBACNpmB,KAAKomB,gBAAkB,IAAI,IAAmB,2BAA4BpmB,KAAKiN,SAEnFjN,KAAKomB,gBAAgBwD,aAAc,EACnC5pB,KAAKomB,gBAAgBmB,aAAevnB,KAAKgnB,SAAS5B,YAClDplB,KAAKomB,gBAAgByD,aAAc,EAEnC7pB,KAAKimB,QAAQ6D,SAAW9pB,KAAKomB,gBACjC,CAKQ,6BAAAqC,GACCzoB,KAAKomB,kBAINpmB,KAAKkmB,iBAILlmB,KAAKgnB,SAAS9B,yBAAyB,IACvCllB,KAAKomB,gBAAgByE,kBAAoB7qB,KAAKgnB,SAAS9B,eAI3DllB,KAAKkmB,eAAiB,IAAI,IAAYlmB,KAAKgnB,SAAS9B,cAAellB,KAAKiN,YAAQb,OAAWA,OAAWA,OAAWA,EAAWpM,KAAK8mB,eACjI9mB,KAAKkmB,eAAekF,gBAAkB,IAAQC,YAC9CrrB,KAAKkmB,eAAe8D,YAAa,EACjChqB,KAAKomB,gBAAgByE,kBAAoB7qB,KAAKkmB,iBAClD,CASO,OAAArS,GACC7T,KAAK6mB,iBACL7mB,KAAK6mB,gBAAgBhT,SAAQ,GAAM,GAEnC7T,KAAKomB,iBACLpmB,KAAKomB,gBAAgBvS,SAAQ,GAAM,GAEvC7T,KAAK+lB,UAAUlS,SAAQ,EAC3B,EAlgBe,EAAAoQ,qBAAuB,iEAKvB,EAAAkB,qBAAuB,iEAKvB,EAAAO,0BAA4B,mE,wGCpM/C,EAAA5lB,EAAKwrB,mBAAmB,gBAAgB,CAAC7qB,EAAM8M,IACpC,IAAM,IAAIge,EAAW9qB,EAAM,IAAQyF,OAAQqH,KAS/C,MAAMge,UAAmB,IAS5B,eAAWC,GACP,OAAOxrB,KAAKyrB,YAChB,CAOA,eAAWD,CAAYrrB,GACnBH,KAAKyrB,aAAetrB,EACpBH,KAAK0rB,8BACT,CAMA,aAAWC,GACP,OAAO3rB,KAAK4rB,UAChB,CAKA,aAAWD,CAAUxrB,GACjB,MAAM0rB,EAAmB7rB,KAAK8rB,WAE9B,GADA9rB,KAAK4rB,WAAazrB,EACdH,KAAK8rB,aAAeD,GAAoB7rB,KAAK+rB,kBAAmB,CAChE,MAAMC,EAAWhsB,KAAK+rB,kBAAkBE,SACxC,IAAK,IAAIC,EAAMF,EAASG,QAAqB,IAAbD,EAAIE,KAAeF,EAAMF,EAASG,OACtCD,EAAI/rB,MACZksB,mB,CAG5B,CAeA,WAAA7rB,CAAYC,EAAc+D,EAAmB+I,GACzCvM,MAAMP,EAAM8M,GA3DR,KAAAke,aAAepC,KAAKC,GAAK,EA4D7BtpB,KAAKwE,SAAWA,CACpB,CAMO,YAAAjC,GACH,MAAO,YACX,CAMO,SAAA+pB,GACH,OAAO,IAAMC,sBACjB,CAMO,QAAAT,GACH,OAAQ9rB,KAAK2rB,SACjB,CAOO,kBAAAa,CAAmBzJ,GACtB,GAAI/iB,KAAK2rB,UACL,OAAO3qB,MAAMwrB,mBAAmBzJ,GAEhC,OAAQA,GACJ,KAAK,EACD,OAAO,IAAI,IAAQ,EAAK,EAAK,GACjC,KAAK,EACD,OAAO,IAAI,KAAS,EAAK,EAAK,GAClC,KAAK,EACD,OAAO,IAAI,IAAQ,GAAM,EAAK,GAClC,KAAK,EACD,OAAO,IAAI,IAAQ,EAAK,EAAK,GACjC,KAAK,EACD,OAAO,IAAI,IAAQ,EAAK,EAAK,GACjC,KAAK,EACD,OAAO,IAAI,IAAQ,EAAK,GAAM,GAI1C,OAAO,IAAQ7c,MACnB,CAaU,iCAAAumB,CAAkChpB,EAAgBipB,EAAoB/F,GAC5E,MAAMqC,EAAehpB,KAAKiB,WAAW+nB,aAErC,IAAKA,EACD,OAGJ,MAAM2D,OAA2BvgB,IAApBpM,KAAK4sB,WAA2B5sB,KAAK4sB,WAAa5D,EAAa2D,KACtEE,OAA2BzgB,IAApBpM,KAAK8sB,WAA2B9sB,KAAK8sB,WAAa9D,EAAa6D,KAEtEE,EAAwB/sB,KAAKiB,WAAWqN,YAAYye,sBAE1D,KAAOC,sBACHhtB,KAAKwrB,YACL,EACAuB,EAAwBF,EAAOF,EAC/BI,EAAwBJ,EAAOE,EAC/BppB,GACA,EACAzD,KAAKiN,OAAOqB,YAAY2e,qBACxB7gB,EACA2gB,EAER,CAEU,mBAAAG,GACNltB,KAAKmtB,eAAeC,WAAW,aAAc,GAC7CptB,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,iBAAkB,GACjDptB,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,cAAe,GAC9CptB,KAAKmtB,eAAeC,WAAW,cAAe,GAC9CptB,KAAKmtB,eAAeE,QACxB,CAQO,gBAAAC,CAAiBC,EAAgBC,GAQpC,OAPIxtB,KAAKytB,gCACLztB,KAAKmtB,eAAeO,aAAa,aAAc1tB,KAAK2tB,oBAAoBtmB,EAAGrH,KAAK2tB,oBAAoBrmB,EAAGtH,KAAK2tB,oBAAoBpmB,EAAG,EAAKimB,GAExIxtB,KAAKmtB,eAAeO,aAAa,aAAc1tB,KAAKwE,SAAS6C,EAAGrH,KAAKwE,SAAS8C,EAAGtH,KAAKwE,SAAS+C,EAAG,EAAGimB,GAGzGxtB,KAAKmtB,eAAeO,aAAa,gBAAiB1tB,KAAKoR,MAAOpR,KAAK4tB,qBAAsB,EAAG,EAAGJ,GACxFxtB,IACX,CAEO,4BAAA6tB,CAA6BN,EAAgBO,GAOhD,OANI9tB,KAAKytB,gCACLF,EAAOQ,UAAUD,EAAsB9tB,KAAK2tB,oBAAoBtmB,EAAGrH,KAAK2tB,oBAAoBrmB,EAAGtH,KAAK2tB,oBAAoBpmB,GAExHgmB,EAAOQ,UAAUD,EAAsB9tB,KAAKwE,SAAS6C,EAAGrH,KAAKwE,SAAS8C,EAAGtH,KAAKwE,SAAS+C,GAGpFvH,IACX,CAOO,2BAAAguB,CAA4BC,EAAcT,GAC7CS,EAAQ,aAAeT,IAAc,CACzC,GA3LA,UADC,W,kJCbL,EAAA1tB,EAAKwrB,mBAAmB,gBAAgB,CAAC7qB,EAAM8M,IACpC,IAAM,IAAI2gB,EAAUztB,EAAM,IAAQyF,OAAQ,IAAQA,OAAQ,EAAG,EAAGqH,KAUpE,MAAM2gB,UAAkB,IAyB3B,SAAWjkB,GACP,OAAOjK,KAAKmuB,MAChB,CAIA,SAAWlkB,CAAM9J,GACbH,KAAKmuB,OAAShuB,EACdH,KAAKouB,cAAgB/E,KAAKgF,IAAY,GAARluB,GAC9BH,KAAKsuB,wCAAyC,EAC9CtuB,KAAK0rB,+BACL1rB,KAAKuuB,qBACT,CAQA,cAAWC,GACP,OAAOxuB,KAAKyuB,WAChB,CAMA,cAAWD,CAAWruB,GAClBH,KAAKyuB,YAActuB,EACnBH,KAAKuuB,qBACT,CAOA,oBAAWG,GACP,OAAO1uB,KAAK2uB,iBAChB,CAIA,oBAAWD,CAAiBvuB,GACxBH,KAAK2uB,kBAAoBxuB,EACzBH,KAAK0rB,8BACT,CAYA,2BAAWkD,GACP,OAAO5uB,KAAK6uB,wBAChB,CAOA,8BAAWC,GACP,OAAO9uB,KAAK+uB,2BAChB,CAIA,8BAAWD,CAA2B3uB,GAClCH,KAAK+uB,4BAA8B5uB,EACnCH,KAAKsuB,wCAAyC,CAClD,CAOA,6BAAWU,GACP,OAAOhvB,KAAKivB,0BAChB,CAIA,6BAAWD,CAA0B7uB,GACjCH,KAAKivB,2BAA6B9uB,EAClCH,KAAKsuB,wCAAyC,CAClD,CAOA,gCAAWY,GACP,OAAOlvB,KAAKmvB,6BAChB,CAIA,gCAAWD,CAA6B/uB,GACpCH,KAAKmvB,8BAAgChvB,EACrCH,KAAKsuB,wCAAyC,CAClD,CAQA,qBAAWc,GACP,OAAOpvB,KAAKqvB,kBAChB,CAIA,qBAAWD,CAAkBjvB,GACrBH,KAAKqvB,qBAAuBlvB,IAGhCH,KAAKqvB,mBAAqBlvB,EAC1BH,KAAKsvB,yBAA0B,EAC3BtvB,KAAKqvB,qBAAuBrvB,KAAKqvB,mBAAmBvQ,YAChDoP,EAAUqB,qBAAqBvvB,KAAKqvB,oBACpCrvB,KAAKqvB,mBAAmBG,YAAYC,qBAAoB,KACpDzvB,KAAK0vB,yBAAyB,IAE3BxB,EAAUyB,WAAW3vB,KAAKqvB,qBACjCrvB,KAAKqvB,mBAAmBO,iBAAiBC,SAAQ,KAC7C7vB,KAAK0vB,yBAAyB,KAI9C,CAEQ,2BAAOH,CAAqB1W,GAChC,YAAgEzM,IAAxDyM,EAA8BiX,qBAC1C,CAEQ,iBAAOH,CAAW9W,GACtB,YAAiDzM,IAAzCyM,EAAoB+W,gBAChC,CAYA,0CAAWG,GACP,OAAO/vB,KAAKgwB,uCAChB,CAEA,0CAAWD,CAAuCE,GAC9CjwB,KAAKgwB,wCAA0CC,EAC/CjwB,KAAKsuB,wCAAyC,EAC9CtuB,KAAKsvB,yBAA0B,CACnC,CAeA,WAAA9uB,CAAYC,EAAc+D,EAAmBmnB,EAAoB1hB,EAAeimB,EAAkB3iB,GAC9FvM,MAAMP,EAAM8M,GAlMR,KAAAkhB,YAAsB,EAiEtB,KAAAI,yBAA2B,KAAO3oB,OAQhC,KAAA6oB,4BAAsC,KAgBtC,KAAAE,2BAAqC,IAgBrC,KAAAE,8BAAyC,IAAQgB,KAuDnD,KAAAC,kCAAmC,EACnC,KAAA9B,wCAAyC,EACzC,KAAAgB,yBAA0B,EAC1B,KAAAe,mCAAqC,IAAQnqB,OAC7C,KAAAoqB,kCAAoC,KAAOpqB,OAE3C,KAAA8pB,wCAA0C,KAAO9pB,OAcjD,KAAAqqB,gCAAkC,KAAOC,WAAW,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,GAAK,GAAK,GAAK,GAgBnIxwB,KAAKwE,SAAWA,EAChBxE,KAAK2rB,UAAYA,EACjB3rB,KAAKiK,MAAQA,EACbjK,KAAKkwB,SAAWA,CACpB,CAMO,YAAA3tB,GACH,MAAO,WACX,CAMO,SAAA+pB,GACH,OAAO,IAAMmE,qBACjB,CAMU,aAAAC,CAAcvwB,GACpBa,MAAM0vB,cAAcvwB,GACpBH,KAAKowB,kCAAmC,CAC5C,CAMU,YAAAO,CAAaxwB,GACnBa,MAAM2vB,aAAaxwB,GACnBH,KAAKowB,kCAAmC,CAC5C,CAUU,iCAAA3D,CAAkChpB,EAAgBipB,EAAoB/F,GAC5E,MAAMqC,EAAehpB,KAAKiB,WAAW+nB,aAErC,IAAKA,EACD,OAGJhpB,KAAK2uB,kBAAoB3uB,KAAK2uB,mBAAqB,EACnD,MAAM1kB,EAAQjK,KAAK2uB,kBAAoB3uB,KAAKmuB,OAEtCxB,OAA2BvgB,IAApBpM,KAAK4sB,WAA2B5sB,KAAK4sB,WAAa5D,EAAa2D,KACtEE,OAA2BzgB,IAApBpM,KAAK8sB,WAA2B9sB,KAAK8sB,WAAa9D,EAAa6D,KAEtEE,EAAwB/sB,KAAKiB,WAAWqN,YAAYye,sBAE1D,KAAOC,sBACH/iB,EACA,EACA8iB,EAAwBF,EAAOF,EAC/BI,EAAwBJ,EAAOE,EAC/BppB,GACA,EACAzD,KAAKiN,OAAOqB,YAAY2e,qBACxB7gB,EACA2gB,EAER,CAEU,wCAAA6D,GACN5wB,KAAKowB,kCAAmC,EACxCpwB,KAAKsvB,yBAA0B,EAE/BtvB,KAAKkL,sBAAsB2lB,SAAS7wB,KAAK2rB,UAAW3rB,KAAKqwB,oCACzD,KAAOS,cAAc9wB,KAAKkL,sBAAuBlL,KAAKqwB,mCAAoCrwB,KAAKmvB,8BAA+BnvB,KAAKswB,kCACvI,CAEU,8CAAAS,GACN/wB,KAAKsuB,wCAAyC,EAC9CtuB,KAAKsvB,yBAA0B,EAE/B,MAAM0B,EAAWhxB,KAAKgvB,0BAChBiC,EAAYjxB,KAAK8uB,2BAEjBoC,EAAIF,GAAYA,EAAWC,GAC3BE,GAAKD,EAAID,EACTG,EAAI,EAAM/H,KAAKgI,IAAIrxB,KAAKmuB,OAAS,GAGvC,KAAOmD,gBAAgBF,EAFb,EAEoB,EAAK,EAAK,EAAK,EAAKA,EAAG,EAAK,EAAK,EAAK,EAAKF,EAAG,EAAK,EAAK,EAAKC,EAAG,EAAKnxB,KAAKgwB,wCAC5G,CAKU,+BAAAuB,GAIN,GAHAvxB,KAAKsvB,yBAA0B,EAE/BtvB,KAAKswB,kCAAkChqB,cAActG,KAAKgwB,wCAAyChwB,KAAK6uB,0BACpG7uB,KAAKqvB,8BAA8B,IAAS,CAC5C,MAAMmC,EAAIxxB,KAAKqvB,mBAAmBoC,OAAS,EACrCC,EAAI1xB,KAAKqvB,mBAAmBsC,OAAS,EAC3C,KAAOL,gBAAgBE,EAAG,EAAK,EAAK,EAAK,EAAKE,EAAG,EAAK,EAAK,EAAK,EAAK,GAAK,EAAK,GAAK,GAAK,GAAK,EAAK1xB,KAAKuwB,gC,CAE5GvwB,KAAK6uB,yBAAyBvoB,cAActG,KAAKuwB,gCAAiCvwB,KAAK6uB,yBAC3F,CAEU,mBAAA3B,GACNltB,KAAKmtB,eAAeC,WAAW,aAAc,GAC7CptB,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,iBAAkB,GACjDptB,KAAKmtB,eAAeC,WAAW,kBAAmB,GAClDptB,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,cAAe,GAC9CptB,KAAKmtB,eAAeC,WAAW,cAAe,GAC9CptB,KAAKmtB,eAAeE,QACxB,CAEQ,mBAAAkB,GACJvuB,KAAK4xB,iBAAmB,EAAMvI,KAAKP,IAAI,KAAOO,KAAKgF,IAAuB,GAAnBruB,KAAKyuB,aAAqBzuB,KAAKouB,eACtFpuB,KAAK6xB,mBAAqB7xB,KAAKouB,cAAgBpuB,KAAK4xB,gBACxD,CAQO,wBAAAE,CAAyBvE,EAAgBC,GAc5C,OAbIxtB,KAAKovB,mBAAqBpvB,KAAKovB,kBAAkBtQ,YAC7C9e,KAAKowB,kCACLpwB,KAAK4wB,2CAEL5wB,KAAKsuB,wCACLtuB,KAAK+wB,iDAEL/wB,KAAKsvB,yBACLtvB,KAAKuxB,kCAEThE,EAAOwE,UAAU,0BAA4BvE,EAAYxtB,KAAK6uB,0BAC9DtB,EAAOyE,WAAW,yBAA2BxE,EAAYxtB,KAAKovB,oBAE3DpvB,IACX,CAQO,gBAAAstB,CAAiBC,EAAgBC,GACpC,IAAIyE,EAeJ,OAbIjyB,KAAKytB,iCACLztB,KAAKmtB,eAAeO,aAAa,aAAc1tB,KAAK2tB,oBAAoBtmB,EAAGrH,KAAK2tB,oBAAoBrmB,EAAGtH,KAAK2tB,oBAAoBpmB,EAAGvH,KAAKkwB,SAAU1C,GAElJyE,EAAqB,IAAQC,UAAUlyB,KAAKmyB,wBAE5CnyB,KAAKmtB,eAAeO,aAAa,aAAc1tB,KAAKwE,SAAS6C,EAAGrH,KAAKwE,SAAS8C,EAAGtH,KAAKwE,SAAS+C,EAAGvH,KAAKkwB,SAAU1C,GAEjHyE,EAAqB,IAAQC,UAAUlyB,KAAK2rB,YAGhD3rB,KAAKmtB,eAAeO,aAAa,kBAAmBuE,EAAmB5qB,EAAG4qB,EAAmB3qB,EAAG2qB,EAAmB1qB,EAAGvH,KAAKouB,cAAeZ,GAE1IxtB,KAAKmtB,eAAeO,aAAa,gBAAiB1tB,KAAKoR,MAAOpR,KAAK4tB,qBAAsB5tB,KAAK4xB,iBAAkB5xB,KAAK6xB,kBAAmBrE,GACjIxtB,IACX,CAEO,4BAAA6tB,CAA6BN,EAAgBO,GAChD,IAAImE,EAcJ,OAXIA,EADAjyB,KAAKytB,gCACgB,IAAQyE,UAAUlyB,KAAKmyB,sBAEvB,IAAQD,UAAUlyB,KAAK2rB,WAG5C3rB,KAAKiB,WAAWmxB,qBAChB7E,EAAOQ,UAAUD,GAAuBmE,EAAmB5qB,GAAI4qB,EAAmB3qB,GAAI2qB,EAAmB1qB,GAEzGgmB,EAAOQ,UAAUD,EAAsBmE,EAAmB5qB,EAAG4qB,EAAmB3qB,EAAG2qB,EAAmB1qB,GAGnGvH,IACX,CAKO,OAAA6T,GACH7S,MAAM6S,UACF7T,KAAKqvB,oBACLrvB,KAAKqvB,mBAAmBxb,SAEhC,CAOO,YAAAwe,CAAarJ,GAChB,MAAMsJ,EAAStyB,KAAKiN,OAAOqB,YACrBqe,OAA2BvgB,IAApBpM,KAAK4sB,WAA2B5sB,KAAK4sB,WAAa5D,EAAa2D,KAE5E,OAAO2F,EAAOvF,uBAAyBuF,EAAOrF,gBAAkBN,EAAO3sB,KAAKiN,OAAOqB,YAAY2e,gBAAkB,EAAIN,CACzH,CAOO,YAAA4F,CAAavJ,GAChB,MAAMsJ,EAAStyB,KAAKiN,OAAOqB,YACrBue,OAA2BzgB,IAApBpM,KAAK8sB,WAA2B9sB,KAAK8sB,WAAa9D,EAAa6D,KAE5E,OAAOyF,EAAOvF,uBAAyBuF,EAAOrF,gBAAkB,EAAIJ,CACxE,CAOO,2BAAAmB,CAA4BC,EAAcT,GAC7CS,EAAQ,YAAcT,IAAc,EACpCS,EAAQ,wBAA0BT,MAAcxtB,KAAKovB,oBAAqBpvB,KAAKovB,kBAAkBtQ,UACrG,GAxaA,UADC,W,2BAqBD,UADC,W,gCAmBD,UADC,W,sCAgBM,UADN,W,gCAgBD,UADC,W,gDAiBD,UADC,W,+CAiBD,UADC,W,kDAaO,UADP,QAAmB,0B,mPCvIxB,IAAY0T,qBAAyB,8BAtBtB,upB,SCaf,IAAYA,qBAAyB,yBAZtB,kkB,qHCoNf,IAAYC,aAAiB,sBAtMd,skNCHf,IAAYD,qBAAyB,4BAZtB,iX,mHCiHf,IAAYC,aAAiB,uBAjGd,gtF,0BC0Bf,MAAMC,UAAkC,IA4IpC,WAAAlyB,GACIQ,QAzIG,KAAA2xB,SAAU,EAKV,KAAAC,gBAAkB,EAKlB,KAAAC,cAAe,EAKf,KAAAC,iBAAkB,EAKlB,KAAAC,gBAAiB,EAKjB,KAAAC,gBAAiB,EAKjB,KAAAC,mBAAoB,EAKpB,KAAAC,mBAAoB,EAKpB,KAAAC,mBAAoB,EAKpB,KAAAC,kBAAmB,EAKnB,KAAAC,aAAc,EAMd,KAAAC,6BAA8B,EAK9B,KAAAC,oBAAqB,EAKrB,KAAAC,OAAQ,EAMR,KAAAC,eAAgB,EAEhB,KAAAC,iBAAkB,EAClB,KAAAC,UAAW,EACX,KAAAC,2BAA4B,EAC5B,KAAAC,yBAA0B,EAC1B,KAAAC,aAAc,EACd,KAAAC,kBAAmB,EACnB,KAAAC,UAAW,EACX,KAAAC,aAAc,EACd,KAAAC,cAAe,EACf,KAAAC,gBAAiB,EACjB,KAAAC,qBAAsB,EACtB,KAAAC,iBAAkB,EAClB,KAAAC,QAAS,EACT,KAAAC,4BAA6B,EAC7B,KAAAC,qBAAsB,EACtB,KAAAC,UAAW,EACX,KAAAC,WAAY,EAGZ,KAAAC,YAAa,EACb,KAAAC,kBAAmB,EACnB,KAAAC,yBAA0B,EAC1B,KAAAC,sBAAuB,EACvB,KAAAC,qBAAsB,EACtB,KAAAC,0BAA2B,EAC3B,KAAAC,sBAAuB,EACvB,KAAAC,wBAAyB,EACzB,KAAAC,+BAAgC,EAChC,KAAAC,qCAAsC,EACtC,KAAAC,6CAA8C,EAC9C,KAAAC,gBAAiB,EACjB,KAAAC,yBAA0B,EAC1B,KAAAC,sBAAuB,EACvB,KAAAC,iBAAkB,EAClB,KAAAC,gBAAiB,EACjB,KAAAC,gCAAiC,EAGjC,KAAAC,SAAU,EACV,KAAAC,SAAU,EACV,KAAAC,KAAM,EACN,KAAAC,KAAM,EACN,KAAAC,WAAY,EACZ,KAAAC,YAAa,EACb,KAAAC,YAAa,EACb,KAAAC,YAAa,EACb,KAAAC,YAAa,EACb,KAAAC,YAAa,EACb,KAAAC,WAAY,EACZ,KAAAC,KAAM,EACN,KAAAC,QAAS,EACT,KAAAC,qBAAuB,EACvB,KAAAC,aAAe,EACf,KAAAC,WAAY,EACZ,KAAAC,aAAc,EACd,KAAAC,kBAAmB,EACnB,KAAAC,mBAAoB,EACpB,KAAAC,WAAY,EAOf/2B,KAAKg3B,SACT,EAMG,MAAMC,UAA2B,IA+BpC,oBAAWC,GACP,OAAOl3B,KAAKm3B,iBAChB,CACA,oBAAWD,CAAiB/2B,GACxBH,KAAKm3B,kBAAoBh3B,EACzBH,KAAKo3B,0CACLp3B,KAAKq3B,gCACT,CAQA,2BAAWC,GACP,OAAOt3B,KAAKu3B,wBAChB,CACA,2BAAWD,CAAwBn3B,GAC/BH,KAAKu3B,yBAA2Bp3B,EAChCH,KAAKw3B,wBACLx3B,KAAKq3B,gCACT,CASA,8BAAWI,GACP,OAAOz3B,KAAK03B,2BAChB,CACA,8BAAWD,CAA2Bt3B,GAClCH,KAAK03B,4BAA8Bv3B,EACnCH,KAAKw3B,wBACLx3B,KAAKq3B,gCACT,CAgHA,mCAAWrM,CAAgC7qB,GACvC,IAAIw3B,EAAmBx3B,EAEnBw3B,EAAmB,IACnBA,GAAsC,EACtC33B,KAAK43B,uBAAyBX,EAAmBY,qBAAuBF,EACxE33B,KAAK83B,wBAA0Bb,EAAmBc,sBAAwBJ,IAE1EA,EAAsC,EAAnBA,EAAyB,EAC5C33B,KAAK43B,uBAAyBX,EAAmBY,sBAAwB,EAAMZ,EAAmBY,sBAAwBF,EAC1H33B,KAAK83B,wBAA0Bb,EAAmBc,uBAAyB,EAAMd,EAAmBc,uBAAyBJ,EAErI,CAuBA,iBAAWK,GACP,OAAOh4B,KAAKi4B,cAChB,CACA,iBAAWD,CAAc73B,GACjB2K,MAAM3K,KACNA,EAAQ,GAEZH,KAAKi4B,eAAiB5O,KAAKP,IAAI,EAAKO,KAAKvI,IAAI,EAAK3gB,GACtD,CAuCU,mCAAA+3B,CAAoCC,GACtCA,IAAkBn4B,KAAKo4B,gCAKvBp4B,KAAKo4B,+BAAiCp4B,KAAKq4B,0BAC3Cr4B,KAAKo4B,8BAA8BE,mBAAmBC,OAAOv4B,KAAKq4B,0BAOlEr4B,KAAKo4B,8BAHJD,GACoCn4B,KAAKiB,WAAW0mB,6BAMrD3nB,KAAKo4B,gCACLp4B,KAAKq4B,yBAA2Br4B,KAAKo4B,8BAA8BE,mBAAmBnP,KAAI,KACtFnpB,KAAKo3B,0CACLp3B,KAAKw4B,yCAAyC,KAG1D,CAKA,gCAAW7Q,GACP,OAAO3nB,KAAKo4B,6BAChB,CAOA,gCAAWzQ,CAA6BxnB,GACpCH,KAAKk4B,oCAAoC/3B,GAGzCH,KAAKy4B,kCACT,CAKA,4BAAWC,GACP,OAAsC14B,KAAK2nB,6BAA8BgR,kBAC7E,CAIA,4BAAWD,CAAyBv4B,GACDH,KAAK2nB,6BAA8BgR,mBAAqBx4B,CAC3F,CAKA,6BAAWy4B,GACP,OAAsC54B,KAAK2nB,6BAA8BkR,mBAC7E,CAIA,6BAAWD,CAA0Bz4B,GACFH,KAAK2nB,6BAA8BkR,oBAAsB14B,CAC5F,CAKA,4BAAW24B,GACP,OAAO94B,KAAKo4B,8BAA8BvS,kBAC9C,CAIA,4BAAWiT,CAAyB34B,GAChCH,KAAKo4B,8BAA8BvS,mBAAqB1lB,CAC5D,CAOA,kBAAWwlB,GACP,OAAO3lB,KAAKo4B,8BAA8BvQ,QAC9C,CAMA,kBAAWlC,CAAexlB,GACtBH,KAAKo4B,8BAA8BvQ,SAAW1nB,CAClD,CAKA,kBAAWylB,GACP,OAAO5lB,KAAKo4B,8BAA8BxQ,QAC9C,CAKA,kBAAWhC,CAAezlB,GACtBH,KAAKo4B,8BAA8BxQ,SAAWznB,CAClD,CAKA,6BAAW44B,GACP,OAAO/4B,KAAKo4B,8BAA8BY,mBAC9C,CAIA,6BAAWD,CAA0B54B,GACFH,KAAK2nB,6BAA8BqR,oBAAsB74B,CAC5F,CAQA,qBAAW84B,GACP,OAAsCj5B,KAAK2nB,6BAA8BuR,WAC7E,CAOA,qBAAWD,CAAkB94B,GACMH,KAAK2nB,6BAA8BuR,YAAc/4B,CACpF,CAoBA,WAAAK,CAAYC,EAAc8M,GACtBvM,MAAMP,EAAM8M,GA5ZT,KAAAga,aAAe,KAAO4R,QAwBnB,KAAA5B,yBAAkC,EAelC,KAAAG,4BAAqC,EAsBxC,KAAA7M,kBAA2C,KAW3C,KAAAuO,eAAwB,EASxB,KAAArP,eAAwC,KAErC,KAAAsP,cAA0C,KAM7C,KAAAC,aAAyC,KASzC,KAAA3P,YAAqB,EASrB,KAAA4P,YAAuB,IAAQrzB,OAS/B,KAAAszB,gBAA0B,EAS1B,KAAA1O,mBAA6B,EAS7B,KAAAG,0BAAoC,EAQpC,KAAAF,iBAA2B,EAQ3B,KAAA6M,uBAAiC,IAQjC,KAAAE,wBAAkC,GA0BlC,KAAAlO,aAAuB,EAQvB,KAAAC,aAAuB,EAgBtB,KAAAoO,eAAwB,EAKzB,KAAAwB,uBAAiC,EAGhC,KAAAC,uBAA8B,EAK/B,KAAAC,sBAA6B,EAG5B,KAAAC,aAAuB,EAKxB,KAAAC,YAAsB,EAWrB,KAAAxB,yBAA6E,KA6J9E,KAAAyB,aAAuB,EAGtB,KAAAC,eAAiB,IAAI,IAAgC,IACrD,KAAAC,oBAAsB,KAAQ9zB,OAC9B,KAAA+zB,OAAS,KAAOd,QAChB,KAAAe,oBAAsB,KAAOC,QAC7B,KAAAC,uBAAyB,KAAOD,QAWpCn6B,KAAKk4B,oCAAoC,MAEzCl4B,KAAKq6B,wBAA0B,KAC3Br6B,KAAK+5B,eAAeO,QAEhBt6B,KAAKu6B,iBAAmBv6B,KAAKu6B,gBAAgBC,gBAC7Cx6B,KAAK+5B,eAAe33B,KAAKpC,KAAKu6B,iBAG9Bv6B,KAAKy6B,oBAAsBz6B,KAAKy6B,mBAAmBD,gBACnDx6B,KAAK+5B,eAAe33B,KAAKpC,KAAKy6B,oBAG3Bz6B,KAAK+5B,eAEpB,CAKA,2BAAWW,GACP,SAAI16B,KAAKu6B,kBAAmBv6B,KAAKu6B,gBAAgBC,oBAI7Cx6B,KAAKy6B,qBAAsBz6B,KAAKy6B,mBAAmBD,eAK3D,CAMO,gBAAAG,GACH,OAAO,CACX,CAMO,iBAAAC,GACH,OAAO56B,KAAKypB,MAAQ,GAA8B,MAAxBzpB,KAAKu6B,iBAA2Bv6B,KAAKu6B,gBAAgBtQ,UAAajqB,KAAK45B,WACrG,CASO,iBAAAiB,CAAkBhsB,EAAoBisB,EAAkBC,GAAwB,GACnF,GAAID,EAAQvN,QAAUvtB,KAAKg7B,UACnBF,EAAQvN,OAAO0N,qBAAuBH,EAAQvN,OAAO2N,+BAAiCH,EACtF,OAAO,EAIVD,EAAQK,kBACTL,EAAQK,gBAAkB,IAAIzI,GAGlC,MAAMnlB,EAAQvN,KAAKiB,WACbgtB,EAAqC6M,EAAQK,gBAEnD,GAAIn7B,KAAKo7B,mBAAmBN,GACxB,OAAO,EAGX,MAAMxI,EAAS/kB,EAAMe,YAUrB,GAPA,IAAe+sB,wBAAwB9tB,EAAOsB,EAAMof,GAAS,EAAOjuB,KAAK05B,wBACzEzL,EAAQqN,cAAe,EAGvB,IAAeC,2BAA2BhuB,EAAO0gB,GAG7CA,EAAQuN,kBAAmB,CAE3B,GADAvN,EAAQwN,UAAW,EACfluB,EAAMmuB,gBAAiB,CAKvB,GAJInuB,EAAMe,YAAYC,UAAUotB,aAC5B1N,EAAQkF,mBAAoB,GAG5BnzB,KAAKu6B,iBAAmB,IAAcqB,sBAAuB,CAC7D,IAAK57B,KAAKu6B,gBAAgBsB,uBACtB,OAAO,EAGX,IAAeC,0BAA0B97B,KAAKu6B,gBAAiBtM,EAAS,WACxEA,EAAQ6E,gBAAkB9yB,KAAKu6B,gBAAgBtQ,SAC/CgE,EAAQ4E,aAAe7yB,KAAKu6B,gBAAgBvQ,WAC5CiE,EAAQ8E,eAAiB/yB,KAAK+7B,e,MAE9B9N,EAAQ0E,SAAU,EAClB1E,EAAQ2E,gBAAkB,EAC1B3E,EAAQ6E,iBAAkB,EAC1B7E,EAAQ4E,cAAe,EACvB5E,EAAQ8E,gBAAiB,EAG7B,MAAMlI,EAAoB7qB,KAAKy6B,mBAC/B,GAAI5P,GAAqB,IAAcmR,yBAA0B,CAC7D,IAAKnR,EAAkBgR,uBACnB,OAAO,EAkBX,OAfA5N,EAAQ0G,YAAa,EACrB1G,EAAQwH,gBAAkB5K,EAAkBb,WAC5CiE,EAAQyH,eAAiB7K,EAAkBoR,OAC3ChO,EAAQ+E,eAAiBhzB,KAAKk8B,gBAAkB,EAChDjO,EAAQuH,qBAAuB3K,EAAkBsR,gBACjDlO,EAAQ0H,+BAAiC31B,KAAKy5B,sBAC9CxL,EAAQwF,cAAgBzzB,KAAK85B,YAEzBjP,EAAkBO,kBAAoB,IAAQgR,gBAC9CnO,EAAQqH,gBAAiB,GAG7BrH,EAAQ2G,iBAAmB/J,EAAkBvU,OAC7C2X,EAAQsH,wBAA0BtH,EAAQ2G,kBAAoB50B,KAAKiB,WAAWmxB,sBAAwBvH,EAAkBwR,QAAUxR,EAAkBwR,QAE5IxR,EAAkBO,iBACtB,KAAK,IAAQkR,cACTrO,EAAQiH,wBAAyB,EACjC,MACJ,KAAK,IAAQqH,YACTtO,EAAQ6G,sBAAuB,EAC/B,MACJ,KAAK,IAAQ0H,gBACTvO,EAAQ+G,0BAA2B,EACnC,MACJ,KAAK,IAAQ3J,YACT4C,EAAQgH,sBAAuB,EAC/B,MACJ,KAAK,IAAQwH,eACTxO,EAAQ4G,yBAA0B,EAClC,MACJ,KAAK,IAAQ6H,qBACTzO,EAAQkH,+BAAgC,EACxC,MACJ,KAAK,IAAQwH,2BACT1O,EAAQmH,qCAAsC,EAC9C,MACJ,KAAK,IAAQwH,oCACT3O,EAAQoH,6CAA8C,EACtD,MACJ,KAAK,IAAQwH,WACb,KAAK,IAAQT,cACb,QACInO,EAAQ8G,qBAAsB,EAIlC/0B,KAAK8qB,mBACLmD,EAAQgF,mBAAoB,EAC5BhF,EAAQiF,kBAAoBlzB,KAAKirB,0BAA4B,EAE7DjrB,KAAKg6B,oBAAoB3yB,EAAIrH,KAAK+qB,iBAClC/qB,KAAKg6B,oBAAoB1yB,EAAItH,KAAK43B,uBAClC53B,KAAKg6B,oBAAoBzyB,EAAIvH,KAAK83B,wBAClC93B,KAAKg6B,oBAAoB8C,EAAI,EAAI98B,KAAKirB,4BAEtCgD,EAAQgF,mBAAoB,EAC5BhF,EAAQiF,mBAAoB,E,MAGhCjF,EAAQ0G,YAAa,EACrB1G,EAAQgF,mBAAoB,EAC5BhF,EAAQiF,mBAAoB,EAC5BjF,EAAQ+E,gBAAiB,EACzB/E,EAAQ2G,kBAAmB,EAC3B3G,EAAQ4G,yBAA0B,EAClC5G,EAAQ6G,sBAAuB,EAC/B7G,EAAQ8G,qBAAsB,EAC9B9G,EAAQ+G,0BAA2B,EACnC/G,EAAQgH,sBAAuB,EAC/BhH,EAAQiH,wBAAyB,EACjCjH,EAAQkH,+BAAgC,EACxClH,EAAQmH,qCAAsC,EAC9CnH,EAAQoH,6CAA8C,EACtDpH,EAAQqH,gBAAiB,EACzBrH,EAAQsH,yBAA0B,EAClCtH,EAAQuH,sBAAuB,EAC/BvH,EAAQwH,iBAAkB,EAC1BxH,EAAQyH,gBAAiB,C,CAIjCzH,EAAQmF,iBAAsC,IAAnBpzB,KAAK0pB,WAAwB,IAAV,KAAU,UACxDuE,EAAQoF,YAAcrzB,KAAK+8B,aAC3B9O,EAAQuF,MAAQxzB,KAAKg9B,Y,CAQzB,GALI/O,EAAQgP,kBACRhP,EAAQqF,6BAA+BtzB,KAAK+8B,eAAmD,IAAlC/8B,KAAKu3B,0BAAuE,IAArCv3B,KAAK03B,6BACzGzJ,EAAQsF,mBAAqBvzB,KAAK45B,aAGlC3L,EAAQiP,0BAA4Bl9B,KAAKo4B,8BAA+B,CACxE,IAAKp4B,KAAKo4B,8BAA8BtZ,UACpC,OAAO,EAGX9e,KAAKo4B,8BAA8B+E,eAAelP,E,CAoBtD,GAhBA,IAAemP,sBAAsBvuB,EAAMtB,GAAO,EAAOvN,KAAKq9B,YAAar9B,KAAKs9B,WAAYt9B,KAAKu9B,uBAAuB1uB,GAAOof,GAG/H,IAAeuP,kCAAkCjwB,EAAO+kB,EAAQtyB,KAAMiuB,EAAS8M,EAAc,KAAMD,EAAQ2C,mBAAmBC,kBAG1H,IAAeC,4BAA4B9uB,EAAMof,GAAS,GAAO,GAAM,IACnEpf,IACKtB,EAAMe,YAAYC,UAAUqvB,qBAAwB/uB,EAAKgvB,sBAAsB,IAAaC,cAC7FjvB,EAAKkvB,eAAc,GACnB,IAAOjtB,KAAK,+DAAiEjC,EAAKpO,QAM1FwtB,EAAQ+P,QAAS,CACjB/P,EAAQgQ,kBACR1wB,EAAM2wB,sBAGN,MAAMC,EAAY,IAAI,IAClBlQ,EAAQsI,KACR4H,EAAUC,YAAY,EAAG,OAGzBnQ,EAAQqI,WACR6H,EAAUC,YAAY,EAAG,aAGzBnQ,EAAQyG,WACRyJ,EAAUC,YAAY,EAAG,aAG7B,IAAeC,0BAA0BpQ,EAASkQ,EAAWn+B,KAAK05B,wBAGlE,MAAM4E,EAAU,CAAC,IAAaC,cAE1BtQ,EAAQuI,QACR8H,EAAQl8B,KAAK,IAAa07B,YAG1B7P,EAAQ6H,KACRwI,EAAQl8B,KAAK,IAAao8B,QAG1BvQ,EAAQ8H,KACRuI,EAAQl8B,KAAK,IAAaq8B,SAG9B,IAAeC,0BAA0BJ,EAASzvB,EAAMof,EAASkQ,GACjE,IAAeQ,8BAA8BL,EAASrQ,GAEtD,MAAM2Q,EAAW,CACb,QACA,OACA,iBACA,eACA,cACA,YACA,YACA,YACA,SAEA,gBACA,sBACA,mBACA,mBACA,+BACA,iBAEA,cACA,QAEA,oBACA,qBAEA,gBACA,kBAGJ,QAAqBA,GACrB,MAAMC,EAAW,CAAC,iBAAkB,oBAAqB,uBAAwB,yBAC3EC,EAAiB,CAAC,WAAY,SAEhC,MACA,IAA6BC,gBAAgBH,EAAU3Q,GACvD,IAA6B+Q,gBAAgBH,EAAU5Q,IAG3D,IAAegR,+BAAuD,CAClEC,cAAeN,EACfO,oBAAqBL,EACrBD,SAAUA,EACV5Q,QAASA,EACT0L,sBAAuB35B,KAAK05B,yBAGhC,MAAM0F,EAAOnR,EAAQ9e,WACfoe,EAAShgB,EAAMe,YAAY+wB,aAC7B,aACwB,CACpBC,WAAYhB,EACZY,cAAeN,EACfO,oBAAqBL,EACrBD,SAAUA,EACV5Q,QAASmR,EACTjB,UAAWA,EACXoB,WAAYv/B,KAAKu/B,WACjB5mB,QAAS3Y,KAAK2Y,QACd6mB,gBAAiB,CAAE7F,sBAAuB35B,KAAK05B,yBAEnDpH,GAEJwI,EAAQ2E,UAAUlS,EAAQU,EAASjuB,KAAK0/B,kBAExC1/B,KAAK2/B,oB,CAGT,SAAK7E,EAAQvN,SAAWuN,EAAQvN,OAAOzO,YAIvCmP,EAAQ2R,UAAYryB,EAAM6F,cAC1B0nB,EAAQvN,OAAO0N,qBAAsB,EACrCH,EAAQvN,OAAO2N,6BAA+BH,EAE9C/6B,KAAK6/B,iCAEE,GACX,CAKQ,uCAAAzI,GACCp3B,KAAKm3B,oBAIVn3B,KAAK8/B,cAAcx/B,SAASN,KAAKm3B,mBAGjCn3B,KAAK8/B,cAAcC,mBAAmB//B,KAAK8/B,cAAe9/B,KAAKiB,WAAWqN,YAAY8V,yBAGlFpkB,KAAKo4B,+BAELp4B,KAAK8/B,cAAcE,WAAW,EAAIhgC,KAAKo4B,8BAA8BvQ,SAAU7nB,KAAK8/B,eAGxF9/B,KAAKw3B,wBACT,CAKQ,qBAAAA,GACkC,IAAlCx3B,KAAKu3B,0BAAuE,IAArCv3B,KAAK03B,8BAKhD13B,KAAK8/B,cAAcE,WAAWhgC,KAAKu3B,yBAA0Bv3B,KAAKk6B,qBAClEl6B,KAAK8/B,cAAcG,cAAcjgC,KAAKk6B,oBAAqBl6B,KAAKk6B,qBAGhEl6B,KAAKi6B,OAAOgG,cAAcjgC,KAAK8/B,cAAe9/B,KAAKo6B,wBACnDp6B,KAAKo6B,uBAAuB4F,WAAWhgC,KAAK03B,4BAA6B13B,KAAKo6B,wBAC9Ep6B,KAAK8/B,cAAcjP,SAAS7wB,KAAKo6B,uBAAwBp6B,KAAKo6B,wBAClE,CAKO,kBAAAuF,GAEH3/B,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,sBAAuB,GACtDptB,KAAKmtB,eAAeC,WAAW,gBAAiB,GAChDptB,KAAKmtB,eAAeC,WAAW,mBAAoB,GACnDptB,KAAKmtB,eAAeC,WAAW,gBAAiB,IAChDptB,KAAKmtB,eAAeC,WAAW,mBAAoB,IACnDptB,KAAKmtB,eAAeC,WAAW,+BAAgC,GAC/DptB,KAAKmtB,eAAeC,WAAW,iBAAkB,GACjDptB,KAAKmtB,eAAeC,WAAW,YAAa,GAC5CptB,KAAKmtB,eAAeC,WAAW,cAAe,GAC9CptB,KAAKmtB,eAAeC,WAAW,QAAS,GACxCptB,KAAKmtB,eAAeC,WAAW,oBAAqB,GACpDptB,KAAKmtB,eAAeC,WAAW,qBAAsB,GAErDptB,KAAKmtB,eAAeE,QACxB,CAKO,MAAA6S,GACClgC,KAAKu6B,iBAAmBv6B,KAAKu6B,gBAAgBC,gBAC7Cx6B,KAAKmtB,eAAe6E,WAAW,iBAAkB,MAGjDhyB,KAAKy6B,oBAAsBz6B,KAAKy6B,mBAAmBD,gBACnDx6B,KAAKmtB,eAAe6E,WAAW,oBAAqB,MAGxDhxB,MAAMk/B,QACV,CAMO,mBAAAC,CAAoBC,GACvBpgC,KAAKqgC,cAAetO,UAAU,QAASqO,EAC3C,CAQO,cAAAE,CAAeF,EAAevxB,EAAYisB,GAC7C,MAAMvtB,EAAQvN,KAAKiB,WAEbgtB,EAAqC6M,EAAQK,gBACnD,IAAKlN,EACD,OAGJ,MAAMV,EAASuN,EAAQvN,OACvB,IAAKA,EACD,OAEJvtB,KAAKqgC,cAAgB9S,EAGrBvtB,KAAKmgC,oBAAoBC,GAGzB,IAAeG,oBAAoB1xB,EAAM7O,KAAKqgC,eAE9C,MAAMG,EAAaxgC,KAAKygC,YAAYlzB,EAAOggB,EAAQ1e,EAAK6xB,YACxD,GAAIF,EAAY,CACZxgC,KAAKmtB,eAAewT,aAAapT,EAAQ,YAEzCvtB,KAAK4gC,mBAAmBrT,GAExB,MAAM1C,EAAoB7qB,KAAKy6B,mBAC1Bz6B,KAAKmtB,eAAe0T,QAAW7gC,KAAKg7B,UAAah7B,KAAKmtB,eAAe2T,SAElEvzB,EAAMmuB,kBACF17B,KAAKu6B,iBAAmB,IAAcqB,wBACtC57B,KAAKmtB,eAAe4T,aAAa,gBAAiB/gC,KAAKu6B,gBAAgByG,iBAAkBhhC,KAAKu6B,gBAAgBzX,OAC9G,IAAeme,kBAAkBjhC,KAAKu6B,gBAAiBv6B,KAAKmtB,eAAgB,YAG5EtC,GAAqB,IAAcmR,2BACnCh8B,KAAKmtB,eAAetpB,aAAa,mBAAoBgnB,EAAkBqW,8BACvElhC,KAAKmtB,eAAe4T,aAAa,mBAAoBlW,EAAkB/H,MAAO9iB,KAAKk8B,iBAEnFl8B,KAAKmtB,eAAegU,aAChB,+BACAtW,EAAkBlX,UAAUC,MAC5BiX,EAAkBuW,mBAClBvW,EAAkBwW,uBAK1BrhC,KAAK2pB,YAAc,GACnB3pB,KAAKmtB,eAAemU,YAAY,cAAethC,KAAK2pB,aAExD3pB,KAAKmtB,eAAemU,YAAY,QAASthC,KAAKypB,OAG1CzpB,KAAKq9B,aACLr9B,KAAKmtB,eAAemU,YAAY,YAAathC,KAAKuhC,WAGlDtT,EAAQqF,6BACRtzB,KAAKmtB,eAAeqU,aAAa,gBAAiBxhC,KAAKo6B,uBAAwB,GAC/Ep6B,KAAKmtB,eAAeqU,aAAa,sBAAuBxhC,KAAKk6B,oBAAqB,IAElFl6B,KAAKmtB,eAAeqU,aAAa,gBAAiBxhC,KAAK8/B,cAAe,IAI9E9/B,KAAKmtB,eAAemU,YAAY,iBAAkBthC,KAAKi4B,gBAGnD1qB,EAAMmuB,kBACF17B,KAAKu6B,iBAAmB,IAAcqB,uBACtC57B,KAAKmtB,eAAe6E,WAAW,iBAAkBhyB,KAAKu6B,iBAGtD1P,GAAqB,IAAcmR,2BAC/B/N,EAAQ+E,gBAAkB/E,EAAQkF,kBAClCnzB,KAAKmtB,eAAe6E,WAAW,oBAAqBnH,GAC5CoD,EAAQ+E,gBAGhBhzB,KAAKmtB,eAAe6E,WAAW,oBAAqBnH,EAAkB4W,gBAAkB5W,GACxF7qB,KAAKmtB,eAAe6E,WAAW,uBAAwBnH,EAAkB6W,gBAAkB7W,GAC3F7qB,KAAKmtB,eAAe6E,WAAW,wBAAyBnH,EAAkB8W,iBAAmB9W,IAJ7F7qB,KAAKmtB,eAAe6E,WAAW,oBAAqBnH,GAOpDoD,EAAQgF,oBACRjzB,KAAKmtB,eAAegU,aAAa,oBAAqBnhC,KAAKu5B,YAAYlyB,EAAGrH,KAAKu5B,YAAYjyB,EAAGtH,KAAKu5B,YAAYhyB,GAC/GvH,KAAKmtB,eAAeO,aAChB,qBACA1tB,KAAKg6B,oBAAoB3yB,EACzBrH,KAAKg6B,oBAAoB1yB,EACzBtH,KAAKg6B,oBAAoBzyB,EACzBvH,KAAKg6B,oBAAoB8C,OAOzC,QAAc98B,KAAKqgC,cAAergC,KAAMuN,GAExCA,EAAMq0B,gBAAgBrU,E,MACfhgB,EAAMe,YAAYuzB,UAAUC,iCACnC9hC,KAAKmtB,eAAewT,aAAapT,EAAQ,YACzCvtB,KAAK+hC,qBAAsB,IAG3BvB,GAAexgC,KAAKg7B,WAChBztB,EAAMy0B,eACN,IAAeC,WAAW10B,EAAOsB,EAAM7O,KAAKqgC,cAAepS,EAASjuB,KAAK05B,wBAI7E15B,KAAKkiC,SAAS3U,GAGd,IAAe4U,kBAAkB50B,EAAOsB,EAAM7O,KAAKqgC,eAAe,GAG9DrgC,KAAKo4B,+BACLp4B,KAAKo4B,8BAA8BgK,KAAKpiC,KAAKqgC,gBAIrDrgC,KAAKqiC,WAAWxzB,EAAM7O,KAAKqgC,eAE3BrgC,KAAKmtB,eAAepZ,QACxB,CAOO,UAAAuuB,CAAWzpB,GACd,QAAI7X,MAAMshC,WAAWzpB,IAIjB7Y,KAAKy6B,qBAAuB5hB,GAI5B7Y,KAAKu6B,kBAAoB1hB,CAKjC,CAOO,OAAAhF,CAAQ0uB,GAA8B,EAAOC,GAAgC,GAC5EA,IACIxiC,KAAK+pB,gBACL/pB,KAAK+pB,eAAelW,UAEpB7T,KAAK6qB,mBACL7qB,KAAK6qB,kBAAkBhX,WAI/B7T,KAAK+5B,eAAelmB,UAEhB7T,KAAKo4B,+BAAiCp4B,KAAKq4B,0BAC3Cr4B,KAAKo4B,8BAA8BE,mBAAmBC,OAAOv4B,KAAKq4B,0BAGtEr3B,MAAM6S,QAAQ0uB,EAClB,CAOO,KAAA5gC,CAAMlB,GACT,OAAO,KAAoBgiC,OAAM,IAAM,IAAIxL,EAAmBx2B,EAAMT,KAAKiB,aAAajB,KAC1F,CAMO,SAAA2U,GACH,MAAMC,EAAsB5T,MAAM2T,YAElC,OADAC,EAAoB8tB,WAAa,6BAC1B9tB,CACX,CAMO,YAAArS,GACH,MAAO,oBACX,CASO,YAAO8S,CAAM7E,EAAajD,EAAcgN,GAC3C,OAAO,KAAoBlF,OAAM,IAAM,IAAI4hB,EAAmBzmB,EAAO/P,KAAM8M,IAAQiD,EAAQjD,EAAOgN,EACtG,EApjCc,EAAAsd,qBAAuB,IAKvB,EAAAE,sBAAwB,IAG5B,UADT,W,qCAMM,UADN,QAAiB,mC,oCAIR,UADT,W,yCAsBS,UADT,W,gDAgBS,UADT,W,mDAOD,UADC,QAAiB,mC,gDAWR,UADT,W,0CAOM,UADN,QAAiB,qC,yCAIR,UADT,W,uCASM,UADN,QAAiB,qC,sCAIR,UADT,W,uCAOM,UADN,QAAiB,qC,sCASX,UADN,QAAiB,qC,oCAIR,UADT,W,oCAOM,UADN,QAAiB,qC,mCAIR,UADT,W,oCAOM,UADN,QAAiB,qC,mCAIR,UADT,W,uCAOM,UADN,QAAiB,qC,sCAIR,UADT,W,0CAOM,UADN,QAAiB,qC,yCAIR,UADT,W,kDAOM,UADN,QAAiB,qC,iDAIR,UADT,W,yCAMM,UADN,QAAiB,qC,wCAIR,UADT,W,+CAMM,UADN,QAAiB,qC,8CAIR,UADT,W,gDAMM,UADN,QAAiB,qC,+CAsBR,UADT,W,oCAMM,UADN,QAAiB,qC,mCAIR,UADT,W,oCAMM,UADN,QAAiB,qC,mCAyBV,UADP,W,8CAMM,UADN,QAAiB,qC,6CAIV,UADP,W,mCAMM,UADN,QAAiB,mC,kCAOR,UADT,W,qDAg0BL,OAAc,6BAA8Bd,E,mFCpvCrC,MAAM0L,UAA4B,IAAzC,c,oBACI,KAAAC,0BAA2B,EAC3B,KAAAC,6BAA8B,EAC9B,KAAAC,qBAAsB,EACtB,KAAAC,yCAA0C,CAC9C,EAKO,MAAMC,UAA6B,IA2E/B,4BAAAC,GACHjjC,KAAKkjC,sCACT,CAEA,WAAA1iC,CAAYspB,EAA2BqZ,GAAkB,GACrDniC,MAAM8oB,EAAU,UAAW,GAAI,IAAI6Y,EAAuBQ,GArDtD,KAAAC,uBAAyBJ,EAAqBK,gCAM/C,KAAAC,sBAAwBN,EAAqBK,gCAE5C,KAAAE,oCAAsCP,EAAqBQ,+CAW5D,KAAAC,mCAAqCT,EAAqBQ,+CAEzD,KAAAE,uBAAyBV,EAAqBW,gCAU/C,KAAAC,sBAAwBZ,EAAqBW,gCAE5C,KAAAE,8CAAgDb,EAAqBc,0DAStE,KAAAC,6CAA+Cf,EAAqBc,0DAavE9jC,KAAKkjC,qCAAuCpZ,EAASka,gBAAgB,IACrEhkC,KAAKikC,SAAQ,EACjB,CAEO,cAAA9G,CAAelP,GAClBA,EAAQ2U,yBAA2B5iC,KAAKujC,oCACxCtV,EAAQ4U,4BAA8B7iC,KAAKojC,wBAA0BpjC,KAAKujC,oCAC1EtV,EAAQ6U,oBAAsB9iC,KAAK0jC,uBACnCzV,EAAQ8U,wCAA0C/iC,KAAK6jC,6CAC3D,CAEO,YAAAthC,GACH,MAAO,sBACX,EA1Fc,EAAA8gC,iCAAkC,EAMlC,EAAAG,gDAAiD,EAOjD,EAAAG,iCAAkC,EAOlC,EAAAG,2DAA4D,GAQnE,UAFN,WACA,QAAiB,iC,6CAcX,UAFN,WACA,QAAiB,iC,0DAaX,UAFN,WACA,QAAiB,iC,6CAYX,UAFN,WACA,QAAiB,iC,oLCrEf,MAAMI,UAAoB,IAkO7B,qBAAWC,GACP,OAAOnkC,KAAKokC,WAAWD,iBAC3B,CACA,qBAAWA,CAAkBhkC,GACzBH,KAAKokC,WAAWD,kBAAoBhkC,EAChCA,EACAH,KAAKokC,WAAWC,qBAAsB,EAC9BrkC,KAAKokC,WAAWE,iCACxBtkC,KAAKokC,WAAWC,qBAAsB,EAE9C,CAoDA,qBAAWE,GACP,OAAOvkC,KAAKokC,WAAWG,iBAC3B,CACA,qBAAWA,CAAkBpkC,GACzBH,KAAKokC,WAAWG,kBAAoBpkC,CACxC,CAKA,qBAAWqkC,GACP,OAAOxkC,KAAKokC,WAAWI,iBAC3B,CACA,qBAAWA,CAAkBrkC,GACzBH,KAAKokC,WAAWI,kBAAoBrkC,CACxC,CAMA,kCAAWmkC,GACP,OAAOtkC,KAAKokC,WAAWE,8BAC3B,CACA,kCAAWA,CAA+BnkC,GACtCH,KAAKokC,WAAWE,+BAAiCnkC,EAC7CA,IACAH,KAAKokC,WAAWC,qBAAsB,EAE9C,CA8FA,2BAAWI,GACP,OAAOzkC,KAAK0kC,gBAAkB,IAAgBC,qBAClD,CAOA,2BAAWF,CAAwBtkC,GAC3BA,IAAUH,KAAKykC,0BAEfzkC,KAAKy4B,mCAGDz4B,KAAK0kC,cADLvkC,EACqB,IAAgBwkC,sBAEhB,IAAgBC,sBAGjD,CAOA,uBAAWC,GACP,OAAO7kC,KAAK0kC,gBAAkB,IAAgBI,iBAClD,CAMA,uBAAWD,CAAoB1kC,GACvBA,IAAUH,KAAK6kC,sBAEf7kC,KAAKy4B,mCAGDz4B,KAAK0kC,cADLvkC,EACqB,IAAgB2kC,kBAEhB,IAAgBF,sBAGjD,CA4JA,gCAAWjd,GACP,OAAO3nB,KAAKo4B,6BAChB,CAOA,gCAAWzQ,CAA6BxnB,GACpCH,KAAKk4B,oCAAoC/3B,GAGzCH,KAAKy4B,kCACT,CAKA,4BAAWC,GACP,OAAO14B,KAAK2nB,6BAA6BgR,kBAC7C,CAIA,4BAAWD,CAAyBv4B,GAChCH,KAAK2nB,6BAA6BgR,mBAAqBx4B,CAC3D,CAKA,6BAAWy4B,GACP,OAAO54B,KAAK2nB,6BAA6BkR,mBAC7C,CAIA,6BAAWD,CAA0Bz4B,GACjCH,KAAK2nB,6BAA6BkR,oBAAsB14B,CAC5D,CAKA,4BAAW24B,GACP,OAAO94B,KAAKo4B,8BAA8BvS,kBAC9C,CAIA,4BAAWiT,CAAyB34B,GAChCH,KAAKo4B,8BAA8BvS,mBAAqB1lB,CAC5D,CAOA,kBAAWwlB,GACP,OAAO3lB,KAAKo4B,8BAA8BvQ,QAC9C,CAMA,kBAAWlC,CAAexlB,GACtBH,KAAKo4B,8BAA8BvQ,SAAW1nB,CAClD,CAKA,kBAAWylB,GACP,OAAO5lB,KAAKo4B,8BAA8BxQ,QAC9C,CAKA,kBAAWhC,CAAezlB,GACtBH,KAAKo4B,8BAA8BxQ,SAAWznB,CAClD,CAKA,6BAAW44B,GACP,OAAO/4B,KAAKo4B,8BAA8BY,mBAC9C,CAIA,6BAAWD,CAA0B54B,GACjCH,KAAKo4B,8BAA8BY,oBAAsB74B,CAC7D,CAQA,qBAAW84B,GACP,OAAOj5B,KAAKo4B,8BAA8Bc,WAC9C,CAOA,qBAAWD,CAAkB94B,GACzBH,KAAKo4B,8BAA8Bc,YAAc/4B,CACrD,CAQA,WAAAK,CAAYC,EAAc8M,GACtBvM,MAAMP,EAAM8M,GAhsBT,KAAAw3B,gBAA0B,EAQ1B,KAAAC,kBAA4B,EAQ5B,KAAAC,qBAA+B,EAQ/B,KAAAC,kBAA4B,EAO5B,KAAAC,gBAA0B,EAqB1B,KAAAC,uBAAiC,EASjC,KAAAC,uCAAiDnB,EAAYoB,gCAgE7D,KAAAC,iBAAmB,EAanB,KAAAC,yBAA2B,KAAOrM,QAQlC,KAAAsM,+CAAgD,EA+DhD,KAAAC,aAAe,IAAI,KAAO,EAAG,EAAG,GAOhC,KAAAC,YAAc,IAAI,KAAO,EAAG,EAAG,GAO/B,KAAAC,kBAAoB,IAAI,KAAO,EAAG,EAAG,GAOrC,KAAAC,gBAAkB,IAAI,KAAO,EAAK,EAAK,GAOvC,KAAAC,cAAgB,IAAI,KAAO,EAAG,EAAG,GAOjC,KAAAC,aAAe,EA8Cf,KAAAC,wBAAyB,EAOzB,KAAAC,2BAA4B,EAO5B,KAAAC,gBAAiB,EAOjB,KAAAC,YAAc,GAQd,KAAAC,sBAAuB,EAOvB,KAAAC,yCAA0C,EAO1C,KAAAC,sCAAuC,EAOvC,KAAAC,sCAAuC,EAOvC,KAAAC,sCAAuC,EAOvC,KAAAC,2CAA4C,EAO5C,KAAAC,uBAAwB,EAQxB,KAAAC,wCAAyC,EA8DzC,KAAAC,sBAAuB,EAOvB,KAAAC,yBAA0B,EAO1B,KAAAC,aAAc,EAOd,KAAAC,sBAAuB,EAOvB,KAAAC,kBAAoB,IAOpB,KAAAC,iBAAkB,EAOlB,KAAAC,2BAA4B,EAO5B,KAAAvN,sBAAwB,EAOxB,KAAAwN,kBAAmB,EAOnB,KAAAC,kBAAmB,EAOnB,KAAAC,kBAAmB,EAQnB,KAAAC,iBAAkB,EAQlB,KAAAC,uBAAwB,EAWxB,KAAAC,uBAAgD,KAOhD,KAAAC,oBAAqB,EASrB,KAAAC,4BAA6B,EAQ7B,KAAAC,qBAAsB,EAQtB,KAAAC,sBAAuB,EAOvB,KAAAC,OAAQ,EAOR,KAAAC,6BAA8B,EAoIjC9nC,KAAK+nC,yBAA0B,OAA0B/nC,KAAKiB,WAClE,CAKO,YAAAsB,GACH,MAAO,aACX,CAQO,KAAAZ,CAAMlB,EAAcunC,GAAiC,EAAMztB,EAAU,IACxE,MAAM5Y,EAAQ,KAAoB8gC,OAAM,IAAM,IAAIyB,EAAYzjC,EAAMT,KAAKiB,aAAajB,KAAM,CAAEgoC,0BAS9F,OAPArmC,EAAM2L,GAAK7M,EACXkB,EAAMlB,KAAOA,EAEbT,KAAKioC,QAAQC,OAAOvmC,EAAMsmC,SAE1BjoC,KAAKmoC,cAAcxmC,EAAO4Y,GAEnB5Y,CACX,CAMO,SAAAgT,GACH,MAAMC,EAAsB5T,MAAM2T,YAGlC,OAFAC,EAAoB8tB,WAAa,sBAE1B9tB,CACX,CAUO,YAAOS,CAAM7E,EAAajD,EAAcgN,GAC3C,MAAMuP,EAAW,KAAoBzU,OAAM,IAAM,IAAI6uB,EAAY1zB,EAAO/P,KAAM8M,IAAQiD,EAAQjD,EAAOgN,GA4BrG,OA1BI/J,EAAOy3B,SACPne,EAASme,QAAQG,MAAM53B,EAAOy3B,QAAS16B,EAAOgN,GAGlD,IAAS8tB,cAAc73B,EAAQsZ,EAAUvc,EAAOgN,GAG5C/J,EAAO83B,WACPxe,EAASwe,UAAUF,MAAM53B,EAAO83B,UAAW/6B,EAAOgN,GAElD/J,EAAO+3B,YACPze,EAASye,WAAWH,MAAM53B,EAAO+3B,WAAYh7B,EAAOgN,GAEpD/J,EAAOg4B,MACP1e,EAAS0e,KAAKJ,MAAM53B,EAAOg4B,KAAMj7B,EAAOgN,GAExC/J,EAAOi4B,OACP3e,EAAS2e,MAAML,MAAM53B,EAAOi4B,MAAOl7B,EAAOgN,GAE1C/J,EAAO4zB,YACPta,EAASsa,WAAWgE,MAAM53B,EAAO4zB,WAAY72B,EAAOgN,GAEpD/J,EAAOk4B,aACP5e,EAAS4e,YAAYN,MAAM53B,EAAOk4B,YAAan7B,EAAOgN,GAGnDuP,CACX,EA9yBuB,EAAA6e,mBAAqB,IAAgBA,mBAKrC,EAAAC,sBAAwB,IAAgBA,sBAKxC,EAAAC,uBAAyB,IAAgBA,uBAMzC,EAAAC,8BAAgC,IAAgBA,8BAMzD,EAAAxD,gCAAkC,IAAgBA,iCAQzD,UAFN,WACA,QAAiB,qC,uCASX,UAFN,WACA,QAAiB,qC,yCASX,UAFN,WACA,QAAiB,qC,4CASX,UAFN,WACA,QAAiB,qC,yCAQX,UAFN,WACA,QAAiB,qC,sCAQX,UAFN,WACA,QAAiB,qC,qCAQX,UAFN,WACA,QAAiB,qC,sCAQX,UAFN,WACA,QAAiB,qC,8CAUX,UAFN,WACA,QAAiB,qC,8DAQX,UAFN,WACA,QAAiB,4C,sCAQX,UAFN,WACA,QAAiB,qC,yCAQX,UAFN,WACA,QAAiB,qC,uCAQX,UAFN,WACA,QAAiB,qC,2CAQX,UAFN,WACA,QAAiB,qC,uCASX,UAFN,WACA,QAAiB,qC,gCASX,UAFN,WACA,QAAiB,qC,iCAcX,UAFN,WACA,QAAiB,qC,wCAcX,UAFN,WACA,QAAiB,qC,gDASX,UAFN,WACA,QAAiB,qC,qEAUX,UAFN,WACA,QAAiB,qC,kDAWX,UAFN,WACA,QAAiB,qC,0CASX,UAFN,WACA,QAAiB,qC,2CAQX,UAFN,WACA,QAAiB,qC,mCAQX,UAFN,WACA,QAAiB,mCAAoC,O,uCAuB/C,UAFN,QAAkB,YAClB,QAAiB,qC,oCAQX,UAFN,QAAkB,WAClB,QAAiB,qC,mCAQX,UAFN,QAAkB,iBAClB,QAAiB,qC,yCAQX,UAFN,QAAkB,eAClB,QAAiB,qC,uCAQX,UAFN,QAAkB,aAClB,QAAiB,qC,qCAQX,UAFN,WACA,QAAiB,qC,oCA+CX,UAFN,WACA,QAAiB,qC,8CAQX,UAFN,WACA,QAAiB,4C,iDAQX,UAFN,WACA,QAAiB,4C,sCAQX,UAFN,WACA,QAAiB,4C,mCASX,UAFN,WACA,QAAiB,qC,4CAQX,UAFN,WACA,QAAiB,qC,+DAQX,UAFN,WACA,QAAiB,qC,4DAQX,UAFN,WACA,QAAiB,qC,4DAQX,UAFN,WACA,QAAiB,qC,4DAQX,UAFN,WACA,QAAiB,qC,iEAQX,UAFN,WACA,QAAiB,qC,6CASX,UAFN,WACA,QAAiB,qC,8DASlB,UADC,W,6CA4BD,UADC,W,yCA4BM,UAFN,WACA,QAAiB,qC,4CAQX,UAFN,WACA,QAAiB,qC,+CAQX,UAFN,WACA,QAAiB,qC,mCAQX,UAFN,WACA,QAAiB,qC,4CAQX,UAFN,WACA,QAAiB,qC,yCAQX,UAFN,WACA,QAAiB,mC,uCAQX,UAFN,WACA,QAAiB,qC,iDAQX,UAFN,WACA,QAAiB,mC,6CAQX,UAFN,WACA,QAAiB,qC,wCAQX,UAFN,WACA,QAAiB,qC,wCAQX,UAFN,WACA,QAAiB,qC,wCASX,UAFN,WACA,QAAiB,qC,uCASX,UAFN,WACA,QAAiB,qC,6CAYX,UADN,QAAiB,qC,8CAQX,UAFN,WACA,QAAiB,qC,0CAUX,UAFN,WACA,QAAiB,qC,kDASX,UAFN,WACA,QAAiB,qC,2CASX,UAFN,WACA,QAAiB,qC,4CAQX,UAFN,WACA,QAAiB,iC,6BAQX,UAFN,WACA,QAAiB,iC,mDAsNtB,OAAc,sBAAuBpB,E,0CClzBrC,IAAYnuB,UAAUgzB,mCAAqC,WACnD/oC,KAAKgpC,WACLhpC,KAAKgpC,SAASC,qBAAuB,KACrCjpC,KAAKgpC,SAASE,4BAA8B,KAC5ClpC,KAAKgpC,SAASG,8BAA+B,EAErD,EAEA75B,OAAO85B,eAAe,IAAYrzB,UAAW,sBAAuB,CAChEszB,IAAK,WACD,GAAIrpC,KAAKgpC,SAAU,CACf,GAAIhpC,KAAKgpC,SAASC,sBAAwBjpC,KAAKgpC,SAASG,6BACpD,OAAOnpC,KAAKgpC,SAASC,qBAGzB,GAAIjpC,KAAKgpC,SAASlqB,QAad,OAZK9e,KAAKgpC,SAASE,8BACflpC,KAAKgpC,SAASE,4BAA8B,IAAkCI,2CAA2CtpC,MACvE,OAA9CA,KAAKgpC,SAASE,4BACdlpC,KAAKgpC,SAASG,8BAA+B,EAE7CnpC,KAAKgpC,SAASE,4BAA4BK,MAAMC,IAC5CxpC,KAAKgpC,SAAUC,qBAAuBO,EACtCxpC,KAAKgpC,SAAUG,8BAA+B,CAAI,KAKvD,I,CAIf,OAAO,IACX,EACAM,IAAK,SAA6BtpC,GAC1BH,KAAKgpC,WACLhpC,KAAKgpC,SAASC,qBAAuB9oC,EAE7C,EACAupC,YAAY,EACZC,cAAc,G,yIC7CX,MAAMC,UAAoB,IAiC7B,mBAAWC,CAAgB1pC,GACvB,GAAIH,KAAK8pC,kBAAoB9pC,KAAK8pC,iBAAiBC,OAAO5pC,GACtD,OAEJH,KAAK8pC,iBAAmB3pC,EACxB,MAAMoN,EAAQvN,KAAKiB,WACfsM,GACAA,EAAMy8B,wBAAwB,EAEtC,CAMA,mBAAWH,GACP,OAAO7pC,KAAK8pC,gBAChB,CAQA,aAAWG,CAAU9pC,GACjBH,KAAKkqC,WAAa/pC,EAClBH,KAAKmqC,2BAA2B,KAAOC,UAAUpqC,KAAKkqC,YAC1D,CAIA,aAAWD,GACP,OAAOjqC,KAAKkqC,UAChB,CAKA,YAAW1vB,GACP,OAAOxa,KAAKqqC,SAChB,CAcA,mBAAW1vB,GACP,OAAO3a,KAAKsqC,gBAChB,CAuBO,uBAAOC,CAAiB7xB,EAAiBnL,EAAciN,GAC1D,IAAIgwB,EAAa,GAIjB,OAFA9xB,EAAMpE,SAASyD,GAASyyB,GAAczyB,IAE/B,IAAI6xB,EAAYY,EAAYj9B,EAAO,KAAMiN,EAAU9B,EAC9D,CAUO,gCAAOqP,CAA0BhQ,EAAaxK,EAAcoN,EAAuB,KAAMC,GAA6B,GACzH,MAAM6vB,EAAWl9B,EAAMm9B,yBACvBn9B,EAAMm9B,0BAA2B,EAEjC,MAAM3hC,EAAS,IAAI6gC,EAAY7xB,EAAKxK,EAAO,MAAM,EAAO,KAAM,KAAM,UAAMnB,GAAW,EAAMuO,EAAiBC,GAI5G,OAFArN,EAAMm9B,yBAA2BD,EAE1B1hC,CACX,CAsBA,WAAAvI,CACI+Z,EACAowB,EACAC,EAAiC,KACjCpwB,GAAoB,EACpB9B,EAA4B,KAC5B+B,EAA+B,KAC/B9B,EAAiE,KACjE+B,EAAiB,KAAU,IACf,KAAE,GACd,EACA,OACA,IACA,G,MAIA1Z,MAAM2pC,GA9KF,KAAAE,UAAoB,GACpB,KAAAC,WAAqB,EAKtB,KAAAlb,iBAA4C,IAAI,KAchD,KAAAmb,oBAAsB,IAAQ7kC,OA6B3B,KAAAgkC,WAAqB,EA4BxB,KAAAnuB,OAA6B,KAG1B,KAAAuuB,iBAAqC,KAUvC,KAAAU,YAAkC,KAMlC,KAAAC,yBAAmC,IAAI,KAgF3CjrC,KAAKS,KAAO8Z,EACZva,KAAK+X,IAAMwC,EACXva,KAAKqqC,UAAY7vB,EACjBxa,KAAKiqB,UAAW,EAChBjqB,KAAKkrC,QAAUxwB,EACf1a,KAAKsW,QAAS,EACdtW,KAAKmrC,eAAiB,KAAOvpC,WAC7B5B,KAAKorC,mBAAqBxwB,EAC1B5a,KAAKorB,gBAAkB,IAAQyR,WAC/B78B,KAAKgrC,YAAcJ,EACnB5qC,KAAK+b,OAASrD,EACd1Y,KAAKsqC,iBAAmB3vB,EACxB3a,KAAKqrC,eAAiB/tB,EACtBtd,KAAKub,eAAiBL,EACtBlb,KAAK6qC,UAAYhwB,EACjB7a,KAAK8qC,WAAahwB,GAEbP,GAAY7B,IAIjB1Y,KAAKsrC,UAAU/wB,EAASI,EAAiBF,EAAQ8wB,EAAa5yB,EAASiyB,EAA2B,QAAf,EAAA5qC,KAAKiB,kBAAU,eAAEypC,yBAA0BhyB,EAClI,CAMO,YAAAnW,GACH,MAAO,aACX,CAaO,SAAA+oC,CACHvzB,EACA4C,EACAF,EAA+B,KAC/B8wB,GAAuB,EACvB5yB,EAAiE,KACjEiyB,EAAiC,KACjCY,GAAY,EACZ9yB,EAA4B,MAEvB1Y,KAAKS,OAAQT,KAAKS,KAAKgrC,WAAW,WACnCzrC,KAAKS,KAAOsX,GAEhB/X,KAAK+X,IAAMA,EAEP4C,IACA3a,KAAKsqC,iBAAmB3vB,GAG5B,MAAMyB,EAAUrE,EAAIsE,YAAY,KAC1BC,EAAY3B,IAAoCyB,GAAW,EAAIrE,EAAI6D,UAAUQ,GAASG,cAAgB,IACtGmvB,EAAsC,IAA9BpvB,EAAUxZ,QAAQ,QAC1B6oC,EAAsC,IAA9BrvB,EAAUxZ,QAAQ,QAC1B8oC,EAA0C,IAAhCtvB,EAAUxZ,QAAQ,UAelC,GAbI6oC,GACA3rC,KAAKgqB,YAAa,EAClBhqB,KAAK6rC,cAAe,EACpB7rC,KAAKuqB,0BAA4B,IAEjCvqB,KAAK6rC,aAAeN,EAEhBA,IACAvrC,KAAKgqB,YAAa,EAClBhqB,KAAKuqB,0BAA4B,IAIrC7R,EACA1Y,KAAK+b,OAASrD,OASd,GAPKkzB,GAAYD,GAAUD,GAAUd,IACjCA,EAAa,CAAC,UAAW,UAAW,UAAW,UAAW,UAAW,YAGzE5qC,KAAK+b,OAAS/b,KAAK+b,QAAU,GAC7B/b,KAAK+b,OAAOvV,OAAS,EAEjBokC,EAAY,CACZ,IAAK,IAAI7pC,EAAQ,EAAGA,EAAQ6pC,EAAWpkC,OAAQzF,IAC3Cf,KAAK+b,OAAO3Z,KAAK2V,EAAM6yB,EAAW7pC,IAEtCf,KAAKgrC,YAAcJ,C,CAIvBY,GACAxrC,KAAK8rC,eAAiB,EACtB9rC,KAAK+rC,eAAiBtxB,EACtBza,KAAKgsC,gBAAkBrzB,GAEvB3Y,KAAKisC,aAAaxxB,EAAQ9B,EAElC,CAMO,SAAA6yB,CAAU7wB,GACe,IAAxB3a,KAAK8rC,iBAGLnxB,IACA3a,KAAKsqC,iBAAmB3vB,GAG5B3a,KAAK8rC,eAAiB,EACtB9rC,KAAKisC,aAAajsC,KAAK+rC,eAAgB/rC,KAAKgsC,iBAChD,CAMO,0BAAA9K,GACH,OAAOlhC,KAAKmrC,cAChB,CAMO,0BAAAhB,CAA2BhqC,G,QAC9B,GAAIA,EAAMC,aAAeJ,KAAKmrC,eAAe/qC,WACzC,OASJ,GANID,EAAM+rC,eAAiBlsC,KAAKmrC,eAAee,eAC5B,QAAf,EAAAlsC,KAAKiB,kBAAU,SAAE+oC,wBAAwB,OAAkD,IAAxC,sBAAyB,QAAQ,SAGxFhqC,KAAKmrC,eAAiBhrC,IAEF,QAAf,EAAAH,KAAKiB,kBAAU,eAAEmxB,sBAClB,OAGJ,MAAM9pB,EAAQ,KAAWnE,QAAQ,GAC3BiF,EAAO,KAAW/E,WAAW,GAC7B8nC,EAAQ,KAAWhoC,QAAQ,GAEjCnE,KAAKmrC,eAAe5mC,UAAU+D,EAAOc,EAAM+iC,GAE3C/iC,EAAK7B,IAAM,EACX6B,EAAK0zB,IAAM,EAEX,KAAO32B,aAAamC,EAAOc,EAAM+iC,EAAOnsC,KAAKirC,yBACjD,CAOO,0BAAAmB,G,MACH,OAAsB,QAAf,EAAApsC,KAAKiB,kBAAU,eAAEmxB,sBAAuBpyB,KAAKirC,yBAA2BjrC,KAAKmrC,cACxF,CAEQ,YAAAc,CAAaxxB,EAA+B,KAAM9B,EAAiE,M,MACvH,MAAMpL,EAAQvN,KAAKiB,WACborC,EAAarsC,KAAKgpC,SACxBhpC,KAAKgpC,SAAWhpC,KAAKssC,cAActsC,KAAK+X,IAAK/X,KAAKqqC,eAAWj+B,OAAWA,EAAWpM,KAAKub,eAAgBvb,KAAKsW,QAE7G,MAAMi2B,EAAmB,K,MACrBvsC,KAAK4vB,iBAAiB9c,gBAAgB9S,MAClCqsC,IACAA,EAAWx4B,UACI,QAAf,EAAA7T,KAAKiB,kBAAU,SAAE+oC,wBAAwB,IAEzCvvB,GACAA,G,EAIF+xB,EAAe,CAACpzB,EAAkBd,KACpCtY,KAAKysC,eAAgB,EACrBzsC,KAAK0sC,aAAe,CAAEtzB,UAASd,aAC3BK,GACAA,EAAQS,EAASd,GAErB,IAAQq0B,6BAA6B75B,gBAAgB9S,KAAK,EAGzDA,KAAKgpC,SAkCFhpC,KAAKgpC,SAASlqB,QACd,KAAM8tB,cAAa,IAAML,MAEzBvsC,KAAKgpC,SAASjqB,mBAAmBoK,KAAI,IAAMojB,OApC3CvsC,KAAK6rC,aACL7rC,KAAKgpC,SAAWhpC,KAAK6sC,aAAcC,6BAC/B9sC,KAAK+X,IACLxK,EACAvN,KAAK6qC,UACL7qC,KAAK8qC,WACLrwB,EACA+xB,EACAxsC,KAAKkrC,QACLlrC,KAAKsqC,iBACLtqC,KAAKorC,oBAGTprC,KAAKgpC,SAAWhpC,KAAK6sC,aAAcxvB,kBAC/Brd,KAAK+X,IACLxK,EACAvN,KAAK+b,OACL/b,KAAKqqC,UACL5vB,EACA+xB,EACAxsC,KAAKkrC,QACLlrC,KAAKsqC,kBACL,EACAtqC,KAAK6qC,UACL7qC,KAAK8qC,WACL,KACA9qC,KAAKqrC,iBACHrrC,KAAKub,gBAIF,QAAb,EAAAvb,KAAKgpC,gBAAQ,SAAEjqB,mBAAmBoK,KAAI,IAAMnpB,KAAK4vB,iBAAiB9c,gBAAgB9S,QAQ1F,CASO,YAAOqV,CAAM03B,EAAoBx/B,EAAcgN,GAClD,MAAM1B,EAAU,KAAoBxD,OAChC,K,MACI,IAAIk2B,GAAuB,EAI3B,OAHIwB,EAAcxB,cACdA,EAAcwB,EAAcxB,aAEzB,IAAI3B,EACPrvB,GAA4B,QAAjB,EAAAwyB,EAAch1B,WAAG,QAAIg1B,EAActsC,MAC9C8M,EACAw/B,EAAcnC,YACd,EACAmC,EAAcr0B,OAAS,KACvB,KACA,UACAtM,EACAm/B,EACAwB,EAAcpyB,gBACjB,GAELoyB,EACAx/B,GAYJ,GARIw/B,EAAchC,sBACdlyB,EAAQkyB,oBAAsB,IAAQx1B,UAAUw3B,EAAchC,sBAE9DgC,EAAclD,kBACdhxB,EAAQgxB,gBAAkB,IAAQt0B,UAAUw3B,EAAclD,kBAI1DkD,EAAc3rC,WACd,IAAK,IAAI4rC,EAAiB,EAAGA,EAAiBD,EAAc3rC,WAAWoF,OAAQwmC,IAAkB,CAC7F,MAAMC,EAAkBF,EAAc3rC,WAAW4rC,GAC3CE,GAAgB,OAAS,qBAC3BA,GACAr0B,EAAQzX,WAAWgB,KAAK8qC,EAAc73B,MAAM43B,G,CAKxD,OAAOp0B,CACX,CAMO,KAAAlX,GACH,IAAIyL,EAAW,EAEf,MAAM+/B,EAAiB,KAAoB1K,OAAM,KAC7C,MAAM2K,EAAc,IAAIxD,EAAY5pC,KAAK+X,IAAK/X,KAAKiB,YAAcjB,KAAK6sC,aAAe7sC,KAAKgrC,YAAahrC,KAAKqqC,UAAWrqC,KAAK+b,QAG5H,OAFA3O,EAAWggC,EAAYhgC,SAEhBggC,CAAW,GACnBptC,MAIH,OAFAmtC,EAAe//B,SAAWA,EAEnB+/B,CACX,GAzdO,UADN,W,2BASM,UADN,W,2CA0BD,UADC,W,qCAWD,UADC,QAAU,c,+BAuBJ,UADN,QAAU,U,8BAID,UADT,QAAU,oB,wCAWH,UADP,QAAU,e,mCAIH,UADP,QAAkB,kB,sCAIX,UADP,QAAkB,4B,+CAyYvB,IAAQE,mBAAqBzD,EAAYv0B,OAEzC,OAAc,sBAAuBu0B,E,6FC3e9B,MAAM0D,UAAsB,IAW/B,aAAWC,CAAUptC,GACbH,KAAKwtC,aAAertC,IAIxBH,KAAKwtC,WAAartC,EAClBH,KAAKytC,wBACT,CAEA,aAAWF,GACP,OAAOvtC,KAAKwtC,UAChB,CAMA,sBAAW5iB,CAAmBzqB,GAC1BH,KAAK0tC,oBAAsBvtC,EAC3BH,KAAK2tC,wBACT,CAMA,cAAWC,CAAWztC,GAClBH,KAAK6tC,YAAc1tC,EACnBH,KAAK8tC,YAAc3tC,CACvB,CAMA,eAAW0tC,CAAY1tC,GACfH,KAAK+tC,eAAiB5tC,IAI1BH,KAAK+tC,aAAe5tC,EACpBH,KAAKytC,wBACT,CAEA,eAAWI,GACP,OAAO7tC,KAAK+tC,YAChB,CAMA,eAAWD,CAAY3tC,GACfH,KAAKguC,eAAiB7tC,IAI1BH,KAAKguC,aAAe7tC,EACpBH,KAAKytC,wBACT,CAEA,eAAWK,GACP,OAAO9tC,KAAKguC,YAChB,CAEQ,sBAAAL,GACJ,MAAMrb,EAAStyB,KAAKiB,WAAYqN,YAE1B2/B,EAAKjuC,KAAKkuC,iBAAmB5b,EAAO4b,iBACpCC,EAAKnuC,KAAKouC,kBAAoB9b,EAAO8b,kBAC3CpuC,KAAK6tC,YAAc7tC,KAAK0tC,oBAAsBO,EAC9CjuC,KAAK8tC,YAAc9tC,KAAK0tC,oBAAsBS,CAClD,CAEU,eAAAE,GACFruC,KAAKsuC,aACLtuC,KAAKuuC,OAAOvuC,KAAKwuC,uBACZxuC,KAAK0tC,qBACN1tC,KAAKytC,yBAITztC,KAAK0tC,qBACL1tC,KAAK2tC,wBAEb,CAEQ,iBAAAc,GACJ,MAAMlhC,EAAQvN,KAAKiB,WAEdsM,IAILvN,KAAKgqB,YAAczc,EAAMoa,6BAA6B+mB,YAAcnhC,EAAMoa,6BAA6BgnB,mBAC3G,CA+BA,WAAAnuC,CACIC,EACAwV,EACA1I,EACA6N,EACAkF,EAAe,IAAU,0BACZ,GAAU,GAOvB,GAJAtf,MAAMP,EAAMwV,EAAM1I,EAAO6N,GAAiB,EAAMkF,GAAM,EAAOpG,EAAc00B,GA5IxE,KAAAtkB,YAAc,IAAI,IAAM,EAAG,EAAG,EAAG,GAwGhC,KAAAukB,iBAAmB,KAAO3oC,OAC1B,KAAA4oC,cAAgB,KAAO5oC,OAIvB,KAAAwnC,oBAAsB,EACtB,KAAAK,aAAe,EACf,KAAAC,aAAe,EACf,KAAAR,WAAa,IA8BjBjgC,EAAevN,KAAKiB,YAGhB,OAAOjB,KAEXA,KAAK+uC,sBAAuB,EAE5B/uC,KAAKyuC,oBACLzuC,KAAKgvC,qCAAuCzhC,EAAMoa,6BAA6B2Q,mBAAmBnP,KAAI,KAClGnpB,KAAKyuC,mBAAmB,IAG5B,MAAMnc,EAAS/kB,EAAMe,YAcrB,IAAI2gC,EAZA3c,EAAO4c,yBACPlvC,KAAKmvC,UAAY5hC,EAAM6hC,yBAAyB,mCAAmC3uC,QAGvFT,KAAKqvC,uBAAuBlmB,KAAI,K,MACN,QAAtB,EAAAmJ,EAAOgd,uBAAe,gBAAG,yBAAyB7uC,IAAQ,EAAE,IAGhET,KAAKuvC,wBAAwBpmB,KAAI,K,MACR,QAArB,EAAAmJ,EAAOkd,sBAAc,gBAAG,EAAE,IAK9BxvC,KAAKyvC,yBAAyBtmB,KAAI,KAC1BnpB,KAAKmvC,YACLnvC,KAAK0vC,iBAAmBniC,EAAOoiC,wBAC/BpiC,EAAOqiC,sBAAsB5vC,KAAKmvC,WAClC5hC,EAAOoiC,wBAAwBE,gBAGnC,KAAOC,gBAAgB9vC,KAAKsqB,YAAatqB,KAAK8uC,eAC9C9uC,KAAK8uC,cAAcxoC,cAAciH,EAAOwiC,gBAAiB/vC,KAAK6uC,kBAE9DthC,EAAOyiC,mBAAmBhwC,KAAK6uC,iBAAkBthC,EAAO0iC,uBAExDhB,EAAgB1hC,EAAO2iC,UACvB3iC,EAAO2iC,UAAYlwC,KAAKsqB,YAExB/c,EAAO4iC,wBAA0B,IAAQC,qBAA8B7iC,EAAOyb,aAAcqnB,eAAgBrwC,KAAK8uC,cAAc,IAGnI9uC,KAAKswC,wBAAwBnnB,KAAI,KACzBnpB,KAAKmvC,WACL5hC,EAAOqiC,sBAAsB5vC,KAAK0vC,kBAEtCniC,EAAOgjC,wBACPhjC,EAAO4iC,wBAA0B,KAEjC5iC,EAAO2iC,UAAYjB,CAAa,GAExC,CAEQ,qBAAAxB,GAGJ,GAFAztC,KAAKwwC,oBAAmB,GAEpBxwC,KAAK+tC,cAAgB/tC,KAAKguC,aAAc,CACxC,MAAM1b,EAAiBtyB,KAAKiB,WAAYqN,YAElC6Q,EACFmT,EAAO/jB,UAAUkU,oBAAsB6P,EAAO/jB,UAAU+T,4BAA8B,IAE1FtiB,KAAKywC,OAAS,IAAI,IACd,kBACA,IAAI,KAAQ,EAAK,GACjBzwC,KAAK+tC,aACL/tC,KAAKwtC,WACL,KACA,IAAQnjB,sBACRiI,GACA,EACAnT,GAEJnf,KAAKywC,OAAOC,WAAY,EAEA,IAApB1wC,KAAKwtC,YAAoBxtC,KAAK2wC,QAAU,GAAK3wC,KAAKgpC,SAClDhpC,KAAKywC,OAAOG,aAAe5wC,KAAK6wC,cAEhC7wC,KAAKywC,OAAOK,gBAAiB,EAGjC9wC,KAAK+wC,OAAS,IAAI,IACd,gBACA,IAAI,KAAQ,EAAG,GACf/wC,KAAKguC,aACLhuC,KAAKwtC,WACL,KACA,IAAQnjB,sBACRiI,GACA,EACAnT,GAEJnf,KAAK+wC,OAAOL,WAAY,EACxB1wC,KAAK+wC,OAAOD,eAAqC,IAApB9wC,KAAKwtC,WAElCxtC,KAAKgxC,eAAehxC,KAAKywC,QACzBzwC,KAAKgxC,eAAehxC,KAAK+wC,O,MAErB/wC,KAAK+wC,SACL/wC,KAAKixC,kBAAkBjxC,KAAK+wC,QAC5B/wC,KAAK+wC,OAAOl9B,UACZ7T,KAAK+wC,OAAS,MAEd/wC,KAAKywC,SACLzwC,KAAKixC,kBAAkBjxC,KAAKywC,QAC5BzwC,KAAKywC,OAAO58B,UACZ7T,KAAKywC,OAAS,KAG1B,CAMO,KAAA9uC,GACH,MAAM4L,EAAQvN,KAAKiB,WAEnB,IAAKsM,EACD,OAAOvN,KAGX,MAAMkxC,EAAclxC,KAAK2T,UACnBw9B,EAAa,IAAI7D,EACnBttC,KAAKS,KACLywC,EAAYt9B,MACZrG,EACAvN,KAAKoxC,qBAAqBh2B,gBAC1Bpb,KAAKoxC,qBAAqB9wB,KAC1BtgB,KAAKoxC,qBAAqBl3B,aAC1Bla,KAAKoxC,qBAAqBxC,qBAa9B,OATAuC,EAAWlnB,SAAWjqB,KAAKiqB,SAC3BknB,EAAWruB,MAAQ9iB,KAAK8iB,MAGxBquB,EAAW7mB,YAActqB,KAAKsqB,YAAY3oB,QACtC3B,KAAK2mB,aACLwqB,EAAWxqB,WAAa3mB,KAAK2mB,WAAW0qB,MAAM,IAG3CF,CACX,CAMO,SAAAx8B,GACH,IAAK3U,KAAKS,KACN,OAAO,KAGX,MAAMmU,EAAsB5T,MAAM2T,YAIlC,OAFAC,EAAoB0V,YAActqB,KAAKsqB,YAAYzV,UAE5CD,CACX,CAKO,OAAAf,G,MACH7S,MAAM6S,UACN,MAAMtG,EAAQvN,KAAKiB,WAEfsM,GACAA,EAAMoa,6BAA6B2Q,mBAAmBC,OAAOv4B,KAAKgvC,sCAExD,QAAd,EAAAhvC,KAAKmvC,iBAAS,SAAEt7B,SACpB,EAGJ,IAAQy9B,cAAgB,CAAC7wC,EAAc8wC,EAA0BhkC,EAAc6N,IACpE,IAAIkyB,EAAc7sC,EAAM8wC,EAAkBhkC,EAAO6N,E,0DC/UrD,MAAMo2B,UAAmB,IAkB5B,WAAAhxC,CACIkV,EACA9B,EACA8J,EAIOhD,EACPiwB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAU,OAKjClZ,MAAM,KAAM2pC,GAAgBvvB,EAAiBwE,OAASxT,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,EAAW0V,GATvI,KAAApH,OAAAA,EAWF1a,KAAKyxC,UAILzxC,KAAKyxC,QAAQj2B,MAAM8G,6BAAwC,IAAThC,IACnDpG,EAAe,GAEdla,KAAKyxC,QAAQj2B,MAAMgH,iCAA4C,IAATlC,IACvDpG,EAAe,GAGnBla,KAAKgpC,SAAWhpC,KAAKyxC,QAAQ5vB,iBAAiBnM,EAAM9B,EAAO8J,EAAQhD,EAAQU,EAAiBwE,EAAS1F,EAAc,KAAMoG,EAAMwB,QAAAA,EAAiB,EAAG5G,SAAAA,GAEnJlb,KAAKwqB,MAAQ,IAAQL,kBACrBnqB,KAAKyqB,MAAQ,IAAQN,kBACzB,CAMO,MAAApW,CAAO2B,GACV1V,KAAK6sC,aAAcnrB,iBAAiB1hB,KAAKgpC,SAAUtzB,EAAM1V,KAAKgpC,SAAUtuB,OAAQ1a,KAAKgpC,SAAUppB,QAAS,KAAM5f,KAAKgpC,SAAU1oB,KAAMtgB,KAAKgpC,SAAUztB,eACtJ,CAaO,6BAAOm2B,CACVh8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,GAEvB,OAAO,IAAIs3B,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAyB,IAClF,CAaO,kCAAOi0B,CACVj8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,GAEvB,OAAO,IAAIs3B,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,IAA+B,EACxF,CAaO,yBAAOk0B,CACVl8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,GAEvB,OAAO,IAAIs3B,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAqB,EAAa,EAC3F,CAgBO,uBAAOm0B,CACVn8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAU,SACjC,GAIA,OAAO,IAAIs3B,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAmB,EAAe,IAAiB,EAAS,EACrH,CAgBO,wBAAO5J,CACV4B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAU,SACjC,GAIA,OAAO,IAAIs3B,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAoB,EAAa,EAAE,EAAiB,EAAS,EACtH,CAeO,+BAAOo0B,CACVp8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAU,QAIjC,OAAO,IAAIs3B,EACP97B,EACA9B,EACA8J,EACA,IAAU,EACV,EAAa,EACb,EACA,IAMR,CAcO,qBAAOq0B,CACVr8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAQ83B,uBAC/B1xB,EAAe,GAEf,OAAO,IAAIkxB,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAiB,EAAe,EAAe,EACxG,CAcO,4BAAOu0B,CACVv8B,EACA9B,EACA8J,EACAitB,EACAvvB,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAQ83B,uBAC/B1xB,EAAe,GAEf,OAAO,IAAIkxB,EAAW97B,EAAM9B,EAAO8J,EAAQ,IAAU,EAAiB,EAAe,EAAe,EAAE,EAC1G,E,0DCtRG,MAAMw0B,UAA0B,IAMnC,SAAWvyB,GACP,OAAO3f,KAAKmyC,MAChB,CAgBA,WAAA3xC,CACIkV,EACA9B,EACA8J,EACAiC,EAEOjF,EACPnN,EACA6N,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAQ83B,uBAC/B7yB,EAAc,KAGdne,MAAM,KAAMuM,GAAQ6N,EAAiBwE,GAR9B,KAAAlF,OAAAA,EAUP1a,KAAKgpC,SAAWz7B,EAAMe,YAAYoV,wBAAwBhO,EAAM9B,EAAO8J,EAAQiC,EAAOjF,EAAQU,EAAiBwE,EAAS1F,EAAc,KAAMiF,EAAa2C,GAEzJ9hB,KAAKmyC,OAASxyB,EACd3f,KAAKugB,WAAY,CACrB,CAMO,MAAAxM,CAAO2B,GACL1V,KAAKgpC,UAGVhpC,KAAK6sC,aAAcnsB,wBAAwB1gB,KAAKgpC,SAAUtzB,EAAM1V,KAAKgpC,SAAStuB,OAAQ1a,KAAKgpC,SAAUppB,QAAS,KAAM5f,KAAKgpC,SAAS1oB,KACtI,CAeO,wBAAOxM,CACV4B,EACA9B,EACA8J,EACAiC,EACApS,EACA6N,GAA2B,EAC3BwE,GAAmB,EACnB1F,EAAuB,IAAU,GAGjC,OAAO,IAAIg4B,EAAkBx8B,EAAM9B,EAAO8J,EAAQiC,EAAO,IAAU,IAAyB,EAAE,EAClG,E,oEClDJ,MAAMyyB,EAAuB,CACzB/oB,KAAKgpB,KAAK,GAAK,EAAIhpB,KAAKC,MAEvBD,KAAKgpB,KAAK,GAAK,EAAIhpB,KAAKC,KACzBD,KAAKgpB,KAAK,GAAK,EAAIhpB,KAAKC,MACvBD,KAAKgpB,KAAK,GAAK,EAAIhpB,KAAKC,KAEzBD,KAAKgpB,KAAK,IAAM,EAAIhpB,KAAKC,MACxBD,KAAKgpB,KAAK,IAAM,EAAIhpB,KAAKC,KAC1BD,KAAKgpB,KAAK,GAAK,GAAKhpB,KAAKC,MACxBD,KAAKgpB,KAAK,IAAM,EAAIhpB,KAAKC,KAC1BD,KAAKgpB,KAAK,IAAM,GAAKhpB,KAAKC,MAOxBgpB,EAAgC,CAClC,IAAM,EAEL3mB,GAAuBA,EAAUrkB,EACjCqkB,GAAuBA,EAAUpkB,EACjCokB,GAAuBA,EAAUtkB,EAEjCskB,GAAuBA,EAAUtkB,EAAIskB,EAAUrkB,EAC/CqkB,GAAuBA,EAAUrkB,EAAIqkB,EAAUpkB,EAC/CokB,GAAuB,EAAIA,EAAUpkB,EAAIokB,EAAUpkB,EAAI,EACvDokB,GAAuBA,EAAUtkB,EAAIskB,EAAUpkB,EAC/CokB,GAAuBA,EAAUtkB,EAAIskB,EAAUtkB,EAAIskB,EAAUrkB,EAAIqkB,EAAUrkB,GAI1EirC,EAAW,CAACprC,EAAYwkB,IACnBymB,EAAqBjrC,GAAMmrC,EAA8BnrC,GAAIwkB,GAKlE6mB,EAAyB,CAACnpB,KAAKC,GAAK,EAAID,KAAKC,GAAM,EAAI,EAAID,KAAKC,GAAM,EAAI,EAAID,KAAKC,GAAM,EAAGD,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAGD,KAAKC,GAAK,GAKzJ,MAAMmpB,EAAb,cAIW,KAAAC,WAAY,EAKZ,KAAAC,IAAe,IAAQzsC,OAKvB,KAAA0sC,KAAgB,IAAQ1sC,OAKxB,KAAA2sC,IAAe,IAAQ3sC,OAKvB,KAAA4sC,IAAe,IAAQ5sC,OAKvB,KAAA6sC,KAAgB,IAAQ7sC,OAKxB,KAAA8sC,KAAgB,IAAQ9sC,OAKxB,KAAA+sC,IAAe,IAAQ/sC,OAKvB,KAAAgtC,IAAe,IAAQhtC,OAKvB,KAAAitC,IAAe,IAAQjtC,MAiMlC,CAzLW,QAAAktC,CAASznB,EAAoBrE,EAAe+rB,GAC/C,KAAWlvC,QAAQ,GAAGslC,IAAIniB,EAAMG,EAAGH,EAAMI,EAAGJ,EAAM3Y,GAClD,MAAM2kC,EAAc,KAAWnvC,QAAQ,GACjCovC,EAAI,KAAWpvC,QAAQ,GAC7BmvC,EAAYtT,WAAWqT,EAAiBE,GAExCA,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAK2yC,IAAIa,WAAW,KAAWrvC,QAAQ,IAEvCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAK4yC,KAAKY,WAAW,KAAWrvC,QAAQ,IACxCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAK6yC,IAAIW,WAAW,KAAWrvC,QAAQ,IACvCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAK8yC,IAAIU,WAAW,KAAWrvC,QAAQ,IAEvCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAK+yC,KAAKS,WAAW,KAAWrvC,QAAQ,IACxCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAKgzC,KAAKQ,WAAW,KAAWrvC,QAAQ,IACxCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAKizC,IAAIO,WAAW,KAAWrvC,QAAQ,IACvCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAKkzC,IAAIM,WAAW,KAAWrvC,QAAQ,IACvCovC,EAAEvT,WAAWuS,EAAS,EAAG5mB,GAAY,KAAWxnB,QAAQ,IACxDnE,KAAKmzC,IAAIK,WAAW,KAAWrvC,QAAQ,GAC3C,CAMO,YAAAsvC,CAAanrC,GAChBtI,KAAK2yC,IAAIc,aAAanrC,GACtBtI,KAAK4yC,KAAKa,aAAanrC,GACvBtI,KAAK6yC,IAAIY,aAAanrC,GACtBtI,KAAK8yC,IAAIW,aAAanrC,GACtBtI,KAAK+yC,KAAKU,aAAanrC,GACvBtI,KAAKgzC,KAAKS,aAAanrC,GACvBtI,KAAKizC,IAAIQ,aAAanrC,GACtBtI,KAAKkzC,IAAIO,aAAanrC,GACtBtI,KAAKmzC,IAAIM,aAAanrC,EAC1B,CAaO,mCAAAorC,GAEH1zC,KAAK2yC,IAAIc,aAAajB,EAAuB,IAG7CxyC,KAAK4yC,KAAKa,aAAajB,EAAuB,IAC9CxyC,KAAK6yC,IAAIY,aAAajB,EAAuB,IAC7CxyC,KAAK8yC,IAAIW,aAAajB,EAAuB,IAG7CxyC,KAAK+yC,KAAKU,aAAajB,EAAuB,IAC9CxyC,KAAKgzC,KAAKS,aAAajB,EAAuB,IAC9CxyC,KAAKizC,IAAIQ,aAAajB,EAAuB,IAC7CxyC,KAAKkzC,IAAIO,aAAajB,EAAuB,IAC7CxyC,KAAKmzC,IAAIM,aAAajB,EAAuB,GACjD,CAWO,qCAAAmB,GACH3zC,KAAKyzC,aAAa,EAAMpqB,KAAKC,GAIjC,CASO,oBAAAsqB,GACH5zC,KAAK0yC,WAAY,EAEjB1yC,KAAK2yC,IAAIc,aAAarB,EAAqB,IAE3CpyC,KAAK4yC,KAAKa,aAAarB,EAAqB,IAC5CpyC,KAAK6yC,IAAIY,aAAarB,EAAqB,IAC3CpyC,KAAK8yC,IAAIW,aAAarB,EAAqB,IAE3CpyC,KAAK+yC,KAAKU,aAAarB,EAAqB,IAC5CpyC,KAAKgzC,KAAKS,aAAarB,EAAqB,IAC5CpyC,KAAKizC,IAAIQ,aAAarB,EAAqB,IAC3CpyC,KAAKkzC,IAAIO,aAAarB,EAAqB,IAC3CpyC,KAAKmzC,IAAIM,aAAarB,EAAqB,GAC/C,CAOO,eAAAyB,CAAgBn+B,GAUnB,OATA,IAAQo+B,eAAep+B,EAAK,GAAI,EAAG1V,KAAK2yC,KACxC,IAAQmB,eAAep+B,EAAK,GAAI,EAAG1V,KAAK4yC,MACxC,IAAQkB,eAAep+B,EAAK,GAAI,EAAG1V,KAAK6yC,KACxC,IAAQiB,eAAep+B,EAAK,GAAI,EAAG1V,KAAK8yC,KACxC,IAAQgB,eAAep+B,EAAK,GAAI,EAAG1V,KAAK+yC,MACxC,IAAQe,eAAep+B,EAAK,GAAI,EAAG1V,KAAKgzC,MACxC,IAAQc,eAAep+B,EAAK,GAAI,EAAG1V,KAAKizC,KACxC,IAAQa,eAAep+B,EAAK,GAAI,EAAG1V,KAAKkzC,KACxC,IAAQY,eAAep+B,EAAK,GAAI,EAAG1V,KAAKmzC,KACjCnzC,IACX,CAOO,qBAAA+zC,CAAsBr+B,GAUzB,OATA,IAAQs+B,gBAAgBt+B,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI1V,KAAK2yC,KACxD,IAAQqB,gBAAgBt+B,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI1V,KAAK4yC,MACxD,IAAQoB,gBAAgBt+B,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI1V,KAAK6yC,KACxD,IAAQmB,gBAAgBt+B,EAAK,GAAIA,EAAK,IAAKA,EAAK,IAAK1V,KAAK8yC,KAC1D,IAAQkB,gBAAgBt+B,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK1V,KAAK+yC,MAC3D,IAAQiB,gBAAgBt+B,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK1V,KAAKgzC,MAC3D,IAAQgB,gBAAgBt+B,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK1V,KAAKizC,KAC3D,IAAQe,gBAAgBt+B,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK1V,KAAKkzC,KAC3D,IAAQc,gBAAgBt+B,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK1V,KAAKmzC,KACpDnzC,IACX,CAOO,gBAAOuV,CAAUG,GAEpB,OADW,IAAI+8B,GACLoB,gBAAgBn+B,EAC9B,CAQO,qBAAOu+B,CAAeC,GACzB,MAAMnrC,EAAS,IAAI0pC,EAmBnB,OAjBA1pC,EAAO4pC,IAAMuB,EAAWC,GAAG7rC,MAAM,SAAU6gB,IAAI+qB,EAAWE,GAAG9rC,MAAM,UAAW6gB,IAAI+qB,EAAWG,GAAG/rC,MAAM,UACtGS,EAAO6pC,KAAOsB,EAAW5sC,EAAEgB,MAAM,SACjCS,EAAO8pC,IAAMqB,EAAW3sC,EAAEe,MAAM,SAChCS,EAAO+pC,IAAMoB,EAAW7sC,EAAEiB,MAAM,SAChCS,EAAOgqC,KAAOmB,EAAWI,GAAGhsC,MAAM,SAClCS,EAAOiqC,KAAOkB,EAAWK,GAAGjsC,MAAM,SAClCS,EAAOkqC,IAAMiB,EAAWG,GAAG/rC,MAAM,SAASygB,SAASmrB,EAAWC,GAAG7rC,MAAM,UAAWygB,SAASmrB,EAAWE,GAAG9rC,MAAM,UAC/GS,EAAOmqC,IAAMgB,EAAWM,GAAGlsC,MAAM,SACjCS,EAAOoqC,IAAMe,EAAWC,GAAG7rC,MAAM,SAASygB,SAASmrB,EAAWE,GAAG9rC,MAAM,UAEvES,EAAO6pC,KAAKa,cAAc,GAC1B1qC,EAAO+pC,IAAIW,cAAc,GACzB1qC,EAAOiqC,KAAKS,cAAc,GAC1B1qC,EAAOmqC,IAAIO,cAAc,GAEzB1qC,EAAO0qC,aAAapqB,KAAKC,IAElBvgB,CACX,EAMG,MAAM0rC,EAAb,cAmBW,KAAAptC,EAAa,IAAQnB,OAKrB,KAAAoB,EAAa,IAAQpB,OAKrB,KAAAqB,EAAa,IAAQrB,OAKrB,KAAAiuC,GAAc,IAAQjuC,OAKtB,KAAAkuC,GAAc,IAAQluC,OAKtB,KAAAmuC,GAAc,IAAQnuC,OAKtB,KAAAouC,GAAc,IAAQpuC,OAKtB,KAAAquC,GAAc,IAAQruC,OAKtB,KAAAsuC,GAAc,IAAQtuC,MA+FjC,CApJI,sBAAWwuC,GAOP,OANK10C,KAAK20C,aACN30C,KAAK20C,WAAalC,EAAmBwB,eAAej0C,OAEnDA,KAAK20C,WAAWjC,WACjB1yC,KAAK20C,WAAWf,uBAEb5zC,KAAK20C,UAChB,CAmDO,UAAAC,CAAWttB,GACd,KAAWnjB,QAAQ,GAAG0wC,eAAevtB,EAAMG,EAAGH,EAAMI,EAAGJ,EAAM3Y,GAC7D,MAAM2kC,EAAc,KAAWnvC,QAAQ,GACvCnE,KAAKm0C,GAAGX,WAAWF,GACnBtzC,KAAKo0C,GAAGZ,WAAWF,GACnBtzC,KAAKq0C,GAAGb,WAAWF,EACvB,CAMO,YAAAG,CAAanrC,GAChBtI,KAAKqH,EAAEosC,aAAanrC,GACpBtI,KAAKsH,EAAEmsC,aAAanrC,GACpBtI,KAAKuH,EAAEksC,aAAanrC,GACpBtI,KAAKm0C,GAAGV,aAAanrC,GACrBtI,KAAKo0C,GAAGX,aAAanrC,GACrBtI,KAAKq0C,GAAGZ,aAAanrC,GACrBtI,KAAKu0C,GAAGd,aAAanrC,GACrBtI,KAAKw0C,GAAGf,aAAanrC,GACrBtI,KAAKs0C,GAAGb,aAAanrC,EACzB,CAOO,mBAAAwsC,CAAoBC,GA6BvB,OA5BA/0C,KAAK20C,WAAaI,EAElB/0C,KAAKqH,EAAE/G,SAASy0C,EAAUjC,KAC1B9yC,KAAKqH,EAAEosC,aAAa,SAASA,cAAc,GAC3CzzC,KAAKsH,EAAEhH,SAASy0C,EAAUnC,MAC1B5yC,KAAKsH,EAAEmsC,aAAa,SAASA,cAAc,GAC3CzzC,KAAKuH,EAAEjH,SAASy0C,EAAUlC,KAC1B7yC,KAAKuH,EAAEksC,aAAa,SAEpBzzC,KAAKm0C,GAAG7zC,SAASy0C,EAAUpC,KAC3B,KAAWxuC,QAAQ,GAAG7D,SAASy0C,EAAU9B,KAAKQ,aAAa,SAC3D,KAAWtvC,QAAQ,GAAG7D,SAASy0C,EAAU5B,KAAKM,aAAa,SAC3DzzC,KAAKm0C,GAAGV,aAAa,SAAUuB,gBAAgB,KAAW7wC,QAAQ,IAAIqvC,WAAW,KAAWrvC,QAAQ,IACpGnE,KAAKo0C,GAAG9zC,SAASy0C,EAAUpC,KAC3B3yC,KAAKo0C,GAAGX,aAAa,SAAUuB,gBAAgB,KAAW7wC,QAAQ,IAAI6wC,gBAAgB,KAAW7wC,QAAQ,IACzGnE,KAAKq0C,GAAG/zC,SAASy0C,EAAUpC,KAC3B,KAAWxuC,QAAQ,GAAG7D,SAASy0C,EAAU9B,KAAKQ,aAAa,SAC3DzzC,KAAKq0C,GAAGZ,aAAa,SAAUD,WAAW,KAAWrvC,QAAQ,IAE7DnE,KAAKu0C,GAAGj0C,SAASy0C,EAAU/B,MAC3BhzC,KAAKu0C,GAAGd,aAAa,SAAUA,cAAc,GAC7CzzC,KAAKw0C,GAAGl0C,SAASy0C,EAAU7B,KAC3BlzC,KAAKw0C,GAAGf,aAAa,SAAUA,cAAc,GAC7CzzC,KAAKs0C,GAAGh0C,SAASy0C,EAAUhC,MAC3B/yC,KAAKs0C,GAAGb,aAAa,SAErBzzC,KAAKyzC,aAAa,EAAMpqB,KAAKC,IAEtBtpB,IACX,CAOO,oBAAOi1C,CAAcF,GAExB,OADe,IAAIN,GACLK,oBAAoBC,EACtC,CAOO,gBAAOx/B,CAAUG,GACpB,MAAMw/B,EAAK,IAAIT,EAUf,OATA,IAAQX,eAAep+B,EAAK,GAAI,EAAGw/B,EAAG7tC,GACtC,IAAQysC,eAAep+B,EAAK,GAAI,EAAGw/B,EAAG5tC,GACtC,IAAQwsC,eAAep+B,EAAK,GAAI,EAAGw/B,EAAG3tC,GACtC,IAAQusC,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGf,IACtC,IAAQL,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGd,IACtC,IAAQN,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGb,IACtC,IAAQP,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGX,IACtC,IAAQT,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGV,IACtC,IAAQV,eAAep+B,EAAK,GAAI,EAAGw/B,EAAGZ,IAC/BY,CACX,E,4ECpXJ,KAAKn/B,UAAUo/B,gBAAkB,SAAU1xC,EAA0E2xC,GAAmB,GACpI,IAAKp1C,KAAKiB,WAAWqN,YAAYC,UAAU8mC,gBAEvC,OADA,IAAO7+B,MAAM,+FACL,EAGZxW,KAAKs1C,8BAA8B,SAAUn0C,MAAMo0C,QAAQ9xC,GAAUA,EAAO+C,OAAS,GAErF,MAAMzF,EAAQf,KAAKw1C,yBAAyBC,eAE5C,GAAIt0C,MAAMo0C,QAAQ9xC,GACd,IAAK,IAAI8H,EAAI,EAAGA,EAAI9H,EAAO+C,SAAU+E,EACjCvL,KAAK01C,wBAAwB11C,KAAKw1C,yBAAyBC,iBAAkBhyC,EAAO8H,GAAIA,IAAM9H,EAAO+C,OAAS,GAAK4uC,QAGvHp1C,KAAK01C,wBAAwB11C,KAAKw1C,yBAAyBC,iBAAkBhyC,EAAQ2xC,GAGzF,OAAOr0C,CACX,EAEA,KAAKgV,UAAU4/B,oBAAsB,SAAUP,GAAmB,GAC9D,OAAOp1C,KAAKm1C,gBAAgB,KAAOS,iBAAkBR,EACzD,EAEA,KAAKr/B,UAAU8/B,8BAAgC,SAAUC,EAAcC,GAE/DD,IAAS,IAAaE,YACtBF,EAAO,IAAaG,mBAGxBj2C,KAAKk2C,mBAAmBJ,GAExB91C,KAAKm2C,qCAELn2C,KAAKo2C,gCAAgCC,QAAQP,GAAQC,EACrD/1C,KAAKo2C,gCAAgCE,MAAMR,GAAQC,EAAS1sB,KAAKP,IAAI,GAAI9oB,KAAKw1C,yBAAyBC,gBACvGz1C,KAAKo2C,gCAAgC1gC,KAAKogC,GAAQ,IAAIviC,aAAavT,KAAKo2C,gCAAgCE,MAAMR,IAC9G91C,KAAKo2C,gCAAgCG,cAAcT,GAAQ,IAAI,IAAa91C,KAAKsO,YAAatO,KAAKo2C,gCAAgC1gC,KAAKogC,GAAOA,GAAM,GAAM,EAAOC,GAAQ,GAE1K/1C,KAAKw2C,kBAAkBx2C,KAAKo2C,gCAAgCG,cAAcT,GAC9E,EAEA,KAAK//B,UAAU2/B,wBAA0B,SAAU30C,EAAe0C,EAAqC2xC,GAAmB,GACtH,IAAKp1C,KAAKw1C,yBAAyBiB,YAAc11C,GAASf,KAAKw1C,yBAAyBC,eACpF,OAAO,EAGX,MAAMgB,EAAaz2C,KAAKw1C,yBAAyBiB,WAgBjD,OAdAhzC,EAAOwP,YAAYwjC,EAAoB,GAAR11C,GAE3Bf,KAAKw1C,yBAAyBkB,gBAC9B12C,KAAKw1C,yBAAyBkB,cAAc31C,GAAS0C,GAGrD2xC,IACAp1C,KAAK22C,0BAA0B,UAE1B32C,KAAK42C,uBACN52C,KAAK62C,iCAAgC,KAItC,CACX,EAEA,KAAK9gC,UAAU+gC,2BAA6B,SAAUhB,EAAc/0C,EAAeZ,EAAsBi1C,GAAmB,GAMxH,OAJIU,IAAS,IAAaE,YACtBF,EAAO,IAAaG,sBAGnBj2C,KAAKo2C,kCAAoCp2C,KAAKo2C,gCAAgC1gC,KAAKogC,IAAS/0C,GAASf,KAAKw1C,yBAAyBC,iBAIxIz1C,KAAKs1C,8BAA8BQ,EAAM,GAEzC91C,KAAKo2C,gCAAgC1gC,KAAKogC,GAAMrM,IAAItpC,EAAOY,EAAQf,KAAKo2C,gCAAgCC,QAAQP,IAE5GV,GACAp1C,KAAK22C,0BAA0Bb,GAG5B,GACX,EAEAxmC,OAAO85B,eAAe,KAAKrzB,UAAW,oBAAqB,CACvDszB,IAAK,WACD,OAAOrpC,KAAKw1C,yBAAyBC,cACzC,EACAhM,IAAK,SAAsBtpC,G,QACvB,MAAMs2C,EAAqD,QAAxC,EAAAz2C,KAAKw1C,yBAAyBiB,kBAAU,QAAe,QAAX,EAAAz2C,KAAKwQ,cAAM,eAAEglC,yBAAyBiB,WAGjGt2C,IAFoBs2C,EAAaA,EAAWjwC,OAAS,GAAK,KAG1DxG,KAAKw1C,yBAAyBC,eAAiBt1C,EAEvD,EACAupC,YAAY,EACZC,cAAc,IAGlB,KAAK5zB,UAAUghC,gCAAkC,SAAUjB,EAAckB,EAAsBC,GAAwB,GAE/GnB,IAAS,IAAaE,YACtBF,EAAO,IAAaG,mBAGxB,MAAMiB,EAAe,IAAI,IAAOl3C,KAAKsO,YAAa0oC,GAASC,EAAc,IAAI,GAAO,GAEpF,IAAK,IAAI1rC,EAAI,EAAGA,EAAI,EAAGA,IACnBvL,KAAKw2C,kBAAkBU,EAAaC,mBAAmBrB,EAAOvqC,EAAO,EAAJA,EAAO,IAG5E,OAAO2rC,CACX,EAEA,KAAKnhC,UAAUqhC,sBAAwB,SAAUtB,EAAckB,EAAgCjB,EAAiB,EAAGkB,GAAwB,G,UACvIlB,EAASA,GAAU,GAEN,WAATD,GAC0C,QAA1C,EAAA91C,KAAKw1C,yBAAyB0B,oBAAY,SAAErjC,UAC5C7T,KAAKw1C,yBAAyB0B,aAAe,KAC7Cl3C,KAAKw1C,yBAAyB6B,iBAAmBL,EAASA,EAAOxwC,OAAS,GAAKuvC,EAC/E/1C,KAAKw1C,yBAAyBiB,WAAaO,EAC3Ch3C,KAAKw1C,yBAAyBkB,cAAgB,KAE/B,OAAXM,GACAh3C,KAAKw1C,yBAAyBC,eAAiBuB,EAAOxwC,OAASuvC,EAC/D/1C,KAAKw1C,yBAAyB0B,aAAel3C,KAAK+2C,gCAAgC,QAASC,EAAQC,GAE9Fj3C,KAAK42C,uBACN52C,KAAK62C,iCAAgC,KAGzC72C,KAAKw1C,yBAAyBC,eAAiB,EAC1Cz1C,KAAK42C,uBAEN52C,KAAKs3C,wBAGG,mBAATxB,GAC2C,QAAlD,EAAA91C,KAAKw1C,yBAAyB+B,4BAAoB,SAAE1jC,UACpD7T,KAAKw1C,yBAAyB+B,qBAAuB,KACrDv3C,KAAKw1C,yBAAyBgC,mBAAqBR,EACpC,OAAXA,IACAh3C,KAAKw1C,yBAAyB+B,qBAAuBv3C,KAAK+2C,gCAAgC,gBAAiBC,EAAQC,MAKnHnB,IAAS,IAAaE,YACtBF,EAAO,IAAaG,mBAGT,OAAXe,GACwC,QAApC,EAAAh3C,KAAKo2C,uCAA+B,eAAE1gC,KAAKogC,MAC3C91C,KAAKk2C,mBAAmBJ,UACjB91C,KAAKo2C,gCAAgC1gC,KAAKogC,UAC1C91C,KAAKo2C,gCAAgCC,QAAQP,UAC7C91C,KAAKo2C,gCAAgCE,MAAMR,UAC3C91C,KAAKo2C,gCAAgCG,cAAcT,KAG9D91C,KAAKm2C,qCAELn2C,KAAKo2C,gCAAgC1gC,KAAKogC,GAAQkB,EAClDh3C,KAAKo2C,gCAAgCC,QAAQP,GAAQC,EACrD/1C,KAAKo2C,gCAAgCE,MAAMR,GAAQkB,EAAOxwC,OAC1DxG,KAAKo2C,gCAAgCG,cAAcT,GAAQ,IAAI,IAAa91C,KAAKsO,YAAa0oC,EAAQlB,GAAOmB,GAAc,EAAOlB,GAAQ,GAE1I/1C,KAAKw2C,kBAAkBx2C,KAAKo2C,gCAAgCG,cAAcT,KAGtF,EAEA,KAAK//B,UAAU4gC,0BAA4B,SAAUb,G,UACpC,WAATA,EAC0C,QAA1C,EAAA91C,KAAKw1C,yBAAyB0B,oBAAY,SAAEO,eAAez3C,KAAKw1C,yBAAyBiB,WAAa,EAAGz2C,KAAKw1C,yBAAyBC,gBACvH,mBAATK,EAC2C,QAAlD,EAAA91C,KAAKw1C,yBAAyB+B,4BAAoB,SAAEE,eAAez3C,KAAKw1C,yBAAyBgC,mBAAqB,EAAGx3C,KAAKw1C,yBAAyBC,iBAGnJK,IAAS,IAAaE,YACtBF,EAAO,IAAaG,oBAGgB,QAApC,EAAAj2C,KAAKo2C,uCAA+B,eAAEG,cAAcT,KACpD91C,KAAKo2C,gCAAgCG,cAAcT,GAAO2B,eAAez3C,KAAKo2C,gCAAgC1gC,KAAKogC,GAAO,GAGtI,EAEA,KAAK//B,UAAU2hC,gCAAkC,SAAU5B,EAAcpgC,EAAoBiiC,G,MAC5E,WAAT7B,EACI91C,KAAKw1C,yBAAyB0B,cAC9Bl3C,KAAKw1C,yBAAyB0B,aAAaO,eAAe/hC,EAAMiiC,IAIhE7B,IAAS,IAAaE,YACtBF,EAAO,IAAaG,oBAGgB,QAApC,EAAAj2C,KAAKo2C,uCAA+B,eAAEG,cAAcT,KACpD91C,KAAKo2C,gCAAgCG,cAAcT,GAAO2B,eAAe/hC,EAAMiiC,GAG3F,EAEA,KAAK5hC,UAAU6hC,6BAA+B,WAC1C,IAAK53C,KAAKw1C,yBAAyBiB,aAAez2C,KAAKw1C,yBAAyB0B,aAC5E,MAAO,GAEX,MAAMT,EAAaz2C,KAAKw1C,yBAAyBiB,WAEjD,IAAKz2C,KAAKw1C,yBAAyBkB,cAAe,CAC9C12C,KAAKw1C,yBAAyBkB,cAAgB,IAAIv1C,MAElD,IAAK,IAAIoK,EAAI,EAAGA,EAAIvL,KAAKw1C,yBAAyBC,iBAAkBlqC,EAChEvL,KAAKw1C,yBAAyBkB,cAAcnrC,GAAK,KAAOgK,UAAUkhC,EAAgB,GAAJlrC,E,CAItF,OAAOvL,KAAKw1C,yBAAyBkB,aACzC,EAEA,KAAK3gC,UAAU8gC,gCAAkC,SAAUgB,GAAkC,EAAOC,GAAyB,EAAOC,GAAsB,GACtJ,IAAK/3C,KAAKw1C,yBAAyBiB,aAAez2C,KAAKw1C,yBAAyB0B,aAC5E,OAGJ,MAAMc,EAAUh4C,KAAKw1C,yBAAyByC,gBAE9C,GAAIJ,IAA2B73C,KAAKk4C,gBAAiB,CACjDF,EAAQxxC,OAAS,EACjBxG,KAAKs3C,oBAAoBQ,EAAeC,GACxC,MAAMI,EAAen4C,KAAKo4C,kBAC1Bp4C,KAAKk4C,gBAAkB,IAAI,IAAaC,EAAaE,QAASF,EAAaG,Q,CAG/E,MAAMH,EAAen4C,KAAKo4C,kBACpB3B,EAAaz2C,KAAKw1C,yBAAyBiB,WAEjD,GAAuB,IAAnBuB,EAAQxxC,OACR,IAAK,IAAIkrB,EAAI,EAAGA,EAAIymB,EAAaI,YAAYP,QAAQxxC,SAAUkrB,EAC3DsmB,EAAQ51C,KAAK+1C,EAAaI,YAAYP,QAAQtmB,GAAG/vB,SAIzD,KAAWwC,QAAQ,GAAGq0C,OAAOC,OAAOC,mBACpC,KAAWv0C,QAAQ,GAAGq0C,OAAOC,OAAOE,mBAEpC,IAAK,IAAIptC,EAAI,EAAGA,EAAIvL,KAAKw1C,yBAAyBC,iBAAkBlqC,EAAG,CACnE,KAAOuoC,eAAe2C,EAAgB,GAAJlrC,EAAQ,KAAWkI,OAAO,IAE5D,IAAK,IAAIie,EAAI,EAAGA,EAAIsmB,EAAQxxC,SAAUkrB,EAClC,IAAQzpB,0BAA0B+vC,EAAQtmB,GAAI,KAAWje,OAAO,GAAI,KAAWtP,QAAQ,IACvF,KAAWA,QAAQ,GAAGy0C,gBAAgB,KAAWz0C,QAAQ,IACzD,KAAWA,QAAQ,GAAG00C,gBAAgB,KAAW10C,QAAQ,G,CAIjEg0C,EAAaW,YAAY,KAAW30C,QAAQ,GAAI,KAAWA,QAAQ,IAEnEnE,KAAK+4C,qBACT,EAEA,KAAKhjC,UAAUu/B,8BAAgC,SAAUQ,EAAckD,EAAuB,G,UAEtFlD,IAAS,IAAaE,YACtBF,EAAO,IAAaG,mBAGxB,MAAMgD,EAAwB,WAATnD,EAErB,KAAKmD,GAAkBj5C,KAAKo2C,iCAAoCp2C,KAAKo2C,gCAAgCC,QAAQP,IACzG,OAGJ,MAAMC,EAASkD,EAAe,GAAKj5C,KAAKo2C,gCAAgCC,QAAQP,GAC1EoD,EAAcD,EAAej5C,KAAKw1C,yBAAyB6B,iBAAmBr3C,KAAKo2C,gCAAgCE,MAAMR,GAC/H,IAAIpgC,EAAOujC,EAAej5C,KAAKw1C,yBAAyBiB,WAAaz2C,KAAKo2C,gCAAgC1gC,KAAKogC,GAE/G,MAAMqD,GAAcn5C,KAAKw1C,yBAAyBC,eAAiBuD,GAAgBjD,EAEnF,IAAIqD,EAAUF,EAEd,KAAOE,EAAUD,GACbC,GAAW,EAGf,IAAK1jC,GAAQwjC,GAAeE,EAAS,CACjC,GAAK1jC,EAEE,CACH,MAAM2jC,EAAU,IAAI9lC,aAAa6lC,GACjCC,EAAQ5P,IAAI/zB,EAAM,GAClBA,EAAO2jC,C,MAJP3jC,EAAO,IAAInC,aAAa6lC,GAOxBH,GAC0C,QAA1C,EAAAj5C,KAAKw1C,yBAAyB0B,oBAAY,SAAErjC,UAC5C7T,KAAKw1C,yBAAyB0B,aAAel3C,KAAK+2C,gCAAgC,QAASrhC,GAAM,GACjG1V,KAAKw1C,yBAAyBiB,WAAa/gC,EAC3C1V,KAAKw1C,yBAAyB6B,iBAAmB+B,EAC7Cp5C,KAAKiN,OAAOqsC,6BAA+Bt5C,KAAKw1C,yBAAyBgC,qBACvB,QAAlD,EAAAx3C,KAAKw1C,yBAAyB+B,4BAAoB,SAAE1jC,UACpD7T,KAAKw1C,yBAAyB+B,qBAAuBv3C,KAAK+2C,gCAAgC,gBAAiBrhC,GAAM,MAG7D,QAAxD,EAAA1V,KAAKo2C,gCAAgCG,cAAcT,UAAK,SAAEjiC,UAE1D7T,KAAKo2C,gCAAgC1gC,KAAKogC,GAAQpgC,EAClD1V,KAAKo2C,gCAAgCE,MAAMR,GAAQsD,EACnDp5C,KAAKo2C,gCAAgCG,cAAcT,GAAQ,IAAI,IAAa91C,KAAKsO,YAAaoH,EAAMogC,GAAM,GAAM,EAAOC,GAAQ,GAE/H/1C,KAAKw2C,kBAAkBx2C,KAAKo2C,gCAAgCG,cAAcT,I,CAGtF,EAEA,KAAK//B,UAAUogC,mCAAqC,WAC3Cn2C,KAAKo2C,kCACNp2C,KAAKo2C,gCAAkC,CACnC1gC,KAAM,CAAC,EACP4gC,MAAO,CAAC,EACRC,cAAe,CAAC,EAChBF,QAAS,CAAC,GAGtB,EAEA,KAAKtgC,UAAUwjC,iCAAmC,W,OACb,QAA7B,EAAAv5C,KAAKw1C,gCAAwB,eAAE0B,gBAC/Bl3C,KAAKw1C,yBAAyB0B,aAAarjC,UAC3C7T,KAAKw1C,yBAAyB0B,aAAe,KAErD,C,6FC5bA,MAAMsC,EAMF,YAAmB/4C,EAAcg5C,EAA6BC,EAA4BC,GACtF35C,KAAKS,KAAOA,EACZT,KAAKy5C,mBAAqBA,EAC1Bz5C,KAAK05C,kBAAoBA,EACzB15C,KAAK25C,kBAAoBA,CAC7B,EAOG,MAAMC,EAsBF,iDAAOtQ,CAA2CzwB,G,MACrD,IAAKA,EAAQvC,OAET,OAAO,KAGO,QAAlB,EAAAuC,EAAQ5X,kBAAU,SAAEqN,YAAYurC,mBAEhC,MAAM5jC,EAAO4C,EAAQlF,UAAUC,MACzBkmC,EAAejhC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GAC3D4tC,EAAcnhC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GAEhE,IAAI6tC,EACAC,EACArhC,EAAQ2hB,gBACRyf,EAAYphC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GACxD8tC,EAAcrhC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,KAE1D6tC,EAAYphC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GACxD8tC,EAAcrhC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,IAG9D,MAAM+tC,EAAethC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GAC3DguC,EAAcvhC,EAAQkhC,WAAW,OAAG3tC,OAAWA,GAAW,GAE1D4d,EAAanR,EAAQmR,WAG3B,IAAI1J,EAAO,EAKX,OAJ2B,GAAvBzH,EAAQsG,aAA2C,GAA5B,EAAU,cACjCmB,EAAO,GAGJ,IAAI+5B,SAASC,IAChBD,QAAQE,IAAI,CAACP,EAAaF,EAAcG,EAAWC,EAAaC,EAAcC,IAAc7Q,MAAK,EAAEiR,EAAMC,EAAOC,EAAIC,EAAMC,EAAOC,MAC7H,MAAMC,EAAwB,CAC1B7kC,OACAwkC,QACAD,OACAE,KACAC,OACAC,QACAC,OACAngC,OAhBG,EAiBH4F,OACA0J,cAGJswB,EAAQt6C,KAAK+6C,oCAAoCD,GAAU,GAC7D,GAEV,CAQQ,mBAAOE,CAAa3zC,EAAWC,GACnC,OAAO+hB,KAAK4xB,MAAM5zC,EAAIC,EAAG+hB,KAAKgpB,KAAKhrC,EAAIA,EAAIC,EAAIA,EAAI,GACvD,CASO,0CAAOyzC,CAAoCD,GAC9C,MAAMI,EAAqB,IAAI,IAC/B,IAAIC,EAAkB,EAGtB,MAAMC,EAAK,EAAMN,EAAS7kC,KACpBolC,EAAKD,EAELE,EAAY,GAAMF,EAGlBG,EAAQD,EAAY,EAE1B,IAAK,IAAIv4B,EAAY,EAAGA,EAAY,EAAGA,IAAa,CAChD,MAAMy4B,EAAWx7C,KAAKy7C,WAAW14B,GAC3B24B,EAAkBZ,EAAUU,EAAS/6C,MAC3C,IAAIixB,EAAI6pB,EAKR,MAAMxF,EAA6B,IAApB+E,EAASpgC,OAAW,IACnC,IAAK,IAAIpT,EAAI,EAAGA,EAAIwzC,EAAS7kC,KAAM3O,IAAK,CACpC,IAAIkqB,EAAI+pB,EAER,IAAK,IAAIl0C,EAAI,EAAGA,EAAIyzC,EAAS7kC,KAAM5O,IAAK,CAEpC,MAAMs0C,EAAiBH,EAAS9B,kBAAkBpxC,MAAMkpB,GAAGrI,IAAIqyB,EAAS7B,kBAAkBrxC,MAAMopB,IAAIvI,IAAIqyB,EAAS/B,oBACjHkC,EAAe7vC,YAEf,MAAMunC,EACFrzC,KAAKg7C,aAAaxpB,EAAI8pB,EAAW5pB,EAAI4pB,GACrCt7C,KAAKg7C,aAAaxpB,EAAI8pB,EAAW5pB,EAAI4pB,GACrCt7C,KAAKg7C,aAAaxpB,EAAI8pB,EAAW5pB,EAAI4pB,GACrCt7C,KAAKg7C,aAAaxpB,EAAI8pB,EAAW5pB,EAAI4pB,GAEzC,IAAI7zB,EAAIi0B,EAAUp0C,EAAIwzC,EAAS7kC,KAAO8/B,EAAS1uC,EAAI0uC,EAAS,GACxDruB,EAAIg0B,EAAUp0C,EAAIwzC,EAAS7kC,KAAO8/B,EAAS1uC,EAAI0uC,EAAS,GACxDpnC,EAAI+sC,EAAUp0C,EAAIwzC,EAAS7kC,KAAO8/B,EAAS1uC,EAAI0uC,EAAS,GAGxDjrC,MAAM2c,KACNA,EAAI,GAEJ3c,MAAM4c,KACNA,EAAI,GAEJ5c,MAAM6D,KACNA,EAAI,GAIc,IAAlBmsC,EAASx6B,OACTmH,GAAK,IACLC,GAAK,IACL/Y,GAAK,KAILmsC,EAAS9wB,aACTvC,EAAI4B,KAAKuyB,IAAI,IAAOC,MAAMp0B,GAAI,MAC9BC,EAAI2B,KAAKuyB,IAAI,IAAOC,MAAMn0B,GAAI,MAC9B/Y,EAAI0a,KAAKuyB,IAAI,IAAOC,MAAMltC,GAAI,OAKlC,MAAMma,EAAM9oB,KAAK87C,eACjB,GAAI97C,KAAK+7C,wBAAyB,CAC9B,MAAMC,EAAa3yB,KAAKP,IAAIrB,EAAGC,EAAG/Y,GAClC,GAAIqtC,EAAalzB,EAAK,CAClB,MAAMmzB,EAASnzB,EAAMkzB,EACrBv0B,GAAKw0B,EACLv0B,GAAKu0B,EACLttC,GAAKstC,C,OAGTx0B,EAAI,IAAOo0B,MAAMp0B,EAAG,EAAGqB,GACvBpB,EAAI,IAAOm0B,MAAMn0B,EAAG,EAAGoB,GACvBna,EAAI,IAAOktC,MAAMltC,EAAG,EAAGma,GAG3B,MAAMxB,EAAQ,IAAI,KAAOG,EAAGC,EAAG/Y,GAE/BusC,EAAmB9H,SAASuI,EAAgBr0B,EAAO+rB,GAEnD8H,GAAmB9H,EAEnB7hB,GAAK4pB,C,CAGT1pB,GAAK2pB,C,EAKb,MAUMa,EAVmB,EAAM7yB,KAAKC,GAGb,EAC0C,EAMnB6xB,EAM9C,OALAD,EAAmBzH,aAAayI,GAEhChB,EAAmBxH,sCACnBwH,EAAmBvH,wCAEZ,IAAoBsB,cAAciG,EAC7C,EA5Me,EAAAO,WAAoC,CAC/C,IAAIjC,EAAoB,QAAS,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,GAAI,GAAI,IAAI,IAAQ,GAAI,EAAG,IACjG,IAAIA,EAAoB,OAAQ,IAAI,KAAS,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,GAAI,EAAG,IAChG,IAAIA,EAAoB,KAAM,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,IAC5F,IAAIA,EAAoB,OAAQ,IAAI,IAAQ,GAAI,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,GAAI,IAChG,IAAIA,EAAoB,QAAS,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,EAAG,EAAG,GAAI,IAAI,IAAQ,GAAI,EAAG,IAChG,IAAIA,EAAoB,OAAQ,IAAI,IAAQ,EAAG,GAAI,GAAI,IAAI,KAAS,EAAG,EAAG,GAAI,IAAI,IAAQ,GAAI,EAAG,KAIvF,EAAAsC,eAAiB,KAEjB,EAAAC,yBAA0B,C,iFC1BrC,MAAMI,EAKF,wBAAOC,CAAkBvjC,GAC5B,MAAMzC,EAAkByC,EAAQmwB,SAChC,IAAK5yB,IAAoByC,EAAQojB,OAC7B,OAIJ,MAAM3J,EAASlc,EAAgB9H,YACzB+tC,EAAO/pB,EAAO/jB,UACduQ,EAAU1I,EAAgB0I,QAChC,IAAIw9B,GAAgB,EAGhBD,EAAKE,wBAA0BF,EAAK75B,iCACpC85B,GAAgB,EAChBlmC,EAAgBkK,KAAO,GAGlB+7B,EAAK55B,oBAAsB45B,EAAK/5B,8BACrCg6B,GAAgB,EAChBlmC,EAAgBkK,KAAO,GAGvBg8B,IAEAlmC,EAAgB0I,SAAU,EAC1B1I,EAAgBomC,SAAU,EAC1BpmC,EAAgBwJ,SAAU,GAG9B,MAAM68B,EAAoB,KAEtB,GAAIH,EAAe,CAEf,MAAMI,EAAkB,IAAI,IACxB,aACA,aACA,KACA,KACA,EACA,KACA,KAAU,WACV,UACA,EACA,MACA,GAKJA,EAAgBC,+BAAgC,EAGhD,MAAMC,EAAkBtqB,EAAOuqB,0BAA0BzmC,EAAgBxC,MAAO,CAC5Eg7B,qBAAqB,EACrBxzB,iBAAiB,EACjB0hC,uBAAuB,EACvB5iC,aAAc9D,EAAgB8D,aAC9BoG,KAAMlK,EAAgBkK,KACtB5F,OAAQ,IAGZgiC,EAAgBltB,YAAYC,qBAAoB,KAE5CitB,EAAgBK,QAAWxvB,IACvBA,EAAOyvB,aAAa,iBAAkB5mC,GACtCmX,EAAO0vB,UAAU,QAAS,EAAG,EAAE,EAEnCpkC,EAAQ5X,WAAYi8C,mBAAmBC,aAAa,CAACT,GAAmBE,GAAiB,GAGzFtqB,EAAO8qB,4BACP9qB,EAAO+qB,gBAAgBjnC,GACnBsmC,GACAA,EAAgB7oC,UAIpB+oC,EAAgBU,YAAYlnC,GAG5BA,EAAgB0I,SAAU,CAAI,G,GAKtCA,EACA29B,IAEA5jC,EAAQ+W,iBAAiBC,QAAQ4sB,EAEzC,CASO,0BAAOc,CAAoBnnC,EAAkC7I,EAAciwC,EAAoB,GAClG,OAAO,QAAiB,aAAcpnC,EAAiB7I,EAAOiwC,EAAmB,IACrF,E,wGCzGG,MAAMC,EAyBT,aAAWC,GACP,OAAO19C,KAAK29C,UAChB,CAEA,aAAWD,CAAUA,GACjB,GAAI19C,KAAK29C,aAAeD,EACpB,OAGJ,MAAME,EAAW59C,KAAK29C,WACtB39C,KAAK29C,WAAaD,EAEd19C,KAAK69C,mBAAmBC,gBACxB99C,KAAK69C,mBAAmB/qC,gBAA6B,IAAb8qC,GAAgC,IAAdF,EAElE,CAaA,+BAAW13C,GACP,OAAKhG,KAAKgN,8BAAgChN,KAAKiN,OACpCjN,KAAKiN,OAAOjH,4BAEhBhG,KAAKgN,4BAChB,CAEA,+BAAWhH,CAA4B7F,GACnCH,KAAKgN,6BAA+B7M,CACxC,CAQA,YAEWM,EACPi9C,EAAY,EACZnwC,EAAyB,MAFlB,KAAA9M,KAAAA,EApEJ,KAAAW,WAAa,IAAID,MAGhB,KAAA48C,WAAmC,KACnC,KAAAC,SAAiC,KACjC,KAAAC,UAAkC,KAClC,KAAAC,KAA6B,KAE7B,KAAA7wC,UAAY,EAKb,KAAAwwC,mBAAqB,IAAI,KAGzB,KAAAM,qBAAuB,IAAI,KA4B1B,KAAAnxC,6BAAsE,KA4B1EhN,KAAKiN,OAASM,GAAS,IAAYW,iBACnClO,KAAK09C,UAAYA,EAEb19C,KAAKiN,SACLjN,KAAKqN,UAAYrN,KAAKiN,OAAOkB,cAErC,CAKA,YAAWf,GACP,OAAOpN,KAAKqN,SAChB,CAKA,gBAAW+wC,GACP,QAASp+C,KAAK+9C,UAClB,CAKA,cAAWM,GACP,QAASr+C,KAAKg+C,QAClB,CAKA,eAAWM,GACP,QAASt+C,KAAKi+C,SAClB,CAKA,UAAWM,GACP,QAASv+C,KAAKk+C,IAClB,CAMO,YAAAM,CAAa9oC,GAChB,MAAM+oC,EAAez+C,KAAKo+C,aAE1Bp+C,KAAK+9C,WAAaroC,EAEd+oC,IAAiBz+C,KAAKo+C,cACtBp+C,KAAKm+C,qBAAqBrrC,qBAAgB1G,EAElD,CAMO,YAAAsyC,GACH,OAAO1+C,KAAK+9C,UAChB,CAMO,UAAAY,CAAWjpC,GACd,MAAMkpC,EAAa5+C,KAAKq+C,WAExBr+C,KAAKg+C,SAAWtoC,EAEZkpC,IAAe5+C,KAAKq+C,YACpBr+C,KAAKm+C,qBAAqBrrC,qBAAgB1G,EAElD,CAMO,UAAAyyC,GACH,OAAO7+C,KAAKg+C,QAChB,CAMO,WAAAc,CAAYppC,GACf,MAAMqpC,EAAc/+C,KAAKs+C,YAEzBt+C,KAAKi+C,UAAYvoC,EAEbqpC,IAAgB/+C,KAAKs+C,aACrBt+C,KAAKm+C,qBAAqBrrC,qBAAgB1G,EAElD,CAMO,WAAA4yC,GACH,OAAOh/C,KAAKi+C,SAChB,CAMO,MAAAgB,CAAOvpC,GACV,MAAMwpC,EAASl/C,KAAKu+C,OAEpBv+C,KAAKk+C,KAAOxoC,EAERwpC,IAAWl/C,KAAKu+C,QAChBv+C,KAAKm+C,qBAAqBrrC,qBAAgB1G,EAElD,CAMO,MAAA+yC,GACH,OAAOn/C,KAAKk+C,IAChB,CAMO,KAAAv8C,GACH,MAAMy9C,EAAS,KAAoB3c,OAAM,IAAM,IAAIgb,EAAYz9C,KAAKS,KAAMT,KAAK09C,UAAW19C,KAAKiN,SAASjN,MAOxG,OALAo/C,EAAOrB,WAAa/9C,KAAK+9C,WACzBqB,EAAOpB,SAAWh+C,KAAKg+C,SACvBoB,EAAOnB,UAAYj+C,KAAKi+C,UACxBmB,EAAOlB,KAAOl+C,KAAKk+C,KAEZkB,CACX,CAMO,SAAAzqC,GACH,MAAMC,EAA2B,CAAC,EAsBlC,OApBAA,EAAoBnU,KAAOT,KAAKS,KAChCmU,EAAoB8oC,UAAY19C,KAAK09C,UAErC9oC,EAAoByqC,UAAYl+C,MAAM4U,UAAUs7B,MAAMiO,KAAKt/C,KAAK0+C,gBACjD,MAAX1+C,KAAKsN,KACLsH,EAAoBtH,GAAKtN,KAAKsN,IAE9BtN,KAAKq+C,aACLzpC,EAAoB2qC,QAAUp+C,MAAM4U,UAAUs7B,MAAMiO,KAAKt/C,KAAK6+C,eAE9D7+C,KAAKs+C,cACL1pC,EAAoB4qC,SAAWr+C,MAAM4U,UAAUs7B,MAAMiO,KAAKt/C,KAAKg/C,gBAE/Dh/C,KAAKu+C,SACL3pC,EAAoB6qC,IAAMt+C,MAAM4U,UAAUs7B,MAAMiO,KAAKt/C,KAAKm/C,WAI9D,KAAoBO,2BAA2B1/C,KAAM4U,GAE9CA,CACX,CAMO,YAAArS,GACH,MAAO,aACX,CAUO,YAAO8S,CAAMT,EAA0BrH,GAC1C,MAAMxE,EAAS,IAAI00C,EAAY7oC,EAAoBnU,KAAMmU,EAAoB8oC,WAkB7E,GAhBA30C,EAAOy1C,aAAa5pC,EAAoByqC,WAEV,MAA1BzqC,EAAoBtH,KACpBvE,EAAOuE,GAAKsH,EAAoBtH,IAEhCsH,EAAoB2qC,SACpBx2C,EAAO41C,WAAW/pC,EAAoB2qC,SAEtC3qC,EAAoB4qC,UACpBz2C,EAAO+1C,YAAYlqC,EAAoB4qC,UAEvC5qC,EAAoB6qC,KACpB12C,EAAOk2C,OAAOrqC,EAAoB6qC,KAIlC7qC,EAAoBxT,WAAY,CAChC,IAAK,IAAI4rC,EAAiB,EAAGA,EAAiBp4B,EAAoBxT,WAAWoF,OAAQwmC,IAAkB,CACnG,MAAMC,EAAkBr4B,EAAoBxT,WAAW4rC,GACjDE,GAAgB,OAAS,qBAC3BA,GACAnkC,EAAO3H,WAAWgB,KAAK8qC,EAAc73B,MAAM43B,G,CAI/Cr4B,EAAoB+qC,aAAepyC,GACnCA,EAAMiE,eACFzI,EACA6L,EAAoBgrC,gBACpBhrC,EAAoBirC,cACpBjrC,EAAoBkrC,gBACpBlrC,EAAoBmrC,kBAAoB,E,CAKpD,OAAOh3C,CACX,CASO,eAAOi3C,CAASnxC,EAAoBpO,EAAei9C,GACjDj9C,IACDA,EAAOoO,EAAKpO,MAGhB,MAAMsI,EAAS,IAAI00C,EAAYh9C,EAAMi9C,EAAW7uC,EAAK5N,YAcrD,OAZA8H,EAAOy1C,aAAyB3vC,EAAKoxC,gBAAgB,IAAa1hB,eAE9D1vB,EAAKgvB,sBAAsB,IAAaC,aACxC/0B,EAAO41C,WAAuB9vC,EAAKoxC,gBAAgB,IAAaniB,aAEhEjvB,EAAKgvB,sBAAsB,IAAaqiB,cACxCn3C,EAAO+1C,YAAwBjwC,EAAKoxC,gBAAgB,IAAaC,cAEjErxC,EAAKgvB,sBAAsB,IAAaW,SACxCz1B,EAAOk2C,OAAmBpwC,EAAKoxC,gBAAgB,IAAazhB,SAGzDz1B,CACX,GAnSO,UADN,W,sHC9CE,MAAMo3C,EAuDT,oBAAWC,CAAiBC,GACpBA,EACArgD,KAAKsgD,iBAELtgD,KAAKsgD,gBACDtgD,KAAKsgD,eAAiB,IACtBtgD,KAAKsgD,cAAgB,EAErBtgD,KAAKugD,oBAAmB,IAGpC,CAEA,oBAAWH,GACP,OAAOpgD,KAAKsgD,cAAgB,CAChC,CAMA,YAAmB/yC,EAAyB,MAOxC,GA5EI,KAAAizC,SAAW,IAAIr/C,MACf,KAAAs/C,iCAAmC,IAAIt/C,MACvC,KAAAu/C,kCAAoC,IAAIv/C,MACxC,KAAAw/C,eAAiB,IAAI,IAAwB,IAI7C,KAAAC,kBAAmB,EACnB,KAAAC,mBAAoB,EACpB,KAAAC,cAAe,EACf,KAAAC,aAAe,EACf,KAAAC,qBAAuB,EACvB,KAAAC,cAAgB,EAChB,KAAAC,eAAiB,EACjB,KAAA7zC,UAAY,EACZ,KAAA8zC,gBAAkB,IAAIhgD,MACtB,KAAAigD,0BAA2B,EAC3B,KAAAd,cAAgB,EAGjB,KAAAvyC,iBAA4C,KAQ5C,KAAAszC,qBAAsB,EAKtB,KAAAC,sBAAuB,EAKvB,KAAAC,uBAAwB,EAKxB,KAAAC,kBAAmB,EAoGlB,KAAAC,2BAA4B,EAzE3Bl0C,IACDA,EAAQ,IAAYW,kBAGxBlO,KAAKiN,OAASM,EAEVvN,KAAKiN,OAAQ,CACbjN,KAAKiN,OAAOy0C,sBAAsB1hD,MAElCA,KAAKqN,UAAYrN,KAAKiN,OAAOkB,cAE7B,MAAME,EAAarO,KAAKiN,OAAOqB,YAAYC,UAC3CvO,KAAKohD,yBACD/yC,EAAWszC,kBAAoBtzC,EAAWG,cAAgBH,EAAWI,2BAA6B,GAAKJ,EAAWuzC,4BAA8B,C,CAE5J,CAKA,YAAWx0C,GACP,OAAOpN,KAAKqN,SAChB,CAKA,eAAWw0C,GACP,OAAO7hD,KAAK+gD,YAChB,CAKA,mBAAWe,GACP,OAAO9hD,KAAK4gD,kBAAoB5gD,KAAKshD,oBACzC,CAKA,oBAAWS,GACP,OAAO/hD,KAAK6gD,mBAAqB7gD,KAAKuhD,qBAC1C,CAKA,eAAWS,GACP,OAAOhiD,KAAK8gD,cAAgB9gD,KAAKwhD,gBACrC,CAKA,cAAWS,GACP,OAAOjiD,KAAKwgD,SAASh6C,MACzB,CAKA,kBAAW07C,GACP,OAAOliD,KAAK2gD,eAAen6C,MAC/B,CAKA,cAAW27C,GACP,OAAOniD,KAAKoiD,WAChB,CAOA,4BAAWC,GACP,OAAOriD,KAAKyhD,yBAChB,CAEA,4BAAWY,CAAyBliD,GAChCH,KAAKyhD,0BAA4BthD,CACrC,CAKA,4BAAWmiD,G,MACP,OACInC,EAAmBoC,sBACnBviD,KAAKqiD,0BACLriD,KAAKohD,4BACO,QAAX,EAAAphD,KAAKiN,cAAM,eAAEqB,YAAYC,UAAUi0C,0BAE5C,CAOO,eAAAC,CAAgB1hD,GACnB,OAAOf,KAAK2gD,eAAejrC,KAAK3U,EACpC,CAOO,SAAA2hD,CAAU3hD,GACb,OAAOf,KAAKwgD,SAASz/C,EACzB,CAMO,SAAA4hD,CAAU7iC,GACb9f,KAAKwgD,SAASp+C,KAAK0d,GACnB9f,KAAKygD,iCAAiCr+C,KAClC0d,EAAO+9B,mBAAmB10B,KAAKy5B,IAC3B5iD,KAAKugD,mBAAmBqC,EAAW,KAG3C5iD,KAAK0gD,kCAAkCt+C,KACnC0d,EAAOq+B,qBAAqBh1B,KAAI,KAC5BnpB,KAAKugD,oBAAmB,EAAK,KAGrCvgD,KAAKugD,oBAAmB,EAC5B,CAMO,YAAAsC,CAAa/iC,GAChB,MAAM/e,EAAQf,KAAKwgD,SAAS19C,QAAQgd,GAChC/e,GAAS,IACTf,KAAKwgD,SAASv9C,OAAOlC,EAAO,GAE5B+e,EAAO+9B,mBAAmBtlB,OAAOv4B,KAAKygD,iCAAiCx9C,OAAOlC,EAAO,GAAG,IACxF+e,EAAOq+B,qBAAqB5lB,OAAOv4B,KAAK0gD,kCAAkCz9C,OAAOlC,EAAO,GAAG,IAC3Ff,KAAKugD,oBAAmB,IAGxBvgD,KAAKiN,QACLjN,KAAKiN,OAAOuH,cAAcsL,EAElC,CAKO,KAAAgjC,CAAMv1B,GACTA,EAAOQ,UAAU,yBAA0B/tB,KAAKghD,qBAAsBhhD,KAAKihD,cAAejhD,KAAKkhD,gBAC/F3zB,EAAOw1B,cAAc,4BAA6B/iD,KAAKgjD,4BACvDz1B,EAAOyE,WAAW,eAAgBhyB,KAAKijD,oBAC3C,CAMO,KAAAthD,GACH,MAAMuhD,EAAO,IAAI/C,EAAmBngD,KAAKiN,QAEzC,IAAK,MAAM6S,KAAU9f,KAAKwgD,SACtB0C,EAAKP,UAAU7iC,EAAOne,SAO1B,OAJAuhD,EAAK5B,qBAAuBthD,KAAKshD,qBACjC4B,EAAK3B,sBAAwBvhD,KAAKuhD,sBAClC2B,EAAK1B,iBAAmBxhD,KAAKwhD,iBAEtB0B,CACX,CAMO,SAAAvuC,GACH,MAAMC,EAA2B,CAAC,EAElCA,EAAoBtH,GAAKtN,KAAKoN,SAE9BwH,EAAoBuuC,QAAU,GAC9B,IAAK,MAAMrjC,KAAU9f,KAAKwgD,SACtB5rC,EAAoBuuC,QAAQ/gD,KAAK0d,EAAOnL,aAG5C,OAAOC,CACX,CAEQ,kBAAA2rC,CAAmBqC,GACvB,GAAI5iD,KAAKogD,iBACL,OAGJ,IAAIgD,EAAiB,EACrBpjD,KAAK2gD,eAAermB,QACpBt6B,KAAK4gD,kBAAmB,EACxB5gD,KAAK6gD,mBAAoB,EACzB7gD,KAAK8gD,cAAe,EACpB9gD,KAAK+gD,aAAe,EAEhB/gD,KAAKiN,QAAUjN,KAAKwgD,SAASh6C,OAASxG,KAAKiN,OAAOqB,YAAYC,UAAUqzC,8BACxE5hD,KAAKqiD,0BAA2B,GAG/BriD,KAAKgjD,4BAA8BhjD,KAAKgjD,2BAA2Bx8C,SAAWxG,KAAKwgD,SAASh6C,SAC7FxG,KAAKgjD,2BAA6B,IAAIzvC,aAAavT,KAAKwgD,SAASh6C,SAGrE,IAAI68C,GAAe,EACnB,IAAK,MAAMvjC,KAAU9f,KAAKwgD,SAAU,CAEhC,GADA6C,IACyB,IAArBvjC,EAAO49B,WAAmB19C,KAAKqhD,oBAC/B,SAGJ,GAAIrhD,KAAK2gD,eAAen6C,QAAU25C,EAAmBmD,6CAA+CtjD,KAAKsiD,yBACrG,MAGJtiD,KAAK2gD,eAAev+C,KAAK0d,GACzB9f,KAAKgjD,2BAA2BI,GAAkBC,EAClDrjD,KAAKmhD,gBAAgBiC,KAAoBtjC,EAAO49B,UAEhD19C,KAAK4gD,iBAAmB5gD,KAAK4gD,kBAAoB9gC,EAAOu+B,WACxDr+C,KAAK6gD,kBAAoB7gD,KAAK6gD,mBAAqB/gC,EAAOw+B,YAC1Dt+C,KAAK8gD,aAAe9gD,KAAK8gD,cAAgBhhC,EAAOy+B,OAEhD,MAAMc,EAAYv/B,EAAO4+B,eACzB,GAAIW,EAAW,CACX,MAAMwC,EAAcxC,EAAU74C,OAAS,EACvC,GAA0B,IAAtBxG,KAAK+gD,aACL/gD,KAAK+gD,aAAec,OACjB,GAAI7hD,KAAK+gD,eAAiBc,EAE7B,YADA,IAAOrrC,MAAM,sE,EAMrBxW,KAAKgjD,2BAA2Bx8C,SAAW48C,IAC3CpjD,KAAKgjD,2BAA6BhjD,KAAKgjD,2BAA2B3R,MAAM,EAAG+R,IAG1EpjD,KAAKoiD,aAAepiD,KAAKoiD,YAAY57C,SAAW48C,IACjDpjD,KAAKoiD,YAAc,IAAI7uC,aAAa6vC,IAGxC,IAAK,IAAIriD,EAAQ,EAAGA,EAAQqiD,EAAgBriD,IACxCf,KAAKoiD,YAAYrhD,GAASf,KAAKmhD,gBAAgBpgD,GAG/C6hD,GACA5iD,KAAKujD,aAEb,CAKO,WAAAA,GACH,GAAKvjD,KAAKiN,SAAUjN,KAAKogD,iBAAzB,CAIA,GAAIpgD,KAAKsiD,0BAA4BtiD,KAAK+gD,aAAc,CACpD/gD,KAAKghD,qBAAuB,EAExBhhD,KAAK4gD,kBACL5gD,KAAKghD,uBAGLhhD,KAAK6gD,mBACL7gD,KAAKghD,uBAGLhhD,KAAK8gD,cACL9gD,KAAKghD,uBAGThhD,KAAKihD,cAAgBjhD,KAAK+gD,aAAe/gD,KAAKghD,qBAC9ChhD,KAAKkhD,eAAiB,EAEtB,MAAMsC,EAAiBxjD,KAAKiN,OAAOqB,YAAYC,UAAUi1C,eACrDxjD,KAAKihD,cAAgBuC,IACrBxjD,KAAKkhD,eAAiB73B,KAAKo6B,KAAKzjD,KAAKihD,cAAgBuC,GACrDxjD,KAAKihD,cAAgBuC,GAGzB,IAAIE,GAAoB,EACxB,GAAI1jD,KAAKijD,oBAAqB,CAC1B,MAAM/R,EAAclxC,KAAKijD,oBAAoBtvC,UACzCu9B,EAAYt9B,QAAU5T,KAAKihD,eAAiB/P,EAAYxzB,SAAW1d,KAAKkhD,gBAAkBlhD,KAAKijD,oBAAoBtjC,QAAU3f,KAAKwgD,SAASh6C,SAC3Ik9C,GAAoB,E,CAI5B,GAAIA,EAAmB,CACf1jD,KAAKijD,qBACLjjD,KAAKijD,oBAAoBpvC,UAG7B,MAAM8vC,EAAc3jD,KAAKwgD,SAASh6C,OAC5BkP,EAAO,IAAInC,aAAaowC,EAAc3jD,KAAKihD,cAAgBjhD,KAAKkhD,eAAiB,GAEvF,IAAIvJ,EAAS,EACb,IAAK,IAAI52C,EAAQ,EAAGA,EAAQ4iD,EAAa5iD,IAAS,CAC9C,MAAM+e,EAAS9f,KAAKwgD,SAASz/C,GAEvBs+C,EAAYv/B,EAAO4+B,eACnBa,EAAUz/B,EAAO++B,aACjBY,EAAM3/B,EAAOq/B,SACbK,EAAW1/B,EAAOk/B,cAExB,IAAKK,EAID,YAHc,IAAVt+C,GACA,IAAOyV,MAAM,sDAKrBmhC,EAAS52C,EAAQf,KAAKihD,cAAgBjhD,KAAKkhD,eAAiB,EAC5D,IAAK,IAAI0C,EAAS,EAAGA,EAAS5jD,KAAK+gD,aAAc6C,IAC7CluC,EAAKiiC,GAAU0H,EAAmB,EAATuE,GACzBluC,EAAKiiC,EAAS,GAAK0H,EAAmB,EAATuE,EAAa,GAC1CluC,EAAKiiC,EAAS,GAAK0H,EAAmB,EAATuE,EAAa,GAE1CjM,GAAU,EAEN33C,KAAK4gD,kBAAoBrB,IACzB7pC,EAAKiiC,GAAU4H,EAAiB,EAATqE,GACvBluC,EAAKiiC,EAAS,GAAK4H,EAAiB,EAATqE,EAAa,GACxCluC,EAAKiiC,EAAS,GAAK4H,EAAiB,EAATqE,EAAa,GACxCjM,GAAU,GAGV33C,KAAK8gD,cAAgBrB,IACrB/pC,EAAKiiC,GAAU8H,EAAa,EAATmE,GACnBluC,EAAKiiC,EAAS,GAAK8H,EAAa,EAATmE,EAAa,GACpCjM,GAAU,GAGV33C,KAAK6gD,mBAAqBrB,IAC1B9pC,EAAKiiC,GAAU6H,EAAkB,EAAToE,GACxBluC,EAAKiiC,EAAS,GAAK6H,EAAkB,EAAToE,EAAa,GACzCluC,EAAKiiC,EAAS,GAAK6H,EAAkB,EAAToE,EAAa,GACzCjM,GAAU,E,CAKtB33C,KAAKijD,oBAAsB,IAAkBnvC,kBACzC4B,EACA1V,KAAKihD,cACLjhD,KAAKkhD,eACLyC,EACA3jD,KAAKiN,QACL,GACA,EACA,I,EAOZ,IAAK,MAAM4B,KAAQ7O,KAAKiN,OAAOyb,OACjB7Z,EAAMg1C,qBAAuB7jD,MAC5B6O,EAAMi1C,qC,CAGzB,CAKO,OAAAjwC,GAQH,GAPI7T,KAAKijD,qBACLjjD,KAAKijD,oBAAoBpvC,UAG7B7T,KAAKijD,oBAAsB,KAGvBjjD,KAAKiN,OAAQ,CAGb,GAFAjN,KAAKiN,OAAO82C,yBAAyB/jD,MAEjCA,KAAK+N,iBAAkB,CACvB,MAAMhN,EAAQf,KAAK+N,iBAAiBi2C,oBAAoBlhD,QAAQ9C,MAC5De,GAAS,GACTf,KAAK+N,iBAAiBi2C,oBAAoB/gD,OAAOlC,EAAO,GAE5Df,KAAK+N,iBAAmB,I,CAG5B,IAAK,MAAMk2C,KAASjkD,KAAKwgD,SACrBxgD,KAAKiN,OAAOuH,cAAcyvC,E,CAGtC,CAUO,YAAO5uC,CAAMT,EAA0BrH,GAC1C,MAAMxE,EAAS,IAAIo3C,EAAmB5yC,GAEtCxE,EAAOsE,UAAYuH,EAAoBtH,GAEvC,IAAK,MAAM42C,KAActvC,EAAoBuuC,QACzCp6C,EAAO45C,UAAU,IAAYttC,MAAM6uC,EAAY32C,IAGnD,OAAOxE,CACX,EAvfc,EAAAw5C,sBAAuB,EAGvB,EAAAe,2CAA6C,C,2BCA/D,EAAY9wB,qBAAyB,mBAjBtB,y8B,2BCsDf,EAAYA,qBAAyB,sBAtDtB,o1G,2BCKf,EAAYA,qBAAyB,mBALtB,+pB,2BCoIf,EAAYA,qBAAyB,iBApItB,uoR,mDCSf,IAAYA,qBAAyB,kBAPtB,+xC,2BCCf,EAAYA,qBAAyB,8BAHtB,gF,4DCwIf,IAAYA,qBAAyB,uBAvItB,86I,kBCgBf,IAAYA,qBAAyB,4BAhBtB,qZ,0BCkBf,IAAYA,qBAAyB,oCAnBtB,ydCgGf,IAAYA,qBAAyB,+BA9FtB,8qJ,+DCkCf,IAAYA,qBAAyB,mBApCtB,khG,2BCaf,IAAYA,qBAAyB,gCAbtB,i8CCoCf,IAAYA,qBAAyB,kCApCtB,+kF,kBC8Df,IAAYA,qBAAyB,2BA9DtB,q5KCgBf,IAAYA,qBAAyB,gBAhBtB,oxC,oCC0Ef,IAAYA,qBAAyB,sBAzEtB,orDC+Gf,IAAYA,qBAAyB,qBAhHtB,21HC4Bf,IAAYA,qBAAyB,yBA5BtB,q1BC+Bf,IAAYA,qBAAyB,qBA/BtB,o2BCoCf,IAAYA,qBAAyB,oBApCtB,o9CCyPf,IAAYA,qBAAyB,mBAzPtB,ynOCwLf,IAAYA,qBAAyB,cAxLtB,klKCyPf,IAAYA,qBAAyB,kBAzPtB,4rRC6Cf,IAAYA,qBAAyB,oBA7CtB,03DCgTf,IAAYA,qBAAyB,mBAhTtB,o+U,SCYf,IAAYA,qBAAyB,wBAZtB,sX,SCYf,IAAYA,qBAAyB,oBAZtB,mY,SCYf,IAAYA,qBAAyB,qBAZtB,mSC0Bf,IAAYA,qBAAyB,qBA1BtB,q2BCWf,IAAYA,qBAAyB,qBAXtB,0hBCuBf,IAAYA,qBAAyB,oBAvBtB,uwBCiBf,IAAYA,qBAAyB,uBAjBtB,oZ,SCyFf,IAAYA,qBAAyB,2BAzFtB,inHCmBf,IAAYA,qBAAyB,6BAnBtB,yzBC4Cf,IAAYA,qBAAyB,8BA5CtB,k0B,kBCaf,IAAYA,qBAAyB,wBAbtB,wT,SCqLf,IAAYA,qBAAyB,SArLtB,+pOConBf,IAAYC,aAAiB,eA3jBd,gwf,0CCyDf,IAAYD,qBAAyB,qBAjHtB,s/G,8RCmOf,IAAYC,aAAiB,gBAnMd,64T,0CC1Bf,IAAYA,aAAiB,sBANd,yM,0CCMf,IAAYA,aAAiB,sBANd,iM","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Bones/bone.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Bones/skeleton.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.cubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Engines/Extensions/engine.rawTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Helpers/environmentHelper.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/pointLight.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/spotLight.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/backgroundFragmentDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/backgroundUboDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/background.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/backgroundVertexDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/background.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Background/backgroundMaterial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/PBR/pbrBRDFConfiguration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/PBR/pbrMaterial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/baseTexture.polynomial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/cubeTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/mirrorTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/rawTexture.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/Textures/rawTexture2DArray.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Maths/sphericalPolynomial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/thinInstanceMesh.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Misc/rgbdTextureTools.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Morph/morphTarget.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Morph/morphTargetManager.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/harmonicsFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/hdrFilteringFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/importanceSampling.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBRDFFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrUboDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/subSurfaceScatteringFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrFragmentDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrHelperFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrDirectLightingFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrIBLFunctions.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockReflectivity.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockAlphaFresnel.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockAnisotropic.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockReflection.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockSheen.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockClearcoat.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockIridescence.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockSubSurface.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockNormalGeometric.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockNormalFinal.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockLightmapInit.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockGeometryInfo.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockReflectance0.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockReflectance.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockDirectLighting.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockFinalLitComponents.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockFinalColorComposition.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrBlockImageProcessing.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrDebug.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/pbr.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/ShadersInclude/pbrVertexDeclaration.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/pbr.vertex.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/rgbdDecode.fragment.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Shaders/rgbdEncode.fragment.ts"],"sourcesContent":["import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children = new Array<Bone>();\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @internal Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix; // transformation of the bone, in local space\r\n    private _absoluteMatrix: Matrix; // transformation of the bone, in world space (relative to the skeleton root)\r\n    private _bindMatrix: Matrix; // the bind matrix, in local space\r\n    private _absoluteBindMatrix: Matrix; // the bind matrix, in world space (relative to the skeleton root)\r\n    private _absoluteInverseBindMatrix: Matrix; // the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n    private _finalMatrix: Matrix; // the final matrix used to transform vertices of the mesh according to the bone, in world space (relative to the skeleton root). It is the multiplication of _absoluteInverseBindMatrix with _absoluteMatrix.\r\n    private _restMatrix: Matrix; // a matrix for the exclusive use of the end user (not used internally by the framework), in local space\r\n    private _scalingDeterminant = 1;\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @internal */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @internal */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    set _matrix(value: Matrix) {\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix (default: identity)\r\n     * @param restMatrix defines the rest matrix (default: localMatrix)\r\n     * @param bindMatrix defines the bind matrix (default: localMatrix)\r\n     * @param index defines index of the bone in the hierarchy (default: null)\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restMatrix: Nullable<Matrix> = null,\r\n        bindMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene());\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix?.clone() ?? Matrix.Identity();\r\n        this._restMatrix = restMatrix ?? this._localMatrix.clone();\r\n        this._bindMatrix = bindMatrix ?? this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        this._absoluteMatrix = new Matrix();\r\n        this._absoluteBindMatrix = new Matrix();\r\n        this._absoluteInverseBindMatrix = new Matrix();\r\n        this._finalMatrix = new Matrix();\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        this._updateAbsoluteBindMatrices();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the children of the bone\r\n     * @returns an array containing the children of the bone (can be empty if the bone has no children)\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateAbsoluteBindMatrices: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns the local matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     */\r\n    public getBindMatrix(): Matrix {\r\n        return this._bindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix.\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     */\r\n    public getRestMatrix(): Matrix {\r\n        return this._restMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     * @deprecated Please use getRestMatrix instead\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this.getRestMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest matrix to set for this bone\r\n     */\r\n    public setRestMatrix(matrix: Matrix): void {\r\n        this._restMatrix.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest to set for this bone\r\n     * @deprecated Please use setRestMatrix instead\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this.setRestMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * This will trigger a recomputation of the absolute bind and absolute inverse bind matrices for this bone and its children\r\n     * Note that the local matrix will also be set with the matrix passed in parameter!\r\n     * @param matrix the local-space bind matrix to set for this bone\r\n     */\r\n    public setBindMatrix(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * @param matrix the local-space bind to set for this bone\r\n     * @deprecated Please use setBindMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.setBindMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     */\r\n    public getFinalMatrix(): Matrix {\r\n        return this._finalMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @deprecated Please use getFinalMatrix instead\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        return this.getFinalMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to the rest matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestMatrix().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restMatrix;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     */\r\n    public getAbsoluteInverseBindMatrix(): Matrix {\r\n        return this._absoluteInverseBindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     * @deprecated Please use getAbsoluteInverseBindMatrix instead\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this.getAbsoluteInverseBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     */\r\n    public getAbsoluteMatrix(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     * @deprecated Please use getAbsoluteMatrix instead\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is overwritten by the transform of the node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the bind (and optionally the local) matrix\r\n     * @param bindMatrix defines the new matrix to set to the bind/local matrix, in local space\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be recomputed (default: true)\r\n     * @param updateLocalMatrix defines if the local matrix should also be updated with the matrix passed in parameter (default: true)\r\n     */\r\n    public updateMatrix(bindMatrix: Matrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true): void {\r\n        this._bindMatrix.copyFrom(bindMatrix);\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = bindMatrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateAbsoluteBindMatrices(bindMatrix?: Matrix, updateChildren = true): void {\r\n        if (!bindMatrix) {\r\n            bindMatrix = this._bindMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);\r\n        } else {\r\n            this._absoluteBindMatrix.copyFrom(bindMatrix);\r\n        }\r\n\r\n        this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateAbsoluteBindMatrices();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    private _updatePosition(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode, translationMode = true): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, vec.x);\r\n                lm.addAtIndex(13, vec.y);\r\n                lm.addAtIndex(14, vec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n            }\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            if (translationMode) {\r\n                tmat.setTranslationFromFloats(0, 0, 0);\r\n            }\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, tvec.x);\r\n                lm.addAtIndex(13, tvec.y);\r\n                lm.addAtIndex(14, tvec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);\r\n            }\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(vec, space, tNode, true);\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(position, space, tNode, false);\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteMatrix());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteMatrices();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteMatrices();\r\n\r\n            let tmat = Bone._TmpMats[0];\r\n\r\n            if (tNode && wm) {\r\n                tmat.copyFrom(this.getAbsoluteMatrix());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteMatrix();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     */\r\n    public computeAbsoluteMatrices(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);\r\n        } else {\r\n            this._absoluteMatrix.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteMatrices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this.computeAbsoluteMatrices();\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const mat = Bone._TmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteMatrices()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteMatrices();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restMatrix for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestMatrix(this.getLocalMatrix());\r\n    }\r\n}\r\n","import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones = new Array<Bone>();\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n    private _currentRenderId = -1;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _absoluteTransformIsDirty = true;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @internal */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @internal */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: AbstractMesh): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare();\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices || this._isDirty) {\r\n            this.prepare();\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @returns the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n        this._absoluteTransformIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\r\n                } else {\r\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\r\n     */\r\n    public prepare(dontCheckFrameId = false): void {\r\n        if (!dontCheckFrameId) {\r\n            const currentRenderId = this.getScene().getRenderId();\r\n            if (this._currentRenderId === currentRenderId) {\r\n                return;\r\n            }\r\n            this._currentRenderId = currentRenderId;\r\n        }\r\n\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    const node = bone._linkedTransformNode;\r\n                    bone.position = node.position;\r\n                    if (node.rotationQuaternion) {\r\n                        bone.rotationQuaternion = node.rotationQuaternion;\r\n                    } else {\r\n                        bone.rotation = node.rotation;\r\n                    }\r\n                    bone.scaling = node.scaling;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBindMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        result.prepare(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        this.bones.forEach((bone) => {\r\n            bone.animations.forEach((animation: Animation) => {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix.length = 0;\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBindMatrix().toArray(),\r\n                rest: bone.getRestMatrix().toArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteMatrices(forceUpdate = false): void {\r\n        if (this._absoluteTransformIsDirty || forceUpdate) {\r\n            this.bones[0].computeAbsoluteMatrices();\r\n            this._absoluteTransformIsDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        this.computeAbsoluteMatrices(forceUpdate);\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones = new Array<Bone>();\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) return;\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.bones.forEach((b) => {\r\n            b.setCurrentPoseAsRest();\r\n        });\r\n    }\r\n}\r\n","import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { IInternalTextureLoader } from \"../../Materials/Textures/internalTextureLoader\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @param rtWrapper The render target wrapper for which the depth/stencil texture must be created\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n    rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene.addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\r\n    if (texture !== fallback) {\r\n        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const rootUrlWithoutUriParams = rootUrl.split(\"?\")[0];\r\n    const lastDot = rootUrlWithoutUriParams.lastIndexOf(\".\");\r\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (const availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                onError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            if (beforeLoadCubeDataCallback) {\r\n                beforeLoadCubeDataCallback(texture, data);\r\n            }\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            } else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        } else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    } else {\r\n        if (!files) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            onError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n","import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number,\r\n            useSRGBBuffer?: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n","import { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { ArcRotateCamera } from \"../Cameras/arcRotateCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MirrorTexture } from \"../Materials/Textures/mirrorTexture\";\r\nimport { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Represents the different options available during the creation of\r\n * a Environment helper.\r\n *\r\n * This can control the default ground, skybox and image processing setup of your scene.\r\n */\r\nexport interface IEnvironmentHelperOptions {\r\n    /**\r\n     * Specifies whether or not to create a ground.\r\n     * True by default.\r\n     */\r\n    createGround: boolean;\r\n    /**\r\n     * Specifies the ground size.\r\n     * 15 by default.\r\n     */\r\n    groundSize: number;\r\n    /**\r\n     * The texture used on the ground for the main color.\r\n     * Comes from the BabylonJS CDN by default.\r\n     *\r\n     * Remarks: Can be either a texture or a url.\r\n     */\r\n    groundTexture: string | BaseTexture;\r\n    /**\r\n     * The color mixed in the ground texture by default.\r\n     * BabylonJS clearColor by default.\r\n     */\r\n    groundColor: Color3;\r\n    /**\r\n     * Specifies the ground opacity.\r\n     * 1 by default.\r\n     */\r\n    groundOpacity: number;\r\n    /**\r\n     * Enables the ground to receive shadows.\r\n     * True by default.\r\n     */\r\n    enableGroundShadow: boolean;\r\n    /**\r\n     * Helps preventing the shadow to be fully black on the ground.\r\n     * 0.5 by default.\r\n     */\r\n    groundShadowLevel: number;\r\n    /**\r\n     * Creates a mirror texture attach to the ground.\r\n     * false by default.\r\n     */\r\n    enableGroundMirror: boolean;\r\n    /**\r\n     * Specifies the ground mirror size ratio.\r\n     * 0.3 by default as the default kernel is 64.\r\n     */\r\n    groundMirrorSizeRatio: number;\r\n    /**\r\n     * Specifies the ground mirror blur kernel size.\r\n     * 64 by default.\r\n     */\r\n    groundMirrorBlurKernel: number;\r\n    /**\r\n     * Specifies the ground mirror visibility amount.\r\n     * 1 by default\r\n     */\r\n    groundMirrorAmount: number;\r\n    /**\r\n     * Specifies the ground mirror reflectance weight.\r\n     * This uses the standard weight of the background material to setup the fresnel effect\r\n     * of the mirror.\r\n     * 1 by default.\r\n     */\r\n    groundMirrorFresnelWeight: number;\r\n    /**\r\n     * Specifies the ground mirror Falloff distance.\r\n     * This can helps reducing the size of the reflection.\r\n     * 0 by Default.\r\n     */\r\n    groundMirrorFallOffDistance: number;\r\n    /**\r\n     * Specifies the ground mirror texture type.\r\n     * Unsigned Int by Default.\r\n     */\r\n    groundMirrorTextureType: number;\r\n    /**\r\n     * Specifies a bias applied to the ground vertical position to prevent z-fighting with\r\n     * the shown objects.\r\n     */\r\n    groundYBias: number;\r\n\r\n    /**\r\n     * Specifies whether or not to create a skybox.\r\n     * True by default.\r\n     */\r\n    createSkybox: boolean;\r\n    /**\r\n     * Specifies the skybox size.\r\n     * 20 by default.\r\n     */\r\n    skyboxSize: number;\r\n    /**\r\n     * The texture used on the skybox for the main color.\r\n     * Comes from the BabylonJS CDN by default.\r\n     *\r\n     * Remarks: Can be either a texture or a url.\r\n     */\r\n    skyboxTexture: string | BaseTexture;\r\n    /**\r\n     * The color mixed in the skybox texture by default.\r\n     * BabylonJS clearColor by default.\r\n     */\r\n    skyboxColor: Color3;\r\n\r\n    /**\r\n     * The background rotation around the Y axis of the scene.\r\n     * This helps aligning the key lights of your scene with the background.\r\n     * 0 by default.\r\n     */\r\n    backgroundYRotation: number;\r\n\r\n    /**\r\n     * Compute automatically the size of the elements to best fit with the scene.\r\n     */\r\n    sizeAuto: boolean;\r\n\r\n    /**\r\n     * Default position of the rootMesh if autoSize is not true.\r\n     */\r\n    rootPosition: Vector3;\r\n\r\n    /**\r\n     * Sets up the image processing in the scene.\r\n     * true by default.\r\n     */\r\n    setupImageProcessing: boolean;\r\n\r\n    /**\r\n     * The texture used as your environment texture in the scene.\r\n     * Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.\r\n     *\r\n     * Remarks: Can be either a texture or a url.\r\n     */\r\n    environmentTexture: string | BaseTexture;\r\n\r\n    /**\r\n     * The value of the exposure to apply to the scene.\r\n     * 0.6 by default if setupImageProcessing is true.\r\n     */\r\n    cameraExposure: number;\r\n\r\n    /**\r\n     * The value of the contrast to apply to the scene.\r\n     * 1.6 by default if setupImageProcessing is true.\r\n     */\r\n    cameraContrast: number;\r\n\r\n    /**\r\n     * Specifies whether or not tonemapping should be enabled in the scene.\r\n     * true by default if setupImageProcessing is true.\r\n     */\r\n    toneMappingEnabled: boolean;\r\n}\r\n\r\ninterface ISceneSize {\r\n    groundSize: number;\r\n    skyboxSize: number;\r\n    rootPosition: Vector3;\r\n}\r\n\r\n/**\r\n * The EnvironmentHelper class can be used to add a fully featured non-expensive background to your scene.\r\n * It includes by default a skybox and a ground relying on the BackgroundMaterial.\r\n * It also helps with the default setup of your ImageProcessingConfiguration.\r\n */\r\nexport class EnvironmentHelper {\r\n    /**\r\n     * Default ground texture URL.\r\n     */\r\n    private static _GroundTextureCDNUrl = \"https://assets.babylonjs.com/environments/backgroundGround.png\";\r\n\r\n    /**\r\n     * Default skybox texture URL.\r\n     */\r\n    private static _SkyboxTextureCDNUrl = \"https://assets.babylonjs.com/environments/backgroundSkybox.dds\";\r\n\r\n    /**\r\n     * Default environment texture URL.\r\n     */\r\n    private static _EnvironmentTextureCDNUrl = \"https://assets.babylonjs.com/environments/environmentSpecular.env\";\r\n\r\n    /**\r\n     * Creates the default options for the helper.\r\n     * @param scene The scene the environment helper belongs to.\r\n     */\r\n    private static _GetDefaultOptions(scene: Scene): IEnvironmentHelperOptions {\r\n        return {\r\n            createGround: true,\r\n            groundSize: 15,\r\n            groundTexture: this._GroundTextureCDNUrl,\r\n            groundColor: new Color3(0.2, 0.2, 0.3).toLinearSpace(scene.getEngine().useExactSrgbConversions).scale(3),\r\n            groundOpacity: 0.9,\r\n            enableGroundShadow: true,\r\n            groundShadowLevel: 0.5,\r\n\r\n            enableGroundMirror: false,\r\n            groundMirrorSizeRatio: 0.3,\r\n            groundMirrorBlurKernel: 64,\r\n            groundMirrorAmount: 1,\r\n            groundMirrorFresnelWeight: 1,\r\n            groundMirrorFallOffDistance: 0,\r\n            groundMirrorTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n\r\n            groundYBias: 0.00001,\r\n\r\n            createSkybox: true,\r\n            skyboxSize: 20,\r\n            skyboxTexture: this._SkyboxTextureCDNUrl,\r\n            skyboxColor: new Color3(0.2, 0.2, 0.3).toLinearSpace(scene.getEngine().useExactSrgbConversions).scale(3),\r\n\r\n            backgroundYRotation: 0,\r\n            sizeAuto: true,\r\n            rootPosition: Vector3.Zero(),\r\n\r\n            setupImageProcessing: true,\r\n            environmentTexture: this._EnvironmentTextureCDNUrl,\r\n            cameraExposure: 0.8,\r\n            cameraContrast: 1.2,\r\n            toneMappingEnabled: true,\r\n        };\r\n    }\r\n\r\n    private _rootMesh: Mesh;\r\n    /**\r\n     * Gets the root mesh created by the helper.\r\n     */\r\n    public get rootMesh(): Mesh {\r\n        return this._rootMesh;\r\n    }\r\n\r\n    private _skybox: Nullable<Mesh>;\r\n    /**\r\n     * Gets the skybox created by the helper.\r\n     */\r\n    public get skybox(): Nullable<Mesh> {\r\n        return this._skybox;\r\n    }\r\n\r\n    private _skyboxTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets the skybox texture created by the helper.\r\n     */\r\n    public get skyboxTexture(): Nullable<BaseTexture> {\r\n        return this._skyboxTexture;\r\n    }\r\n\r\n    private _skyboxMaterial: Nullable<BackgroundMaterial>;\r\n    /**\r\n     * Gets the skybox material created by the helper.\r\n     */\r\n    public get skyboxMaterial(): Nullable<BackgroundMaterial> {\r\n        return this._skyboxMaterial;\r\n    }\r\n\r\n    private _ground: Nullable<Mesh>;\r\n    /**\r\n     * Gets the ground mesh created by the helper.\r\n     */\r\n    public get ground(): Nullable<Mesh> {\r\n        return this._ground;\r\n    }\r\n\r\n    private _groundTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets the ground texture created by the helper.\r\n     */\r\n    public get groundTexture(): Nullable<BaseTexture> {\r\n        return this._groundTexture;\r\n    }\r\n\r\n    private _groundMirror: Nullable<MirrorTexture>;\r\n    /**\r\n     * Gets the ground mirror created by the helper.\r\n     */\r\n    public get groundMirror(): Nullable<MirrorTexture> {\r\n        return this._groundMirror;\r\n    }\r\n\r\n    /**\r\n     * Gets the ground mirror render list to helps pushing the meshes\r\n     * you wish in the ground reflection.\r\n     */\r\n    public get groundMirrorRenderList(): Nullable<AbstractMesh[]> {\r\n        if (this._groundMirror) {\r\n            return this._groundMirror.renderList;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _groundMaterial: Nullable<BackgroundMaterial>;\r\n    /**\r\n     * Gets the ground material created by the helper.\r\n     */\r\n    public get groundMaterial(): Nullable<BackgroundMaterial> {\r\n        return this._groundMaterial;\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene;\r\n    private _options: IEnvironmentHelperOptions;\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<IEnvironmentHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...EnvironmentHelper._GetDefaultOptions(scene),\r\n            ...options,\r\n        };\r\n        this._scene = scene;\r\n        this.onErrorObservable = new Observable();\r\n\r\n        this._setupBackground();\r\n        this._setupImageProcessing();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<IEnvironmentHelperOptions>) {\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        if (this._ground && !newOptions.createGround) {\r\n            this._ground.dispose();\r\n            this._ground = null;\r\n        }\r\n\r\n        if (this._groundMaterial && !newOptions.createGround) {\r\n            this._groundMaterial.dispose();\r\n            this._groundMaterial = null;\r\n        }\r\n\r\n        if (this._groundTexture) {\r\n            if (this._options.groundTexture != newOptions.groundTexture) {\r\n                this._groundTexture.dispose();\r\n                this._groundTexture = null;\r\n            }\r\n        }\r\n\r\n        if (this._skybox && !newOptions.createSkybox) {\r\n            this._skybox.dispose();\r\n            this._skybox = null;\r\n        }\r\n\r\n        if (this._skyboxMaterial && !newOptions.createSkybox) {\r\n            this._skyboxMaterial.dispose();\r\n            this._skyboxMaterial = null;\r\n        }\r\n\r\n        if (this._skyboxTexture) {\r\n            if (this._options.skyboxTexture != newOptions.skyboxTexture) {\r\n                this._skyboxTexture.dispose();\r\n                this._skyboxTexture = null;\r\n            }\r\n        }\r\n\r\n        if (this._groundMirror && !newOptions.enableGroundMirror) {\r\n            this._groundMirror.dispose();\r\n            this._groundMirror = null;\r\n        }\r\n\r\n        if (this._scene.environmentTexture) {\r\n            if (this._options.environmentTexture != newOptions.environmentTexture) {\r\n                this._scene.environmentTexture.dispose();\r\n            }\r\n        }\r\n\r\n        this._options = newOptions;\r\n\r\n        this._setupBackground();\r\n        this._setupImageProcessing();\r\n    }\r\n\r\n    /**\r\n     * Sets the primary color of all the available elements.\r\n     * @param color the main color to affect to the ground and the background\r\n     */\r\n    public setMainColor(color: Color3): void {\r\n        if (this.groundMaterial) {\r\n            this.groundMaterial.primaryColor = color;\r\n        }\r\n\r\n        if (this.skyboxMaterial) {\r\n            this.skyboxMaterial.primaryColor = color;\r\n        }\r\n\r\n        if (this.groundMirror) {\r\n            this.groundMirror.clearColor = new Color4(color.r, color.g, color.b, 1.0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the image processing according to the specified options.\r\n     */\r\n    private _setupImageProcessing(): void {\r\n        if (this._options.setupImageProcessing) {\r\n            this._scene.imageProcessingConfiguration.contrast = this._options.cameraContrast;\r\n            this._scene.imageProcessingConfiguration.exposure = this._options.cameraExposure;\r\n            this._scene.imageProcessingConfiguration.toneMappingEnabled = this._options.toneMappingEnabled;\r\n            this._setupEnvironmentTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the environment texture according to the specified options.\r\n     */\r\n    private _setupEnvironmentTexture(): void {\r\n        if (this._scene.environmentTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.environmentTexture instanceof BaseTexture) {\r\n            this._scene.environmentTexture = this._options.environmentTexture;\r\n            return;\r\n        }\r\n\r\n        const environmentTexture = CubeTexture.CreateFromPrefilteredData(this._options.environmentTexture, this._scene);\r\n        this._scene.environmentTexture = environmentTexture;\r\n    }\r\n\r\n    /**\r\n     * Setup the background according to the specified options.\r\n     */\r\n    private _setupBackground(): void {\r\n        if (!this._rootMesh) {\r\n            this._rootMesh = new Mesh(\"BackgroundHelper\", this._scene);\r\n        }\r\n        this._rootMesh.rotation.y = this._options.backgroundYRotation;\r\n\r\n        const sceneSize = this._getSceneSize();\r\n        if (this._options.createGround) {\r\n            this._setupGround(sceneSize);\r\n            this._setupGroundMaterial();\r\n            this._setupGroundDiffuseTexture();\r\n\r\n            if (this._options.enableGroundMirror) {\r\n                this._setupGroundMirrorTexture(sceneSize);\r\n            }\r\n            this._setupMirrorInGroundMaterial();\r\n        }\r\n\r\n        if (this._options.createSkybox) {\r\n            this._setupSkybox(sceneSize);\r\n            this._setupSkyboxMaterial();\r\n            this._setupSkyboxReflectionTexture();\r\n        }\r\n\r\n        this._rootMesh.position.x = sceneSize.rootPosition.x;\r\n        this._rootMesh.position.z = sceneSize.rootPosition.z;\r\n        this._rootMesh.position.y = sceneSize.rootPosition.y;\r\n    }\r\n\r\n    /**\r\n     * Get the scene sizes according to the setup.\r\n     */\r\n    private _getSceneSize(): ISceneSize {\r\n        let groundSize = this._options.groundSize;\r\n        let skyboxSize = this._options.skyboxSize;\r\n        let rootPosition = this._options.rootPosition;\r\n        if (!this._scene.meshes || this._scene.meshes.length === 1) {\r\n            // 1 only means the root of the helper.\r\n            return { groundSize, skyboxSize, rootPosition };\r\n        }\r\n\r\n        const sceneExtends = this._scene.getWorldExtends((mesh) => {\r\n            return mesh !== this._ground && mesh !== this._rootMesh && mesh !== this._skybox;\r\n        });\r\n        const sceneDiagonal = sceneExtends.max.subtract(sceneExtends.min);\r\n\r\n        if (this._options.sizeAuto) {\r\n            if (this._scene.activeCamera instanceof ArcRotateCamera && this._scene.activeCamera.upperRadiusLimit) {\r\n                groundSize = this._scene.activeCamera.upperRadiusLimit * 2;\r\n                skyboxSize = groundSize;\r\n            }\r\n\r\n            const sceneDiagonalLenght = sceneDiagonal.length();\r\n            if (sceneDiagonalLenght > groundSize) {\r\n                groundSize = sceneDiagonalLenght * 2;\r\n                skyboxSize = groundSize;\r\n            }\r\n\r\n            // 10 % bigger.\r\n            groundSize *= 1.1;\r\n            skyboxSize *= 1.5;\r\n            rootPosition = sceneExtends.min.add(sceneDiagonal.scale(0.5));\r\n            rootPosition.y = sceneExtends.min.y - this._options.groundYBias;\r\n        }\r\n\r\n        return { groundSize, skyboxSize, rootPosition };\r\n    }\r\n\r\n    /**\r\n     * Setup the ground according to the specified options.\r\n     * @param sceneSize\r\n     */\r\n    private _setupGround(sceneSize: ISceneSize): void {\r\n        if (!this._ground || this._ground.isDisposed()) {\r\n            this._ground = CreatePlane(\"BackgroundPlane\", { size: sceneSize.groundSize }, this._scene);\r\n            this._ground.rotation.x = Math.PI / 2; // Face up by default.\r\n            this._ground.parent = this._rootMesh;\r\n            this._ground.onDisposeObservable.add(() => {\r\n                this._ground = null;\r\n            });\r\n        }\r\n\r\n        this._ground.receiveShadows = this._options.enableGroundShadow;\r\n    }\r\n\r\n    /**\r\n     * Setup the ground material according to the specified options.\r\n     */\r\n    private _setupGroundMaterial(): void {\r\n        if (!this._groundMaterial) {\r\n            this._groundMaterial = new BackgroundMaterial(\"BackgroundPlaneMaterial\", this._scene);\r\n        }\r\n        this._groundMaterial.alpha = this._options.groundOpacity;\r\n        this._groundMaterial.alphaMode = Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n        this._groundMaterial.shadowLevel = this._options.groundShadowLevel;\r\n        this._groundMaterial.primaryColor = this._options.groundColor;\r\n        this._groundMaterial.useRGBColor = false;\r\n        this._groundMaterial.enableNoise = true;\r\n\r\n        if (this._ground) {\r\n            this._ground.material = this._groundMaterial;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the ground diffuse texture according to the specified options.\r\n     */\r\n    private _setupGroundDiffuseTexture(): void {\r\n        if (!this._groundMaterial) {\r\n            return;\r\n        }\r\n\r\n        if (this._groundTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.groundTexture instanceof BaseTexture) {\r\n            this._groundMaterial.diffuseTexture = this._options.groundTexture;\r\n            return;\r\n        }\r\n\r\n        this._groundTexture = new Texture(this._options.groundTexture, this._scene, undefined, undefined, undefined, undefined, this._errorHandler);\r\n        this._groundTexture.gammaSpace = false;\r\n        this._groundTexture.hasAlpha = true;\r\n        this._groundMaterial.diffuseTexture = this._groundTexture;\r\n    }\r\n\r\n    /**\r\n     * Setup the ground mirror texture according to the specified options.\r\n     * @param sceneSize\r\n     */\r\n    private _setupGroundMirrorTexture(sceneSize: ISceneSize): void {\r\n        const wrapping = Texture.CLAMP_ADDRESSMODE;\r\n        if (!this._groundMirror) {\r\n            this._groundMirror = new MirrorTexture(\r\n                \"BackgroundPlaneMirrorTexture\",\r\n                { ratio: this._options.groundMirrorSizeRatio },\r\n                this._scene,\r\n                false,\r\n                this._options.groundMirrorTextureType,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                true\r\n            );\r\n            this._groundMirror.mirrorPlane = new Plane(0, -1, 0, sceneSize.rootPosition.y);\r\n            this._groundMirror.anisotropicFilteringLevel = 1;\r\n            this._groundMirror.wrapU = wrapping;\r\n            this._groundMirror.wrapV = wrapping;\r\n\r\n            if (this._groundMirror.renderList) {\r\n                for (let i = 0; i < this._scene.meshes.length; i++) {\r\n                    const mesh = this._scene.meshes[i];\r\n                    if (mesh !== this._ground && mesh !== this._skybox && mesh !== this._rootMesh) {\r\n                        this._groundMirror.renderList.push(mesh);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const gammaGround = this._options.groundColor.toGammaSpace(this._scene.getEngine().useExactSrgbConversions);\r\n        this._groundMirror.clearColor = new Color4(gammaGround.r, gammaGround.g, gammaGround.b, 1);\r\n        this._groundMirror.adaptiveBlurKernel = this._options.groundMirrorBlurKernel;\r\n    }\r\n\r\n    /**\r\n     * Setup the ground to receive the mirror texture.\r\n     */\r\n    private _setupMirrorInGroundMaterial(): void {\r\n        if (this._groundMaterial) {\r\n            this._groundMaterial.reflectionTexture = this._groundMirror;\r\n            this._groundMaterial.reflectionFresnel = true;\r\n            this._groundMaterial.reflectionAmount = this._options.groundMirrorAmount;\r\n            this._groundMaterial.reflectionStandardFresnelWeight = this._options.groundMirrorFresnelWeight;\r\n            this._groundMaterial.reflectionFalloffDistance = this._options.groundMirrorFallOffDistance;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the skybox according to the specified options.\r\n     * @param sceneSize\r\n     */\r\n    private _setupSkybox(sceneSize: ISceneSize): void {\r\n        if (!this._skybox || this._skybox.isDisposed()) {\r\n            this._skybox = CreateBox(\"BackgroundSkybox\", { size: sceneSize.skyboxSize, sideOrientation: Mesh.BACKSIDE }, this._scene);\r\n            this._skybox.onDisposeObservable.add(() => {\r\n                this._skybox = null;\r\n            });\r\n        }\r\n        this._skybox.parent = this._rootMesh;\r\n    }\r\n\r\n    /**\r\n     * Setup the skybox material according to the specified options.\r\n     */\r\n    private _setupSkyboxMaterial(): void {\r\n        if (!this._skybox) {\r\n            return;\r\n        }\r\n\r\n        if (!this._skyboxMaterial) {\r\n            this._skyboxMaterial = new BackgroundMaterial(\"BackgroundSkyboxMaterial\", this._scene);\r\n        }\r\n        this._skyboxMaterial.useRGBColor = false;\r\n        this._skyboxMaterial.primaryColor = this._options.skyboxColor;\r\n        this._skyboxMaterial.enableNoise = true;\r\n\r\n        this._skybox.material = this._skyboxMaterial;\r\n    }\r\n\r\n    /**\r\n     * Setup the skybox reflection texture according to the specified options.\r\n     */\r\n    private _setupSkyboxReflectionTexture(): void {\r\n        if (!this._skyboxMaterial) {\r\n            return;\r\n        }\r\n\r\n        if (this._skyboxTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.skyboxTexture instanceof BaseTexture) {\r\n            this._skyboxMaterial.reflectionTexture = this._options.skyboxTexture;\r\n            return;\r\n        }\r\n\r\n        this._skyboxTexture = new CubeTexture(this._options.skyboxTexture, this._scene, undefined, undefined, undefined, undefined, this._errorHandler);\r\n        this._skyboxTexture.coordinatesMode = Texture.SKYBOX_MODE;\r\n        this._skyboxTexture.gammaSpace = false;\r\n        this._skyboxMaterial.reflectionTexture = this._skyboxTexture;\r\n    }\r\n\r\n    private _errorHandler = (message?: string, exception?: any) => {\r\n        this.onErrorObservable.notifyObservers({ message: message, exception: exception });\r\n    };\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        if (this._groundMaterial) {\r\n            this._groundMaterial.dispose(true, true);\r\n        }\r\n        if (this._skyboxMaterial) {\r\n            this._skyboxMaterial.dispose(true, true);\r\n        }\r\n        this._rootMesh.dispose(false);\r\n    }\r\n}\r\n","import { serialize } from \"../Misc/decorators\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\r\n    return () => new PointLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A point light is a light defined by an unique point in world space.\r\n * The light is emitted in every direction from this point.\r\n * A good example of a point light is a standard light bulb.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class PointLight extends ShadowLight {\r\n    private _shadowAngle = Math.PI / 2;\r\n    /**\r\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    @serialize()\r\n    public get shadowAngle(): number {\r\n        return this._shadowAngle;\r\n    }\r\n    /**\r\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    public set shadowAngle(value: number) {\r\n        this._shadowAngle = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Gets the direction if it has been set.\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public set direction(value: Vector3) {\r\n        const previousNeedCube = this.needCube();\r\n        this._direction = value;\r\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.recreateShadowMap();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\r\n     * A PointLight emits the light in every direction.\r\n     * It can cast shadows.\r\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\r\n     * ```javascript\r\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\r\n     * ```\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the point light in the scene\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointLight\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"PointLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 0.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_POINTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the shadowmap should be a cube texture.\r\n     * @returns true if the shadowmap needs to be a cube texture.\r\n     */\r\n    public needCube(): boolean {\r\n        return !this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        if (this.direction) {\r\n            return super.getShadowDirection(faceIndex);\r\n        } else {\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    return new Vector3(1.0, 0.0, 0.0);\r\n                case 1:\r\n                    return new Vector3(-1.0, 0.0, 0.0);\r\n                case 2:\r\n                    return new Vector3(0.0, -1.0, 0.0);\r\n                case 3:\r\n                    return new Vector3(0.0, 1.0, 0.0);\r\n                case 4:\r\n                    return new Vector3(0.0, 0.0, 1.0);\r\n                case 5:\r\n                    return new Vector3(0.0, 0.0, -1.0);\r\n            }\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\r\n     * - fov = PI / 2\r\n     * - aspect ratio : 1.0\r\n     * - z-near and far equal to the active camera minZ and maxZ.\r\n     * Returns the PointLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this.shadowAngle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The point light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): PointLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0.0, lightIndex);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, lightIndex);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"POINTLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n","import { serialize, serializeAsTexture } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\r\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\r\n});\r\n\r\n/**\r\n * A spot light is defined by a position, a direction, an angle, and an exponent.\r\n * These values define a cone of light starting from the position, emitting toward the direction.\r\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\r\n * and the exponent defines the speed of the decay of the light with distance (reach).\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class SpotLight extends ShadowLight {\r\n    /*\r\n        upVector , rightVector and direction will form the coordinate system for this spot light.\r\n        These three vectors will be used as projection matrix when doing texture projection.\r\n\r\n        Also we have the following rules always holds:\r\n        direction cross up   = right\r\n        right cross direction = up\r\n        up cross right       = forward\r\n\r\n        light_near and light_far will control the range of the texture projection. If a plane is\r\n        out of the range in spot light space, there is no texture projection.\r\n    */\r\n\r\n    private _angle: number;\r\n    private _innerAngle: number = 0;\r\n    private _cosHalfAngle: number;\r\n\r\n    private _lightAngleScale: number;\r\n    private _lightAngleOffset: number;\r\n\r\n    /**\r\n     * Gets the cone angle of the spot light in Radians.\r\n     */\r\n    @serialize()\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n    /**\r\n     * Sets the cone angle of the spot light in Radians.\r\n     */\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._cosHalfAngle = Math.cos(value * 0.5);\r\n        this._projectionTextureProjectionLightDirty = true;\r\n        this.forceProjectionMatrixCompute();\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    @serialize()\r\n    public get innerAngle(): number {\r\n        return this._innerAngle;\r\n    }\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    public set innerAngle(value: number) {\r\n        this._innerAngle = value;\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    private _shadowAngleScale: number;\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    @serialize()\r\n    public get shadowAngleScale(): number {\r\n        return this._shadowAngleScale;\r\n    }\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    public set shadowAngleScale(value: number) {\r\n        this._shadowAngleScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * The light decay speed with the distance from the emission spot.\r\n     */\r\n    @serialize()\r\n    public exponent: number;\r\n\r\n    private _projectionTextureMatrix = Matrix.Zero();\r\n    /**\r\n     * Allows reading the projection texture\r\n     */\r\n    public get projectionTextureMatrix(): Matrix {\r\n        return this._projectionTextureMatrix;\r\n    }\r\n\r\n    protected _projectionTextureLightNear: number = 1e-6;\r\n    /**\r\n     * Gets the near clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightNear(): number {\r\n        return this._projectionTextureLightNear;\r\n    }\r\n    /**\r\n     * Sets the near clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightNear(value: number) {\r\n        this._projectionTextureLightNear = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureLightFar: number = 1000.0;\r\n    /**\r\n     * Gets the far clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightFar(): number {\r\n        return this._projectionTextureLightFar;\r\n    }\r\n    /**\r\n     * Sets the far clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightFar(value: number) {\r\n        this._projectionTextureLightFar = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureUpDirection: Vector3 = Vector3.Up();\r\n    /**\r\n     * Gets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureUpDirection(): Vector3 {\r\n        return this._projectionTextureUpDirection;\r\n    }\r\n    /**\r\n     * Sets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureUpDirection(value: Vector3) {\r\n        this._projectionTextureUpDirection = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    @serializeAsTexture(\"projectedLightTexture\")\r\n    private _projectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets the projection texture of the light.\r\n     */\r\n    public get projectionTexture(): Nullable<BaseTexture> {\r\n        return this._projectionTexture;\r\n    }\r\n    /**\r\n     * Sets the projection texture of the light.\r\n     */\r\n    public set projectionTexture(value: Nullable<BaseTexture>) {\r\n        if (this._projectionTexture === value) {\r\n            return;\r\n        }\r\n        this._projectionTexture = value;\r\n        this._projectionTextureDirty = true;\r\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\r\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\r\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            } else if (SpotLight._IsTexture(this._projectionTexture)) {\r\n                this._projectionTexture.onLoadObservable.addOnce(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsProceduralTexture(texture: BaseTexture): texture is ProceduralTexture {\r\n        return (texture as ProceduralTexture).onGeneratedObservable !== undefined;\r\n    }\r\n\r\n    private static _IsTexture(texture: BaseTexture): texture is Texture {\r\n        return (texture as Texture).onLoadObservable !== undefined;\r\n    }\r\n\r\n    private _projectionTextureViewLightDirty = true;\r\n    private _projectionTextureProjectionLightDirty = true;\r\n    private _projectionTextureDirty = true;\r\n    private _projectionTextureViewTargetVector = Vector3.Zero();\r\n    private _projectionTextureViewLightMatrix = Matrix.Zero();\r\n\r\n    private _projectionTextureProjectionLightMatrix = Matrix.Zero();\r\n    /**\r\n     * Gets or sets the light projection matrix as used by the projection texture\r\n     */\r\n    public get projectionTextureProjectionLightMatrix(): Matrix {\r\n        return this._projectionTextureProjectionLightMatrix;\r\n    }\r\n\r\n    public set projectionTextureProjectionLightMatrix(projection: Matrix) {\r\n        this._projectionTextureProjectionLightMatrix = projection;\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n    }\r\n\r\n    private _projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\r\n\r\n    /**\r\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the spot light in the scene\r\n     * @param direction The direction of the light in the scene\r\n     * @param angle The cone angle of the light in Radians\r\n     * @param exponent The light decay speed with the distance from the emission spot\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, direction: Vector3, angle: number, exponent: number, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.position = position;\r\n        this.direction = direction;\r\n        this.angle = angle;\r\n        this.exponent = exponent;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpotLight\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SpotLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 2.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_SPOTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected _setDirection(value: Vector3) {\r\n        super._setDirection(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Overrides the position setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected _setPosition(value: Vector3) {\r\n        super._setPosition(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\r\n     * Returns the SpotLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this._shadowAngleScale = this._shadowAngleScale || 1;\r\n        const angle = this._shadowAngleScale * this._angle;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            angle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _computeProjectionTextureViewLightMatrix(): void {\r\n        this._projectionTextureViewLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        this.getAbsolutePosition().addToRef(this.direction, this._projectionTextureViewTargetVector);\r\n        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\r\n    }\r\n\r\n    protected _computeProjectionTextureProjectionLightMatrix(): void {\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        const lightFar = this.projectionTextureLightFar;\r\n        const lightNear = this.projectionTextureLightNear;\r\n\r\n        const P = lightFar / (lightFar - lightNear);\r\n        const Q = -P * lightNear;\r\n        const S = 1.0 / Math.tan(this._angle / 2.0);\r\n        const A = 1.0;\r\n\r\n        Matrix.FromValuesToRef(S / A, 0.0, 0.0, 0.0, 0.0, S, 0.0, 0.0, 0.0, 0.0, P, 1.0, 0.0, 0.0, Q, 0.0, this._projectionTextureProjectionLightMatrix);\r\n    }\r\n\r\n    /**\r\n     * Main function for light texture projection matrix computing.\r\n     */\r\n    protected _computeProjectionTextureMatrix(): void {\r\n        this._projectionTextureDirty = false;\r\n\r\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\r\n        if (this._projectionTexture instanceof Texture) {\r\n            const u = this._projectionTexture.uScale / 2.0;\r\n            const v = this._projectionTexture.vScale / 2.0;\r\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\r\n        }\r\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    private _computeAngleValues(): void {\r\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\r\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\r\n            if (this._projectionTextureViewLightDirty) {\r\n                this._computeProjectionTextureViewLightMatrix();\r\n            }\r\n            if (this._projectionTextureProjectionLightDirty) {\r\n                this._computeProjectionTextureProjectionLightMatrix();\r\n            }\r\n            if (this._projectionTextureDirty) {\r\n                this._computeProjectionTextureMatrix();\r\n            }\r\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\r\n            effect.setTexture(\"projectionLightSampler\" + lightIndex, this.projectionTexture);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The spot light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): SpotLight {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);\r\n\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);\r\n\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the light and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        if (this._projectionTexture) {\r\n            this._projectionTexture.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\r\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"backgroundFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;uniform vec4 vPrimaryColor;\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nuniform vec4 vPrimaryColorShadow;\n#endif\nuniform float shadowLevel;uniform float alpha;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;\n#endif\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const backgroundFragmentDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\n\nconst name = \"backgroundUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Material\n{uniform vec4 vPrimaryColor;uniform vec4 vPrimaryColorShadow;uniform vec2 vDiffuseInfos;uniform vec2 vReflectionInfos;uniform mat4 diffuseMatrix;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;uniform float fFovMultiplier;uniform float pointSize;uniform float shadowLevel;uniform float alpha;\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\nuniform vec3 vBackgroundCenter;\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 vReflectionControl;\n#endif\n};\n#include<sceneUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const backgroundUboDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundFragmentDeclaration\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"backgroundPixelShader\";\nconst shader = `#ifdef TEXTURELODSUPPORT\n#extension GL_EXT_shader_texture_lod : enable\n#endif\nprecision highp float;\n#include<__decl__backgroundFragment>\n#include<helperFunctions>\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif \n#ifdef MAINUV2 \nvarying vec2 vMainUV2; \n#endif \n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV==1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV==2\n#define vDiffuseUV vMainUV2\n#else\nvarying vec2 vDiffuseUV;\n#endif\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef TEXTURELODSUPPORT\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE;\n#endif\n#ifndef SHADOWONLY\n#define SHADOWONLY;\n#endif\n#include<imageProcessingDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<imageProcessingFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef REFLECTIONFRESNEL\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(0.0,1.0,0.0);\n#endif\nfloat shadow=1.;float globalShadow=0.;float shadowLightCount=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef SHADOWINUSE\nglobalShadow/=shadowLightCount;\n#else\nglobalShadow=1.0;\n#endif\n#ifndef BACKMAT_SHADOWONLY\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\n#ifdef REFLECTION\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=reflectionVector;\n#else\nvec2 reflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n#ifdef REFLECTIONBLUR\nfloat reflectionLOD=vReflectionInfos.y;\n#ifdef TEXTURELODSUPPORT\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;reflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD);float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);if(lodReflectionNormalizedDoubled<1.0){reflectionColor=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nreflectionSpecularMid,\nlodReflectionNormalizedDoubled\n);} else {reflectionColor=mix(\nreflectionSpecularMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\n#else\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);reflectionColor=reflectionSample;\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef GAMMAREFLECTION\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\n#endif\n#ifdef REFLECTIONBGR\nreflectionColor.rgb=reflectionColor.bgr;\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#endif\nvec3 diffuseColor=vec3(1.,1.,1.);float finalAlpha=alpha;\n#ifdef DIFFUSE\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef GAMMADIFFUSE\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\n#endif\ndiffuseMap.rgb*=vDiffuseInfos.y;\n#ifdef DIFFUSEHASALPHA\nfinalAlpha*=diffuseMap.a;\n#endif\ndiffuseColor=diffuseMap.rgb;\n#endif\n#ifdef REFLECTIONFRESNEL\nvec3 colorBase=diffuseColor;\n#else\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\n#endif\ncolorBase=max(colorBase,0.0);\n#ifdef USERGBCOLOR\nvec3 finalColor=colorBase;\n#else\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\n#else\nvec3 mainColor=vPrimaryColor.rgb;\n#endif\nvec3 finalColor=colorBase*mainColor;\n#endif\n#ifdef REFLECTIONFRESNEL\nvec3 reflectionAmount=vReflectionControl.xxx;vec3 reflectionReflectance0=vReflectionControl.yyy;vec3 reflectionReflectance90=vReflectionControl.zzz;float VdotN=dot(normalize(vEyePosition.xyz),normalW);vec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);reflectionAmount*=planarReflectionFresnel;\n#ifdef REFLECTIONFALLOFF\nfloat reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);reflectionDistanceFalloff*=reflectionDistanceFalloff;reflectionAmount*=reflectionDistanceFalloff;\n#endif\nfinalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));\n#endif\n#ifdef OPACITYFRESNEL\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition.xyz-vBackgroundCenter));const float startAngle=0.1;float fadeFactor=saturate(viewAngleToFloor/startAngle);finalAlpha*=fadeFactor*fadeFactor;\n#endif\n#ifdef SHADOWINUSE\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\n#endif\nvec4 color=vec4(finalColor,finalAlpha);\n#else\nvec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);\n#endif\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n#if !defined(SKIPFINALCOLORCLAMP)\ncolor.rgb=clamp(color.rgb,0.,30.0);\n#endif\n#else\ncolor=applyImageProcessing(color);\n#endif\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#ifdef NOISE\ncolor.rgb+=dither(vPositionW.xy,0.5);color=max(color,0.0);\n#endif\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const backgroundPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"backgroundVertexDeclaration\";\nconst shader = `uniform mat4 view;uniform mat4 viewProjection;uniform float shadowLevel;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;uniform float fFovMultiplier;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const backgroundVertexDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundVertexDeclaration\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\n\nconst name = \"backgroundVertexShader\";\nconst shader = `precision highp float;\n#include<__decl__backgroundVertex>\n#include<helperFunctions>\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef MAINUV1\nvarying vec2 vMainUV1;\n#endif\n#ifdef MAINUV2\nvarying vec2 vMainUV2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nvarying vec2 vDiffuseUV;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*finalWorld*vec4(position,1.0);} else {gl_Position=viewProjectionR*finalWorld*vec4(position,1.0);}\n#else\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#endif\nvec4 worldPos=finalWorld*vec4(position,1.0);vPositionW=vec3(worldPos);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normal);\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));vec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));if (fFovMultiplier<=1.0) {vDirectionW=normalize(segment);} else {vDirectionW=normalize(vDirectionW+(vDirectionW-segment));}\n#endif\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uv;\n#endif\n#ifdef MAINUV2\nvMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const backgroundVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport {\r\n    SerializationHelper,\r\n    serialize,\r\n    serializeAsColor3,\r\n    expandToProperty,\r\n    serializeAsTexture,\r\n    serializeAsVector3,\r\n    serializeAsImageProcessingConfiguration,\r\n} from \"../../Misc/decorators\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable, int, float } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport type { ColorCurves } from \"../../Materials/colorCurves\";\r\nimport type { IImageProcessingConfigurationDefines } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { IShadowLight } from \"../../Lights/shadowLight\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nimport \"../../Shaders/background.fragment\";\r\nimport \"../../Shaders/background.vertex\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Background material defines definition.\r\n * @internal Mainly internal Use\r\n */\r\nclass BackgroundMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    /**\r\n     * True if the diffuse texture is in use.\r\n     */\r\n    public DIFFUSE = false;\r\n\r\n    /**\r\n     * The direct UV channel to use.\r\n     */\r\n    public DIFFUSEDIRECTUV = 0;\r\n\r\n    /**\r\n     * True if the diffuse texture is in gamma space.\r\n     */\r\n    public GAMMADIFFUSE = false;\r\n\r\n    /**\r\n     * True if the diffuse texture has opacity in the alpha channel.\r\n     */\r\n    public DIFFUSEHASALPHA = false;\r\n\r\n    /**\r\n     * True if you want the material to fade to transparent at grazing angle.\r\n     */\r\n    public OPACITYFRESNEL = false;\r\n\r\n    /**\r\n     * True if an extra blur needs to be added in the reflection.\r\n     */\r\n    public REFLECTIONBLUR = false;\r\n\r\n    /**\r\n     * True if you want the material to fade to reflection at grazing angle.\r\n     */\r\n    public REFLECTIONFRESNEL = false;\r\n\r\n    /**\r\n     * True if you want the material to falloff as far as you move away from the scene center.\r\n     */\r\n    public REFLECTIONFALLOFF = false;\r\n\r\n    /**\r\n     * False if the current Webgl implementation does not support the texture lod extension.\r\n     */\r\n    public TEXTURELODSUPPORT = false;\r\n\r\n    /**\r\n     * True to ensure the data are premultiplied.\r\n     */\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    /**\r\n     * True if the texture contains cooked RGB values and not gray scaled multipliers.\r\n     */\r\n    public USERGBCOLOR = false;\r\n\r\n    /**\r\n     * True if highlight and shadow levels have been specified. It can help ensuring the main perceived color\r\n     * stays aligned with the desired configuration.\r\n     */\r\n    public USEHIGHLIGHTANDSHADOWCOLORS = false;\r\n\r\n    /**\r\n     * True if only shadows must be rendered\r\n     */\r\n    public BACKMAT_SHADOWONLY = false;\r\n\r\n    /**\r\n     * True to add noise in order to reduce the banding effect.\r\n     */\r\n    public NOISE = false;\r\n\r\n    /**\r\n     * is the reflection texture in BGR color scheme?\r\n     * Mainly used to solve a bug in ios10 video tag\r\n     */\r\n    public REFLECTIONBGR = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public EXPOSURE = false;\r\n    public MULTIVIEW = false;\r\n\r\n    // Reflection.\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public EQUIRECTANGULAR_RELFECTION_FOV = false;\r\n\r\n    // Default BJS.\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public SHADOWFLOAT = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public NONUNIFORMSCALING = false;\r\n    public ALPHATEST = false;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * Background material used to create an efficient environment around your scene.\r\n */\r\nexport class BackgroundMaterial extends PushMaterial {\r\n    /**\r\n     * Standard reflectance value at parallel view angle.\r\n     */\r\n    public static StandardReflectance0 = 0.05;\r\n\r\n    /**\r\n     * Standard reflectance value at grazing angle.\r\n     */\r\n    public static StandardReflectance90 = 0.5;\r\n\r\n    @serializeAsColor3()\r\n    protected _primaryColor: Color3;\r\n    /**\r\n     * Key light Color (multiply against the environment texture)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public primaryColor = Color3.White();\r\n\r\n    @serializeAsColor3()\r\n    protected __perceptualColor: Nullable<Color3>;\r\n    /**\r\n     * Experimental Internal Use Only.\r\n     *\r\n     * Key light Color in \"perceptual value\" meaning the color you would like to see on screen.\r\n     * This acts as a helper to set the primary color to a more \"human friendly\" value.\r\n     * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the\r\n     * output color as close as possible from the chosen value.\r\n     * (This does not account for contrast color grading and color curves as they are considered post effect and not directly\r\n     * part of lighting setup.)\r\n     */\r\n    public get _perceptualColor(): Nullable<Color3> {\r\n        return this.__perceptualColor;\r\n    }\r\n    public set _perceptualColor(value: Nullable<Color3>) {\r\n        this.__perceptualColor = value;\r\n        this._computePrimaryColorFromPerceptualColor();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serialize()\r\n    protected _primaryColorShadowLevel: float = 0;\r\n    /**\r\n     * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.\r\n     * The color opposite to the primary color is used at the level chosen to define what the black area would look.\r\n     */\r\n    public get primaryColorShadowLevel(): float {\r\n        return this._primaryColorShadowLevel;\r\n    }\r\n    public set primaryColorShadowLevel(value: float) {\r\n        this._primaryColorShadowLevel = value;\r\n        this._computePrimaryColors();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serialize()\r\n    protected _primaryColorHighlightLevel: float = 0;\r\n    /**\r\n     * Defines the level of the highlights (highlight area of the reflection map) in order to help scaling the colors.\r\n     * The primary color is used at the level chosen to define what the white area would look.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public get primaryColorHighlightLevel(): float {\r\n        return this._primaryColorHighlightLevel;\r\n    }\r\n    public set primaryColorHighlightLevel(value: float) {\r\n        this._primaryColorHighlightLevel = value;\r\n        this._computePrimaryColors();\r\n        this._markAllSubMeshesAsLightsDirty();\r\n    }\r\n\r\n    @serializeAsTexture()\r\n    protected _reflectionTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Reflection Texture used in the material.\r\n     * Should be author in a specific way for the best result (refer to the documentation).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture> = null;\r\n\r\n    @serialize()\r\n    protected _reflectionBlur: float;\r\n    /**\r\n     * Reflection Texture level of blur.\r\n     *\r\n     * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the\r\n     * texture twice.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionBlur: float = 0;\r\n\r\n    @serializeAsTexture()\r\n    protected _diffuseTexture: Nullable<BaseTexture>;\r\n    /**\r\n     * Diffuse Texture used in the material.\r\n     * Should be author in a specific way for the best result (refer to the documentation).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture> = null;\r\n\r\n    protected _shadowLights: Nullable<IShadowLight[]> = null;\r\n    /**\r\n     * Specify the list of lights casting shadow on the material.\r\n     * All scene shadow lights will be included if null.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public shadowLights: Nullable<IShadowLight[]> = null;\r\n\r\n    @serialize()\r\n    protected _shadowLevel: float;\r\n    /**\r\n     * Helps adjusting the shadow to a softer level if required.\r\n     * 0 means black shadows and 1 means no shadows.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public shadowLevel: float = 0;\r\n\r\n    @serializeAsVector3()\r\n    protected _sceneCenter: Vector3;\r\n    /**\r\n     * In case of opacity Fresnel or reflection falloff, this is use as a scene center.\r\n     * It is usually zero but might be interesting to modify according to your setup.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public sceneCenter: Vector3 = Vector3.Zero();\r\n\r\n    @serialize()\r\n    protected _opacityFresnel: boolean;\r\n    /**\r\n     * This helps specifying that the material is falling off to the sky box at grazing angle.\r\n     * This helps ensuring a nice transition when the camera goes under the ground.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityFresnel: boolean = true;\r\n\r\n    @serialize()\r\n    protected _reflectionFresnel: boolean;\r\n    /**\r\n     * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.\r\n     * This helps adding a mirror texture on the ground.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionFresnel: boolean = false;\r\n\r\n    @serialize()\r\n    protected _reflectionFalloffDistance: number;\r\n    /**\r\n     * This helps specifying the falloff radius off the reflection texture from the sceneCenter.\r\n     * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionFalloffDistance: number = 0.0;\r\n\r\n    @serialize()\r\n    protected _reflectionAmount: number;\r\n    /**\r\n     * This specifies the weight of the reflection against the background in case of reflection Fresnel.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionAmount: number = 1.0;\r\n\r\n    @serialize()\r\n    protected _reflectionReflectance0: number;\r\n    /**\r\n     * This specifies the weight of the reflection at grazing angle.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionReflectance0: number = 0.05;\r\n\r\n    @serialize()\r\n    protected _reflectionReflectance90: number;\r\n    /**\r\n     * This specifies the weight of the reflection at a perpendicular point of view.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionReflectance90: number = 0.5;\r\n\r\n    /**\r\n     * Sets the reflection reflectance fresnel values according to the default standard\r\n     * empirically know to work well :-)\r\n     */\r\n    public set reflectionStandardFresnelWeight(value: number) {\r\n        let reflectionWeight = value;\r\n\r\n        if (reflectionWeight < 0.5) {\r\n            reflectionWeight = reflectionWeight * 2.0;\r\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 * reflectionWeight;\r\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 * reflectionWeight;\r\n        } else {\r\n            reflectionWeight = reflectionWeight * 2.0 - 1.0;\r\n            this.reflectionReflectance0 = BackgroundMaterial.StandardReflectance0 + (1.0 - BackgroundMaterial.StandardReflectance0) * reflectionWeight;\r\n            this.reflectionReflectance90 = BackgroundMaterial.StandardReflectance90 + (1.0 - BackgroundMaterial.StandardReflectance90) * reflectionWeight;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    protected _useRGBColor: boolean;\r\n    /**\r\n     * Helps to directly use the maps channels instead of their level.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRGBColor: boolean = true;\r\n\r\n    @serialize()\r\n    protected _enableNoise: boolean;\r\n    /**\r\n     * This helps reducing the banding effect that could occur on the background.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableNoise: boolean = false;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.\r\n     * Recommended to be keep at 1.0 except for special cases.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        if (isNaN(value)) {\r\n            value = 1.0;\r\n        }\r\n        this._fovMultiplier = Math.max(0.0, Math.min(2.0, value));\r\n    }\r\n    private _fovMultiplier: float = 1.0;\r\n\r\n    /**\r\n     * Enable the FOV adjustment feature controlled by fovMultiplier.\r\n     */\r\n    public useEquirectangularFOV: boolean = false;\r\n\r\n    @serialize()\r\n    private _maxSimultaneousLights: int = 4;\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public maxSimultaneousLights: int = 4;\r\n\r\n    @serialize()\r\n    private _shadowOnly: boolean = false;\r\n    /**\r\n     * Make the material only render shadows\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public shadowOnly: boolean = false;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the Background Material.\r\n     */\r\n    @serializeAsImageProcessingConfiguration()\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration (if null the scene configuration will be use)\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._computePrimaryColorFromPerceptualColor();\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): float {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: float) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): float {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: float) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        (<ImageProcessingConfiguration>this.imageProcessingConfiguration).colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.\r\n     * Setting this flag to true (not done automatically!) will convert it back to RGB.\r\n     */\r\n    public switchToBGR: boolean = false;\r\n\r\n    // Temp values kept as cache in the material.\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n    private _reflectionControls = Vector4.Zero();\r\n    private _white = Color3.White();\r\n    private _primaryShadowColor = Color3.Black();\r\n    private _primaryHighlightColor = Color3.Black();\r\n\r\n    /**\r\n     * Instantiates a Background Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n                this._renderTargets.push(this._diffuseTexture as RenderTargetTexture);\r\n            }\r\n\r\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(this._reflectionTexture as RenderTargetTexture);\r\n            }\r\n\r\n            return this._renderTargets;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The entire material has been created in order to prevent overdraw.\r\n     * @returns false\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The entire material has been created in order to prevent overdraw.\r\n     * @returns true if blending is enable\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1 || (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._shadowOnly;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @param useInstances Specify wether or not the material is used with instances\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new BackgroundMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <BackgroundMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        MaterialHelper.PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (scene.getEngine().getCaps().textureLOD) {\r\n                    defines.TEXTURELODSUPPORT = true;\r\n                }\r\n\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    defines.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha;\r\n                    defines.GAMMADIFFUSE = this._diffuseTexture.gammaSpace;\r\n                    defines.OPACITYFRESNEL = this._opacityFresnel;\r\n                } else {\r\n                    defines.DIFFUSE = false;\r\n                    defines.DIFFUSEDIRECTUV = 0;\r\n                    defines.DIFFUSEHASALPHA = false;\r\n                    defines.GAMMADIFFUSE = false;\r\n                    defines.OPACITYFRESNEL = false;\r\n                }\r\n\r\n                const reflectionTexture = this._reflectionTexture;\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.REFLECTION = true;\r\n                    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\r\n                    defines.RGBDREFLECTION = reflectionTexture.isRGBD;\r\n                    defines.REFLECTIONBLUR = this._reflectionBlur > 0;\r\n                    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\r\n                    defines.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV;\r\n                    defines.REFLECTIONBGR = this.switchToBGR;\r\n\r\n                    if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {\r\n                        defines.INVERTCUBICMAP = true;\r\n                    }\r\n\r\n                    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\r\n\r\n                    switch (reflectionTexture.coordinatesMode) {\r\n                        case Texture.EXPLICIT_MODE:\r\n                            defines.REFLECTIONMAP_EXPLICIT = true;\r\n                            break;\r\n                        case Texture.PLANAR_MODE:\r\n                            defines.REFLECTIONMAP_PLANAR = true;\r\n                            break;\r\n                        case Texture.PROJECTION_MODE:\r\n                            defines.REFLECTIONMAP_PROJECTION = true;\r\n                            break;\r\n                        case Texture.SKYBOX_MODE:\r\n                            defines.REFLECTIONMAP_SKYBOX = true;\r\n                            break;\r\n                        case Texture.SPHERICAL_MODE:\r\n                            defines.REFLECTIONMAP_SPHERICAL = true;\r\n                            break;\r\n                        case Texture.EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                            defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                            defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\r\n                            break;\r\n                        case Texture.CUBIC_MODE:\r\n                        case Texture.INVCUBIC_MODE:\r\n                        default:\r\n                            defines.REFLECTIONMAP_CUBIC = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (this.reflectionFresnel) {\r\n                        defines.REFLECTIONFRESNEL = true;\r\n                        defines.REFLECTIONFALLOFF = this.reflectionFalloffDistance > 0;\r\n\r\n                        this._reflectionControls.x = this.reflectionAmount;\r\n                        this._reflectionControls.y = this.reflectionReflectance0;\r\n                        this._reflectionControls.z = this.reflectionReflectance90;\r\n                        this._reflectionControls.w = 1 / this.reflectionFalloffDistance;\r\n                    } else {\r\n                        defines.REFLECTIONFRESNEL = false;\r\n                        defines.REFLECTIONFALLOFF = false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONFRESNEL = false;\r\n                    defines.REFLECTIONFALLOFF = false;\r\n                    defines.REFLECTIONBLUR = false;\r\n                    defines.REFLECTIONMAP_3D = false;\r\n                    defines.REFLECTIONMAP_SPHERICAL = false;\r\n                    defines.REFLECTIONMAP_PLANAR = false;\r\n                    defines.REFLECTIONMAP_CUBIC = false;\r\n                    defines.REFLECTIONMAP_PROJECTION = false;\r\n                    defines.REFLECTIONMAP_SKYBOX = false;\r\n                    defines.REFLECTIONMAP_EXPLICIT = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n                    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n                    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n                    defines.INVERTCUBICMAP = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                    defines.LODINREFLECTIONALPHA = false;\r\n                    defines.GAMMAREFLECTION = false;\r\n                    defines.RGBDREFLECTION = false;\r\n                }\r\n            }\r\n\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.USERGBCOLOR = this._useRGBColor;\r\n            defines.NOISE = this._enableNoise;\r\n        }\r\n\r\n        if (defines._areLightsDirty) {\r\n            defines.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (this._primaryColorShadowLevel !== 0 || this._primaryColorHighlightLevel !== 0);\r\n            defines.BACKMAT_SHADOWONLY = this._shadowOnly;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        // Attribs\r\n        if (MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true, false)) {\r\n            if (mesh) {\r\n                if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n                    mesh.createNormals(true);\r\n                    Logger.Warn(\"BackgroundMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(0, \"FOG\");\r\n            }\r\n\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(1, \"POINTSIZE\");\r\n            }\r\n\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n\r\n                \"vPrimaryColor\",\r\n                \"vPrimaryColorShadow\",\r\n                \"vReflectionInfos\",\r\n                \"reflectionMatrix\",\r\n                \"vReflectionMicrosurfaceInfos\",\r\n                \"fFovMultiplier\",\r\n\r\n                \"shadowLevel\",\r\n                \"alpha\",\r\n\r\n                \"vBackgroundCenter\",\r\n                \"vReflectionControl\",\r\n\r\n                \"vDiffuseInfos\",\r\n                \"diffuseMatrix\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers = [\"diffuseSampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\"];\r\n            const uniformBuffers = [\"Material\", \"Scene\"];\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights,\r\n            });\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"background\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compute the primary color according to the chosen perceptual color.\r\n     */\r\n    private _computePrimaryColorFromPerceptualColor(): void {\r\n        if (!this.__perceptualColor) {\r\n            return;\r\n        }\r\n\r\n        this._primaryColor.copyFrom(this.__perceptualColor);\r\n\r\n        // Revert gamma space.\r\n        this._primaryColor.toLinearSpaceToRef(this._primaryColor, this.getScene().getEngine().useExactSrgbConversions);\r\n\r\n        // Revert image processing configuration.\r\n        if (this._imageProcessingConfiguration) {\r\n            // Revert Exposure.\r\n            this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor);\r\n        }\r\n\r\n        this._computePrimaryColors();\r\n    }\r\n\r\n    /**\r\n     * Compute the highlights and shadow colors according to their chosen levels.\r\n     */\r\n    private _computePrimaryColors(): void {\r\n        if (this._primaryColorShadowLevel === 0 && this._primaryColorHighlightLevel === 0) {\r\n            return;\r\n        }\r\n\r\n        // Find the highlight color based on the configuration.\r\n        this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor);\r\n        this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor);\r\n\r\n        // Find the shadow color based on the configuration.\r\n        this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor);\r\n        this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor);\r\n        this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor);\r\n    }\r\n\r\n    /**\r\n     * Build the uniform buffer used in the material.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        this._uniformBuffer.addUniform(\"vPrimaryColor\", 4);\r\n        this._uniformBuffer.addUniform(\"vPrimaryColorShadow\", 4);\r\n        this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2);\r\n        this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\r\n        this._uniformBuffer.addUniform(\"diffuseMatrix\", 16);\r\n        this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\r\n        this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\r\n        this._uniformBuffer.addUniform(\"fFovMultiplier\", 1);\r\n        this._uniformBuffer.addUniform(\"pointSize\", 1);\r\n        this._uniformBuffer.addUniform(\"shadowLevel\", 1);\r\n        this._uniformBuffer.addUniform(\"alpha\", 1);\r\n        this._uniformBuffer.addUniform(\"vBackgroundCenter\", 3);\r\n        this._uniformBuffer.addUniform(\"vReflectionControl\", 4);\r\n\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Unbind the material.\r\n     */\r\n    public unbind(): void {\r\n        if (this._diffuseTexture && this._diffuseTexture.isRenderTarget) {\r\n            this._uniformBuffer.setTexture(\"diffuseSampler\", null);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            this._uniformBuffer.setTexture(\"reflectionSampler\", null);\r\n        }\r\n\r\n        super.unbind();\r\n    }\r\n\r\n    /**\r\n     * Bind only the world matrix to the material.\r\n     * @param world The world matrix to bind.\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Bind the material for a dedicated submeh (every used meshes will be considered opaque).\r\n     * @param world The world matrix to bind.\r\n     * @param mesh\r\n     * @param subMesh The submesh to bind for.\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <BackgroundMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        if (mustRebind) {\r\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n            this.bindViewProjection(effect);\r\n\r\n            const reflectionTexture = this._reflectionTexture;\r\n            if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\");\r\n                    }\r\n\r\n                    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                        this._uniformBuffer.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\r\n                        this._uniformBuffer.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, this._reflectionBlur);\r\n\r\n                        this._uniformBuffer.updateFloat3(\r\n                            \"vReflectionMicrosurfaceInfos\",\r\n                            reflectionTexture.getSize().width,\r\n                            reflectionTexture.lodGenerationScale,\r\n                            reflectionTexture.lodGenerationOffset\r\n                        );\r\n                    }\r\n                }\r\n\r\n                if (this.shadowLevel > 0) {\r\n                    this._uniformBuffer.updateFloat(\"shadowLevel\", this.shadowLevel);\r\n                }\r\n                this._uniformBuffer.updateFloat(\"alpha\", this.alpha);\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                if (defines.USEHIGHLIGHTANDSHADOWCOLORS) {\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryHighlightColor, 1.0);\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColorShadow\", this._primaryShadowColor, 1.0);\r\n                } else {\r\n                    this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryColor, 1.0);\r\n                }\r\n            }\r\n\r\n            this._uniformBuffer.updateFloat(\"fFovMultiplier\", this._fovMultiplier);\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    this._uniformBuffer.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (defines.REFLECTIONBLUR && defines.TEXTURELODSUPPORT) {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else if (!defines.REFLECTIONBLUR) {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\r\n                    } else {\r\n                        this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\r\n                        this._uniformBuffer.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\r\n                        this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\r\n                    }\r\n\r\n                    if (defines.REFLECTIONFRESNEL) {\r\n                        this._uniformBuffer.updateFloat3(\"vBackgroundCenter\", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z);\r\n                        this._uniformBuffer.updateFloat4(\r\n                            \"vReflectionControl\",\r\n                            this._reflectionControls.x,\r\n                            this._reflectionControls.y,\r\n                            this._reflectionControls.z,\r\n                            this._reflectionControls.w\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            scene.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            if (scene.lightsEnabled) {\r\n                MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            this.bindView(effect);\r\n\r\n            // Fog\r\n            MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n\r\n        this._uniformBuffer.update();\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material.\r\n     * @param forceDisposeEffect Force disposal of the associated effect.\r\n     * @param forceDisposeTextures Force disposal of the associated textures.\r\n     */\r\n    public dispose(forceDisposeEffect: boolean = false, forceDisposeTextures: boolean = false): void {\r\n        if (forceDisposeTextures) {\r\n            if (this.diffuseTexture) {\r\n                this.diffuseTexture.dispose();\r\n            }\r\n            if (this.reflectionTexture) {\r\n                this.reflectionTexture.dispose();\r\n            }\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public clone(name: string): BackgroundMaterial {\r\n        return SerializationHelper.Clone(() => new BackgroundMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.BackgroundMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"BackgroundMaterial\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BackgroundMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a background material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated BackgroundMaterial.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): BackgroundMaterial {\r\n        return SerializationHelper.Parse(() => new BackgroundMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BackgroundMaterial\", BackgroundMaterial);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { serialize, expandToProperty } from \"../../Misc/decorators\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialBRDFDefines extends MaterialDefines {\r\n    BRDF_V_HEIGHT_CORRELATED = false;\r\n    MS_BRDF_ENERGY_CONSERVATION = false;\r\n    SPHERICAL_HARMONICS = false;\r\n    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the BRDF component of the PBR material\r\n */\r\nexport class PBRBRDFConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for the energy conservation.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value used for the Smith Visibility Height Correlated mode.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;\r\n\r\n    /**\r\n     * Default value used for the IBL diffuse part.\r\n     * This can help switching back to the polynomials mode globally which is a tiny bit\r\n     * less GPU intensive at the drawback of a lower quality.\r\n     */\r\n    public static DEFAULT_USE_SPHERICAL_HARMONICS = true;\r\n\r\n    /**\r\n     * Default value used for activating energy conservation for the specular workflow.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     */\r\n    public static DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;\r\n\r\n    private _useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n\r\n    private _useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses height smith correlated visibility term.\r\n     * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR\r\n     * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png\r\n     * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision\r\n     * Not relying on height correlated will also disable energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n\r\n    private _useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     * The harmonics despite a tiny bigger cost has been proven to provide closer results\r\n     * to the ground truth.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n\r\n    private _useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation, when the specular workflow is active.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRBRDF\", 90, new MaterialBRDFDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n        this._enable(true);\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialBRDFDefines): void {\r\n        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;\r\n        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;\r\n        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;\r\n        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRBRDFConfiguration\";\r\n    }\r\n}\r\n","import { serialize, SerializationHelper, serializeAsColor3, expandToProperty, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { ColorCurves } from \"../../Materials/colorCurves\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Material } from \"../material\";\r\n\r\n/**\r\n * The Physically based material of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n */\r\nexport class PBRMaterial extends PBRBaseMaterial {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTextureImpactOnAnalyticalLights: number = PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallic: Nullable<number>;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number>;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     */\r\n    @serializeAsColor3()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If useOnlyMetallicFromMetallicReflectanceTexture is true, don't use the RGB channels, only A\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public metallicReflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both reflectanceTexture and metallicReflectanceTexture textures are provided and useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, metallicReflectanceTexture takes priority and reflectanceTexture is not used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectanceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurfaceTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Stores the refracted light information in a texture.\r\n     */\r\n    public get refractionTexture(): Nullable<BaseTexture> {\r\n        return this.subSurface.refractionTexture;\r\n    }\r\n    public set refractionTexture(value: Nullable<BaseTexture>) {\r\n        this.subSurface.refractionTexture = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        } else if (!this.subSurface.linkRefractionWithTransparency) {\r\n            this.subSurface.isRefractionEnabled = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"albedo\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     */\r\n    @serializeAsColor3(\"reflectivity\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color reflected from the material.\r\n     */\r\n    @serializeAsColor3(\"reflection\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionColor = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The color emitted from the material.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public microSurface = 1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    public get indexOfRefraction(): number {\r\n        return this.subSurface.indexOfRefraction;\r\n    }\r\n    public set indexOfRefraction(value: number) {\r\n        this.subSurface.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    public get invertRefractionY(): boolean {\r\n        return this.subSurface.invertRefractionY;\r\n    }\r\n    public set invertRefractionY(value: boolean) {\r\n        this.subSurface.invertRefractionY = value;\r\n    }\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    public get linkRefractionWithTransparency(): boolean {\r\n        return this.subSurface.linkRefractionWithTransparency;\r\n    }\r\n    public set linkRefractionWithTransparency(value: boolean) {\r\n        this.subSurface.linkRefractionWithTransparency = value;\r\n        if (value) {\r\n            this.subSurface.isRefractionEnabled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If true, the light map contains occlusion information instead of lighting info.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public forceAlphaTest = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    @serialize()\r\n    public get usePhysicalLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n    }\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    public set usePhysicalLightFalloff(value: boolean) {\r\n        if (value !== this.usePhysicalLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    @serialize()\r\n    public get useGLTFLightFalloff(): boolean {\r\n        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    public set useGLTFLightFalloff(value: boolean) {\r\n        if (value !== this.useGLTFLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;\r\n            } else {\r\n                this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceIrradianceInFragment = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Let user defines the brdf lookup texture used for IBL.\r\n     * A default 8bit version is embedded but you could point at :\r\n     * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png\r\n     * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png\r\n     * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap = false;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n    }\r\n\r\n    /**\r\n     * Returns the name of this material class.\r\n     */\r\n    public getClassName(): string {\r\n        return \"PBRMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name - name to use for the new material.\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     */\r\n    public clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): PBRMaterial {\r\n        const clone = SerializationHelper.Clone(() => new PBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        this.stencil.copyTo(clone.stencil);\r\n\r\n        this._clonePlugins(clone, rootUrl);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this PBR Material.\r\n     * @returns - An object with the serialized material.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.PBRMaterial\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Parses a PBR Material from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene - BJS scene instance.\r\n     * @param rootUrl - url for the scene object\r\n     * @returns - PBRMaterial\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): PBRMaterial {\r\n        const material = SerializationHelper.Parse(() => new PBRMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._parsePlugins(source, material, scene, rootUrl);\r\n\r\n        // The code block below ensures backward compatibility with serialized materials before plugins are automatically serialized.\r\n        if (source.clearCoat) {\r\n            material.clearCoat.parse(source.clearCoat, scene, rootUrl);\r\n        }\r\n        if (source.anisotropy) {\r\n            material.anisotropy.parse(source.anisotropy, scene, rootUrl);\r\n        }\r\n        if (source.brdf) {\r\n            material.brdf.parse(source.brdf, scene, rootUrl);\r\n        }\r\n        if (source.sheen) {\r\n            material.sheen.parse(source.sheen, scene, rootUrl);\r\n        }\r\n        if (source.subSurface) {\r\n            material.subSurface.parse(source.subSurface, scene, rootUrl);\r\n        }\r\n        if (source.iridescence) {\r\n            material.iridescence.parse(source.iridescence, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRMaterial\", PBRMaterial);\r\n","import type { Nullable } from \"../../types\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\n\r\ndeclare module \"./baseTexture\" {\r\n    export interface BaseTexture {\r\n        /**\r\n         * Get the polynomial representation of the texture data.\r\n         * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n         * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n         */\r\n        sphericalPolynomial: Nullable<SphericalPolynomial>;\r\n\r\n        /**\r\n         * Force recomputation of spherical polynomials.\r\n         * Can be useful if you generate a cubemap multiple times (from a probe for eg) and you need the proper polynomials each time\r\n         */\r\n        forceSphericalPolynomialsRecompute(): void;\r\n    }\r\n}\r\n\r\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function (): void {\r\n    if (this._texture) {\r\n        this._texture._sphericalPolynomial = null;\r\n        this._texture._sphericalPolynomialPromise = null;\r\n        this._texture._sphericalPolynomialComputed = false;\r\n    }\r\n};\r\n\r\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\r\n    get: function (this: BaseTexture) {\r\n        if (this._texture) {\r\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\r\n                return this._texture._sphericalPolynomial;\r\n            }\r\n\r\n            if (this._texture.isReady) {\r\n                if (!this._texture._sphericalPolynomialPromise) {\r\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n                    if (this._texture._sphericalPolynomialPromise === null) {\r\n                        this._texture._sphericalPolynomialComputed = true;\r\n                    } else {\r\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\r\n                            this._texture!._sphericalPolynomial = sphericalPolynomial;\r\n                            this._texture!._sphericalPolynomialComputed = true;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n    set: function (this: BaseTexture, value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n","import { serialize, serializeAsMatrix, SerializationHelper, serializeAsVector3 } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number = 0.8;\r\n    private _lodOffset: number = 0;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    @serializeAsMatrix(\"textureMatrixRefraction\")\r\n    private _textureMatrixRefraction: Matrix = new Matrix();\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => (rootUrlKey += url));\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        extensions: Nullable<string[]> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = 0.8,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._lodScale = lodScale;\r\n        this._lodOffset = lodOffset;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension?: string,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n\r\n        if (!this.getScene()?.useRightHandedSystem) {\r\n            return;\r\n        }\r\n\r\n        const scale = TmpVectors.Vector3[0];\r\n        const quat = TmpVectors.Quaternion[0];\r\n        const trans = TmpVectors.Vector3[1];\r\n\r\n        this._textureMatrix.decompose(scale, quat, trans);\r\n\r\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\r\n        quat.w *= -1;\r\n\r\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + (parsedTexture.url ?? parsedTexture.name),\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n","import type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { BlurPostProcess } from \"../../PostProcesses/blurPostProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\n/**\r\n * Mirror texture can be used to simulate the view from a mirror in a scene.\r\n * It will dynamically be rendered every frame to adapt to the camera point of view.\r\n * You can then easily use it as a reflectionTexture on a flat surface.\r\n * In case the surface is not a plane, please consider relying on reflection probes.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrortexture\r\n */\r\nexport class MirrorTexture extends RenderTargetTexture {\r\n    /**\r\n     * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.\r\n     * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrors\r\n     */\r\n    public mirrorPlane = new Plane(0, 1, 0, 1);\r\n\r\n    /**\r\n     * Define the blur ratio used to blur the reflection if needed.\r\n     */\r\n    public set blurRatio(value: number) {\r\n        if (this._blurRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurRatio = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurRatio(): number {\r\n        return this._blurRatio;\r\n    }\r\n\r\n    /**\r\n     * Define the adaptive blur kernel used to blur the reflection if needed.\r\n     * This will autocompute the closest best match for the `blurKernel`\r\n     */\r\n    public set adaptiveBlurKernel(value: number) {\r\n        this._adaptiveBlurKernel = value;\r\n        this._autoComputeBlurKernel();\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernel(value: number) {\r\n        this.blurKernelX = value;\r\n        this.blurKernelY = value;\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel on the X Axis used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernelX(value: number) {\r\n        if (this._blurKernelX === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurKernelX = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurKernelX(): number {\r\n        return this._blurKernelX;\r\n    }\r\n\r\n    /**\r\n     * Define the blur kernel on the Y Axis used to blur the reflection if needed.\r\n     * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.\r\n     */\r\n    public set blurKernelY(value: number) {\r\n        if (this._blurKernelY === value) {\r\n            return;\r\n        }\r\n\r\n        this._blurKernelY = value;\r\n        this._preparePostProcesses();\r\n    }\r\n\r\n    public get blurKernelY(): number {\r\n        return this._blurKernelY;\r\n    }\r\n\r\n    private _autoComputeBlurKernel(): void {\r\n        const engine = this.getScene()!.getEngine();\r\n\r\n        const dw = this.getRenderWidth() / engine.getRenderWidth();\r\n        const dh = this.getRenderHeight() / engine.getRenderHeight();\r\n        this.blurKernelX = this._adaptiveBlurKernel * dw;\r\n        this.blurKernelY = this._adaptiveBlurKernel * dh;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n            if (!this._adaptiveBlurKernel) {\r\n                this._preparePostProcesses();\r\n            }\r\n        }\r\n\r\n        if (this._adaptiveBlurKernel) {\r\n            this._autoComputeBlurKernel();\r\n        }\r\n    }\r\n\r\n    private _updateGammaSpace() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.gammaSpace = !scene.imageProcessingConfiguration.isEnabled || !scene.imageProcessingConfiguration.applyByPostProcess;\r\n    }\r\n\r\n    private _imageProcessingConfigChangeObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _mirrorMatrix = Matrix.Zero();\r\n\r\n    private _blurX: Nullable<BlurPostProcess>;\r\n    private _blurY: Nullable<BlurPostProcess>;\r\n    private _adaptiveBlurKernel = 0;\r\n    private _blurKernelX = 0;\r\n    private _blurKernelY = 0;\r\n    private _blurRatio = 1.0;\r\n    private _sceneUBO: UniformBuffer;\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /**\r\n     * Instantiates a Mirror Texture.\r\n     * Mirror texture can be used to simulate the view from a mirror in a scene.\r\n     * It will dynamically be rendered every frame to adapt to the camera point of view.\r\n     * You can then easily use it as a reflectionTexture on a flat surface.\r\n     * In case the surface is not a plane, please consider relying on reflection probes.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#mirrors\r\n     * @param name\r\n     * @param size\r\n     * @param scene\r\n     * @param generateMipMaps\r\n     * @param type\r\n     * @param samplingMode\r\n     * @param generateDepthBuffer\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: number | { width: number; height: number } | { ratio: number },\r\n        scene?: Scene,\r\n        generateMipMaps?: boolean,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        samplingMode = Texture.BILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer = true\r\n    ) {\r\n        super(name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer);\r\n\r\n        scene = <Scene>this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        this.ignoreCameraViewport = true;\r\n\r\n        this._updateGammaSpace();\r\n        this._imageProcessingConfigChangeObserver = scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this._updateGammaSpace();\r\n        });\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        if (engine.supportsUniformBuffers) {\r\n            this._sceneUBO = scene.createSceneUniformBuffer(`Scene for Mirror Texture (name \"${name}\")`);\r\n        }\r\n\r\n        this.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(`mirror generation for ${name}`, 1);\r\n        });\r\n\r\n        this.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        let saveClipPlane: Nullable<Plane>;\r\n\r\n        this.onBeforeRenderObservable.add(() => {\r\n            if (this._sceneUBO) {\r\n                this._currentSceneUBO = scene!.getSceneUniformBuffer();\r\n                scene!.setSceneUniformBuffer(this._sceneUBO);\r\n                scene!.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n\r\n            Matrix.ReflectionToRef(this.mirrorPlane, this._mirrorMatrix);\r\n            this._mirrorMatrix.multiplyToRef(scene!.getViewMatrix(), this._transformMatrix);\r\n\r\n            scene!.setTransformMatrix(this._transformMatrix, scene!.getProjectionMatrix());\r\n\r\n            saveClipPlane = scene!.clipPlane;\r\n            scene!.clipPlane = this.mirrorPlane;\r\n\r\n            scene!._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene!.activeCamera).globalPosition, this._mirrorMatrix);\r\n        });\r\n\r\n        this.onAfterRenderObservable.add(() => {\r\n            if (this._sceneUBO) {\r\n                scene!.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene!.updateTransformMatrix();\r\n            scene!._mirroredCameraPosition = null;\r\n\r\n            scene!.clipPlane = saveClipPlane;\r\n        });\r\n    }\r\n\r\n    private _preparePostProcesses(): void {\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._blurKernelX && this._blurKernelY) {\r\n            const engine = (<Scene>this.getScene()).getEngine();\r\n\r\n            const textureType =\r\n                engine.getCaps().textureFloatRender && engine.getCaps().textureFloatLinearFiltering ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            this._blurX = new BlurPostProcess(\r\n                \"horizontal blur\",\r\n                new Vector2(1.0, 0),\r\n                this._blurKernelX,\r\n                this._blurRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                textureType\r\n            );\r\n            this._blurX.autoClear = false;\r\n\r\n            if (this._blurRatio === 1 && this.samples < 2 && this._texture) {\r\n                this._blurX.inputTexture = this._renderTarget!;\r\n            } else {\r\n                this._blurX.alwaysForcePOT = true;\r\n            }\r\n\r\n            this._blurY = new BlurPostProcess(\r\n                \"vertical blur\",\r\n                new Vector2(0, 1.0),\r\n                this._blurKernelY,\r\n                this._blurRatio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                textureType\r\n            );\r\n            this._blurY.autoClear = false;\r\n            this._blurY.alwaysForcePOT = this._blurRatio !== 1;\r\n\r\n            this.addPostProcess(this._blurX);\r\n            this.addPostProcess(this._blurY);\r\n        } else {\r\n            if (this._blurY) {\r\n                this.removePostProcess(this._blurY);\r\n                this._blurY.dispose();\r\n                this._blurY = null;\r\n            }\r\n            if (this._blurX) {\r\n                this.removePostProcess(this._blurX);\r\n                this._blurX.dispose();\r\n                this._blurX = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the mirror texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): MirrorTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new MirrorTexture(\r\n            this.name,\r\n            textureSize.width,\r\n            scene,\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._renderTargetOptions.type,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Mirror Texture\r\n        newTexture.mirrorPlane = this.mirrorPlane.clone();\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation you could use in Parse later on\r\n     * @returns the serialized JSON representation\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.mirrorPlane = this.mirrorPlane.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        const scene = this.getScene();\r\n\r\n        if (scene) {\r\n            scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);\r\n        }\r\n        this._sceneUBO?.dispose();\r\n    }\r\n}\r\n\r\nTexture._CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n    return new MirrorTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n","import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n","import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture!.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { TmpVectors } from \"./math\";\r\n\r\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\r\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\r\n// https://www.ppsloan.org/publications/StupidSH36.pdf\r\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\r\n// https://www.ppsloan.org/publications/SHJCGT.pdf\r\n// https://www.ppsloan.org/publications/shdering.pdf\r\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\r\n// https://patapom.com/blog/SHPortal/\r\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\r\n\r\n// Using real SH basis:\r\n//  m>0             m   m\r\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m<0             m   |m|\r\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m=0   0   0\r\n// y   = K * P * trigono terms\r\n//  l     l   l\r\n//\r\n//  m       (2l + 1)(l - |m|)!\r\n// K = sqrt(------------------)\r\n//  l           4pi(l + |m|)!\r\n//\r\n// and P by recursion:\r\n//\r\n// P00(x) = 1\r\n// P01(x) = x\r\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\r\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\r\n// Plm(x) = ---------------------------------------\r\n//                         l - m\r\n// Leaving the trigonometric terms aside we can precompute the constants to :\r\nconst SH3ylmBasisConstants = [\r\n    Math.sqrt(1 / (4 * Math.PI)), // l00\r\n\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l1_1\r\n    Math.sqrt(3 / (4 * Math.PI)), // l10\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l11\r\n\r\n    Math.sqrt(15 / (4 * Math.PI)), // l2_2\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l2_1\r\n    Math.sqrt(5 / (16 * Math.PI)), // l20\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l21\r\n    Math.sqrt(15 / (16 * Math.PI)), // l22\r\n];\r\n\r\n// cm = cos(m * phi)\r\n// sm = sin(m * phi)\r\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\r\n// By recursion on using trigo identities:\r\nconst SH3ylmBasisTrigonometricTerms = [\r\n    () => 1, // l00\r\n\r\n    (direction: Vector3) => direction.y, // l1_1\r\n    (direction: Vector3) => direction.z, // l10\r\n    (direction: Vector3) => direction.x, // l11\r\n\r\n    (direction: Vector3) => direction.x * direction.y, // l2_2\r\n    (direction: Vector3) => direction.y * direction.z, // l2_1\r\n    (direction: Vector3) => 3 * direction.z * direction.z - 1, // l20\r\n    (direction: Vector3) => direction.x * direction.z, // l21\r\n    (direction: Vector3) => direction.x * direction.x - direction.y * direction.y, // l22\r\n];\r\n\r\n// Wrap the full compute\r\nconst applySH3 = (lm: number, direction: Vector3) => {\r\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\r\n};\r\n\r\n// Derived from the integration of the a kernel convolution to SH.\r\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\r\nconst SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\r\n\r\n/**\r\n * Class representing spherical harmonics coefficients to the 3rd degree\r\n */\r\nexport class SphericalHarmonics {\r\n    /**\r\n     * Defines whether or not the harmonics have been prescaled for rendering.\r\n     */\r\n    public preScaled = false;\r\n\r\n    /**\r\n     * The l0,0 coefficients of the spherical harmonics\r\n     */\r\n    public l00: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l1_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,0 coefficients of the spherical harmonics\r\n     */\r\n    public l10: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,1 coefficients of the spherical harmonics\r\n     */\r\n    public l11: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-2 coefficients of the spherical harmonics\r\n     */\r\n    public l2_2: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l2_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,0 coefficients of the spherical harmonics\r\n     */\r\n    public l20: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,1 coefficients of the spherical harmonics\r\n     */\r\n    public l21: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,2 coefficients of the spherical harmonics\r\n     */\r\n    public l22: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds a light to the spherical harmonics\r\n     * @param direction the direction of the light\r\n     * @param color the color of the light\r\n     * @param deltaSolidAngle the delta solid angle of the light\r\n     */\r\n    public addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void {\r\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        const c = TmpVectors.Vector3[1];\r\n        colorVector.scaleToRef(deltaSolidAngle, c);\r\n\r\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\r\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\r\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\r\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\r\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\r\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\r\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\r\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\r\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\r\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical harmonics by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number): void {\r\n        this.l00.scaleInPlace(scale);\r\n        this.l1_1.scaleInPlace(scale);\r\n        this.l10.scaleInPlace(scale);\r\n        this.l11.scaleInPlace(scale);\r\n        this.l2_2.scaleInPlace(scale);\r\n        this.l2_1.scaleInPlace(scale);\r\n        this.l20.scaleInPlace(scale);\r\n        this.l21.scaleInPlace(scale);\r\n        this.l22.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\r\n     *\r\n     * ```\r\n     * E_lm = A_l * L_lm\r\n     * ```\r\n     *\r\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\r\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\r\n     * the scaling factors are given in equation 9.\r\n     */\r\n    public convertIncidentRadianceToIrradiance(): void {\r\n        // Constant (Band 0)\r\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\r\n\r\n        // Linear (Band 1)\r\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\r\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\r\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\r\n\r\n        // Quadratic (Band 2)\r\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\r\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\r\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\r\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\r\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\r\n    }\r\n\r\n    /**\r\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\r\n     *\r\n     * ```\r\n     * L = (1/pi) * E * rho\r\n     * ```\r\n     *\r\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\r\n     */\r\n    public convertIrradianceToLambertianRadiance(): void {\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\r\n        // (The pixel shader must apply albedo after texture fetches, etc).\r\n    }\r\n\r\n    /**\r\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\r\n     * required operations at run time.\r\n     *\r\n     * This is simply done by scaling back the SH with Ylm constants parameter.\r\n     * The trigonometric part being applied by the shader at run time.\r\n     */\r\n    public preScaleForRendering(): void {\r\n        this.preScaled = true;\r\n\r\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\r\n\r\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\r\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\r\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\r\n\r\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\r\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\r\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\r\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\r\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\r\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\r\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\r\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\r\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\r\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\r\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\r\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\r\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given floats array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromFloatsArray(data: ArrayLike<number>): SphericalHarmonics {\r\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\r\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\r\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\r\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\r\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\r\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\r\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\r\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\r\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical harmonics from an array.\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        const sh = new SphericalHarmonics();\r\n        return sh.updateFromArray(data);\r\n    }\r\n\r\n    // Keep for references.\r\n    /**\r\n     * Gets the spherical harmonics from polynomial\r\n     * @param polynomial the spherical polynomial\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics {\r\n        const result = new SphericalHarmonics();\r\n\r\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\r\n        result.l1_1 = polynomial.y.scale(0.977204);\r\n        result.l10 = polynomial.z.scale(0.977204);\r\n        result.l11 = polynomial.x.scale(0.977204);\r\n        result.l2_2 = polynomial.xy.scale(1.16538);\r\n        result.l2_1 = polynomial.yz.scale(1.16538);\r\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\r\n        result.l21 = polynomial.zx.scale(1.16538);\r\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\r\n\r\n        result.l1_1.scaleInPlace(-1);\r\n        result.l11.scaleInPlace(-1);\r\n        result.l2_1.scaleInPlace(-1);\r\n        result.l21.scaleInPlace(-1);\r\n\r\n        result.scaleInPlace(Math.PI);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing spherical polynomial coefficients to the 3rd degree\r\n */\r\nexport class SphericalPolynomial {\r\n    private _harmonics: Nullable<SphericalHarmonics>;\r\n\r\n    /**\r\n     * The spherical harmonics used to create the polynomials.\r\n     */\r\n    public get preScaledHarmonics(): SphericalHarmonics {\r\n        if (!this._harmonics) {\r\n            this._harmonics = SphericalHarmonics.FromPolynomial(this);\r\n        }\r\n        if (!this._harmonics.preScaled) {\r\n            this._harmonics.preScaleForRendering();\r\n        }\r\n        return this._harmonics;\r\n    }\r\n\r\n    /**\r\n     * The x coefficients of the spherical polynomial\r\n     */\r\n    public x: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The y coefficients of the spherical polynomial\r\n     */\r\n    public y: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The z coefficients of the spherical polynomial\r\n     */\r\n    public z: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xx coefficients of the spherical polynomial\r\n     */\r\n    public xx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yy coefficients of the spherical polynomial\r\n     */\r\n    public yy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zz coefficients of the spherical polynomial\r\n     */\r\n    public zz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xy coefficients of the spherical polynomial\r\n     */\r\n    public xy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yz coefficients of the spherical polynomial\r\n     */\r\n    public yz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zx coefficients of the spherical polynomial\r\n     */\r\n    public zx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds an ambient color to the spherical polynomial\r\n     * @param color the color to add\r\n     */\r\n    public addAmbient(color: Color3): void {\r\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        this.xx.addInPlace(colorVector);\r\n        this.yy.addInPlace(colorVector);\r\n        this.zz.addInPlace(colorVector);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical polynomial by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number) {\r\n        this.x.scaleInPlace(scale);\r\n        this.y.scaleInPlace(scale);\r\n        this.z.scaleInPlace(scale);\r\n        this.xx.scaleInPlace(scale);\r\n        this.yy.scaleInPlace(scale);\r\n        this.zz.scaleInPlace(scale);\r\n        this.yz.scaleInPlace(scale);\r\n        this.zx.scaleInPlace(scale);\r\n        this.xy.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Updates the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public updateFromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        this._harmonics = harmonics;\r\n\r\n        this.x.copyFrom(harmonics.l11);\r\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.y.copyFrom(harmonics.l1_1);\r\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.z.copyFrom(harmonics.l10);\r\n        this.z.scaleInPlace(1.02333);\r\n\r\n        this.xx.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\r\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\r\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\r\n        this.yy.copyFrom(harmonics.l00);\r\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\r\n        this.zz.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\r\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\r\n\r\n        this.yz.copyFrom(harmonics.l2_1);\r\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.zx.copyFrom(harmonics.l21);\r\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.xy.copyFrom(harmonics.l2_2);\r\n        this.xy.scaleInPlace(0.858086);\r\n\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        const result = new SphericalPolynomial();\r\n        return result.updateFromHarmonics(harmonics);\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical polynomial from an array.\r\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalPolynomial {\r\n        const sp = new SphericalPolynomial();\r\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\r\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\r\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\r\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\r\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\r\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\r\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\r\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\r\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\r\n        return sp;\r\n    }\r\n}\r\n","import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = false): Buffer {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = false): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = new Array<Matrix>();\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n        const boundingInfo = this.getBoundingInfo();\r\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n","import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Scalar.Clamp(r, 0, max);\r\n                        g = Scalar.Clamp(g, 0, max);\r\n                        b = Scalar.Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n","import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            if (expandTexture) {\r\n                // Simply run through the decode PP.\r\n                const rgbdPostProcess = new PostProcess(\r\n                    \"rgbdDecode\",\r\n                    \"rgbdDecode\",\r\n                    null,\r\n                    null,\r\n                    1,\r\n                    null,\r\n                    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    false,\r\n                    undefined,\r\n                    internalTexture.type,\r\n                    undefined,\r\n                    null,\r\n                    false\r\n                );\r\n                rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n                // Hold the output of the decoding.\r\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                    generateDepthBuffer: false,\r\n                    generateMipMaps: false,\r\n                    generateStencilBuffer: false,\r\n                    samplingMode: internalTexture.samplingMode,\r\n                    type: internalTexture.type,\r\n                    format: Constants.TEXTUREFORMAT_RGBA,\r\n                });\r\n\r\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                    // PP Render Pass\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", internalTexture);\r\n                        effect.setFloat2(\"scale\", 1, 1);\r\n                    };\r\n                    texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    engine._releaseTexture(internalTexture);\r\n                    if (rgbdPostProcess) {\r\n                        rgbdPostProcess.dispose();\r\n                    }\r\n\r\n                    // Internal Swap\r\n                    expandedTexture._swapAndDie(internalTexture);\r\n\r\n                    // Ready to get rolling again.\r\n                    internalTexture.isReady = true;\r\n                });\r\n            }\r\n        };\r\n\r\n        if (isReady) {\r\n            expandRGBDTexture();\r\n        } else {\r\n            texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n","import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","import type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTargetManager implements IDisposable {\r\n    /** Enable storing morph target data into textures when set to true (true by default) */\r\n    public static EnableTextureStorage = true;\r\n\r\n    /** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\r\n    public static MaxActiveMorphTargetsInVertexAttributeMode = 8;\r\n\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _morphTargetTextureIndices: Float32Array;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _vertexCount = 0;\r\n    private _textureVertexStride = 0;\r\n    private _textureWidth = 0;\r\n    private _textureHeight = 1;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n    private _canUseTextureForTargets = false;\r\n    private _blockCounter = 0;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /** @internal */\r\n    public _targetStoreTexture: Nullable<RawTexture2DArray>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\r\n     */\r\n    public optimizeInfluencers = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\r\n     */\r\n    public set areUpdatesFrozen(block: boolean) {\r\n        if (block) {\r\n            this._blockCounter++;\r\n        } else {\r\n            this._blockCounter--;\r\n            if (this._blockCounter <= 0) {\r\n                this._blockCounter = 0;\r\n\r\n                this._syncActiveTargets(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public get areUpdatesFrozen() {\r\n        return this._blockCounter > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.addMorphTargetManager(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n\r\n            const engineCaps = this._scene.getEngine().getCaps();\r\n            this._canUseTextureForTargets =\r\n                engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        return this._influences;\r\n    }\r\n\r\n    private _useTextureToStoreTargets = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreTargets(): boolean {\r\n        return this._useTextureToStoreTargets;\r\n    }\r\n\r\n    public set useTextureToStoreTargets(value: boolean) {\r\n        this._useTextureToStoreTargets = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\r\n     */\r\n    public get isUsingTextureForTargets() {\r\n        return (\r\n            MorphTargetManager.EnableTextureStorage &&\r\n            this.useTextureToStoreTargets &&\r\n            this._canUseTextureForTargets &&\r\n            !this._scene?.getEngine().getCaps().disableMorphTargetTexture\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(\r\n            target.onInfluenceChanged.add((needUpdate) => {\r\n                this._syncActiveTargets(needUpdate);\r\n            })\r\n        );\r\n        this._targetDataLayoutChangedObservers.push(\r\n            target._onDataLayoutChanged.add(() => {\r\n                this._syncActiveTargets(true);\r\n            })\r\n        );\r\n        this._syncActiveTargets(true);\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        const index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._syncActiveTargets(true);\r\n        }\r\n\r\n        if (this._scene) {\r\n            this._scene.stopAnimation(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(effect: Effect) {\r\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\r\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\r\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        const copy = new MorphTargetManager(this._scene);\r\n\r\n        for (const target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (const target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate: boolean): void {\r\n        if (this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._vertexCount = 0;\r\n\r\n        if (this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount) {\r\n            this.useTextureToStoreTargets = false;\r\n        }\r\n\r\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\r\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\r\n        }\r\n\r\n        let targetIndex = -1;\r\n        for (const target of this._targets) {\r\n            targetIndex++;\r\n            if (target.influence === 0 && this.optimizeInfluencers) {\r\n                continue;\r\n            }\r\n\r\n            if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\r\n                break;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n\r\n            const positions = target.getPositions();\r\n            if (positions) {\r\n                const vertexCount = positions.length / 3;\r\n                if (this._vertexCount === 0) {\r\n                    this._vertexCount = vertexCount;\r\n                } else if (this._vertexCount !== vertexCount) {\r\n                    Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._morphTargetTextureIndices.length !== influenceCount) {\r\n            this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (let index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this.synchronize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene || this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        if (this.isUsingTextureForTargets && this._vertexCount) {\r\n            this._textureVertexStride = 1;\r\n\r\n            if (this._supportsNormals) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            if (this._supportsTangents) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            if (this._supportsUVs) {\r\n                this._textureVertexStride++;\r\n            }\r\n\r\n            this._textureWidth = this._vertexCount * this._textureVertexStride;\r\n            this._textureHeight = 1;\r\n\r\n            const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;\r\n            if (this._textureWidth > maxTextureSize) {\r\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\r\n                this._textureWidth = maxTextureSize;\r\n            }\r\n\r\n            let mustUpdateTexture = true;\r\n            if (this._targetStoreTexture) {\r\n                const textureSize = this._targetStoreTexture.getSize();\r\n                if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {\r\n                    mustUpdateTexture = false;\r\n                }\r\n            }\r\n\r\n            if (mustUpdateTexture) {\r\n                if (this._targetStoreTexture) {\r\n                    this._targetStoreTexture.dispose();\r\n                }\r\n\r\n                const targetCount = this._targets.length;\r\n                const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\r\n\r\n                let offset = 0;\r\n                for (let index = 0; index < targetCount; index++) {\r\n                    const target = this._targets[index];\r\n\r\n                    const positions = target.getPositions();\r\n                    const normals = target.getNormals();\r\n                    const uvs = target.getUVs();\r\n                    const tangents = target.getTangents();\r\n\r\n                    if (!positions) {\r\n                        if (index === 0) {\r\n                            Logger.Error(\"Invalid morph target. Target must have positions.\");\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    offset = index * this._textureWidth * this._textureHeight * 4;\r\n                    for (let vertex = 0; vertex < this._vertexCount; vertex++) {\r\n                        data[offset] = positions[vertex * 3];\r\n                        data[offset + 1] = positions[vertex * 3 + 1];\r\n                        data[offset + 2] = positions[vertex * 3 + 2];\r\n\r\n                        offset += 4;\r\n\r\n                        if (this._supportsNormals && normals) {\r\n                            data[offset] = normals[vertex * 3];\r\n                            data[offset + 1] = normals[vertex * 3 + 1];\r\n                            data[offset + 2] = normals[vertex * 3 + 2];\r\n                            offset += 4;\r\n                        }\r\n\r\n                        if (this._supportsUVs && uvs) {\r\n                            data[offset] = uvs[vertex * 2];\r\n                            data[offset + 1] = uvs[vertex * 2 + 1];\r\n                            offset += 4;\r\n                        }\r\n\r\n                        if (this._supportsTangents && tangents) {\r\n                            data[offset] = tangents[vertex * 3];\r\n                            data[offset + 1] = tangents[vertex * 3 + 1];\r\n                            data[offset + 2] = tangents[vertex * 3 + 2];\r\n                            offset += 4;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(\r\n                    data,\r\n                    this._textureWidth,\r\n                    this._textureHeight,\r\n                    targetCount,\r\n                    this._scene,\r\n                    false,\r\n                    false,\r\n                    Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                    Constants.TEXTURETYPE_FLOAT\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (const mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose() {\r\n        if (this._targetStoreTexture) {\r\n            this._targetStoreTexture.dispose();\r\n        }\r\n\r\n        this._targetStoreTexture = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            this._scene.removeMorphTargetManager(this);\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n\r\n            for (const morph of this._targets) {\r\n                this._scene.stopAnimation(morph);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        const result = new MorphTargetManager(scene);\r\n\r\n        result._uniqueId = serializationObject.id;\r\n\r\n        for (const targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData, scene));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"harmonicsFunctions\";\nconst shader = `#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00\n+ vSphericalL1_1*(normal.y)\n+ vSphericalL10*(normal.z)\n+ vSphericalL11*(normal.x)\n+ vSphericalL2_2*(normal.y*normal.x)\n+ vSphericalL2_1*(normal.y*normal.z)\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ vSphericalL21*(normal.z*normal.x)\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}\n#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const harmonicsFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"hdrFilteringFunctions\";\nconst shader = `#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfloat radicalInverse_VdC(uint bits) \n{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }\nvec2 hammersley(uint i,uint N)\n{return vec2(float(i)/float(N),radicalInverse_VdC(i));}\n#else\nfloat vanDerCorpus(int n,int base)\n{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)\n{if(n>0)\n{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}\nreturn result;}\nvec2 hammersley(int i,int N)\n{return vec2(float(i)/float(N),vanDerCorpus(i,2));}\n#endif\nfloat log4(float x) {return log2(x)/2.;}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;}}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);if (alphaG==0.) {vec3 c=textureCube(inputTexture,n).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;}}\nresult=result/weight;return result;}}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const hdrFilteringFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"importanceSampling\";\nconst shader = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \nfloat phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const importanceSampling = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBRDFFunctions\";\nconst shader = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\n{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}\n#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\n#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}\nvec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}\nfloat getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}\nvec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}\nfloat cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)\n{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}\nreturn max(I,vec3(0.0));}\n#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}\n#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}\n#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}\n#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }\n#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\n{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}\nfloat lambdaSheen(float cosTheta,float alphaG)\n{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\n{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}\n#endif\n*/\n#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}\n#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBRDFFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\n\nconst name = \"pbrUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrUboDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"subSurfaceScatteringFunctions\";\nconst shader = `bool testLightingForSSS(float diffusionProfile)\n{return diffusionProfile<1.;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragmentDeclaration\";\n\nconst name = \"pbrFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;\n#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\n#endif\nuniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#endif\n#ifdef IRIDESCENCE\nuniform vec4 vIridescenceParams;\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\nuniform vec4 vSheenColor;\n#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\n#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\nuniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;\n#endif\n#ifdef PREPASS\n#ifdef SS_SCATTERING\nuniform float scatteringDiffusionProfile;\n#endif\n#endif\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./mainUVVaryingDeclaration\";\n\nconst name = \"pbrFragmentExtraDeclaration\";\nconst shader = `varying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentExtraDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerFragmentAlternateDeclaration\";\nconst shader = `#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerFragmentAlternateDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./samplerFragmentDeclaration\";\nimport \"./samplerFragmentAlternateDeclaration\";\n\nconst name = \"pbrFragmentSamplersDeclaration\";\nconst shader = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D clearCoatRoughnessSampler;\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D sheenRoughnessSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;\n#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;\n#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrFragmentSamplersDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrHelperFunctions\";\nconst shader = `#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\n{return square(roughness)+MINIMUMVARIANCE;}\nfloat fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}\nvec2 getAARoughnessFactors(vec3 normalVector) {\n#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2(0.);\n#endif\n}\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_LEGACY\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}\n#else\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}\n#endif\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);return clearCoatAbsorption;}\n#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrHelperFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingSetupFunctions\";\nconst shader = `struct preLightingInfo\n{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;\n#ifdef IRIDESCENCE\nfloat iridescenceIntensity;\n#endif\n};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingSetupFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingFalloffFunctions\";\nconst shader = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\n{return max(0.,1.0-length(lightOffset)/range);}\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n{return 1.0/maxEps(lightDistanceSquared);}\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\n{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\n{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)\n{falloff=max(0.,pow(cosAngle,exponent));}\nreturn falloff;}\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\n{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\n{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingFalloffFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDirectLightingFunctions\";\nconst shader = `#define CLEARCOATREFLECTANCE90 1.0\nstruct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef CLEARCOAT\nvec4 clearCoat;\n#endif\n#ifdef SHEEN\nvec3 sheen;\n#endif\n};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\nfloat lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}\n#ifdef SS_TRANSLUCENCY\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}\n#endif\n#ifdef SPECULARTERM\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef ANISOTROPIC\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef CLEARCOAT\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);}\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}\n#endif\n#ifdef SHEEN\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER\nfloat visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\n#else */\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */\nfloat sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDirectLightingFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrIBLFunctions\";\nconst shader = `#if defined(REFLECTION) || defined(SS_REFRACTION)\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}\n#endif\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\n#define UNPACK_LOD(x) (1.0-x)*255.0\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrIBLFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragment\";\n\nconst name = \"pbrBlockAlbedoOpacity\";\nconst shader = `struct albedoOpacityOutParams\n{vec3 surfaceAlbedo;float alpha;};\n#define pbr_inline\nvoid albedoOpacityBlock(\nin vec4 vAlbedoColor,\n#ifdef ALBEDO\nin vec4 albedoTexture,\nin vec2 albedoInfos,\n#endif\n#ifdef OPACITY\nin vec4 opacityMap,\nin vec2 vOpacityInfos,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\n#ifdef DECAL\nin vec4 decalColor,\nin vec4 vDecalInfos,\n#endif\nout albedoOpacityOutParams outParams\n)\n{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#ifndef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nsurfaceAlbedo*=vColor.rgb;\n#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \n#endif\n#ifdef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST \n#if DEBUGMODE != 88\nif (alpha<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlbedoOpacity = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectivity\";\nconst shader = `struct reflectivityOutParams\n{float microSurface;float roughness;vec3 surfaceReflectivityColor;\n#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\n#endif\n#if DEBUGMODE>0\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness;\n#ifdef REFLECTIVITY\nvec4 surfaceMetallicColorMap;\n#endif\n#ifndef FROSTBITE_REFLECTANCE\nvec3 metallicF0;\n#endif\n#else\n#ifdef REFLECTIVITY\nvec4 surfaceReflectivityColorMap;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid reflectivityBlock(\nin vec4 vReflectivityColor,\n#ifdef METALLICWORKFLOW\nin vec3 surfaceAlbedo,\nin vec4 metallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nin vec3 reflectivityInfos,\nin vec4 surfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nin vec3 ambientOcclusionColorIn,\n#endif\n#ifdef MICROSURFACEMAP\nin vec4 microSurfaceTexel,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\nout reflectivityOutParams outParams\n)\n{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectivity = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAmbientOcclusion\";\nconst shader = `struct ambientOcclusionOutParams\n{vec3 ambientOcclusionColor;\n#if DEBUGMODE>0 && defined(AMBIENT)\nvec3 ambientOcclusionColorMap;\n#endif\n};\n#define pbr_inline\nvoid ambientOcclusionBlock(\n#ifdef AMBIENT\nin vec3 ambientOcclusionColorMap_,\nin vec4 vAmbientInfos,\n#endif\nout ambientOcclusionOutParams outParams\n)\n{vec3 ambientOcclusionColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAmbientOcclusion = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAlphaFresnel\";\nconst shader = `#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{float alpha;};\n#define pbr_inline\nvoid alphaFresnelBlock(\nin vec3 normalW,\nin vec3 viewDirectionW,\nin float alpha,\nin float microSurface,\nout alphaFresnelOutParams outParams\n)\n{float opacityPerceptual=alpha;\n#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\n#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\n#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\noutParams.alpha=1.0;\n#endif\n#endif\n}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAlphaFresnel = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockAnisotropic\";\nconst shader = `#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;\n#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)\nvec3 anisotropyMapData;\n#endif\n};\n#define pbr_inline\nvoid anisotropicBlock(\nin vec3 vAnisotropy,\nin float roughness,\n#ifdef ANISOTROPIC_TEXTURE\nin vec3 anisotropyMapData,\n#endif\nin mat3 TBN,\nin vec3 normalW,\nin vec3 viewDirectionW,\nout anisotropicOutParams outParams\n)\n{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\nanisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;\n#ifdef ANISOTROPIC_LEGACY\nanisotropyDirection.rg*=anisotropyMapData.rg;\n#else\nanisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);\n#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockAnisotropic = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflection\";\nconst shader = `#ifdef REFLECTION\nstruct reflectionOutParams\n{vec4 environmentRadiance;vec3 environmentIrradiance;\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\n#else\nvec2 reflectionCoords;\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid createReflectionCoords(\nin vec3 vPositionW,\nin vec3 normalW,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\n#else\nout vec2 reflectionCoords\n#endif\n)\n{\n#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n}\n#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nconst vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nconst vec2 reflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout vec4 environmentRadiance\n)\n{\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\n#else\nfloat requestedReflectionLOD=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);} else {environmentRadiance=mix(\nenvironmentMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\n#endif\nenvironmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}\n#define pbr_inline\n#define inline\nvoid reflectionBlock(\nin vec3 vPositionW,\nin vec3 normalW,\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nin vec3 vEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin mat4 reflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout reflectionOutParams outParams\n)\n{vec4 environmentRadiance=vec4(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\n#else\nvec2 reflectionCoords=vec2(0.);\n#endif\ncreateReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\nreflectionCoords\n);sampleReflectionTexture(\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\nreflectionCoords,\n#else\nreflectionSampler,\nreflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentRadiance\n);vec3 environmentIrradiance=vec3(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflection = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockSheen\";\nconst shader = `#ifdef SHEEN\nstruct sheenOutParams\n{float sheenIntensity;vec3 sheenColor;float sheenRoughness;\n#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\n#endif\n#if DEBUGMODE>0\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 sheenEnvironmentReflectance;\n#endif\n#endif\n};\n#define pbr_inline\n#define inline\nvoid sheenBlock(\nin vec4 vSheenColor,\n#ifdef SHEEN_ROUGHNESS\nin float vSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 sheenMapRoughnessData,\n#endif\n#endif\nin float roughness,\n#ifdef SHEEN_TEXTURE\nin vec4 sheenMapData,\nin float sheenMapLevel,\n#endif\nin float reflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nin vec3 baseColor,\nin vec3 surfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nin float NdotV,\nin vec3 environmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nin vec2 AARoughnessFactors,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nin vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nin vec2 reflectionCoords,\n#endif\nin float NdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nin float seo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nin float eho,\n#endif\n#endif\nout sheenOutParams outParams\n)\n{float sheenIntensity=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\n#else\nsheenColor.rgb*=sheenMapData.rgb;\n#endif\nsheenColor.rgb*=sheenMapLevel;\n#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\nsheenRoughness*=sheenMapData.a;\n#else\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#endif\n#else\nfloat sheenRoughness=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\nsheenColor*=sheenIntensity;\n#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\nvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\n#else*/\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvec3 environmentSheenBrdf=environmentBrdf;\n#endif\n/*#endif*/\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(\nsheenAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\n#endif\nreflectionSampler,\nreflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentSheenRadiance\n);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\noutParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSheen = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockClearcoat\";\nconst shader = `struct clearcoatOutParams\n{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;\n#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\n#endif\n#if DEBUGMODE>0\n#ifdef CLEARCOAT_BUMP\nmat3 TBNClearCoat;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData;\n#endif\n#ifdef REFLECTION\nvec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;\n#endif\nfloat clearCoatNdotV;\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nvoid clearcoatBlock(\nin vec3 vPositionW,\nin vec3 geometricNormalW,\nin vec3 viewDirectionW,\nin vec2 vClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 clearCoatMapRoughnessData,\n#endif\nin vec3 specularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nin vec4 vClearCoatTintParams,\nin float clearCoatColorAtDistance,\nin vec4 vClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nin vec4 clearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nin vec2 vClearCoatBumpInfos,\nin vec4 clearCoatBumpMapData,\nin vec2 vClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nin mat3 vTBN,\n#else\nin vec2 vClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nin mat4 normalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nin vec3 faceNormal,\n#endif\n#ifdef REFLECTION\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nin float ambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\nin float frontFacingMultiplier,\n#endif\nout clearcoatOutParams outParams\n)\n{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\nclearCoatRoughness*=clearCoatMapData.y;\n#else\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\n#else\nclearCoatColor*=clearCoatTintMapData.rgb;\n#endif\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;\n#endif\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\n#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\n#else\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\n#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nsampleReflectionTexture(\nclearCoatAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\n#endif\nreflectionSampler,\nclearCoatReflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentClearCoatRadiance\n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockClearcoat = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockIridescence\";\nconst shader = `struct iridescenceOutParams\n{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};\n#ifdef IRIDESCENCE\n#define pbr_inline\n#define inline\nvoid iridescenceBlock(\nin vec4 vIridescenceParams,\nin float viewAngle,\nin vec3 specularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\nin vec2 iridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nin vec2 iridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nin float NdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#endif\nout iridescenceOutParams outParams\n)\n{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;\n#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\n#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE\niridescenceThicknessWeight=iridescenceMapData.g;\n#endif\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\n#endif\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; \n#ifdef CLEARCOAT\nfloat clearCoatIntensity=vClearCoatParams.x;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#endif\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\n#endif\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockIridescence = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockSubSurface\";\nconst shader = `struct subSurfaceOutParams\n{vec3 specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvec3 finalRefraction;vec3 surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\n#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;float translucencyIntensity;\n#ifdef REFLECTION\nvec3 refractionIrradiance;\n#endif\n#endif\n#if DEBUGMODE>0\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction;vec3 refractionTransmittance;\n#endif\n#endif\n};\n#ifdef SUBSURFACE\n#define pbr_inline\n#define inline\nvoid subSurfaceBlock(\nin vec3 vSubSurfaceIntensity,\nin vec2 vThicknessParam,\nin vec4 vTintColor,\nin vec3 normalW,\nin vec3 specularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nin vec4 thicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nin vec4 refractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nin vec4 translucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nin mat4 reflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin vec3 irradianceVector_,\n#endif\n#if defined(REALTIME_FILTERING)\nin samplerCube reflectionSampler,\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nin vec3 surfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nin vec3 vPositionW,\nin vec3 viewDirectionW,\nin mat4 view,\nin vec4 vRefractionInfos,\nin mat4 refractionMatrix,\nin vec4 vRefractionMicrosurfaceInfos,\nin vec4 vLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nin float alpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nin float NdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nin float roughness,\n#endif\nin float alphaG,\n#ifdef SS_REFRACTIONMAP_3D\nin samplerCube refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin samplerCube refractionSamplerLow,\nin samplerCube refractionSamplerHigh,\n#endif\n#else\nin sampler2D refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin sampler2D refractionSamplerLow,\nin sampler2D refractionSamplerHigh,\n#endif\n#endif\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nin vec3 refractionPosition,\nin vec3 refractionSize,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nin vec3 vDiffusionDistance,\n#endif\nout subSurfaceOutParams outParams\n)\n{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);outParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#if defined(SS_USE_GLTF_TEXTURES)\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#else\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)\n#if defined(SS_USE_GLTF_TEXTURES)\nrefractionIntensity*=thicknessMap.r;\n#else\nrefractionIntensity*=thicknessMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#endif\n#else\nfloat thickness=vThicknessParam.y;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\n#else\nrefractionIntensity*=refractionIntensityMap.g;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensity*=translucencyIntensityMap.b;\n#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);\n#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\n#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\n#endif\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef SS_HAS_THICKNESS\nfloat ior=vRefractionInfos.y;\n#else\nfloat ior=vRefractionMicrosurfaceInfos.w;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\n#else\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\n#else\nfloat requestedRefractionLOD=refractionLOD;\n#endif\n#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(\nsampleRefraction(refractionSamplerHigh,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);} else {environmentRefraction=mix(\nenvironmentRefractionMid,\nsampleRefraction(refractionSamplerLow,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\n#endif\nenvironmentRefraction.rgb*=vRefractionInfos.x;\n#endif\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;\n#else\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvec3 irradianceVector=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\n#else\nvec2 irradianceCoords=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\n#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\n#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\n#endif\nrefractionIrradiance.rgb*=transmittance;\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.refractionIrradiance=refractionIrradiance.rgb;\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockSubSurface = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockNormalGeometric\";\nconst shader = `vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#endif\nvec3 geometricNormalW=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockNormalGeometric = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockNormalFinal\";\nconst shader = `#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockNormalFinal = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockLightmapInit\";\nconst shader = `#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockLightmapInit = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockGeometryInfo\";\nconst shader = `float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\n#else\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockGeometryInfo = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectance0\";\nconst shader = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\n#else \nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\n#endif\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance0 = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockReflectance\";\nconst shader = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockReflectance = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockDirectLighting\";\nconst shader = `vec3 diffuseBase=vec3(0.,0.,0.);\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatBase=vec3(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvec3 sheenBase=vec3(0.,0.,0.);\n#endif\npreLightingInfo preInfo;lightingInfo info;float shadow=1.; \nfloat aggShadow=0.;float numLights=0.;\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvec3 absorption=vec3(0.);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockDirectLighting = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalLitComponents\";\nconst shader = `aggShadow=aggShadow/numLights;\n#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n#ifdef REFLECTION\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef REFLECTION\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef SHEEN\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef CLEARCOAT\nvec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef ALPHABLEND\nfloat luminanceOverAlpha=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalLitComponents = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalUnlitComponents\";\nconst shader = `vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\n#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\n#else\nfinalEmissive*=emissiveColorTex.rgb;\n#endif\nfinalEmissive*= vEmissiveInfos.y;\n#endif\nfinalEmissive*=vLightingIntensity.y;\n#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\n#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalUnlitComponents = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockFinalColorComposition\";\nconst shader = `vec4 finalColor=vec4(\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalAmbient +\nfinalDiffuse,\nalpha);\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor.rgb;\n#else\nfinalColor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\nfinalColor.rgb+=finalEmissive;\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,0.0);\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockFinalColorComposition = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrBlockImageProcessing\";\nconst shader = `#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\n#if !defined(SKIPFINALCOLORCLAMP)\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\n#endif\n#else\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\nfinalColor.rgb*=finalColor.a;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrBlockImageProcessing = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pbrDebug\";\nconst shader = `#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\n#if DEBUGMODE==1\ngl_FragColor.rgb=vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ngl_FragColor.rgb=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\n#elif DEBUGMODE==7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\n#ifndef GAMMAALBEDO\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE==22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\n#elif DEBUGMODE==23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\n#ifndef GAMMAEMISSIVE\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\n#ifndef GAMMALIGHTMAP\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\n#elif DEBUGMODE==32 && defined(BUMP)\ngl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ngl_FragColor.rgb=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\n#elif DEBUGMODE==63\ngl_FragColor.rgb=vec3(roughness);\n#elif DEBUGMODE==64\ngl_FragColor.rgb=vec3(alphaG);\n#elif DEBUGMODE==65\ngl_FragColor.rgb=vec3(NdotV);\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\n#elif DEBUGMODE==72\ngl_FragColor.rgb=vec3(microSurface);\n#elif DEBUGMODE==73\ngl_FragColor.rgb=vAlbedoColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vReflectivityColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==75\ngl_FragColor.rgb=vEmissiveColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)\ngl_FragColor.rgb=vec3(eho);\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\n#elif DEBUGMODE==87\ngl_FragColor.rgb=vec3(alpha);\n#elif DEBUGMODE==88 && defined(ALBEDO)\ngl_FragColor.rgb=vec3(albedoTexture.a);\n#else\nfloat stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);\n#endif\ngl_FragColor.rgb*=vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\n#endif\ngl_FragColor.a=1.0;\n#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor); \ngl_FragData[1]=vec4(0.,0.,0.,0.); \n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrDebug = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/pbrFragmentDeclaration\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentSamplersDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrHelperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions\";\nimport \"./ShadersInclude/pbrIBLFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/pbrBlockAlbedoOpacity\";\nimport \"./ShadersInclude/pbrBlockReflectivity\";\nimport \"./ShadersInclude/pbrBlockAmbientOcclusion\";\nimport \"./ShadersInclude/pbrBlockAlphaFresnel\";\nimport \"./ShadersInclude/pbrBlockAnisotropic\";\nimport \"./ShadersInclude/pbrBlockReflection\";\nimport \"./ShadersInclude/pbrBlockSheen\";\nimport \"./ShadersInclude/pbrBlockClearcoat\";\nimport \"./ShadersInclude/pbrBlockIridescence\";\nimport \"./ShadersInclude/pbrBlockSubSurface\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/pbrBlockNormalFinal\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/pbrBlockLightmapInit\";\nimport \"./ShadersInclude/pbrBlockGeometryInfo\";\nimport \"./ShadersInclude/pbrBlockReflectance0\";\nimport \"./ShadersInclude/pbrBlockReflectance\";\nimport \"./ShadersInclude/pbrBlockDirectLighting\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/pbrBlockFinalLitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalUnlitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalColorComposition\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/pbrBlockImageProcessing\";\nimport \"./ShadersInclude/oitFragment\";\nimport \"./ShadersInclude/pbrDebug\";\n\nconst name = \"pbrPixelShader\";\nconst shader = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nalbedoOpacityOutParams albedoOpacityOut;\n#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#endif\n#ifdef DECAL\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#endif\nalbedoOpacityBlock(\nvAlbedoColor,\n#ifdef ALBEDO\nalbedoTexture,\nvAlbedoInfos,\n#endif\n#ifdef OPACITY\nopacityMap,\nvOpacityInfos,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\n#ifdef DECAL\ndecalColor,\nvDecalInfos,\n#endif\nalbedoOpacityOut\n);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nambientOcclusionOutParams aoOut;\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\n#endif\nambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nvAmbientInfos,\n#endif\naoOut\n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;\n#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\n#endif\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\n#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityBlock(\nvReflectivityColor,\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo,\nmetallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nvReflectivityInfos,\nsurfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor,\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurfaceTexel,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nreflectivityOut\n);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface,\nalphaFresnelOut\n);alpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\n#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\n#endif\nanisotropicBlock(\nvAnisotropy,\nroughness,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW,\nanisotropicOut\n);\n#endif\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionBlock(\nvPositionW,\nnormalW,\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\nreflectionSampler,\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nvEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nreflectionOut\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nsheenOutParams sheenOut;\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\n#endif\nsheenBlock(\nvSheenColor,\n#ifdef SHEEN_ROUGHNESS\nvSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nsheenMapRoughnessData,\n#endif\n#endif\nroughness,\n#ifdef SHEEN_TEXTURE\nsheenMapData,\nvSheenInfos.y,\n#endif\nreflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nbaseColor,\nsurfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nNdotV,\nenvironmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nAARoughnessFactors,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\nreflectionOut.reflectionCoords,\nNdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nseo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\neho,\n#endif\n#endif\nsheenOut\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\niridescenceOutParams iridescenceOut;\n#ifdef IRIDESCENCE_TEXTURE\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\n#endif\niridescenceBlock(\nvIridescenceParams,\nNdotV,\nspecularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\niridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\niridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nNdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#endif\niridescenceOut\n);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nclearcoatOutParams clearcoatOut;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatBlock(\nvPositionW,\ngeometricNormalW,\nviewDirectionW,\nvClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatMapRoughnessData,\n#endif\nspecularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nvClearCoatTintParams,\nclearCoatColorAtDistance,\nvClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nvClearCoatBumpInfos,\nclearCoatBumpMapData,\nvClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nvTBN,\n#else\nvClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nnormalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nfaceNormal,\n#endif\n#ifdef REFLECTION\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n(gl_FrontFacing ? 1. : -1.),\n#endif\nclearcoatOut\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nsubSurfaceOutParams subSurfaceOut;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\n#endif\nsubSurfaceBlock(\nvSubSurfaceIntensity,\nvThicknessParam,\nvTintColor,\nnormalW,\nspecularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nrefractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nreflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionOut.irradianceVector,\n#endif\n#if defined(REALTIME_FILTERING)\nreflectionSampler,\nvReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nsurfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nvPositionW,\nviewDirectionW,\nview,\nvRefractionInfos,\nrefractionMatrix,\nvRefractionMicrosurfaceInfos,\nvLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nNdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nroughness,\n#endif\nalphaG,\nrefractionSampler,\n#ifndef LODBASEDMICROSFURACE\nrefractionSamplerLow,\nrefractionSamplerHigh,\n#endif\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nvRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nvRefractionPosition,\nvRefractionSize,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvDiffusionDistance,\n#endif\nsubSurfaceOut\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \n#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \nirradiance/=sqAlbedo;\n#else\ngl_FragData[0]=finalColor; \nfloat scatteringDiffusionProfile=255.;\n#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \n#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#ifndef UNLIT\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalVertexDeclaration\";\n\nconst name = \"pbrVertexDeclaration\";\nconst shader = `uniform mat4 view;uniform mat4 viewProjection;\n#ifdef ALBEDO\nuniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#ifdef REFLECTIVITY \nuniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;\n#endif\n#ifdef METALLIC_REFLECTANCE\nuniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;\n#endif\n#ifdef REFLECTANCE\nuniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#ifdef IRIDESCENCE\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\n#endif\n#ifdef NORMAL\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pbrVertexDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/pbrVertexDeclaration\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"pbrVertexShader\";\nconst shader = `precision highp float;\n#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#endif\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);\n#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const pbrVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdDecodePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdEncodePixelShader\";\nconst shader = `varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const rgbdEncodePixelShader = { name, shader };\n"],"names":["Bone","N","_matrix","this","_compose","_localMatrix","value","updateFlag","_needToCompose","copyFrom","_markAsDirtyAndDecompose","constructor","name","skeleton","parentBone","localMatrix","restMatrix","bindMatrix","index","super","getScene","children","Array","animations","_index","_scalingDeterminant","_needToDecompose","_linkedTransformNode","_waitingTransformNodeId","_skeleton","clone","Identity","_restMatrix","_bindMatrix","_absoluteMatrix","_absoluteBindMatrix","_absoluteInverseBindMatrix","_finalMatrix","bones","push","setParent","_updateAbsoluteBindMatrices","getClassName","getSkeleton","parent","_parentNode","getParent","getChildren","getIndex","indexOf","newParent","updateAbsoluteBindMatrices","splice","markAsDirty","getLocalMatrix","getBindMatrix","getBaseMatrix","getRestMatrix","getRestPose","setRestMatrix","matrix","setRestPose","getBindPose","setBindMatrix","updateMatrix","setBindPose","getFinalMatrix","getWorldMatrix","returnToRest","localScaling","Vector3","localRotation","Quaternion","localPosition","decompose","position","rotationQuaternion","scaling","getAbsoluteInverseBindMatrix","getInvertedAbsoluteTransform","getAbsoluteMatrix","getAbsoluteTransform","linkTransformNode","transformNode","_numBonesWithLinkedTransformNode","getTransformNode","_decompose","_localPosition","newPosition","_markAsDirtyAndCompose","rotation","getRotation","newRotation","setRotation","_localRotation","setRotationQuaternion","getScale","newScaling","setScale","animationPropertiesOverride","_localScaling","Zero","ComposeToRef","updateLocalMatrix","updateChildren","multiplyToRef","invertToRef","length","determinant","_currentRenderId","_childUpdateId","_markAsDirty","_updatePosition","vec","space","LOCAL","tNode","translationMode","lm","addAtIndex","x","y","z","setTranslationFromFloats","wm","computeAbsoluteMatrices","tmat","_TmpMats","tvec","_TmpVecs","IdentityToRef","invert","TransformCoordinatesToRef","translate","setPosition","setAbsolutePosition","WORLD","scale","scaleChildren","locMat","scaleMat","ScalingToRef","child","cm","multiplyAtIndex","getScaleToRef","result","setYawPitchRoll","yaw","pitch","roll","quat","_TmpQuat","RotationYawPitchRollToRef","rotMatInv","_getAbsoluteInverseMatrixUnscaledToRef","rotMat","_rotateWithMatrix","rotate","axis","amount","rmat","RotationAxisToRef","setAxisAngle","angle","FromQuaternionToRef","setRotationMatrix","FromRotationMatrixToRef","rotMat2","lmat","lx","m","ly","lz","parentScale","parentScaleInv","scaleMatrix","isNaN","getPosition","pos","getPositionToRef","getAbsolutePosition","getAbsolutePositionToRef","poseMatrix","getPoseMatrix","len","i","computeAbsoluteTransforms","getDirection","localAxis","getDirectionToRef","mat","TransformNormalToRef","normalize","getRotationToRef","getRotationQuaternionToRef","toEulerAnglesToRef","getRotationQuaternion","amat","undefined","getRotationMatrix","getRotationMatrixToRef","getAbsolutePositionFromLocal","getAbsolutePositionFromLocalToRef","getLocalPositionFromAbsolute","getLocalPositionFromAbsoluteToRef","setCurrentPoseAsRest","BuildArray","Skeleton","useTextureToStoreBoneMatrices","_useTextureToStoreBoneMatrices","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","id","scene","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","_identity","_ranges","_absoluteTransformIsDirty","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","LastCreatedScene","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","filter","b","getTransformMatrices","mesh","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","toString","fullDetails","ret","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","nBones","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","bone","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animIndex","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","mappedIndex","multiplyToArray","copyToArray","dontCheckFrameId","currentRenderId","getRenderId","node","needsUpdate","Float32Array","_synchronizedWithMesh","Matrix","textureWidth","getSize","width","dispose","CreateRGBATexture","update","_animatables","parentIndex","DeepCopy","rangeName","enableBlending","blendingSpeed","forEach","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","toArray","rest","linkedTransformNodeId","metadata","ranges","Parse","parsedSkeleton","FromArray","parsedBone","parsedBoneIndex","data","forceUpdate","sortBones","visited","_sortBones","prototype","_createDepthStencilCubeTexture","size","options","rtWrapper","internalTexture","DepthStencil","isCube","webGLVersion","Error","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","gl","_gl","_bindTextureDirectly","TEXTURE_CUBE_MAP","_setupDepthStencilTexture","_depthStencilTexture","_depthStencilTextureWithStencil","face","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","DEPTH24_STENCIL8","DEPTH_STENCIL","UNSIGNED_INT_24_8","DEPTH_COMPONENT24","DEPTH_COMPONENT","UNSIGNED_INT","_internalTexturesCache","_partialLoadFile","url","loadedFiles","onfinish","onErrorCallBack","_loadFile","_internalCount","request","exception","status","statusText","_cascadeLoadFiles","files","onError","_cascadeLoadImgs","texture","mimeType","loadedImages","_partialLoadImg","tokenPendingData","img","removePendingData","message","offlineProvider","addPendingData","_setCubeMapTextureParams","loadMipmap","maxLevel","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","samplingMode","textureMaxLevel","TEXTURE_MAX_LEVEL","_maxLodLevel","createCubeTextureBase","rootUrl","noMipmap","onLoad","format","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","beforeLoadCubeDataCallback","imageHandler","useSRGBBuffer","Cube","generateMipMaps","_lodGenerationScale","_lodGenerationOffset","_useSRGBBuffer","_caps","supportSRGBBuffers","isWebGPU","label","substring","_doNotHandleContextLost","_extension","_files","originalRootUrl","_transformTextureUrl","rootUrlWithoutUriParams","split","lastDot","lastIndexOf","extension","toLowerCase","loader","availableLoader","_TextureLoaders","canLoad","onInternalError","onloaddata","loadCubeData","supportCascades","images","map","image","Uint8Array","imgs","createCubeTexture","loaderOptions","needPOTTextures","GetExponentOfTwo","maxCubemapTextureSize","height","faces","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","_unpackFlipY","internalFormat","_getInternalFormat","_glSRGBExtensionValues","SRGB8_ALPHA8","RGBA","texelFormat","_prepareWorkingCanvas","_workingCanvas","_workingContext","drawImage","UNSIGNED_BYTE","generateMipmap","isReady","onLoadedObservable","clear","_convertRGBtoRGBATextureData","rgbData","textureType","rgbaData","val1","Uint16Array","Uint32Array","newIndex","_makeCreateRawTextureFunction","is3D","depth","invertY","compression","target","TEXTURE_3D","TEXTURE_2D_ARRAY","Raw3D","Raw2DArray","baseWidth","baseHeight","baseDepth","type","is2DArray","_bufferView","updateRawTexture3D","updateRawTexture2DArray","filters","_getSamplingParameters","mag","min","_makeUpdateRawTextureFunction","internalType","_getWebGLTextureType","internalSizedFomat","_getRGBABufferInternalSizedFormat","_compression","pixelStorei","UNPACK_ALIGNMENT","compressedTexImage3D","s3tc","texImage3D","updateRawTexture","TEXTURE_2D","compressedTexImage2D","createRawTexture","creationFlags","Raw","_getUseSRGBBuffer","createRawCubeTexture","CubeRaw","_bufferViewArray","RGB","FLOAT","textureFloatLinearFiltering","HALF_FLOAT_OES","textureHalfFloatLinearFiltering","textureFloatRender","HALF_FLOAT","colorBufferFloat","IsExponentOfTwo","updateRawCubeTexture","level","faceIndex","needConversion","faceData","createRawCubeTextureFromUrl","callback","mipmapGenerator","internalCallback","faceDataArrays","mipData","mipSize","mipFaceData","createRawTexture2DArray","createRawTexture3D","EnvironmentHelper","_GetDefaultOptions","createGround","groundSize","groundTexture","_GroundTextureCDNUrl","groundColor","toLinearSpace","useExactSrgbConversions","groundOpacity","enableGroundShadow","groundShadowLevel","enableGroundMirror","groundMirrorSizeRatio","groundMirrorBlurKernel","groundMirrorAmount","groundMirrorFresnelWeight","groundMirrorFallOffDistance","groundMirrorTextureType","groundYBias","createSkybox","skyboxSize","skyboxTexture","_SkyboxTextureCDNUrl","skyboxColor","backgroundYRotation","sizeAuto","rootPosition","setupImageProcessing","environmentTexture","_EnvironmentTextureCDNUrl","cameraExposure","cameraContrast","toneMappingEnabled","rootMesh","_rootMesh","skybox","_skybox","_skyboxTexture","skyboxMaterial","_skyboxMaterial","ground","_ground","_groundTexture","groundMirror","_groundMirror","groundMirrorRenderList","renderList","groundMaterial","_groundMaterial","_errorHandler","onErrorObservable","_options","_setupBackground","_setupImageProcessing","updateOptions","newOptions","setMainColor","color","primaryColor","clearColor","r","g","imageProcessingConfiguration","contrast","exposure","_setupEnvironmentTexture","CreateFromPrefilteredData","sceneSize","_getSceneSize","_setupGround","_setupGroundMaterial","_setupGroundDiffuseTexture","_setupGroundMirrorTexture","_setupMirrorInGroundMaterial","_setupSkybox","_setupSkyboxMaterial","_setupSkyboxReflectionTexture","meshes","sceneExtends","getWorldExtends","sceneDiagonal","max","subtract","activeCamera","upperRadiusLimit","sceneDiagonalLenght","add","isDisposed","Math","PI","onDisposeObservable","receiveShadows","alpha","alphaMode","shadowLevel","useRGBColor","enableNoise","material","diffuseTexture","gammaSpace","hasAlpha","wrapping","CLAMP_ADDRESSMODE","ratio","BILINEAR_SAMPLINGMODE","mirrorPlane","anisotropicFilteringLevel","wrapU","wrapV","gammaGround","toGammaSpace","adaptiveBlurKernel","reflectionTexture","reflectionFresnel","reflectionAmount","reflectionStandardFresnelWeight","reflectionFalloffDistance","sideOrientation","BACKSIDE","coordinatesMode","SKYBOX_MODE","AddNodeConstructor","PointLight","shadowAngle","_shadowAngle","forceProjectionMatrixCompute","direction","_direction","previousNeedCube","needCube","_shadowGenerators","iterator","values","key","next","done","recreateShadowMap","getTypeID","LIGHTTYPEID_POINTLIGHT","getShadowDirection","_setDefaultShadowProjectionMatrix","viewMatrix","minZ","shadowMinZ","maxZ","shadowMaxZ","useReverseDepthBuffer","PerspectiveFovLHToRef","isNDCHalfZRange","_buildUniformLayout","_uniformBuffer","addUniform","create","transferToEffect","effect","lightIndex","computeTransformedInformation","updateFloat4","transformedPosition","_inverseSquaredRange","transferToNodeMaterialEffect","lightDataUniformName","setFloat3","prepareLightSpecificDefines","defines","SpotLight","_angle","_cosHalfAngle","cos","_projectionTextureProjectionLightDirty","_computeAngleValues","innerAngle","_innerAngle","shadowAngleScale","_shadowAngleScale","projectionTextureMatrix","_projectionTextureMatrix","projectionTextureLightNear","_projectionTextureLightNear","projectionTextureLightFar","_projectionTextureLightFar","projectionTextureUpDirection","_projectionTextureUpDirection","projectionTexture","_projectionTexture","_projectionTextureDirty","_IsProceduralTexture","getEffect","executeWhenCompiled","_markMeshesAsLightDirty","_IsTexture","onLoadObservable","addOnce","onGeneratedObservable","projectionTextureProjectionLightMatrix","_projectionTextureProjectionLightMatrix","projection","exponent","Up","_projectionTextureViewLightDirty","_projectionTextureViewTargetVector","_projectionTextureViewLightMatrix","_projectionTextureScalingMatrix","FromValues","LIGHTTYPEID_SPOTLIGHT","_setDirection","_setPosition","_computeProjectionTextureViewLightMatrix","addToRef","LookAtLHToRef","_computeProjectionTextureProjectionLightMatrix","lightFar","lightNear","P","Q","S","tan","FromValuesToRef","_computeProjectionTextureMatrix","u","uScale","v","vScale","_lightAngleScale","_lightAngleOffset","transferTexturesToEffect","setMatrix","setTexture","normalizeDirection","Normalize","transformedDirection","useRightHandedSystem","getDepthMinZ","engine","getDepthMaxZ","IncludesShadersStore","ShadersStore","BackgroundMaterialDefines","DIFFUSE","DIFFUSEDIRECTUV","GAMMADIFFUSE","DIFFUSEHASALPHA","OPACITYFRESNEL","REFLECTIONBLUR","REFLECTIONFRESNEL","REFLECTIONFALLOFF","TEXTURELODSUPPORT","PREMULTIPLYALPHA","USERGBCOLOR","USEHIGHLIGHTANDSHADOWCOLORS","BACKMAT_SHADOWONLY","NOISE","REFLECTIONBGR","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","EXPOSURE","MULTIVIEW","REFLECTION","REFLECTIONMAP_3D","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_PLANAR","REFLECTIONMAP_CUBIC","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED","INVERTCUBICMAP","REFLECTIONMAP_OPPOSITEZ","LODINREFLECTIONALPHA","GAMMAREFLECTION","RGBDREFLECTION","EQUIRECTANGULAR_RELFECTION_FOV","MAINUV1","MAINUV2","UV1","UV2","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","POINTSIZE","FOG","NORMAL","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","SHADOWFLOAT","LOGARITHMICDEPTH","NONUNIFORMSCALING","ALPHATEST","rebuild","BackgroundMaterial","_perceptualColor","__perceptualColor","_computePrimaryColorFromPerceptualColor","_markAllSubMeshesAsLightsDirty","primaryColorShadowLevel","_primaryColorShadowLevel","_computePrimaryColors","primaryColorHighlightLevel","_primaryColorHighlightLevel","reflectionWeight","reflectionReflectance0","StandardReflectance0","reflectionReflectance90","StandardReflectance90","fovMultiplier","_fovMultiplier","_attachImageProcessingConfiguration","configuration","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","remove","_markAllSubMeshesAsImageProcessingDirty","_markAllSubMeshesAsTexturesDirty","cameraColorCurvesEnabled","colorCurvesEnabled","cameraColorGradingEnabled","colorGradingEnabled","cameraToneMappingEnabled","cameraColorGradingTexture","colorGradingTexture","cameraColorCurves","colorCurves","White","reflectionBlur","_shadowLights","shadowLights","sceneCenter","opacityFresnel","useEquirectangularFOV","_maxSimultaneousLights","maxSimultaneousLights","_shadowOnly","shadowOnly","switchToBGR","_renderTargets","_reflectionControls","_white","_primaryShadowColor","Black","_primaryHighlightColor","getRenderTargetTextures","reset","_diffuseTexture","isRenderTarget","_reflectionTexture","hasRenderTargetTextures","needAlphaTesting","needAlphaBlending","isReadyForSubMesh","subMesh","useInstances","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","_isReadyForSubMesh","PrepareDefinesForLights","_needNormals","PrepareDefinesForMultiview","_areTexturesDirty","_needUVs","texturesEnabled","textureLOD","DiffuseTextureEnabled","isReadyOrNotBlocking","PrepareDefinesForMergedUV","_opacityFresnel","ReflectionTextureEnabled","isRGBD","_reflectionBlur","lodLevelInAlpha","INVCUBIC_MODE","invertZ","EXPLICIT_MODE","PLANAR_MODE","PROJECTION_MODE","SPHERICAL_MODE","EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MODE","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","CUBIC_MODE","w","_useRGBColor","_enableNoise","_areLightsDirty","_areImageProcessingDirty","prepareDefines","PrepareDefinesForMisc","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","PrepareDefinesForFrameBoundValues","getRenderingMesh","hasThinInstances","PrepareDefinesForAttributes","standardDerivatives","isVerticesDataPresent","NormalKind","createNormals","isDirty","markAsProcessed","resetCachedMaterial","fallbacks","addFallback","HandleFallbacksForShadows","attribs","PositionKind","UVKind","UV2Kind","PrepareAttributesForBones","PrepareAttributesForInstances","uniforms","samplers","uniformBuffers","PrepareUniforms","PrepareSamplers","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","join","createEffect","attributes","onCompiled","indexParameters","setEffect","_materialContext","buildUniformLayout","_renderId","_checkScenePerformancePriority","_primaryColor","toLinearSpaceToRef","scaleToRef","subtractToRef","unbind","bindOnlyWorldMatrix","world","_activeEffect","bindForSubMesh","BindBonesParameters","mustRebind","_mustRebind","visibility","bindToEffect","bindViewProjection","useUbo","isSync","updateFloat2","coordinatesIndex","BindTextureMatrix","getReflectionTextureMatrix","updateFloat3","lodGenerationScale","lodGenerationOffset","updateFloat","pointSize","updateColor4","_lodTextureMid","_lodTextureLow","_lodTextureHigh","bindEyePosition","_features","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","lightsEnabled","BindLights","bindView","BindFogParameters","bind","_afterBind","hasTexture","forceDisposeEffect","forceDisposeTextures","Clone","customType","MaterialBRDFDefines","BRDF_V_HEIGHT_CORRELATED","MS_BRDF_ENERGY_CONSERVATION","SPHERICAL_HARMONICS","SPECULAR_GLOSSINESS_ENERGY_CONSERVATION","PBRBRDFConfiguration","_markAllSubMeshesAsMiscDirty","_internalMarkAllSubMeshesAsMiscDirty","addToPluginList","_useEnergyConservation","DEFAULT_USE_ENERGY_CONSERVATION","useEnergyConservation","_useSmithVisibilityHeightCorrelated","DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED","useSmithVisibilityHeightCorrelated","_useSphericalHarmonics","DEFAULT_USE_SPHERICAL_HARMONICS","useSphericalHarmonics","_useSpecularGlossinessInputEnergyConservation","DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION","useSpecularGlossinessInputEnergyConservation","_dirtyCallbacks","_enable","PBRMaterial","refractionTexture","subSurface","isRefractionEnabled","linkRefractionWithTransparency","indexOfRefraction","invertRefractionY","usePhysicalLightFalloff","_lightFalloff","LIGHTFALLOFF_PHYSICAL","LIGHTFALLOFF_STANDARD","useGLTFLightFalloff","LIGHTFALLOFF_GLTF","directIntensity","emissiveIntensity","environmentIntensity","specularIntensity","disableBumpMap","ambientTextureStrength","ambientTextureImpactOnAnalyticalLights","DEFAULT_AO_ON_ANALYTICAL_LIGHTS","metallicF0Factor","metallicReflectanceColor","useOnlyMetallicFromMetallicReflectanceTexture","ambientColor","albedoColor","reflectivityColor","reflectionColor","emissiveColor","microSurface","useLightmapAsShadowmap","useAlphaFromAlbedoTexture","forceAlphaTest","alphaCutOff","useSpecularOverAlpha","useMicroSurfaceFromReflectivityMapAlpha","useRoughnessFromMetallicTextureAlpha","useRoughnessFromMetallicTextureGreen","useMetallnessFromMetallicTextureBlue","useAmbientOcclusionFromMetallicTextureRed","useAmbientInGrayScale","useAutoMicroSurfaceFromReflectivityMap","useRadianceOverAlpha","useObjectSpaceNormalMap","useParallax","useParallaxOcclusion","parallaxScaleBias","disableLighting","forceIrradianceInFragment","invertNormalMapX","invertNormalMapY","twoSidedLighting","useAlphaFresnel","useLinearAlphaFresnel","environmentBRDFTexture","forceNormalForward","enableSpecularAntiAliasing","useHorizonOcclusion","useRadianceOcclusion","unlit","applyDecalMapAfterDetailMap","_environmentBRDFTexture","cloneTexturesOnlyOnce","stencil","copyTo","_clonePlugins","parse","_parsePlugins","clearCoat","anisotropy","brdf","sheen","iridescence","PBRMATERIAL_OPAQUE","PBRMATERIAL_ALPHATEST","PBRMATERIAL_ALPHABLEND","PBRMATERIAL_ALPHATESTANDBLEND","forceSphericalPolynomialsRecompute","_texture","_sphericalPolynomial","_sphericalPolynomialPromise","_sphericalPolynomialComputed","defineProperty","get","ConvertCubeMapTextureToSphericalPolynomial","then","sphericalPolynomial","set","enumerable","configurable","CubeTexture","boundingBoxSize","_boundingBoxSize","equals","markAllMaterialsAsDirty","rotationY","_rotationY","setReflectionTextureMatrix","RotationY","_noMipmap","_forcedExtension","CreateFromImages","rootUrlKey","oldValue","useDelayedTextureLoading","sceneOrEngine","extensions","_lodScale","_lodOffset","boundingBoxPosition","_extensions","_textureMatrixRefraction","_format","_textureMatrix","_createPolynomials","_loaderOptions","updateURL","prefiltered","delayLoad","startsWith","isDDS","isEnv","isBasis","_prefiltered","delayLoadState","_delayedOnLoad","_delayedOnError","_loadTexture","isIdentity","trans","getRefractionTextureMatrix","oldTexture","_getFromCache","onLoadProcessing","errorHandler","_loadingError","_errorObject","OnTextureLoadErrorObservable","SetImmediate","_getEngine","createPrefilteredCubeTexture","parsedTexture","animationIndex","parsedAnimation","internalClass","newCubeTexture","cubeTexture","_CubeTextureParser","MirrorTexture","blurRatio","_blurRatio","_preparePostProcesses","_adaptiveBlurKernel","_autoComputeBlurKernel","blurKernel","blurKernelX","blurKernelY","_blurKernelX","_blurKernelY","dw","getRenderWidth","dh","getRenderHeight","_onRatioRescale","_sizeRatio","resize","_initialSizeParameter","_updateGammaSpace","isEnabled","applyByPostProcess","generateDepthBuffer","_transformMatrix","_mirrorMatrix","ignoreCameraViewport","_imageProcessingConfigChangeObserver","saveClipPlane","supportsUniformBuffers","_sceneUBO","createSceneUniformBuffer","onBeforeBindObservable","_debugPushGroup","onAfterUnbindObservable","_debugPopGroup","onBeforeRenderObservable","_currentSceneUBO","getSceneUniformBuffer","setSceneUniformBuffer","unbindEffect","ReflectionToRef","getViewMatrix","setTransformMatrix","getProjectionMatrix","clipPlane","_mirroredCameraPosition","TransformCoordinates","globalPosition","onAfterRenderObservable","updateTransformMatrix","clearPostProcesses","_blurX","autoClear","samples","inputTexture","_renderTarget","alwaysForcePOT","_blurY","addPostProcess","removePostProcess","textureSize","newTexture","_renderTargetOptions","slice","_CreateMirror","renderTargetSize","RawTexture","_engine","CreateLuminanceTexture","CreateLuminanceAlphaTexture","CreateAlphaTexture","CreateRGBTexture","CreateRGBAStorageTexture","CreateRTexture","TRILINEAR_SAMPLINGMODE","CreateRStorageTexture","RawTexture2DArray","_depth","SH3ylmBasisConstants","sqrt","SH3ylmBasisTrigonometricTerms","applySH3","SHCosKernelConvolution","SphericalHarmonics","preScaled","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","addLight","deltaSolidAngle","colorVector","c","addInPlace","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","preScaleForRendering","updateFromArray","FromArrayToRef","updateFromFloatsArray","FromFloatsToRef","FromPolynomial","polynomial","xx","yy","zz","xy","yz","zx","SphericalPolynomial","preScaledHarmonics","_harmonics","addAmbient","copyFromFloats","updateFromHarmonics","harmonics","subtractInPlace","FromHarmonics","sp","thinInstanceAdd","refresh","instancedArrays","_thinInstanceUpdateBufferSize","isArray","_thinInstanceDataStorage","instancesCount","thinInstanceSetMatrixAt","thinInstanceAddSelf","IdentityReadOnly","thinInstanceRegisterAttribute","kind","stride","ColorKind","ColorInstanceKind","removeVerticesData","_thinInstanceInitializeUserStorage","_userThinInstanceBuffersStorage","strides","sizes","vertexBuffers","setVerticesBuffer","matrixData","worldMatrices","thinInstanceBufferUpdated","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetAttributeAt","_thinInstanceCreateMatrixBuffer","buffer","staticBuffer","matrixBuffer","createVertexBuffer","thinInstanceSetBuffer","matrixBufferSize","refreshBoundingInfo","previousMatrixBuffer","previousMatrixData","updateDirectly","thinInstancePartialBufferUpdate","offset","thinInstanceGetWorldMatrices","forceRefreshParentInfo","applySkeleton","applyMorph","vectors","boundingVectors","rawBoundingInfo","boundingInfo","getBoundingInfo","minimum","maximum","boundingBox","setAll","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","minimizeInPlace","maximizeInPlace","reConstruct","_updateBoundingInfo","numInstances","kindIsMatrix","currentSize","bufferSize","newSize","newData","needsPreviousWorldMatrices","_disposeThinInstanceSpecificData","FileFaceOrientation","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","CubeMapToSphericalPolynomialTools","flushFramebuffer","rightPromise","readPixels","leftPromise","upPromise","downPromise","frontPromise","backPromise","Promise","resolve","all","left","right","up","down","front","back","cubeInfo","ConvertCubeMapToSphericalPolynomial","_AreaElement","atan2","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","fileFace","_FileFaces","dataArray","worldDirection","pow","Clamp","MAX_HDRI_VALUE","PRESERVE_CLAMPED_COLORS","currentMax","factor","correctionFactor","RGBDTextureTools","ExpandRGBDTexture","caps","expandTexture","textureHalfFloatRender","_isRGBD","expandRGBDTexture","rgbdPostProcess","externalTextureSamplerBinding","expandedTexture","createRenderTargetTexture","generateStencilBuffer","onApply","_bindTexture","setFloat2","postProcessManager","directRender","restoreDefaultFramebuffer","_releaseTexture","_swapAndDie","EncodeTextureToRGBD","outputTextureType","MorphTarget","influence","_influence","previous","onInfluenceChanged","hasObservers","_positions","_normals","_tangents","_uvs","_onDataLayoutChanged","hasPositions","hasNormals","hasTangents","hasUVs","setPositions","hadPositions","getPositions","setNormals","hadNormals","getNormals","setTangents","hadTangents","getTangents","setUVs","hadUVs","getUVs","newOne","positions","call","normals","tangents","uvs","AppendSerializedAnimations","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","FromMesh","getVerticesData","TangentKind","MorphTargetManager","areUpdatesFrozen","block","_blockCounter","_syncActiveTargets","_targets","_targetInfluenceChangedObservers","_targetDataLayoutChangedObservers","_activeTargets","_supportsNormals","_supportsTangents","_supportsUVs","_vertexCount","_textureVertexStride","_textureWidth","_textureHeight","_tempInfluences","_canUseTextureForTargets","optimizeInfluencers","enableNormalMorphing","enableTangentMorphing","enableUVMorphing","_useTextureToStoreTargets","addMorphTargetManager","canUseGLVertexID","texture2DArrayMaxLayerCount","vertexCount","supportsNormals","supportsTangents","supportsUVs","numTargets","numInfluencers","influences","_influences","useTextureToStoreTargets","isUsingTextureForTargets","EnableTextureStorage","disableMorphTargetTexture","getActiveTarget","getTarget","addTarget","needUpdate","removeTarget","_bind","setFloatArray","_morphTargetTextureIndices","_targetStoreTexture","copy","targets","influenceCount","targetIndex","MaxActiveMorphTargetsInVertexAttributeMode","synchronize","maxTextureSize","ceil","mustUpdateTexture","targetCount","vertex","morphTargetManager","_syncGeometryWithMorphTargetManager","removeMorphTargetManager","morphTargetManagers","morph","targetData"],"sourceRoot":""}