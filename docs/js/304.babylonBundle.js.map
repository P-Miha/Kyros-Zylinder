{"version":3,"file":"js/304.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./assets/glb/LowPoly.glb","webpack://babylonjs-typescript-webpack-template/./assets/Overlay.png","webpack://babylonjs-typescript-webpack-template/./src/scenes/defaultWithTexture.ts","webpack://babylonjs-typescript-webpack-template/./assets/grass.jpg","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Lights/Shadows/shadowGeneratorSceneComponent.ts","webpack://babylonjs-typescript-webpack-template/./dev/core/src/Meshes/Builders/sphereBuilder.ts"],"sourcesContent":["export default __webpack_public_path__ + \"555db8d15bbc97ae30694376737aa1b3.glb\";","export default __webpack_public_path__ + \"0244f380ef0aafaf377b6d28f359db9a.png\";","import { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\r\nimport { Vector3} from \"@babylonjs/core/Maths/math.vector\";\r\nimport { CreateGround } from \"@babylonjs/core/Meshes/Builders/groundBuilder\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { CreateSceneClass } from \"../createScene\";\r\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader\";\r\nimport { HemisphericLight, PBRMaterial } from \"@babylonjs/core\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\r\n\r\nimport \"@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent\";\r\nimport \"@babylonjs/loaders/glTF\";\r\n// If you don't need the standard material you will still need to import it since the scene requires it.\r\n// import \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\n\r\nimport grassTextureUrl from \"../../assets/grass.jpg\";\r\n\r\n// Import Highlights / Overlays for CyrusMesh\r\n\r\n// Impport Cyrus Mesh\r\n\r\nimport UVCylinder from \"../../assets/glb/LowPoly.glb\"\r\n\r\n// Baked Textures\r\nimport bakedTexture from \"../../assets/Overlay.png\"\r\n\r\n\r\nexport class DefaultSceneWithTexture implements CreateSceneClass {\r\n    createScene = async (\r\n        engine: Engine,\r\n        canvas: HTMLCanvasElement\r\n    ): Promise<Scene> => {\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        const scene = new Scene(engine);\r\n\r\n        void Promise.all([\r\n            import(\"@babylonjs/core/Debug/debugLayer\"),\r\n            import(\"@babylonjs/inspector\"),\r\n        ]).then((_values) => {\r\n            console.log(_values);\r\n            scene.debugLayer.show({\r\n                handleResize: true,\r\n                overlay: true,\r\n                globalRoot: document.getElementById(\"#root\") || undefined,\r\n            });\r\n        });\r\n\r\n        // This creates and positions a free camera (non-mesh)\r\n        const camera = new ArcRotateCamera(\"Camera\", -1.85, 1.2, 50, Vector3.Zero(), scene);\r\n\r\n\r\n        // This targets the camera to scene origin\r\n        camera.setTarget(Vector3.Zero());\r\n\r\n        // This attaches the camera to the canvas\r\n        camera.attachControl(canvas, true);\r\n\r\n        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\r\n         const light = new HemisphericLight(\r\n             \"light\",\r\n             new Vector3(0, 1, 0),\r\n             scene\r\n         );\r\n\r\n        // // Default intensity is 1. Let's dim the light a small amount\r\n        // light.intensity = 0.7;\r\n\r\n\r\n\r\n\r\n\r\n        // // Import Cyrus-Cylinder Mesh\r\n        // const cyrusCylinder = await SceneLoader.ImportMeshAsync(\"\",\"\",cyrus_cylinder,scene,undefined,\".glb\",);\r\n        // // const cyrusCylinder = await SceneLoader.ImportMeshAsync(\"\",\"\",alternative_cylinder ,scene,undefined,\".glb\",);\r\n        //const cyrusCylinder = await SceneLoader.ImportMeshAsync(\"\",\"\",split3CyrusCylinder ,scene,undefined,\".glb\",);\r\n        // [0] = Root\r\n        // [1] = Backside\r\n        // [2] = Bottom\r\n        // [3] = Frontside\r\n        // [4] = Top\r\n\r\n        const cyrusCylinder = await SceneLoader.ImportMeshAsync(\"\",\"\", UVCylinder,scene,undefined,\".glb\",);\r\n        // Cast Material to PRBMaterial\r\n        const cyrusCylinderMaterial = cyrusCylinder.meshes[1].material as PBRMaterial;\r\n        // Set Casted Material to Mesh\r\n        cyrusCylinder.meshes[1].material = cyrusCylinderMaterial;\r\n\r\n        // // Modifing cyrusCylinder mesh\r\n        cyrusCylinder.meshes[0].position.y = 2; // Floating\r\n        console.log(\"Material: \", cyrusCylinder.meshes[1].material )\r\n        const altTexture = new Texture(bakedTexture, scene, false, false);\r\n        const altMaterial = new PBRMaterial(\"altMaterial\", scene);\r\n        altMaterial.albedoTexture = altTexture;\r\n        altMaterial.transparencyMode = 0;\r\n        altMaterial.roughness = 0.5;\r\n        //cyrusCylinder.meshes[1].material = altMaterial;\r\n        cyrusCylinder.meshes[1].material.backFaceCulling = false;\r\n        cyrusCylinderMaterial.albedoTexture = altTexture;\r\n\r\n       \r\n\r\n\r\n\r\n        //camera.setTarget(cyrusCylinder.meshes[0]);\r\n        // Our built-in 'ground' shape.\r\n        const ground = CreateGround(\r\n            \"ground\",\r\n            { width: 6, height: 6 },\r\n            scene\r\n        );\r\n\r\n        // Load a texture to be used as the ground material\r\n        const groundMaterial = new StandardMaterial(\"ground material\", scene);\r\n        groundMaterial.diffuseTexture = new Texture(grassTextureUrl, scene);\r\n\r\n        ground.material = groundMaterial;\r\n        ground.receiveShadows = true;\r\n\r\n        //const light = new DirectionalLight(\r\n         //   \"light\",\r\n         //   new Vector3(0, -1, 1),\r\n         //   scene\r\n        //);\r\n        light.intensity = 0.5;\r\n        //light.position.y = 10;\r\n\r\n        //const shadowGenerator = new ShadowGenerator(512, light)\r\n        //shadowGenerator.useBlurExponentialShadowMap = true;\r\n        //shadowGenerator.blurScale = 2;\r\n        //shadowGenerator.setDarkness(0.2);\r\n\r\n        //shadowGenerator.getShadowMap()!.renderList!.push();\r\n        const onPointerDown = function (evt: PointerEvent) {\r\n            if (evt.button !== 0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n            const pick = scene.pick(scene.pointerX, scene.pointerY, )\r\n            if (pick.hit){\r\n                console.log(pick.getNormal(true))\r\n            }\r\n        }\r\n\r\n        canvas.addEventListener(\"pointerdown\", onPointerDown, false);\r\n\r\n        return scene;\r\n    };\r\n}\r\n\r\nexport default new DefaultSceneWithTexture();\r\n","export default __webpack_public_path__ + \"9b31293ea96c8dfa518b45622da82a13.jpg\";","import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n","import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n"],"names":["DefaultSceneWithTexture","createScene","async","engine","canvas","scene","Promise","all","then","_values","console","log","debugLayer","show","handleResize","overlay","globalRoot","document","getElementById","undefined","camera","Zero","setTarget","attachControl","light","HemisphericLight","cyrusCylinder","ImportMeshAsync","cyrusCylinderMaterial","meshes","material","position","y","altTexture","altMaterial","PBRMaterial","albedoTexture","transparencyMode","roughness","backFaceCulling","ground","width","height","groundMaterial","diffuseTexture","grass","receiveShadows","intensity","addEventListener","evt","button","pick","pointerX","pointerY","hit","getNormal","AddParser","NAME_SHADOWGENERATOR","parsedData","shadowGenerators","index","cache","length","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","name","this","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","getShadowGenerators","iterator","values","key","next","done","shadowGenerator","value","push","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent","CreateSphereVertexData","options","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","normalize","x","z","UseOpenGLOrientationForUV","verticesCount","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","CreateSphere","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","SphereBuilder"],"sourceRoot":""}