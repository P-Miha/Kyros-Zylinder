{"version":3,"file":"js/778.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./dev/core/src/Materials/shaderMaterial.ts"],"sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            if (storeEffectOnSubMeshes) {\r\n                if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                const effect = this._drawWrapper.effect;\r\n                if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    this._options.uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        effect!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                        this.getScene().finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, this.getScene());\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                MaterialHelper.BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!effect._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray = new Array<Texture>();\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n"],"names":["onCreatedEffectParameters","effect","subMesh","ShaderMaterial","constructor","name","scene","shaderPath","options","storeEffectOnSubMeshes","super","_textures","_textureArrays","_externalTextures","_floats","_ints","_uints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_quaternions","_quaternionsArrays","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_uniformBuffers","_textureSamplers","_storageBuffers","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","_materialHelperNeedsPreviousMatrices","this","_shaderPath","_options","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","externalTextures","samplerObjects","storageBuffers","defines","useClipPlane","isMultiview","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setTextureArray","textures","setExternalTexture","setFloat","value","setInt","setUInt","setFloats","setColor3","setColor3Array","reduce","arr","color","toArray","length","setColor4","setColor4Array","setVector2","setVector3","setVector4","setQuaternion","setQuaternionArray","quaternion","setMatrix","setMatrices","float32Array","Float32Array","index","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","setUniformBuffer","buffer","setTextureSampler","sampler","setStorageBuffer","setDefine","define","defineName","trimEnd","existingDefineIdx","findIndex","x","startsWith","splice","isReadyForSubMesh","mesh","useInstances","isReady","_storeEffectOnSubMeshes","isFrozen","_wasPreviouslyReady","_drawWrapper","_wasPreviouslyUsingInstances","getScene","engine","getEngine","attribs","fallbacks","shaderName","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","defineToAdd","isVerticesDataPresent","ColorKind","PushAttributesForInstances","hasThinInstances","ColorInstanceKind","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numInfluencers","manager","morphTargetManager","uv","supportsUVs","tangent","supportsTangents","normal","supportsNormals","isUsingTextureForTargets","PositionKind","NormalKind","TangentKind","UVKind","slice","bvaManager","bakedVertexAnimationManager","isEnabled","PrepareAttributesForBakedVertexAnimation","_shouldTurnAlphaTestOn","customShaderNameResolve","drawWrapper","_getDrawWrapper","previousEffect","previousDefines","join","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","shaderLanguage","setEffect","_materialContext","_onEffectCreatedObservable","subMeshes","notifyObservers","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","getEffect","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_drawWrapperOverride","_activeEffect","useSceneUBO","supportsUniformBuffers","i","getMeshUniformBuffer","bindToEffect","transferToEffect","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","mustRebind","_mustRebind","visibility","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","BindBonesParameters","setArray","setFloat4","r","g","b","a","getBuffer","bindUniformBuffer","BindMorphTargetParameters","_afterBind","getActiveTextures","activeTextures","array","hasTexture","clone","result","Clone","id","Object","keys","forEach","propName","propValue","Array","isArray","stencil","copyTo","key","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","Serialize","customType","uniqueId","textureArrays","ints","uints","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","quaternions","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","quaternionsArrays","Parse","source","rootUrl","material","parse","textureArray","floatsArrays","FromArray","colors","num","map","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","responseText","output","LastCreatedScene","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","CreateFromSnippetAsync"],"sourceRoot":""}