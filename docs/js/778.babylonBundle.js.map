{"version":3,"file":"js/778.babylonBundle.js","mappings":"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","sources":["webpack://babylonjs-typescript-webpack-template/./lts/core/generated/Materials/shaderMaterial.ts"],"sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\ndeclare type ExternalTexture = import(\"./Textures/externalTexture\").ExternalTexture;\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview: boolean = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n     *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            if (storeEffectOnSubMeshes) {\r\n                if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                const effect = this._drawWrapper.effect;\r\n                if (effect && effect._wasPreviouslyReady && effect._wasPreviouslyUsingInstances === useInstances) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    this._options.uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (this._options.uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    this._options.uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        effect!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                        this.getScene().finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, this.getScene());\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                MaterialHelper.BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!effect._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray = new Array<Texture>();\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n"],"names":["onCreatedEffectParameters","effect","subMesh","ShaderMaterial","constructor","name","scene","shaderPath","options","storeEffectOnSubMeshes","super","_textures","_textureArrays","_externalTextures","_floats","_ints","_uints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_quaternions","_quaternionsArrays","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_uniformBuffers","_textureSamplers","_storageBuffers","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","this","_shaderPath","_options","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","externalTextures","samplerObjects","storageBuffers","defines","useClipPlane","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setTextureArray","textures","setExternalTexture","setFloat","value","setInt","setUInt","setFloats","setColor3","setColor3Array","reduce","arr","color","toArray","length","setColor4","setColor4Array","setVector2","setVector3","setVector4","setQuaternion","setQuaternionArray","quaternion","setMatrix","setMatrices","float32Array","Float32Array","index","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","setUniformBuffer","buffer","setTextureSampler","sampler","setStorageBuffer","isReadyForSubMesh","mesh","useInstances","isReady","_storeEffectOnSubMeshes","isFrozen","_wasPreviouslyReady","_drawWrapper","_wasPreviouslyUsingInstances","getScene","engine","getEngine","attribs","fallbacks","shaderName","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","defineToAdd","isVerticesDataPresent","hasThinInstances","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numInfluencers","manager","morphTargetManager","uv","supportsUVs","tangent","supportsTangents","normal","supportsNormals","isUsingTextureForTargets","slice","bvaManager","bakedVertexAnimationManager","isEnabled","_shouldTurnAlphaTestOn","customShaderNameResolve","drawWrapper","_getDrawWrapper","previousEffect","previousDefines","join","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","shaderLanguage","setEffect","_materialContext","_onEffectCreatedObservable","subMeshes","notifyObservers","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","getEffect","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_drawWrapperOverride","_activeEffect","useSceneUBO","supportsUniformBuffers","i","getMeshUniformBuffer","bindToEffect","transferToEffect","getSceneUniformBuffer","finalizeSceneUbo","mustRebind","_mustRebind","visibility","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","setArray","setFloat4","r","g","b","a","getBuffer","bindUniformBuffer","_afterBind","getActiveTextures","activeTextures","array","hasTexture","clone","result","id","Object","keys","forEach","propName","propValue","Array","isArray","stencil","copyTo","key","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","customType","uniqueId","textureArrays","ints","uints","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","quaternions","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","quaternionsArrays","static","source","rootUrl","material","parse","textureArray","floatsArrays","colors","num","map","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","responseText","output","Parse","open","send","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","CreateFromSnippetAsync","ParseFromSnippetAsync"],"sourceRoot":""}