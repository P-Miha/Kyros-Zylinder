"use strict";(self.webpackChunkbabylonjs_typescript_webpack_template=self.webpackChunkbabylonjs_typescript_webpack_template||[]).push([[906],{56906:(e,s,t)=>{t.d(s,{S:()=>d});var r=t(90972),n=t(59288),i=t(87257),a=t(33632),o=t(21369),h=t(44482),c=t(37959),u=t(14651);a.Kj._instancedMeshFactory=(e,s)=>{const t=new d(e,s);if(s.instancedBuffers){t.instancedBuffers={};for(const e in s.instancedBuffers)t.instancedBuffers[e]=s.instancedBuffers[e]}return t};class d extends i.x{constructor(e,s){super(e,s.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,s.addInstance(this),this._sourceMesh=s,this._unIndexed=s._unIndexed,this.position.copyFrom(s.position),this.rotation.copyFrom(s.rotation),this.scaling.copyFrom(s.scaling),s.rotationQuaternion&&(this.rotationQuaternion=s.rotationQuaternion.clone()),this.animations=s.animations.slice();for(const e of s.getAnimationRanges())null!=e&&this.createAnimationRange(e.name,e.from,e.to);this.infiniteDistance=s.infiniteDistance,this.setPivotMatrix(s.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(e){var s;(null===(s=this._sourceMesh)||void 0===s?void 0:s.receiveShadows)!==e&&u.w1.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(e){var s;(null===(s=this._sourceMesh)||void 0===s?void 0:s.material)!==e&&u.w1.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(e){var s;(null===(s=this._sourceMesh)||void 0===s?void 0:s.visibility)!==e&&u.w1.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(e){var s;(null===(s=this._sourceMesh)||void 0===s?void 0:s.skeleton)!==e&&u.w1.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(e){this._sourceMesh&&e!==this._sourceMesh.renderingGroupId&&n.Y.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(e){return this._sourceMesh.createInstance(e)}isReady(e=!1){return this._sourceMesh.isReady(e,!0)}getVerticesData(e,s,t){return this._sourceMesh.getVerticesData(e,s,t)}setVerticesData(e,s,t,r){return this.sourceMesh&&this.sourceMesh.setVerticesData(e,s,t,r),this.sourceMesh}updateVerticesData(e,s,t,r){return this.sourceMesh&&this.sourceMesh.updateVerticesData(e,s,t,r),this.sourceMesh}setIndices(e,s=null){return this.sourceMesh&&this.sourceMesh.setIndices(e,s),this.sourceMesh}isVerticesDataPresent(e){return this._sourceMesh.isVerticesDataPresent(e)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(e=!1,s=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const t=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getPositionData(e,s),t),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(e,s){if(super._activate(e,s),this._sourceMesh.subMeshes||n.Y.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,e),s){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==h.Y.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new r.y3);const e=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,r.jp.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(r.jp.Vector3[7]),this._currentLOD._masterMesh=e,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(e){if(!e)return this;const s=this.sourceMesh.getLODLevels();if(s&&0!==s.length){const s=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(e,s.boundingSphere)}else this._currentLOD=this.sourceMesh;return this._currentLOD}_preActivateForIntermediateRendering(e){return this.sourceMesh._preActivateForIntermediateRendering(e)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let e=0;e<this._sourceMesh.subMeshes.length;e++)this._sourceMesh.subMeshes[e].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(e,s=null,t,r){const n=(r||this._sourceMesh).createInstance(e);if(o.j.DeepCopy(this,n,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),s&&(n.parent=s),!t)for(let e=0;e<this.getScene().meshes.length;e++){const s=this.getScene().meshes[e];s.parent===this&&s.clone(s.name,n)}return n.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(n),n}dispose(e,s=!1){this._sourceMesh.removeInstance(this),super.dispose(e,s)}_serializeAsParent(e){super._serializeAsParent(e),e.parentId=this._sourceMesh.uniqueId,e.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(e=null,s,t){const r=this.clone("Clone of "+(this.name||this.id),e||this.parent,!0,s&&s.newSourcedMesh);r&&t&&t(this,r);for(const e of this.getChildTransformNodes(!0))e.instantiateHierarchy(r,s,t);return r}}a.Kj.prototype.registerInstancedBuffer=function(e,s){var t,r;if(null===(r=null===(t=this._userInstancedBuffersStorage)||void 0===t?void 0:t.vertexBuffers[e])||void 0===r||r.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const e of this.instances)e.instancedBuffers={};this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0})}this.instancedBuffers[e]=null,this._userInstancedBuffersStorage.strides[e]=s,this._userInstancedBuffersStorage.sizes[e]=32*s,this._userInstancedBuffersStorage.data[e]=new Float32Array(this._userInstancedBuffersStorage.sizes[e]),this._userInstancedBuffersStorage.vertexBuffers[e]=new c.o(this.getEngine(),this._userInstancedBuffersStorage.data[e],e,!0,!1,s,!0);for(const s of this.instances)s.instancedBuffers[e]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()},a.Kj.prototype._processInstancedBuffers=function(e,s){const t=e?e.length:0;for(const r in this.instancedBuffers){let n=this._userInstancedBuffersStorage.sizes[r];const i=this._userInstancedBuffersStorage.strides[r],a=(t+1)*i;for(;n<a;)n*=2;this._userInstancedBuffersStorage.data[r].length!=n&&(this._userInstancedBuffersStorage.data[r]=new Float32Array(n),this._userInstancedBuffersStorage.sizes[r]=n,this._userInstancedBuffersStorage.vertexBuffers[r]&&(this._userInstancedBuffersStorage.vertexBuffers[r].dispose(),this._userInstancedBuffersStorage.vertexBuffers[r]=null));const o=this._userInstancedBuffersStorage.data[r];let h=0;if(s){const e=this.instancedBuffers[r];e.toArray?e.toArray(o,h):e.copyToArray?e.copyToArray(o,h):o[h]=e,h+=i}for(let s=0;s<t;s++){const t=e[s].instancedBuffers[r];t.toArray?t.toArray(o,h):t.copyToArray?t.copyToArray(o,h):o[h]=t,h+=i}this._userInstancedBuffersStorage.vertexBuffers[r]?this._userInstancedBuffersStorage.vertexBuffers[r].updateDirectly(o,0):(this._userInstancedBuffersStorage.vertexBuffers[r]=new c.o(this.getEngine(),this._userInstancedBuffersStorage.data[r],r,!0,!1,i,!0),this._invalidateInstanceVertexArrayObject())}},a.Kj.prototype._invalidateInstanceVertexArrayObject=function(){if(this._userInstancedBuffersStorage&&void 0!==this._userInstancedBuffersStorage.vertexArrayObjects){for(const e in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[e]);this._userInstancedBuffersStorage.vertexArrayObjects={}}},a.Kj.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const e in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[e]&&this._userInstancedBuffersStorage.vertexBuffers[e].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}}}}]);
//# sourceMappingURL=906.babylonBundle.js.map